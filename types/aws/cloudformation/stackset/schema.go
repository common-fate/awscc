// Code generated by schema-generate. DO NOT EDIT.

package stackset

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// AutoDeployment 
type AutoDeployment struct {

  // If set to true, StackSets automatically deploys additional stack instances to AWS Organizations accounts that are added to a target organization or organizational unit (OU) in the specified Regions. If an account is removed from a target organization or OU, StackSets deletes stack instances from the account in the specified Regions.
  Enabled bool `json:"Enabled,omitempty"`

  // If set to true, stack resources are retained when an account is removed from a target organization or OU. If set to false, stack resources are deleted. Specify only if Enabled is set to True.
  RetainStacksOnAccountRemoval bool `json:"RetainStacksOnAccountRemoval,omitempty"`
}

// DeploymentTargets  The AWS OrganizationalUnitIds or Accounts for which to create stack instances in the specified Regions.
type DeploymentTargets struct {

  // The filter type you want to apply on organizational units and accounts.
  AccountFilterType string `json:"AccountFilterType,omitempty"`

  // AWS accounts that you want to create stack instances in the specified Region(s) for.
  Accounts []string `json:"Accounts,omitempty"`

  // The organization root ID or organizational unit (OU) IDs to which StackSets deploys.
  OrganizationalUnitIds []string `json:"OrganizationalUnitIds,omitempty"`
}

// ManagedExecution Describes whether StackSets performs non-conflicting operations concurrently and queues conflicting operations.
type ManagedExecution struct {
  Active bool `json:"Active,omitempty"`
}

// OperationPreferences The user-specified preferences for how AWS CloudFormation performs a stack set operation.
type OperationPreferences struct {
  FailureToleranceCount int `json:"FailureToleranceCount,omitempty"`
  FailureTolerancePercentage int `json:"FailureTolerancePercentage,omitempty"`
  MaxConcurrentCount int `json:"MaxConcurrentCount,omitempty"`
  MaxConcurrentPercentage int `json:"MaxConcurrentPercentage,omitempty"`
  RegionConcurrencyType string `json:"RegionConcurrencyType,omitempty"`
  RegionOrder []string `json:"RegionOrder,omitempty"`
}

// Parameter 
type Parameter struct {

  // The key associated with the parameter. If you don't specify a key and value for a particular parameter, AWS CloudFormation uses the default value that is specified in your template.
  ParameterKey string `json:"ParameterKey"`

  // The input value associated with the parameter.
  ParameterValue string `json:"ParameterValue"`
}

// Resource StackSet as a resource provides one-click experience for provisioning a StackSet and StackInstances
type Resource struct {

  // The Amazon Resource Number (ARN) of the IAM role to use to create this stack set. Specify an IAM role only if you are using customized administrator roles to control which users or groups can manage specific stack sets within the same administrator account.
  AdministrationRoleARN string `json:"AdministrationRoleARN,omitempty"`

  // Describes whether StackSets automatically deploys to AWS Organizations accounts that are added to the target organization or organizational unit (OU). Specify only if PermissionModel is SERVICE_MANAGED.
  AutoDeployment *AutoDeployment `json:"AutoDeployment,omitempty"`

  // Specifies the AWS account that you are acting from. By default, SELF is specified. For self-managed permissions, specify SELF; for service-managed permissions, if you are signed in to the organization's management account, specify SELF. If you are signed in to a delegated administrator account, specify DELEGATED_ADMIN.
  CallAs string `json:"CallAs,omitempty"`

  // In some cases, you must explicitly acknowledge that your stack set template contains certain capabilities in order for AWS CloudFormation to create the stack set and related stack instances.
  Capabilities []string `json:"Capabilities,omitempty"`

  // A description of the stack set. You can use the description to identify the stack set's purpose or other important information.
  Description string `json:"Description,omitempty"`

  // The name of the IAM execution role to use to create the stack set. If you do not specify an execution role, AWS CloudFormation uses the AWSCloudFormationStackSetExecutionRole role for the stack set operation.
  ExecutionRoleName string `json:"ExecutionRoleName,omitempty"`

  // Describes whether StackSets performs non-conflicting operations concurrently and queues conflicting operations.
  ManagedExecution *ManagedExecution `json:"ManagedExecution,omitempty"`
  OperationPreferences *OperationPreferences `json:"OperationPreferences,omitempty"`

  // The input parameters for the stack set template.
  Parameters []*Parameter `json:"Parameters,omitempty"`

  // Describes how the IAM roles required for stack set operations are created. By default, SELF-MANAGED is specified.
  PermissionModel string `json:"PermissionModel"`

  // A group of stack instances with parameters in some specific accounts and regions.
  StackInstancesGroup []*StackInstances `json:"StackInstancesGroup,omitempty"`

  // The ID of the stack set that you're creating.
  StackSetId string `json:"StackSetId,omitempty"`

  // The name to associate with the stack set. The name must be unique in the Region where you create your stack set.
  StackSetName string `json:"StackSetName"`

  // The key-value pairs to associate with this stack set and the stacks created from it. AWS CloudFormation also propagates these tags to supported resources that are created in the stacks. A maximum number of 50 tags can be specified.
  Tags []*Tag `json:"Tags,omitempty"`

  // The structure that contains the template body, with a minimum length of 1 byte and a maximum length of 51,200 bytes.
  TemplateBody string `json:"TemplateBody,omitempty"`

  // Location of file containing the template body. The URL must point to a template (max size: 460,800 bytes) that is located in an Amazon S3 bucket.
  TemplateURL string `json:"TemplateURL,omitempty"`
}

// StackInstances Stack instances in some specific accounts and Regions.
type StackInstances struct {
  DeploymentTargets *DeploymentTargets `json:"DeploymentTargets"`

  // A list of stack set parameters whose values you want to override in the selected stack instances.
  ParameterOverrides []*Parameter `json:"ParameterOverrides,omitempty"`

  // The names of one or more Regions where you want to create stack instances using the specified AWS account(s).
  Regions []string `json:"Regions"`
}

// Tag Tag type enables you to specify a key-value pair that can be used to store information about an AWS CloudFormation StackSet.
type Tag struct {

  // A string used to identify this tag. You can specify a maximum of 127 characters for a tag key.
  Key string `json:"Key"`

  // A string containing the value for this tag. You can specify a maximum of 256 characters for a tag value.
  Value string `json:"Value"`
}

func (strct *AutoDeployment) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Enabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RetainStacksOnAccountRemoval" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RetainStacksOnAccountRemoval\": ")
	if tmp, err := json.Marshal(strct.RetainStacksOnAccountRemoval); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AutoDeployment) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Enabled":
            if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
                return err
             }
        case "RetainStacksOnAccountRemoval":
            if err := json.Unmarshal([]byte(v), &strct.RetainStacksOnAccountRemoval); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *DeploymentTargets) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AccountFilterType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AccountFilterType\": ")
	if tmp, err := json.Marshal(strct.AccountFilterType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Accounts" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Accounts\": ")
	if tmp, err := json.Marshal(strct.Accounts); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OrganizationalUnitIds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OrganizationalUnitIds\": ")
	if tmp, err := json.Marshal(strct.OrganizationalUnitIds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DeploymentTargets) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AccountFilterType":
            if err := json.Unmarshal([]byte(v), &strct.AccountFilterType); err != nil {
                return err
             }
        case "Accounts":
            if err := json.Unmarshal([]byte(v), &strct.Accounts); err != nil {
                return err
             }
        case "OrganizationalUnitIds":
            if err := json.Unmarshal([]byte(v), &strct.OrganizationalUnitIds); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ManagedExecution) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Active" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Active\": ")
	if tmp, err := json.Marshal(strct.Active); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ManagedExecution) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Active":
            if err := json.Unmarshal([]byte(v), &strct.Active); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *OperationPreferences) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "FailureToleranceCount" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FailureToleranceCount\": ")
	if tmp, err := json.Marshal(strct.FailureToleranceCount); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FailureTolerancePercentage" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FailureTolerancePercentage\": ")
	if tmp, err := json.Marshal(strct.FailureTolerancePercentage); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MaxConcurrentCount" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaxConcurrentCount\": ")
	if tmp, err := json.Marshal(strct.MaxConcurrentCount); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MaxConcurrentPercentage" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaxConcurrentPercentage\": ")
	if tmp, err := json.Marshal(strct.MaxConcurrentPercentage); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RegionConcurrencyType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RegionConcurrencyType\": ")
	if tmp, err := json.Marshal(strct.RegionConcurrencyType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RegionOrder" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RegionOrder\": ")
	if tmp, err := json.Marshal(strct.RegionOrder); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *OperationPreferences) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "FailureToleranceCount":
            if err := json.Unmarshal([]byte(v), &strct.FailureToleranceCount); err != nil {
                return err
             }
        case "FailureTolerancePercentage":
            if err := json.Unmarshal([]byte(v), &strct.FailureTolerancePercentage); err != nil {
                return err
             }
        case "MaxConcurrentCount":
            if err := json.Unmarshal([]byte(v), &strct.MaxConcurrentCount); err != nil {
                return err
             }
        case "MaxConcurrentPercentage":
            if err := json.Unmarshal([]byte(v), &strct.MaxConcurrentPercentage); err != nil {
                return err
             }
        case "RegionConcurrencyType":
            if err := json.Unmarshal([]byte(v), &strct.RegionConcurrencyType); err != nil {
                return err
             }
        case "RegionOrder":
            if err := json.Unmarshal([]byte(v), &strct.RegionOrder); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Parameter) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ParameterKey" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ParameterKey" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ParameterKey\": ")
	if tmp, err := json.Marshal(strct.ParameterKey); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ParameterValue" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ParameterValue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ParameterValue\": ")
	if tmp, err := json.Marshal(strct.ParameterValue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Parameter) UnmarshalJSON(b []byte) error {
    ParameterKeyReceived := false
    ParameterValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ParameterKey":
            if err := json.Unmarshal([]byte(v), &strct.ParameterKey); err != nil {
                return err
             }
            ParameterKeyReceived = true
        case "ParameterValue":
            if err := json.Unmarshal([]byte(v), &strct.ParameterValue); err != nil {
                return err
             }
            ParameterValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ParameterKey (a required property) was received
    if !ParameterKeyReceived {
        return errors.New("\"ParameterKey\" is required but was not present")
    }
    // check if ParameterValue (a required property) was received
    if !ParameterValueReceived {
        return errors.New("\"ParameterValue\" is required but was not present")
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AdministrationRoleARN" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AdministrationRoleARN\": ")
	if tmp, err := json.Marshal(strct.AdministrationRoleARN); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AutoDeployment" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AutoDeployment\": ")
	if tmp, err := json.Marshal(strct.AutoDeployment); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CallAs" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CallAs\": ")
	if tmp, err := json.Marshal(strct.CallAs); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Capabilities" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Capabilities\": ")
	if tmp, err := json.Marshal(strct.Capabilities); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ExecutionRoleName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ExecutionRoleName\": ")
	if tmp, err := json.Marshal(strct.ExecutionRoleName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ManagedExecution" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ManagedExecution\": ")
	if tmp, err := json.Marshal(strct.ManagedExecution); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OperationPreferences" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OperationPreferences\": ")
	if tmp, err := json.Marshal(strct.OperationPreferences); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Parameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Parameters\": ")
	if tmp, err := json.Marshal(strct.Parameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "PermissionModel" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "PermissionModel" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PermissionModel\": ")
	if tmp, err := json.Marshal(strct.PermissionModel); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StackInstancesGroup" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StackInstancesGroup\": ")
	if tmp, err := json.Marshal(strct.StackInstancesGroup); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StackSetId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StackSetId\": ")
	if tmp, err := json.Marshal(strct.StackSetId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "StackSetName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "StackSetName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StackSetName\": ")
	if tmp, err := json.Marshal(strct.StackSetName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TemplateBody" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TemplateBody\": ")
	if tmp, err := json.Marshal(strct.TemplateBody); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TemplateURL" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TemplateURL\": ")
	if tmp, err := json.Marshal(strct.TemplateURL); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    PermissionModelReceived := false
    StackSetNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AdministrationRoleARN":
            if err := json.Unmarshal([]byte(v), &strct.AdministrationRoleARN); err != nil {
                return err
             }
        case "AutoDeployment":
            if err := json.Unmarshal([]byte(v), &strct.AutoDeployment); err != nil {
                return err
             }
        case "CallAs":
            if err := json.Unmarshal([]byte(v), &strct.CallAs); err != nil {
                return err
             }
        case "Capabilities":
            if err := json.Unmarshal([]byte(v), &strct.Capabilities); err != nil {
                return err
             }
        case "Description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "ExecutionRoleName":
            if err := json.Unmarshal([]byte(v), &strct.ExecutionRoleName); err != nil {
                return err
             }
        case "ManagedExecution":
            if err := json.Unmarshal([]byte(v), &strct.ManagedExecution); err != nil {
                return err
             }
        case "OperationPreferences":
            if err := json.Unmarshal([]byte(v), &strct.OperationPreferences); err != nil {
                return err
             }
        case "Parameters":
            if err := json.Unmarshal([]byte(v), &strct.Parameters); err != nil {
                return err
             }
        case "PermissionModel":
            if err := json.Unmarshal([]byte(v), &strct.PermissionModel); err != nil {
                return err
             }
            PermissionModelReceived = true
        case "StackInstancesGroup":
            if err := json.Unmarshal([]byte(v), &strct.StackInstancesGroup); err != nil {
                return err
             }
        case "StackSetId":
            if err := json.Unmarshal([]byte(v), &strct.StackSetId); err != nil {
                return err
             }
        case "StackSetName":
            if err := json.Unmarshal([]byte(v), &strct.StackSetName); err != nil {
                return err
             }
            StackSetNameReceived = true
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        case "TemplateBody":
            if err := json.Unmarshal([]byte(v), &strct.TemplateBody); err != nil {
                return err
             }
        case "TemplateURL":
            if err := json.Unmarshal([]byte(v), &strct.TemplateURL); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if PermissionModel (a required property) was received
    if !PermissionModelReceived {
        return errors.New("\"PermissionModel\" is required but was not present")
    }
    // check if StackSetName (a required property) was received
    if !StackSetNameReceived {
        return errors.New("\"StackSetName\" is required but was not present")
    }
    return nil
}

func (strct *StackInstances) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "DeploymentTargets" field is required
    if strct.DeploymentTargets == nil {
        return nil, errors.New("DeploymentTargets is a required field")
    }
    // Marshal the "DeploymentTargets" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DeploymentTargets\": ")
	if tmp, err := json.Marshal(strct.DeploymentTargets); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ParameterOverrides" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ParameterOverrides\": ")
	if tmp, err := json.Marshal(strct.ParameterOverrides); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Regions" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Regions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Regions\": ")
	if tmp, err := json.Marshal(strct.Regions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *StackInstances) UnmarshalJSON(b []byte) error {
    DeploymentTargetsReceived := false
    RegionsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DeploymentTargets":
            if err := json.Unmarshal([]byte(v), &strct.DeploymentTargets); err != nil {
                return err
             }
            DeploymentTargetsReceived = true
        case "ParameterOverrides":
            if err := json.Unmarshal([]byte(v), &strct.ParameterOverrides); err != nil {
                return err
             }
        case "Regions":
            if err := json.Unmarshal([]byte(v), &strct.Regions); err != nil {
                return err
             }
            RegionsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if DeploymentTargets (a required property) was received
    if !DeploymentTargetsReceived {
        return errors.New("\"DeploymentTargets\" is required but was not present")
    }
    // check if Regions (a required property) was received
    if !RegionsReceived {
        return errors.New("\"Regions\" is required but was not present")
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}
