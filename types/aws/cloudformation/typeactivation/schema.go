// Code generated by schema-generate. DO NOT EDIT.

package typeactivation

import (
    "fmt"
    "bytes"
    "encoding/json"
)

// LoggingConfig 
type LoggingConfig struct {

  // The Amazon CloudWatch log group to which CloudFormation sends error logging information when invoking the type's handlers.
  LogGroupName string `json:"LogGroupName,omitempty"`

  // The ARN of the role that CloudFormation should assume when sending log entries to CloudWatch logs.
  LogRoleArn string `json:"LogRoleArn,omitempty"`
}

// Resource Enable a resource that has been published in the CloudFormation Registry.
type Resource struct {

  // The Amazon Resource Name (ARN) of the extension.
  Arn string `json:"Arn,omitempty"`

  // Whether to automatically update the extension in this account and region when a new minor version is published by the extension publisher. Major versions released by the publisher must be manually updated.
  AutoUpdate bool `json:"AutoUpdate,omitempty"`

  // The Amazon Resource Name (ARN) of the IAM execution role to use to register the type. If your resource type calls AWS APIs in any of its handlers, you must create an IAM execution role that includes the necessary permissions to call those AWS APIs, and provision that execution role in your account. CloudFormation then assumes that execution role to provide your resource type with the appropriate credentials.
  ExecutionRoleArn string `json:"ExecutionRoleArn,omitempty"`

  // Specifies logging configuration information for a type.
  LoggingConfig *LoggingConfig `json:"LoggingConfig,omitempty"`

  // The Major Version of the type you want to enable
  MajorVersion string `json:"MajorVersion,omitempty"`

  // The Amazon Resource Number (ARN) assigned to the public extension upon publication
  PublicTypeArn string `json:"PublicTypeArn,omitempty"`

  // The publisher id assigned by CloudFormation for publishing in this region.
  PublisherId string `json:"PublisherId,omitempty"`

  // The kind of extension
  Type string `json:"Type,omitempty"`

  // The name of the type being registered.
  // 
  // We recommend that type names adhere to the following pattern: company_or_organization::service::type.
  TypeName string `json:"TypeName,omitempty"`

  // An alias to assign to the public extension in this account and region. If you specify an alias for the extension, you must then use the alias to refer to the extension in your templates.
  TypeNameAlias string `json:"TypeNameAlias,omitempty"`

  // Manually updates a previously-enabled type to a new major or minor version, if available. You can also use this parameter to update the value of AutoUpdateEnabled
  VersionBump string `json:"VersionBump,omitempty"`
}

func (strct *LoggingConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "LogGroupName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LogGroupName\": ")
	if tmp, err := json.Marshal(strct.LogGroupName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LogRoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LogRoleArn\": ")
	if tmp, err := json.Marshal(strct.LogRoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LoggingConfig) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "LogGroupName":
            if err := json.Unmarshal([]byte(v), &strct.LogGroupName); err != nil {
                return err
             }
        case "LogRoleArn":
            if err := json.Unmarshal([]byte(v), &strct.LogRoleArn); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Arn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Arn\": ")
	if tmp, err := json.Marshal(strct.Arn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AutoUpdate" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AutoUpdate\": ")
	if tmp, err := json.Marshal(strct.AutoUpdate); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ExecutionRoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ExecutionRoleArn\": ")
	if tmp, err := json.Marshal(strct.ExecutionRoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LoggingConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LoggingConfig\": ")
	if tmp, err := json.Marshal(strct.LoggingConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MajorVersion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MajorVersion\": ")
	if tmp, err := json.Marshal(strct.MajorVersion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PublicTypeArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PublicTypeArn\": ")
	if tmp, err := json.Marshal(strct.PublicTypeArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PublisherId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PublisherId\": ")
	if tmp, err := json.Marshal(strct.PublisherId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TypeName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TypeName\": ")
	if tmp, err := json.Marshal(strct.TypeName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TypeNameAlias" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TypeNameAlias\": ")
	if tmp, err := json.Marshal(strct.TypeNameAlias); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VersionBump" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VersionBump\": ")
	if tmp, err := json.Marshal(strct.VersionBump); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Arn":
            if err := json.Unmarshal([]byte(v), &strct.Arn); err != nil {
                return err
             }
        case "AutoUpdate":
            if err := json.Unmarshal([]byte(v), &strct.AutoUpdate); err != nil {
                return err
             }
        case "ExecutionRoleArn":
            if err := json.Unmarshal([]byte(v), &strct.ExecutionRoleArn); err != nil {
                return err
             }
        case "LoggingConfig":
            if err := json.Unmarshal([]byte(v), &strct.LoggingConfig); err != nil {
                return err
             }
        case "MajorVersion":
            if err := json.Unmarshal([]byte(v), &strct.MajorVersion); err != nil {
                return err
             }
        case "PublicTypeArn":
            if err := json.Unmarshal([]byte(v), &strct.PublicTypeArn); err != nil {
                return err
             }
        case "PublisherId":
            if err := json.Unmarshal([]byte(v), &strct.PublisherId); err != nil {
                return err
             }
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
        case "TypeName":
            if err := json.Unmarshal([]byte(v), &strct.TypeName); err != nil {
                return err
             }
        case "TypeNameAlias":
            if err := json.Unmarshal([]byte(v), &strct.TypeNameAlias); err != nil {
                return err
             }
        case "VersionBump":
            if err := json.Unmarshal([]byte(v), &strct.VersionBump); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}
