// Code generated by schema-generate. DO NOT EDIT.

package connectpeer

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// BgpOptions Bgp options
type BgpOptions struct {
  PeerAsn float64 `json:"PeerAsn,omitempty"`
}

// ConnectPeerBgpConfiguration Bgp configuration for connect peer
type ConnectPeerBgpConfiguration struct {
  CoreNetworkAddress string `json:"CoreNetworkAddress,omitempty"`
  CoreNetworkAsn float64 `json:"CoreNetworkAsn,omitempty"`
  PeerAddress string `json:"PeerAddress,omitempty"`
  PeerAsn float64 `json:"PeerAsn,omitempty"`
}

// ConnectPeerConfiguration 
type ConnectPeerConfiguration struct {
  BgpConfigurations []*ConnectPeerBgpConfiguration `json:"BgpConfigurations,omitempty"`
  CoreNetworkAddress string `json:"CoreNetworkAddress,omitempty"`
  InsideCidrBlocks []string `json:"InsideCidrBlocks,omitempty"`
  PeerAddress string `json:"PeerAddress,omitempty"`
  Protocol string `json:"Protocol,omitempty"`
}

// Resource AWS::NetworkManager::ConnectPeer Resource Type Definition.
type Resource struct {

  // Bgp options for connect peer.
  BgpOptions *BgpOptions `json:"BgpOptions,omitempty"`

  // Configuration of the connect peer.
  Configuration *ConnectPeerConfiguration `json:"Configuration,omitempty"`

  // The ID of the attachment to connect.
  ConnectAttachmentId string `json:"ConnectAttachmentId"`

  // The ID of the Connect peer.
  ConnectPeerId string `json:"ConnectPeerId,omitempty"`

  // The IP address of a core network.
  CoreNetworkAddress string `json:"CoreNetworkAddress,omitempty"`

  // The ID of the core network.
  CoreNetworkId string `json:"CoreNetworkId,omitempty"`

  // Connect peer creation time.
  CreatedAt string `json:"CreatedAt,omitempty"`

  // The Connect peer Regions where edges are located.
  EdgeLocation string `json:"EdgeLocation,omitempty"`

  // The inside IP addresses used for a Connect peer configuration.
  InsideCidrBlocks []string `json:"InsideCidrBlocks"`

  // The IP address of the Connect peer.
  PeerAddress string `json:"PeerAddress"`

  // State of the connect peer.
  State string `json:"State,omitempty"`

  // An array of key-value pairs to apply to this resource.
  Tags []*Tag `json:"Tags,omitempty"`
}

// Tag A key-value pair to associate with a resource.
type Tag struct {

  // The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
  Key string `json:"Key"`

  // The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
  Value string `json:"Value"`
}

func (strct *BgpOptions) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "PeerAsn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PeerAsn\": ")
	if tmp, err := json.Marshal(strct.PeerAsn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BgpOptions) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "PeerAsn":
            if err := json.Unmarshal([]byte(v), &strct.PeerAsn); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ConnectPeerBgpConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CoreNetworkAddress" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CoreNetworkAddress\": ")
	if tmp, err := json.Marshal(strct.CoreNetworkAddress); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CoreNetworkAsn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CoreNetworkAsn\": ")
	if tmp, err := json.Marshal(strct.CoreNetworkAsn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PeerAddress" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PeerAddress\": ")
	if tmp, err := json.Marshal(strct.PeerAddress); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PeerAsn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PeerAsn\": ")
	if tmp, err := json.Marshal(strct.PeerAsn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ConnectPeerBgpConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CoreNetworkAddress":
            if err := json.Unmarshal([]byte(v), &strct.CoreNetworkAddress); err != nil {
                return err
             }
        case "CoreNetworkAsn":
            if err := json.Unmarshal([]byte(v), &strct.CoreNetworkAsn); err != nil {
                return err
             }
        case "PeerAddress":
            if err := json.Unmarshal([]byte(v), &strct.PeerAddress); err != nil {
                return err
             }
        case "PeerAsn":
            if err := json.Unmarshal([]byte(v), &strct.PeerAsn); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ConnectPeerConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "BgpConfigurations" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BgpConfigurations\": ")
	if tmp, err := json.Marshal(strct.BgpConfigurations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CoreNetworkAddress" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CoreNetworkAddress\": ")
	if tmp, err := json.Marshal(strct.CoreNetworkAddress); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "InsideCidrBlocks" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InsideCidrBlocks\": ")
	if tmp, err := json.Marshal(strct.InsideCidrBlocks); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PeerAddress" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PeerAddress\": ")
	if tmp, err := json.Marshal(strct.PeerAddress); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Protocol" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Protocol\": ")
	if tmp, err := json.Marshal(strct.Protocol); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ConnectPeerConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BgpConfigurations":
            if err := json.Unmarshal([]byte(v), &strct.BgpConfigurations); err != nil {
                return err
             }
        case "CoreNetworkAddress":
            if err := json.Unmarshal([]byte(v), &strct.CoreNetworkAddress); err != nil {
                return err
             }
        case "InsideCidrBlocks":
            if err := json.Unmarshal([]byte(v), &strct.InsideCidrBlocks); err != nil {
                return err
             }
        case "PeerAddress":
            if err := json.Unmarshal([]byte(v), &strct.PeerAddress); err != nil {
                return err
             }
        case "Protocol":
            if err := json.Unmarshal([]byte(v), &strct.Protocol); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "BgpOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BgpOptions\": ")
	if tmp, err := json.Marshal(strct.BgpOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Configuration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Configuration\": ")
	if tmp, err := json.Marshal(strct.Configuration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ConnectAttachmentId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ConnectAttachmentId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConnectAttachmentId\": ")
	if tmp, err := json.Marshal(strct.ConnectAttachmentId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ConnectPeerId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConnectPeerId\": ")
	if tmp, err := json.Marshal(strct.ConnectPeerId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CoreNetworkAddress" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CoreNetworkAddress\": ")
	if tmp, err := json.Marshal(strct.CoreNetworkAddress); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CoreNetworkId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CoreNetworkId\": ")
	if tmp, err := json.Marshal(strct.CoreNetworkId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CreatedAt" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CreatedAt\": ")
	if tmp, err := json.Marshal(strct.CreatedAt); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EdgeLocation" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EdgeLocation\": ")
	if tmp, err := json.Marshal(strct.EdgeLocation); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "InsideCidrBlocks" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "InsideCidrBlocks" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InsideCidrBlocks\": ")
	if tmp, err := json.Marshal(strct.InsideCidrBlocks); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "PeerAddress" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "PeerAddress" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PeerAddress\": ")
	if tmp, err := json.Marshal(strct.PeerAddress); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "State" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"State\": ")
	if tmp, err := json.Marshal(strct.State); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    ConnectAttachmentIdReceived := false
    InsideCidrBlocksReceived := false
    PeerAddressReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BgpOptions":
            if err := json.Unmarshal([]byte(v), &strct.BgpOptions); err != nil {
                return err
             }
        case "Configuration":
            if err := json.Unmarshal([]byte(v), &strct.Configuration); err != nil {
                return err
             }
        case "ConnectAttachmentId":
            if err := json.Unmarshal([]byte(v), &strct.ConnectAttachmentId); err != nil {
                return err
             }
            ConnectAttachmentIdReceived = true
        case "ConnectPeerId":
            if err := json.Unmarshal([]byte(v), &strct.ConnectPeerId); err != nil {
                return err
             }
        case "CoreNetworkAddress":
            if err := json.Unmarshal([]byte(v), &strct.CoreNetworkAddress); err != nil {
                return err
             }
        case "CoreNetworkId":
            if err := json.Unmarshal([]byte(v), &strct.CoreNetworkId); err != nil {
                return err
             }
        case "CreatedAt":
            if err := json.Unmarshal([]byte(v), &strct.CreatedAt); err != nil {
                return err
             }
        case "EdgeLocation":
            if err := json.Unmarshal([]byte(v), &strct.EdgeLocation); err != nil {
                return err
             }
        case "InsideCidrBlocks":
            if err := json.Unmarshal([]byte(v), &strct.InsideCidrBlocks); err != nil {
                return err
             }
            InsideCidrBlocksReceived = true
        case "PeerAddress":
            if err := json.Unmarshal([]byte(v), &strct.PeerAddress); err != nil {
                return err
             }
            PeerAddressReceived = true
        case "State":
            if err := json.Unmarshal([]byte(v), &strct.State); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ConnectAttachmentId (a required property) was received
    if !ConnectAttachmentIdReceived {
        return errors.New("\"ConnectAttachmentId\" is required but was not present")
    }
    // check if InsideCidrBlocks (a required property) was received
    if !InsideCidrBlocksReceived {
        return errors.New("\"InsideCidrBlocks\" is required but was not present")
    }
    // check if PeerAddress (a required property) was received
    if !PeerAddressReceived {
        return errors.New("\"PeerAddress\" is required but was not present")
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}
