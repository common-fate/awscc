// Code generated by schema-generate. DO NOT EDIT.

package corenetwork

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// CoreNetworkEdge 
type CoreNetworkEdge struct {

  // The ASN of a core network edge.
  Asn float64 `json:"Asn,omitempty"`

  // The Region where a core network edge is located.
  EdgeLocation string `json:"EdgeLocation,omitempty"`
  InsideCidrBlocks []string `json:"InsideCidrBlocks,omitempty"`
}

// CoreNetworkSegment 
type CoreNetworkSegment struct {
  EdgeLocations []string `json:"EdgeLocations,omitempty"`

  // Name of segment
  Name string `json:"Name,omitempty"`
  SharedSegments []string `json:"SharedSegments,omitempty"`
}

// PolicyDocument Live policy document for the core network, you must provide PolicyDocument in Json Format
type PolicyDocument struct {
}

// Resource AWS::NetworkManager::CoreNetwork Resource Type Definition.
type Resource struct {

  // The ARN (Amazon resource name) of core network
  CoreNetworkArn string `json:"CoreNetworkArn,omitempty"`

  // The Id of core network
  CoreNetworkId string `json:"CoreNetworkId,omitempty"`

  // The creation time of core network
  CreatedAt string `json:"CreatedAt,omitempty"`

  // The description of core network
  Description string `json:"Description,omitempty"`

  // The edges within a core network.
  Edges []*CoreNetworkEdge `json:"Edges,omitempty"`

  // The ID of the global network that your core network is a part of.
  GlobalNetworkId string `json:"GlobalNetworkId"`

  // Owner of the core network
  OwnerAccount string `json:"OwnerAccount,omitempty"`

  // Live policy document for the core network, you must provide PolicyDocument in Json Format
  PolicyDocument *PolicyDocument `json:"PolicyDocument,omitempty"`

  // The segments within a core network.
  Segments []*CoreNetworkSegment `json:"Segments,omitempty"`

  // The state of core network
  State string `json:"State,omitempty"`

  // The tags for the global network.
  Tags []*Tag `json:"Tags,omitempty"`
}

// Tag A key-value pair to associate with a resource.
type Tag struct {

  // The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
  Key string `json:"Key"`

  // The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
  Value string `json:"Value"`
}

func (strct *CoreNetworkEdge) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Asn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Asn\": ")
	if tmp, err := json.Marshal(strct.Asn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EdgeLocation" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EdgeLocation\": ")
	if tmp, err := json.Marshal(strct.EdgeLocation); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "InsideCidrBlocks" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InsideCidrBlocks\": ")
	if tmp, err := json.Marshal(strct.InsideCidrBlocks); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CoreNetworkEdge) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Asn":
            if err := json.Unmarshal([]byte(v), &strct.Asn); err != nil {
                return err
             }
        case "EdgeLocation":
            if err := json.Unmarshal([]byte(v), &strct.EdgeLocation); err != nil {
                return err
             }
        case "InsideCidrBlocks":
            if err := json.Unmarshal([]byte(v), &strct.InsideCidrBlocks); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *CoreNetworkSegment) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "EdgeLocations" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EdgeLocations\": ")
	if tmp, err := json.Marshal(strct.EdgeLocations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SharedSegments" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SharedSegments\": ")
	if tmp, err := json.Marshal(strct.SharedSegments); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CoreNetworkSegment) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "EdgeLocations":
            if err := json.Unmarshal([]byte(v), &strct.EdgeLocations); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "SharedSegments":
            if err := json.Unmarshal([]byte(v), &strct.SharedSegments); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CoreNetworkArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CoreNetworkArn\": ")
	if tmp, err := json.Marshal(strct.CoreNetworkArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CoreNetworkId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CoreNetworkId\": ")
	if tmp, err := json.Marshal(strct.CoreNetworkId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CreatedAt" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CreatedAt\": ")
	if tmp, err := json.Marshal(strct.CreatedAt); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Edges" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Edges\": ")
	if tmp, err := json.Marshal(strct.Edges); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "GlobalNetworkId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "GlobalNetworkId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"GlobalNetworkId\": ")
	if tmp, err := json.Marshal(strct.GlobalNetworkId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OwnerAccount" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OwnerAccount\": ")
	if tmp, err := json.Marshal(strct.OwnerAccount); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PolicyDocument" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PolicyDocument\": ")
	if tmp, err := json.Marshal(strct.PolicyDocument); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Segments" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Segments\": ")
	if tmp, err := json.Marshal(strct.Segments); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "State" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"State\": ")
	if tmp, err := json.Marshal(strct.State); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    GlobalNetworkIdReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CoreNetworkArn":
            if err := json.Unmarshal([]byte(v), &strct.CoreNetworkArn); err != nil {
                return err
             }
        case "CoreNetworkId":
            if err := json.Unmarshal([]byte(v), &strct.CoreNetworkId); err != nil {
                return err
             }
        case "CreatedAt":
            if err := json.Unmarshal([]byte(v), &strct.CreatedAt); err != nil {
                return err
             }
        case "Description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "Edges":
            if err := json.Unmarshal([]byte(v), &strct.Edges); err != nil {
                return err
             }
        case "GlobalNetworkId":
            if err := json.Unmarshal([]byte(v), &strct.GlobalNetworkId); err != nil {
                return err
             }
            GlobalNetworkIdReceived = true
        case "OwnerAccount":
            if err := json.Unmarshal([]byte(v), &strct.OwnerAccount); err != nil {
                return err
             }
        case "PolicyDocument":
            if err := json.Unmarshal([]byte(v), &strct.PolicyDocument); err != nil {
                return err
             }
        case "Segments":
            if err := json.Unmarshal([]byte(v), &strct.Segments); err != nil {
                return err
             }
        case "State":
            if err := json.Unmarshal([]byte(v), &strct.State); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if GlobalNetworkId (a required property) was received
    if !GlobalNetworkIdReceived {
        return errors.New("\"GlobalNetworkId\" is required but was not present")
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}
