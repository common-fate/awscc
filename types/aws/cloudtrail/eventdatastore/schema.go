// Code generated by schema-generate. DO NOT EDIT.

package eventdatastore

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// AdvancedEventSelector Advanced event selectors let you create fine-grained selectors for the following AWS CloudTrail event record ?elds. They help you control costs by logging only those events that are important to you.
type AdvancedEventSelector struct {

  // Contains all selector statements in an advanced event selector.
  FieldSelectors []*AdvancedFieldSelector `json:"FieldSelectors"`

  // An optional, descriptive name for an advanced event selector, such as "Log data events for only two S3 buckets".
  Name string `json:"Name,omitempty"`
}

// AdvancedFieldSelector A single selector statement in an advanced event selector.
type AdvancedFieldSelector struct {

  // An operator that includes events that match the last few characters of the event record field specified as the value of Field.
  EndsWith []string `json:"EndsWith,omitempty"`

  // An operator that includes events that match the exact value of the event record field specified as the value of Field. This is the only valid operator that you can use with the readOnly, eventCategory, and resources.type fields.
  Equals []string `json:"Equals,omitempty"`

  // A field in an event record on which to filter events to be logged. Supported fields include readOnly, eventCategory, eventSource (for management events), eventName, resources.type, and resources.ARN.
  Field string `json:"Field"`

  // An operator that excludes events that match the last few characters of the event record field specified as the value of Field.
  NotEndsWith []string `json:"NotEndsWith,omitempty"`

  // An operator that excludes events that match the exact value of the event record field specified as the value of Field.
  NotEquals []string `json:"NotEquals,omitempty"`

  // An operator that excludes events that match the first few characters of the event record field specified as the value of Field.
  NotStartsWith []string `json:"NotStartsWith,omitempty"`

  // An operator that includes events that match the first few characters of the event record field specified as the value of Field.
  StartsWith []string `json:"StartsWith,omitempty"`
}

// Resource A storage lake of event data against which you can run complex SQL-based queries. An event data store can include events that you have logged on your account from the last 90 to 2555 days (about three months to up to seven years).
type Resource struct {

  // The advanced event selectors that were used to select events for the data store.
  AdvancedEventSelectors []*AdvancedEventSelector `json:"AdvancedEventSelectors,omitempty"`

  // The timestamp of the event data store's creation.
  CreatedTimestamp string `json:"CreatedTimestamp,omitempty"`

  // The ARN of the event data store.
  EventDataStoreArn string `json:"EventDataStoreArn,omitempty"`

  // Specifies the KMS key ID to use to encrypt the events delivered by CloudTrail. The value can be an alias name prefixed by 'alias/', a fully specified ARN to an alias, a fully specified ARN to a key, or a globally unique identifier.
  KmsKeyId string `json:"KmsKeyId,omitempty"`

  // Indicates whether the event data store includes events from all regions, or only from the region in which it was created.
  MultiRegionEnabled bool `json:"MultiRegionEnabled,omitempty"`

  // The name of the event data store.
  Name string `json:"Name,omitempty"`

  // Indicates that an event data store is collecting logged events for an organization.
  OrganizationEnabled bool `json:"OrganizationEnabled,omitempty"`

  // The retention period, in days.
  RetentionPeriod int `json:"RetentionPeriod,omitempty"`

  // The status of an event data store. Values are ENABLED and PENDING_DELETION.
  Status string `json:"Status,omitempty"`
  Tags []*Tag `json:"Tags,omitempty"`

  // Indicates whether the event data store is protected from termination.
  TerminationProtectionEnabled bool `json:"TerminationProtectionEnabled,omitempty"`

  // The timestamp showing when an event data store was updated, if applicable. UpdatedTimestamp is always either the same or newer than the time shown in CreatedTimestamp.
  UpdatedTimestamp string `json:"UpdatedTimestamp,omitempty"`
}

// Tag An arbitrary set of tags (key-value pairs) for this event data store.
type Tag struct {

  // The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
  Key string `json:"Key"`

  // The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
  Value string `json:"Value"`
}

func (strct *AdvancedEventSelector) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "FieldSelectors" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "FieldSelectors" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FieldSelectors\": ")
	if tmp, err := json.Marshal(strct.FieldSelectors); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AdvancedEventSelector) UnmarshalJSON(b []byte) error {
    FieldSelectorsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "FieldSelectors":
            if err := json.Unmarshal([]byte(v), &strct.FieldSelectors); err != nil {
                return err
             }
            FieldSelectorsReceived = true
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if FieldSelectors (a required property) was received
    if !FieldSelectorsReceived {
        return errors.New("\"FieldSelectors\" is required but was not present")
    }
    return nil
}

func (strct *AdvancedFieldSelector) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "EndsWith" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EndsWith\": ")
	if tmp, err := json.Marshal(strct.EndsWith); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Equals" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Equals\": ")
	if tmp, err := json.Marshal(strct.Equals); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Field" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Field" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Field\": ")
	if tmp, err := json.Marshal(strct.Field); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "NotEndsWith" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NotEndsWith\": ")
	if tmp, err := json.Marshal(strct.NotEndsWith); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "NotEquals" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NotEquals\": ")
	if tmp, err := json.Marshal(strct.NotEquals); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "NotStartsWith" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NotStartsWith\": ")
	if tmp, err := json.Marshal(strct.NotStartsWith); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StartsWith" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StartsWith\": ")
	if tmp, err := json.Marshal(strct.StartsWith); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AdvancedFieldSelector) UnmarshalJSON(b []byte) error {
    FieldReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "EndsWith":
            if err := json.Unmarshal([]byte(v), &strct.EndsWith); err != nil {
                return err
             }
        case "Equals":
            if err := json.Unmarshal([]byte(v), &strct.Equals); err != nil {
                return err
             }
        case "Field":
            if err := json.Unmarshal([]byte(v), &strct.Field); err != nil {
                return err
             }
            FieldReceived = true
        case "NotEndsWith":
            if err := json.Unmarshal([]byte(v), &strct.NotEndsWith); err != nil {
                return err
             }
        case "NotEquals":
            if err := json.Unmarshal([]byte(v), &strct.NotEquals); err != nil {
                return err
             }
        case "NotStartsWith":
            if err := json.Unmarshal([]byte(v), &strct.NotStartsWith); err != nil {
                return err
             }
        case "StartsWith":
            if err := json.Unmarshal([]byte(v), &strct.StartsWith); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Field (a required property) was received
    if !FieldReceived {
        return errors.New("\"Field\" is required but was not present")
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AdvancedEventSelectors" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AdvancedEventSelectors\": ")
	if tmp, err := json.Marshal(strct.AdvancedEventSelectors); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CreatedTimestamp" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CreatedTimestamp\": ")
	if tmp, err := json.Marshal(strct.CreatedTimestamp); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EventDataStoreArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EventDataStoreArn\": ")
	if tmp, err := json.Marshal(strct.EventDataStoreArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "KmsKeyId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KmsKeyId\": ")
	if tmp, err := json.Marshal(strct.KmsKeyId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MultiRegionEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MultiRegionEnabled\": ")
	if tmp, err := json.Marshal(strct.MultiRegionEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OrganizationEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OrganizationEnabled\": ")
	if tmp, err := json.Marshal(strct.OrganizationEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RetentionPeriod" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RetentionPeriod\": ")
	if tmp, err := json.Marshal(strct.RetentionPeriod); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Status" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Status\": ")
	if tmp, err := json.Marshal(strct.Status); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TerminationProtectionEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TerminationProtectionEnabled\": ")
	if tmp, err := json.Marshal(strct.TerminationProtectionEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "UpdatedTimestamp" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UpdatedTimestamp\": ")
	if tmp, err := json.Marshal(strct.UpdatedTimestamp); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AdvancedEventSelectors":
            if err := json.Unmarshal([]byte(v), &strct.AdvancedEventSelectors); err != nil {
                return err
             }
        case "CreatedTimestamp":
            if err := json.Unmarshal([]byte(v), &strct.CreatedTimestamp); err != nil {
                return err
             }
        case "EventDataStoreArn":
            if err := json.Unmarshal([]byte(v), &strct.EventDataStoreArn); err != nil {
                return err
             }
        case "KmsKeyId":
            if err := json.Unmarshal([]byte(v), &strct.KmsKeyId); err != nil {
                return err
             }
        case "MultiRegionEnabled":
            if err := json.Unmarshal([]byte(v), &strct.MultiRegionEnabled); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "OrganizationEnabled":
            if err := json.Unmarshal([]byte(v), &strct.OrganizationEnabled); err != nil {
                return err
             }
        case "RetentionPeriod":
            if err := json.Unmarshal([]byte(v), &strct.RetentionPeriod); err != nil {
                return err
             }
        case "Status":
            if err := json.Unmarshal([]byte(v), &strct.Status); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        case "TerminationProtectionEnabled":
            if err := json.Unmarshal([]byte(v), &strct.TerminationProtectionEnabled); err != nil {
                return err
             }
        case "UpdatedTimestamp":
            if err := json.Unmarshal([]byte(v), &strct.UpdatedTimestamp); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}
