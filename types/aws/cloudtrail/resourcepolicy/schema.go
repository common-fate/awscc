// Code generated by schema-generate. DO NOT EDIT.

package resourcepolicy

import (
    "encoding/json"
    "fmt"
    "errors"
    "bytes"
)

// Resource Resource Type definition for AWS::CloudTrail::ResourcePolicy
type Resource struct {

  // The ARN of the AWS CloudTrail resource to which the policy applies.
  ResourceArn string `json:"ResourceArn"`

  // A policy document containing permissions to add to the specified resource. In IAM, you must provide policy documents in JSON format. However, in CloudFormation you can provide the policy in JSON or YAML format because CloudFormation converts YAML to JSON before submitting it to IAM.
  ResourcePolicy interface{} `json:"ResourcePolicy"`
}

// ResourcePolicy_object A policy document containing permissions to add to the specified resource. In IAM, you must provide policy documents in JSON format. However, in CloudFormation you can provide the policy in JSON or YAML format because CloudFormation converts YAML to JSON before submitting it to IAM.
type ResourcePolicy_object struct {
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ResourceArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ResourceArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ResourceArn\": ")
	if tmp, err := json.Marshal(strct.ResourceArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ResourcePolicy" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ResourcePolicy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ResourcePolicy\": ")
	if tmp, err := json.Marshal(strct.ResourcePolicy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    ResourceArnReceived := false
    ResourcePolicyReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ResourceArn":
            if err := json.Unmarshal([]byte(v), &strct.ResourceArn); err != nil {
                return err
             }
            ResourceArnReceived = true
        case "ResourcePolicy":
            if err := json.Unmarshal([]byte(v), &strct.ResourcePolicy); err != nil {
                return err
             }
            ResourcePolicyReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ResourceArn (a required property) was received
    if !ResourceArnReceived {
        return errors.New("\"ResourceArn\" is required but was not present")
    }
    // check if ResourcePolicy (a required property) was received
    if !ResourcePolicyReceived {
        return errors.New("\"ResourcePolicy\" is required but was not present")
    }
    return nil
}
