// Code generated by schema-generate. DO NOT EDIT.

package experimenttemplate

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// CloudWatchLogsConfiguration 
type CloudWatchLogsConfiguration struct {
  LogGroupArn string `json:"LogGroupArn"`
}

// ExperimentTemplateAction Specifies an action for the experiment template.
type ExperimentTemplateAction struct {
  ActionId string `json:"ActionId"`
  Description string `json:"Description,omitempty"`

  // The parameters for the action, if applicable.
  Parameters *Parameters `json:"Parameters,omitempty"`
  StartAfter []string `json:"StartAfter,omitempty"`

  // One or more targets for the action.
  Targets *Targets `json:"Targets,omitempty"`
}

// ExperimentTemplateActionMap The actions for the experiment.
type ExperimentTemplateActionMap struct {
}

// ExperimentTemplateLogConfiguration 
type ExperimentTemplateLogConfiguration struct {
  CloudWatchLogsConfiguration *CloudWatchLogsConfiguration `json:"CloudWatchLogsConfiguration,omitempty"`
  LogSchemaVersion int `json:"LogSchemaVersion"`
  S3Configuration *S3Configuration `json:"S3Configuration,omitempty"`
}

// ExperimentTemplateStopCondition 
type ExperimentTemplateStopCondition struct {
  Source string `json:"Source"`
  Value string `json:"Value,omitempty"`
}

// ExperimentTemplateTarget Specifies a target for an experiment.
type ExperimentTemplateTarget struct {
  Filters []*ExperimentTemplateTargetFilter `json:"Filters,omitempty"`
  Parameters *Parameters `json:"Parameters,omitempty"`
  ResourceArns []string `json:"ResourceArns,omitempty"`
  ResourceTags *ResourceTags `json:"ResourceTags,omitempty"`
  ResourceType string `json:"ResourceType"`
  SelectionMode string `json:"SelectionMode"`
}

// ExperimentTemplateTargetFilter Describes a filter used for the target resource input in an experiment template.
type ExperimentTemplateTargetFilter struct {
  Path string `json:"Path"`
  Values []string `json:"Values"`
}

// ExperimentTemplateTargetMap The targets for the experiment.
type ExperimentTemplateTargetMap struct {
}

// Parameters 
type Parameters struct {
}

// Resource Resource schema for AWS::FIS::ExperimentTemplate
type Resource struct {
  Actions *ExperimentTemplateActionMap `json:"Actions,omitempty"`
  Description string `json:"Description"`
  Id string `json:"Id,omitempty"`
  LogConfiguration *ExperimentTemplateLogConfiguration `json:"LogConfiguration,omitempty"`
  RoleArn string `json:"RoleArn"`
  StopConditions []*ExperimentTemplateStopCondition `json:"StopConditions"`
  Tags *Tags `json:"Tags"`
  Targets *ExperimentTemplateTargetMap `json:"Targets"`
}

// ResourceTags 
type ResourceTags struct {
}

// S3Configuration 
type S3Configuration struct {
  BucketName string `json:"BucketName"`
  Prefix string `json:"Prefix,omitempty"`
}

// Tags 
type Tags struct {
}

// Targets One or more targets for the action.
type Targets struct {
}

func (strct *CloudWatchLogsConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "LogGroupArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "LogGroupArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LogGroupArn\": ")
	if tmp, err := json.Marshal(strct.LogGroupArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CloudWatchLogsConfiguration) UnmarshalJSON(b []byte) error {
    LogGroupArnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "LogGroupArn":
            if err := json.Unmarshal([]byte(v), &strct.LogGroupArn); err != nil {
                return err
             }
            LogGroupArnReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if LogGroupArn (a required property) was received
    if !LogGroupArnReceived {
        return errors.New("\"LogGroupArn\" is required but was not present")
    }
    return nil
}

func (strct *ExperimentTemplateAction) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ActionId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ActionId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ActionId\": ")
	if tmp, err := json.Marshal(strct.ActionId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Parameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Parameters\": ")
	if tmp, err := json.Marshal(strct.Parameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StartAfter" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StartAfter\": ")
	if tmp, err := json.Marshal(strct.StartAfter); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Targets" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Targets\": ")
	if tmp, err := json.Marshal(strct.Targets); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ExperimentTemplateAction) UnmarshalJSON(b []byte) error {
    ActionIdReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ActionId":
            if err := json.Unmarshal([]byte(v), &strct.ActionId); err != nil {
                return err
             }
            ActionIdReceived = true
        case "Description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "Parameters":
            if err := json.Unmarshal([]byte(v), &strct.Parameters); err != nil {
                return err
             }
        case "StartAfter":
            if err := json.Unmarshal([]byte(v), &strct.StartAfter); err != nil {
                return err
             }
        case "Targets":
            if err := json.Unmarshal([]byte(v), &strct.Targets); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ActionId (a required property) was received
    if !ActionIdReceived {
        return errors.New("\"ActionId\" is required but was not present")
    }
    return nil
}

func (strct *ExperimentTemplateActionMap) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ExperimentTemplateActionMap) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ExperimentTemplateLogConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CloudWatchLogsConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CloudWatchLogsConfiguration\": ")
	if tmp, err := json.Marshal(strct.CloudWatchLogsConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "LogSchemaVersion" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "LogSchemaVersion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LogSchemaVersion\": ")
	if tmp, err := json.Marshal(strct.LogSchemaVersion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "S3Configuration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3Configuration\": ")
	if tmp, err := json.Marshal(strct.S3Configuration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ExperimentTemplateLogConfiguration) UnmarshalJSON(b []byte) error {
    LogSchemaVersionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CloudWatchLogsConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.CloudWatchLogsConfiguration); err != nil {
                return err
             }
        case "LogSchemaVersion":
            if err := json.Unmarshal([]byte(v), &strct.LogSchemaVersion); err != nil {
                return err
             }
            LogSchemaVersionReceived = true
        case "S3Configuration":
            if err := json.Unmarshal([]byte(v), &strct.S3Configuration); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if LogSchemaVersion (a required property) was received
    if !LogSchemaVersionReceived {
        return errors.New("\"LogSchemaVersion\" is required but was not present")
    }
    return nil
}

func (strct *ExperimentTemplateStopCondition) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Source" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Source" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Source\": ")
	if tmp, err := json.Marshal(strct.Source); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ExperimentTemplateStopCondition) UnmarshalJSON(b []byte) error {
    SourceReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Source":
            if err := json.Unmarshal([]byte(v), &strct.Source); err != nil {
                return err
             }
            SourceReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Source (a required property) was received
    if !SourceReceived {
        return errors.New("\"Source\" is required but was not present")
    }
    return nil
}

func (strct *ExperimentTemplateTarget) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Filters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Filters\": ")
	if tmp, err := json.Marshal(strct.Filters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Parameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Parameters\": ")
	if tmp, err := json.Marshal(strct.Parameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ResourceArns" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ResourceArns\": ")
	if tmp, err := json.Marshal(strct.ResourceArns); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ResourceTags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ResourceTags\": ")
	if tmp, err := json.Marshal(strct.ResourceTags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ResourceType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ResourceType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ResourceType\": ")
	if tmp, err := json.Marshal(strct.ResourceType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "SelectionMode" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "SelectionMode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SelectionMode\": ")
	if tmp, err := json.Marshal(strct.SelectionMode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ExperimentTemplateTarget) UnmarshalJSON(b []byte) error {
    ResourceTypeReceived := false
    SelectionModeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Filters":
            if err := json.Unmarshal([]byte(v), &strct.Filters); err != nil {
                return err
             }
        case "Parameters":
            if err := json.Unmarshal([]byte(v), &strct.Parameters); err != nil {
                return err
             }
        case "ResourceArns":
            if err := json.Unmarshal([]byte(v), &strct.ResourceArns); err != nil {
                return err
             }
        case "ResourceTags":
            if err := json.Unmarshal([]byte(v), &strct.ResourceTags); err != nil {
                return err
             }
        case "ResourceType":
            if err := json.Unmarshal([]byte(v), &strct.ResourceType); err != nil {
                return err
             }
            ResourceTypeReceived = true
        case "SelectionMode":
            if err := json.Unmarshal([]byte(v), &strct.SelectionMode); err != nil {
                return err
             }
            SelectionModeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ResourceType (a required property) was received
    if !ResourceTypeReceived {
        return errors.New("\"ResourceType\" is required but was not present")
    }
    // check if SelectionMode (a required property) was received
    if !SelectionModeReceived {
        return errors.New("\"SelectionMode\" is required but was not present")
    }
    return nil
}

func (strct *ExperimentTemplateTargetFilter) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Path" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Path" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Path\": ")
	if tmp, err := json.Marshal(strct.Path); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Values" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Values" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Values\": ")
	if tmp, err := json.Marshal(strct.Values); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ExperimentTemplateTargetFilter) UnmarshalJSON(b []byte) error {
    PathReceived := false
    ValuesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Path":
            if err := json.Unmarshal([]byte(v), &strct.Path); err != nil {
                return err
             }
            PathReceived = true
        case "Values":
            if err := json.Unmarshal([]byte(v), &strct.Values); err != nil {
                return err
             }
            ValuesReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Path (a required property) was received
    if !PathReceived {
        return errors.New("\"Path\" is required but was not present")
    }
    // check if Values (a required property) was received
    if !ValuesReceived {
        return errors.New("\"Values\" is required but was not present")
    }
    return nil
}

func (strct *ExperimentTemplateTargetMap) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ExperimentTemplateTargetMap) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Parameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Parameters) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Actions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Actions\": ")
	if tmp, err := json.Marshal(strct.Actions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Description" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Id" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LogConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LogConfiguration\": ")
	if tmp, err := json.Marshal(strct.LogConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RoleArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoleArn\": ")
	if tmp, err := json.Marshal(strct.RoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "StopConditions" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "StopConditions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StopConditions\": ")
	if tmp, err := json.Marshal(strct.StopConditions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Tags" field is required
    if strct.Tags == nil {
        return nil, errors.New("Tags is a required field")
    }
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Targets" field is required
    if strct.Targets == nil {
        return nil, errors.New("Targets is a required field")
    }
    // Marshal the "Targets" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Targets\": ")
	if tmp, err := json.Marshal(strct.Targets); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    DescriptionReceived := false
    RoleArnReceived := false
    StopConditionsReceived := false
    TagsReceived := false
    TargetsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Actions":
            if err := json.Unmarshal([]byte(v), &strct.Actions); err != nil {
                return err
             }
        case "Description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
            DescriptionReceived = true
        case "Id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
        case "LogConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.LogConfiguration); err != nil {
                return err
             }
        case "RoleArn":
            if err := json.Unmarshal([]byte(v), &strct.RoleArn); err != nil {
                return err
             }
            RoleArnReceived = true
        case "StopConditions":
            if err := json.Unmarshal([]byte(v), &strct.StopConditions); err != nil {
                return err
             }
            StopConditionsReceived = true
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
            TagsReceived = true
        case "Targets":
            if err := json.Unmarshal([]byte(v), &strct.Targets); err != nil {
                return err
             }
            TargetsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Description (a required property) was received
    if !DescriptionReceived {
        return errors.New("\"Description\" is required but was not present")
    }
    // check if RoleArn (a required property) was received
    if !RoleArnReceived {
        return errors.New("\"RoleArn\" is required but was not present")
    }
    // check if StopConditions (a required property) was received
    if !StopConditionsReceived {
        return errors.New("\"StopConditions\" is required but was not present")
    }
    // check if Tags (a required property) was received
    if !TagsReceived {
        return errors.New("\"Tags\" is required but was not present")
    }
    // check if Targets (a required property) was received
    if !TargetsReceived {
        return errors.New("\"Targets\" is required but was not present")
    }
    return nil
}

func (strct *ResourceTags) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ResourceTags) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *S3Configuration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "BucketName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "BucketName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BucketName\": ")
	if tmp, err := json.Marshal(strct.BucketName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Prefix" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Prefix\": ")
	if tmp, err := json.Marshal(strct.Prefix); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *S3Configuration) UnmarshalJSON(b []byte) error {
    BucketNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BucketName":
            if err := json.Unmarshal([]byte(v), &strct.BucketName); err != nil {
                return err
             }
            BucketNameReceived = true
        case "Prefix":
            if err := json.Unmarshal([]byte(v), &strct.Prefix); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if BucketName (a required property) was received
    if !BucketNameReceived {
        return errors.New("\"BucketName\" is required but was not present")
    }
    return nil
}

func (strct *Tags) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tags) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Targets) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Targets) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}
