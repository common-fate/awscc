// Code generated by schema-generate. DO NOT EDIT.

package rulegroup

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// ActionDefinition 
type ActionDefinition struct {
  PublishMetricAction *PublishMetricAction `json:"PublishMetricAction,omitempty"`
}

// Address 
type Address struct {
  AddressDefinition string `json:"AddressDefinition"`
}

// CustomAction 
type CustomAction struct {
  ActionDefinition *ActionDefinition `json:"ActionDefinition"`
  ActionName string `json:"ActionName"`
}

// Dimension 
type Dimension struct {
  Value string `json:"Value"`
}

// Header 
type Header struct {
  Destination string `json:"Destination"`
  DestinationPort string `json:"DestinationPort"`
  Direction string `json:"Direction"`
  Protocol string `json:"Protocol"`
  Source string `json:"Source"`
  SourcePort string `json:"SourcePort"`
}

// IPSet 
type IPSet struct {
  Definition []string `json:"Definition,omitempty"`
}

// IPSetReference 
type IPSetReference struct {
  ReferenceArn string `json:"ReferenceArn,omitempty"`
}

// IPSetReferences 
type IPSetReferences struct {
}

// IPSets 
type IPSets struct {
}

// MatchAttributes 
type MatchAttributes struct {
  DestinationPorts []*PortRange `json:"DestinationPorts,omitempty"`
  Destinations []*Address `json:"Destinations,omitempty"`
  Protocols []int `json:"Protocols,omitempty"`
  SourcePorts []*PortRange `json:"SourcePorts,omitempty"`
  Sources []*Address `json:"Sources,omitempty"`
  TCPFlags []*TCPFlagField `json:"TCPFlags,omitempty"`
}

// PortRange 
type PortRange struct {
  FromPort int `json:"FromPort"`
  ToPort int `json:"ToPort"`
}

// PortSet 
type PortSet struct {
  Definition []string `json:"Definition,omitempty"`
}

// PortSets 
type PortSets struct {
}

// PublishMetricAction 
type PublishMetricAction struct {
  Dimensions []*Dimension `json:"Dimensions"`
}

// ReferenceSets 
type ReferenceSets struct {
  IPSetReferences *IPSetReferences `json:"IPSetReferences,omitempty"`
}

// Resource Resource type definition for AWS::NetworkFirewall::RuleGroup
type Resource struct {
  Capacity int `json:"Capacity"`
  Description string `json:"Description,omitempty"`
  RuleGroup *RuleGroup `json:"RuleGroup,omitempty"`
  RuleGroupArn string `json:"RuleGroupArn,omitempty"`
  RuleGroupId string `json:"RuleGroupId,omitempty"`
  RuleGroupName string `json:"RuleGroupName"`
  Tags []*Tag `json:"Tags,omitempty"`
  Type string `json:"Type"`
}

// RuleDefinition 
type RuleDefinition struct {
  Actions []string `json:"Actions"`
  MatchAttributes *MatchAttributes `json:"MatchAttributes"`
}

// RuleGroup 
type RuleGroup struct {
  ReferenceSets *ReferenceSets `json:"ReferenceSets,omitempty"`
  RuleVariables *RuleVariables `json:"RuleVariables,omitempty"`
  RulesSource *RulesSource `json:"RulesSource"`
  StatefulRuleOptions *StatefulRuleOptions `json:"StatefulRuleOptions,omitempty"`
}

// RuleOption 
type RuleOption struct {
  Keyword string `json:"Keyword"`
  Settings []string `json:"Settings,omitempty"`
}

// RuleVariables 
type RuleVariables struct {
  IPSets *IPSets `json:"IPSets,omitempty"`
  PortSets *PortSets `json:"PortSets,omitempty"`
}

// RulesSource 
type RulesSource struct {
  RulesSourceList *RulesSourceList `json:"RulesSourceList,omitempty"`
  RulesString string `json:"RulesString,omitempty"`
  StatefulRules []*StatefulRule `json:"StatefulRules,omitempty"`
  StatelessRulesAndCustomActions *StatelessRulesAndCustomActions `json:"StatelessRulesAndCustomActions,omitempty"`
}

// RulesSourceList 
type RulesSourceList struct {
  GeneratedRulesType string `json:"GeneratedRulesType"`
  TargetTypes []string `json:"TargetTypes"`
  Targets []string `json:"Targets"`
}

// StatefulRule 
type StatefulRule struct {
  Action string `json:"Action"`
  Header *Header `json:"Header"`
  RuleOptions []*RuleOption `json:"RuleOptions"`
}

// StatefulRuleOptions 
type StatefulRuleOptions struct {
  RuleOrder string `json:"RuleOrder,omitempty"`
}

// StatelessRule 
type StatelessRule struct {
  Priority int `json:"Priority"`
  RuleDefinition *RuleDefinition `json:"RuleDefinition"`
}

// StatelessRulesAndCustomActions 
type StatelessRulesAndCustomActions struct {
  CustomActions []*CustomAction `json:"CustomActions,omitempty"`
  StatelessRules []*StatelessRule `json:"StatelessRules"`
}

// TCPFlagField 
type TCPFlagField struct {
  Flags []string `json:"Flags"`
  Masks []string `json:"Masks,omitempty"`
}

// Tag 
type Tag struct {
  Key string `json:"Key"`
  Value string `json:"Value"`
}

func (strct *ActionDefinition) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "PublishMetricAction" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PublishMetricAction\": ")
	if tmp, err := json.Marshal(strct.PublishMetricAction); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ActionDefinition) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "PublishMetricAction":
            if err := json.Unmarshal([]byte(v), &strct.PublishMetricAction); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Address) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AddressDefinition" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AddressDefinition" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AddressDefinition\": ")
	if tmp, err := json.Marshal(strct.AddressDefinition); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Address) UnmarshalJSON(b []byte) error {
    AddressDefinitionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AddressDefinition":
            if err := json.Unmarshal([]byte(v), &strct.AddressDefinition); err != nil {
                return err
             }
            AddressDefinitionReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if AddressDefinition (a required property) was received
    if !AddressDefinitionReceived {
        return errors.New("\"AddressDefinition\" is required but was not present")
    }
    return nil
}

func (strct *CustomAction) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ActionDefinition" field is required
    if strct.ActionDefinition == nil {
        return nil, errors.New("ActionDefinition is a required field")
    }
    // Marshal the "ActionDefinition" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ActionDefinition\": ")
	if tmp, err := json.Marshal(strct.ActionDefinition); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ActionName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ActionName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ActionName\": ")
	if tmp, err := json.Marshal(strct.ActionName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CustomAction) UnmarshalJSON(b []byte) error {
    ActionDefinitionReceived := false
    ActionNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ActionDefinition":
            if err := json.Unmarshal([]byte(v), &strct.ActionDefinition); err != nil {
                return err
             }
            ActionDefinitionReceived = true
        case "ActionName":
            if err := json.Unmarshal([]byte(v), &strct.ActionName); err != nil {
                return err
             }
            ActionNameReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ActionDefinition (a required property) was received
    if !ActionDefinitionReceived {
        return errors.New("\"ActionDefinition\" is required but was not present")
    }
    // check if ActionName (a required property) was received
    if !ActionNameReceived {
        return errors.New("\"ActionName\" is required but was not present")
    }
    return nil
}

func (strct *Dimension) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Dimension) UnmarshalJSON(b []byte) error {
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *Header) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Destination" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Destination" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Destination\": ")
	if tmp, err := json.Marshal(strct.Destination); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "DestinationPort" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "DestinationPort" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DestinationPort\": ")
	if tmp, err := json.Marshal(strct.DestinationPort); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Direction" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Direction" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Direction\": ")
	if tmp, err := json.Marshal(strct.Direction); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Protocol" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Protocol" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Protocol\": ")
	if tmp, err := json.Marshal(strct.Protocol); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Source" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Source" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Source\": ")
	if tmp, err := json.Marshal(strct.Source); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "SourcePort" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "SourcePort" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SourcePort\": ")
	if tmp, err := json.Marshal(strct.SourcePort); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Header) UnmarshalJSON(b []byte) error {
    DestinationReceived := false
    DestinationPortReceived := false
    DirectionReceived := false
    ProtocolReceived := false
    SourceReceived := false
    SourcePortReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Destination":
            if err := json.Unmarshal([]byte(v), &strct.Destination); err != nil {
                return err
             }
            DestinationReceived = true
        case "DestinationPort":
            if err := json.Unmarshal([]byte(v), &strct.DestinationPort); err != nil {
                return err
             }
            DestinationPortReceived = true
        case "Direction":
            if err := json.Unmarshal([]byte(v), &strct.Direction); err != nil {
                return err
             }
            DirectionReceived = true
        case "Protocol":
            if err := json.Unmarshal([]byte(v), &strct.Protocol); err != nil {
                return err
             }
            ProtocolReceived = true
        case "Source":
            if err := json.Unmarshal([]byte(v), &strct.Source); err != nil {
                return err
             }
            SourceReceived = true
        case "SourcePort":
            if err := json.Unmarshal([]byte(v), &strct.SourcePort); err != nil {
                return err
             }
            SourcePortReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Destination (a required property) was received
    if !DestinationReceived {
        return errors.New("\"Destination\" is required but was not present")
    }
    // check if DestinationPort (a required property) was received
    if !DestinationPortReceived {
        return errors.New("\"DestinationPort\" is required but was not present")
    }
    // check if Direction (a required property) was received
    if !DirectionReceived {
        return errors.New("\"Direction\" is required but was not present")
    }
    // check if Protocol (a required property) was received
    if !ProtocolReceived {
        return errors.New("\"Protocol\" is required but was not present")
    }
    // check if Source (a required property) was received
    if !SourceReceived {
        return errors.New("\"Source\" is required but was not present")
    }
    // check if SourcePort (a required property) was received
    if !SourcePortReceived {
        return errors.New("\"SourcePort\" is required but was not present")
    }
    return nil
}

func (strct *IPSet) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Definition" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Definition\": ")
	if tmp, err := json.Marshal(strct.Definition); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *IPSet) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Definition":
            if err := json.Unmarshal([]byte(v), &strct.Definition); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *IPSetReference) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ReferenceArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ReferenceArn\": ")
	if tmp, err := json.Marshal(strct.ReferenceArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *IPSetReference) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ReferenceArn":
            if err := json.Unmarshal([]byte(v), &strct.ReferenceArn); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *IPSetReferences) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *IPSetReferences) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *IPSets) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *IPSets) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *MatchAttributes) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DestinationPorts" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DestinationPorts\": ")
	if tmp, err := json.Marshal(strct.DestinationPorts); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Destinations" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Destinations\": ")
	if tmp, err := json.Marshal(strct.Destinations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Protocols" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Protocols\": ")
	if tmp, err := json.Marshal(strct.Protocols); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SourcePorts" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SourcePorts\": ")
	if tmp, err := json.Marshal(strct.SourcePorts); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Sources" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Sources\": ")
	if tmp, err := json.Marshal(strct.Sources); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TCPFlags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TCPFlags\": ")
	if tmp, err := json.Marshal(strct.TCPFlags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MatchAttributes) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DestinationPorts":
            if err := json.Unmarshal([]byte(v), &strct.DestinationPorts); err != nil {
                return err
             }
        case "Destinations":
            if err := json.Unmarshal([]byte(v), &strct.Destinations); err != nil {
                return err
             }
        case "Protocols":
            if err := json.Unmarshal([]byte(v), &strct.Protocols); err != nil {
                return err
             }
        case "SourcePorts":
            if err := json.Unmarshal([]byte(v), &strct.SourcePorts); err != nil {
                return err
             }
        case "Sources":
            if err := json.Unmarshal([]byte(v), &strct.Sources); err != nil {
                return err
             }
        case "TCPFlags":
            if err := json.Unmarshal([]byte(v), &strct.TCPFlags); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *PortRange) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "FromPort" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "FromPort" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FromPort\": ")
	if tmp, err := json.Marshal(strct.FromPort); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ToPort" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ToPort" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ToPort\": ")
	if tmp, err := json.Marshal(strct.ToPort); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PortRange) UnmarshalJSON(b []byte) error {
    FromPortReceived := false
    ToPortReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "FromPort":
            if err := json.Unmarshal([]byte(v), &strct.FromPort); err != nil {
                return err
             }
            FromPortReceived = true
        case "ToPort":
            if err := json.Unmarshal([]byte(v), &strct.ToPort); err != nil {
                return err
             }
            ToPortReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if FromPort (a required property) was received
    if !FromPortReceived {
        return errors.New("\"FromPort\" is required but was not present")
    }
    // check if ToPort (a required property) was received
    if !ToPortReceived {
        return errors.New("\"ToPort\" is required but was not present")
    }
    return nil
}

func (strct *PortSet) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Definition" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Definition\": ")
	if tmp, err := json.Marshal(strct.Definition); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PortSet) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Definition":
            if err := json.Unmarshal([]byte(v), &strct.Definition); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *PortSets) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PortSets) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *PublishMetricAction) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Dimensions" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Dimensions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Dimensions\": ")
	if tmp, err := json.Marshal(strct.Dimensions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PublishMetricAction) UnmarshalJSON(b []byte) error {
    DimensionsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Dimensions":
            if err := json.Unmarshal([]byte(v), &strct.Dimensions); err != nil {
                return err
             }
            DimensionsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Dimensions (a required property) was received
    if !DimensionsReceived {
        return errors.New("\"Dimensions\" is required but was not present")
    }
    return nil
}

func (strct *ReferenceSets) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "IPSetReferences" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IPSetReferences\": ")
	if tmp, err := json.Marshal(strct.IPSetReferences); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ReferenceSets) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "IPSetReferences":
            if err := json.Unmarshal([]byte(v), &strct.IPSetReferences); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Capacity" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Capacity" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Capacity\": ")
	if tmp, err := json.Marshal(strct.Capacity); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RuleGroup" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RuleGroup\": ")
	if tmp, err := json.Marshal(strct.RuleGroup); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RuleGroupArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RuleGroupArn\": ")
	if tmp, err := json.Marshal(strct.RuleGroupArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RuleGroupId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RuleGroupId\": ")
	if tmp, err := json.Marshal(strct.RuleGroupId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RuleGroupName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RuleGroupName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RuleGroupName\": ")
	if tmp, err := json.Marshal(strct.RuleGroupName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    CapacityReceived := false
    RuleGroupNameReceived := false
    TypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Capacity":
            if err := json.Unmarshal([]byte(v), &strct.Capacity); err != nil {
                return err
             }
            CapacityReceived = true
        case "Description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "RuleGroup":
            if err := json.Unmarshal([]byte(v), &strct.RuleGroup); err != nil {
                return err
             }
        case "RuleGroupArn":
            if err := json.Unmarshal([]byte(v), &strct.RuleGroupArn); err != nil {
                return err
             }
        case "RuleGroupId":
            if err := json.Unmarshal([]byte(v), &strct.RuleGroupId); err != nil {
                return err
             }
        case "RuleGroupName":
            if err := json.Unmarshal([]byte(v), &strct.RuleGroupName); err != nil {
                return err
             }
            RuleGroupNameReceived = true
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            TypeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Capacity (a required property) was received
    if !CapacityReceived {
        return errors.New("\"Capacity\" is required but was not present")
    }
    // check if RuleGroupName (a required property) was received
    if !RuleGroupNameReceived {
        return errors.New("\"RuleGroupName\" is required but was not present")
    }
    // check if Type (a required property) was received
    if !TypeReceived {
        return errors.New("\"Type\" is required but was not present")
    }
    return nil
}

func (strct *RuleDefinition) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Actions" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Actions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Actions\": ")
	if tmp, err := json.Marshal(strct.Actions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "MatchAttributes" field is required
    if strct.MatchAttributes == nil {
        return nil, errors.New("MatchAttributes is a required field")
    }
    // Marshal the "MatchAttributes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MatchAttributes\": ")
	if tmp, err := json.Marshal(strct.MatchAttributes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RuleDefinition) UnmarshalJSON(b []byte) error {
    ActionsReceived := false
    MatchAttributesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Actions":
            if err := json.Unmarshal([]byte(v), &strct.Actions); err != nil {
                return err
             }
            ActionsReceived = true
        case "MatchAttributes":
            if err := json.Unmarshal([]byte(v), &strct.MatchAttributes); err != nil {
                return err
             }
            MatchAttributesReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Actions (a required property) was received
    if !ActionsReceived {
        return errors.New("\"Actions\" is required but was not present")
    }
    // check if MatchAttributes (a required property) was received
    if !MatchAttributesReceived {
        return errors.New("\"MatchAttributes\" is required but was not present")
    }
    return nil
}

func (strct *RuleGroup) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ReferenceSets" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ReferenceSets\": ")
	if tmp, err := json.Marshal(strct.ReferenceSets); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RuleVariables" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RuleVariables\": ")
	if tmp, err := json.Marshal(strct.RuleVariables); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RulesSource" field is required
    if strct.RulesSource == nil {
        return nil, errors.New("RulesSource is a required field")
    }
    // Marshal the "RulesSource" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RulesSource\": ")
	if tmp, err := json.Marshal(strct.RulesSource); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StatefulRuleOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StatefulRuleOptions\": ")
	if tmp, err := json.Marshal(strct.StatefulRuleOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RuleGroup) UnmarshalJSON(b []byte) error {
    RulesSourceReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ReferenceSets":
            if err := json.Unmarshal([]byte(v), &strct.ReferenceSets); err != nil {
                return err
             }
        case "RuleVariables":
            if err := json.Unmarshal([]byte(v), &strct.RuleVariables); err != nil {
                return err
             }
        case "RulesSource":
            if err := json.Unmarshal([]byte(v), &strct.RulesSource); err != nil {
                return err
             }
            RulesSourceReceived = true
        case "StatefulRuleOptions":
            if err := json.Unmarshal([]byte(v), &strct.StatefulRuleOptions); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if RulesSource (a required property) was received
    if !RulesSourceReceived {
        return errors.New("\"RulesSource\" is required but was not present")
    }
    return nil
}

func (strct *RuleOption) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Keyword" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Keyword" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Keyword\": ")
	if tmp, err := json.Marshal(strct.Keyword); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Settings" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Settings\": ")
	if tmp, err := json.Marshal(strct.Settings); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RuleOption) UnmarshalJSON(b []byte) error {
    KeywordReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Keyword":
            if err := json.Unmarshal([]byte(v), &strct.Keyword); err != nil {
                return err
             }
            KeywordReceived = true
        case "Settings":
            if err := json.Unmarshal([]byte(v), &strct.Settings); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Keyword (a required property) was received
    if !KeywordReceived {
        return errors.New("\"Keyword\" is required but was not present")
    }
    return nil
}

func (strct *RuleVariables) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "IPSets" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IPSets\": ")
	if tmp, err := json.Marshal(strct.IPSets); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PortSets" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PortSets\": ")
	if tmp, err := json.Marshal(strct.PortSets); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RuleVariables) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "IPSets":
            if err := json.Unmarshal([]byte(v), &strct.IPSets); err != nil {
                return err
             }
        case "PortSets":
            if err := json.Unmarshal([]byte(v), &strct.PortSets); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *RulesSource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "RulesSourceList" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RulesSourceList\": ")
	if tmp, err := json.Marshal(strct.RulesSourceList); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RulesString" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RulesString\": ")
	if tmp, err := json.Marshal(strct.RulesString); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StatefulRules" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StatefulRules\": ")
	if tmp, err := json.Marshal(strct.StatefulRules); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StatelessRulesAndCustomActions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StatelessRulesAndCustomActions\": ")
	if tmp, err := json.Marshal(strct.StatelessRulesAndCustomActions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RulesSource) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "RulesSourceList":
            if err := json.Unmarshal([]byte(v), &strct.RulesSourceList); err != nil {
                return err
             }
        case "RulesString":
            if err := json.Unmarshal([]byte(v), &strct.RulesString); err != nil {
                return err
             }
        case "StatefulRules":
            if err := json.Unmarshal([]byte(v), &strct.StatefulRules); err != nil {
                return err
             }
        case "StatelessRulesAndCustomActions":
            if err := json.Unmarshal([]byte(v), &strct.StatelessRulesAndCustomActions); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *RulesSourceList) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "GeneratedRulesType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "GeneratedRulesType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"GeneratedRulesType\": ")
	if tmp, err := json.Marshal(strct.GeneratedRulesType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TargetTypes" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TargetTypes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TargetTypes\": ")
	if tmp, err := json.Marshal(strct.TargetTypes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Targets" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Targets" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Targets\": ")
	if tmp, err := json.Marshal(strct.Targets); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RulesSourceList) UnmarshalJSON(b []byte) error {
    GeneratedRulesTypeReceived := false
    TargetTypesReceived := false
    TargetsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "GeneratedRulesType":
            if err := json.Unmarshal([]byte(v), &strct.GeneratedRulesType); err != nil {
                return err
             }
            GeneratedRulesTypeReceived = true
        case "TargetTypes":
            if err := json.Unmarshal([]byte(v), &strct.TargetTypes); err != nil {
                return err
             }
            TargetTypesReceived = true
        case "Targets":
            if err := json.Unmarshal([]byte(v), &strct.Targets); err != nil {
                return err
             }
            TargetsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if GeneratedRulesType (a required property) was received
    if !GeneratedRulesTypeReceived {
        return errors.New("\"GeneratedRulesType\" is required but was not present")
    }
    // check if TargetTypes (a required property) was received
    if !TargetTypesReceived {
        return errors.New("\"TargetTypes\" is required but was not present")
    }
    // check if Targets (a required property) was received
    if !TargetsReceived {
        return errors.New("\"Targets\" is required but was not present")
    }
    return nil
}

func (strct *StatefulRule) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Action" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Action" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Action\": ")
	if tmp, err := json.Marshal(strct.Action); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Header" field is required
    if strct.Header == nil {
        return nil, errors.New("Header is a required field")
    }
    // Marshal the "Header" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Header\": ")
	if tmp, err := json.Marshal(strct.Header); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RuleOptions" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RuleOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RuleOptions\": ")
	if tmp, err := json.Marshal(strct.RuleOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *StatefulRule) UnmarshalJSON(b []byte) error {
    ActionReceived := false
    HeaderReceived := false
    RuleOptionsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Action":
            if err := json.Unmarshal([]byte(v), &strct.Action); err != nil {
                return err
             }
            ActionReceived = true
        case "Header":
            if err := json.Unmarshal([]byte(v), &strct.Header); err != nil {
                return err
             }
            HeaderReceived = true
        case "RuleOptions":
            if err := json.Unmarshal([]byte(v), &strct.RuleOptions); err != nil {
                return err
             }
            RuleOptionsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Action (a required property) was received
    if !ActionReceived {
        return errors.New("\"Action\" is required but was not present")
    }
    // check if Header (a required property) was received
    if !HeaderReceived {
        return errors.New("\"Header\" is required but was not present")
    }
    // check if RuleOptions (a required property) was received
    if !RuleOptionsReceived {
        return errors.New("\"RuleOptions\" is required but was not present")
    }
    return nil
}

func (strct *StatefulRuleOptions) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "RuleOrder" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RuleOrder\": ")
	if tmp, err := json.Marshal(strct.RuleOrder); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *StatefulRuleOptions) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "RuleOrder":
            if err := json.Unmarshal([]byte(v), &strct.RuleOrder); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *StatelessRule) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Priority" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Priority" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Priority\": ")
	if tmp, err := json.Marshal(strct.Priority); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RuleDefinition" field is required
    if strct.RuleDefinition == nil {
        return nil, errors.New("RuleDefinition is a required field")
    }
    // Marshal the "RuleDefinition" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RuleDefinition\": ")
	if tmp, err := json.Marshal(strct.RuleDefinition); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *StatelessRule) UnmarshalJSON(b []byte) error {
    PriorityReceived := false
    RuleDefinitionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Priority":
            if err := json.Unmarshal([]byte(v), &strct.Priority); err != nil {
                return err
             }
            PriorityReceived = true
        case "RuleDefinition":
            if err := json.Unmarshal([]byte(v), &strct.RuleDefinition); err != nil {
                return err
             }
            RuleDefinitionReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Priority (a required property) was received
    if !PriorityReceived {
        return errors.New("\"Priority\" is required but was not present")
    }
    // check if RuleDefinition (a required property) was received
    if !RuleDefinitionReceived {
        return errors.New("\"RuleDefinition\" is required but was not present")
    }
    return nil
}

func (strct *StatelessRulesAndCustomActions) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CustomActions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CustomActions\": ")
	if tmp, err := json.Marshal(strct.CustomActions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "StatelessRules" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "StatelessRules" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StatelessRules\": ")
	if tmp, err := json.Marshal(strct.StatelessRules); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *StatelessRulesAndCustomActions) UnmarshalJSON(b []byte) error {
    StatelessRulesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CustomActions":
            if err := json.Unmarshal([]byte(v), &strct.CustomActions); err != nil {
                return err
             }
        case "StatelessRules":
            if err := json.Unmarshal([]byte(v), &strct.StatelessRules); err != nil {
                return err
             }
            StatelessRulesReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if StatelessRules (a required property) was received
    if !StatelessRulesReceived {
        return errors.New("\"StatelessRules\" is required but was not present")
    }
    return nil
}

func (strct *TCPFlagField) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Flags" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Flags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Flags\": ")
	if tmp, err := json.Marshal(strct.Flags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Masks" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Masks\": ")
	if tmp, err := json.Marshal(strct.Masks); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TCPFlagField) UnmarshalJSON(b []byte) error {
    FlagsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Flags":
            if err := json.Unmarshal([]byte(v), &strct.Flags); err != nil {
                return err
             }
            FlagsReceived = true
        case "Masks":
            if err := json.Unmarshal([]byte(v), &strct.Masks); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Flags (a required property) was received
    if !FlagsReceived {
        return errors.New("\"Flags\" is required but was not present")
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}
