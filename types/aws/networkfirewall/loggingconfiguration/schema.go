// Code generated by schema-generate. DO NOT EDIT.

package loggingconfiguration

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// LogDestination A key-value pair to configure the logDestinations.
type LogDestination struct {
}

// LogDestinationConfig 
type LogDestinationConfig struct {

  // A key-value pair to configure the logDestinations.
  LogDestination *LogDestination `json:"LogDestination"`
  LogDestinationType string `json:"LogDestinationType"`
  LogType string `json:"LogType"`
}

// LoggingConfiguration 
type LoggingConfiguration struct {
  LogDestinationConfigs []*LogDestinationConfig `json:"LogDestinationConfigs"`
}

// Resource Resource type definition for AWS::NetworkFirewall::LoggingConfiguration
type Resource struct {
  FirewallArn string `json:"FirewallArn"`
  FirewallName string `json:"FirewallName,omitempty"`
  LoggingConfiguration *LoggingConfiguration `json:"LoggingConfiguration"`
}

func (strct *LogDestination) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LogDestination) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *LogDestinationConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "LogDestination" field is required
    if strct.LogDestination == nil {
        return nil, errors.New("LogDestination is a required field")
    }
    // Marshal the "LogDestination" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LogDestination\": ")
	if tmp, err := json.Marshal(strct.LogDestination); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "LogDestinationType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "LogDestinationType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LogDestinationType\": ")
	if tmp, err := json.Marshal(strct.LogDestinationType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "LogType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "LogType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LogType\": ")
	if tmp, err := json.Marshal(strct.LogType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LogDestinationConfig) UnmarshalJSON(b []byte) error {
    LogDestinationReceived := false
    LogDestinationTypeReceived := false
    LogTypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "LogDestination":
            if err := json.Unmarshal([]byte(v), &strct.LogDestination); err != nil {
                return err
             }
            LogDestinationReceived = true
        case "LogDestinationType":
            if err := json.Unmarshal([]byte(v), &strct.LogDestinationType); err != nil {
                return err
             }
            LogDestinationTypeReceived = true
        case "LogType":
            if err := json.Unmarshal([]byte(v), &strct.LogType); err != nil {
                return err
             }
            LogTypeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if LogDestination (a required property) was received
    if !LogDestinationReceived {
        return errors.New("\"LogDestination\" is required but was not present")
    }
    // check if LogDestinationType (a required property) was received
    if !LogDestinationTypeReceived {
        return errors.New("\"LogDestinationType\" is required but was not present")
    }
    // check if LogType (a required property) was received
    if !LogTypeReceived {
        return errors.New("\"LogType\" is required but was not present")
    }
    return nil
}

func (strct *LoggingConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "LogDestinationConfigs" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "LogDestinationConfigs" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LogDestinationConfigs\": ")
	if tmp, err := json.Marshal(strct.LogDestinationConfigs); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LoggingConfiguration) UnmarshalJSON(b []byte) error {
    LogDestinationConfigsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "LogDestinationConfigs":
            if err := json.Unmarshal([]byte(v), &strct.LogDestinationConfigs); err != nil {
                return err
             }
            LogDestinationConfigsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if LogDestinationConfigs (a required property) was received
    if !LogDestinationConfigsReceived {
        return errors.New("\"LogDestinationConfigs\" is required but was not present")
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "FirewallArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "FirewallArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FirewallArn\": ")
	if tmp, err := json.Marshal(strct.FirewallArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FirewallName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FirewallName\": ")
	if tmp, err := json.Marshal(strct.FirewallName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "LoggingConfiguration" field is required
    if strct.LoggingConfiguration == nil {
        return nil, errors.New("LoggingConfiguration is a required field")
    }
    // Marshal the "LoggingConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LoggingConfiguration\": ")
	if tmp, err := json.Marshal(strct.LoggingConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    FirewallArnReceived := false
    LoggingConfigurationReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "FirewallArn":
            if err := json.Unmarshal([]byte(v), &strct.FirewallArn); err != nil {
                return err
             }
            FirewallArnReceived = true
        case "FirewallName":
            if err := json.Unmarshal([]byte(v), &strct.FirewallName); err != nil {
                return err
             }
        case "LoggingConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.LoggingConfiguration); err != nil {
                return err
             }
            LoggingConfigurationReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if FirewallArn (a required property) was received
    if !FirewallArnReceived {
        return errors.New("\"FirewallArn\" is required but was not present")
    }
    // check if LoggingConfiguration (a required property) was received
    if !LoggingConfigurationReceived {
        return errors.New("\"LoggingConfiguration\" is required but was not present")
    }
    return nil
}
