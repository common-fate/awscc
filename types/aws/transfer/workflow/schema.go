// Code generated by schema-generate. DO NOT EDIT.

package workflow

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// CopyStepDetails Details for a step that performs a file copy.
type CopyStepDetails struct {
  DestinationFileLocation *S3FileLocation `json:"DestinationFileLocation,omitempty"`

  // The name of the step, used as an identifier.
  Name string `json:"Name,omitempty"`

  // A flag that indicates whether or not to overwrite an existing file of the same name. The default is FALSE.
  OverwriteExisting string `json:"OverwriteExisting,omitempty"`

  // Specifies which file to use as input to the workflow step.
  SourceFileLocation string `json:"SourceFileLocation,omitempty"`
}

// CustomStepDetails Details for a step that invokes a lambda function.
type CustomStepDetails struct {

  // The name of the step, used as an identifier.
  Name string `json:"Name,omitempty"`

  // Specifies which file to use as input to the workflow step.
  SourceFileLocation string `json:"SourceFileLocation,omitempty"`

  // The ARN for the lambda function that is being called.
  Target string `json:"Target,omitempty"`

  // Timeout, in seconds, for the step.
  TimeoutSeconds int `json:"TimeoutSeconds,omitempty"`
}

// DecryptStepDetails Details for a step that performs a file decryption.
type DecryptStepDetails struct {
  DestinationFileLocation *InputFileLocation `json:"DestinationFileLocation,omitempty"`

  // The name of the step, used as an identifier.
  Name string `json:"Name,omitempty"`

  // A flag that indicates whether or not to overwrite an existing file of the same name. The default is FALSE.
  OverwriteExisting string `json:"OverwriteExisting,omitempty"`

  // Specifies which file to use as input to the workflow step.
  SourceFileLocation string `json:"SourceFileLocation,omitempty"`

  // Specifies which encryption method to use.
  Type string `json:"Type,omitempty"`
}

// DeleteStepDetails Details for a step that deletes the file.
type DeleteStepDetails struct {

  // The name of the step, used as an identifier.
  Name string `json:"Name,omitempty"`

  // Specifies which file to use as input to the workflow step.
  SourceFileLocation string `json:"SourceFileLocation,omitempty"`
}

// EfsInputFileLocation Specifies the details for an EFS file.
type EfsInputFileLocation struct {

  // Specifies the EFS filesystem that contains the file.
  FileSystemId string `json:"FileSystemId,omitempty"`

  // The name assigned to the file when it was created in EFS. You use the object path to retrieve the object.
  Path string `json:"Path,omitempty"`
}

// InputFileLocation Specifies the location for the file being decrypted. Only applicable for the Decrypt type of workflow steps.
type InputFileLocation struct {
  EfsFileLocation *EfsInputFileLocation `json:"EfsFileLocation,omitempty"`
  S3FileLocation *S3InputFileLocation `json:"S3FileLocation,omitempty"`
}

// Resource Resource Type definition for AWS::Transfer::Workflow
type Resource struct {

  // Specifies the unique Amazon Resource Name (ARN) for the workflow.
  Arn string `json:"Arn,omitempty"`

  // A textual description for the workflow.
  Description string `json:"Description,omitempty"`

  // Specifies the steps (actions) to take if any errors are encountered during execution of the workflow.
  OnExceptionSteps []*WorkflowStep `json:"OnExceptionSteps,omitempty"`

  // Specifies the details for the steps that are in the specified workflow.
  Steps []*WorkflowStep `json:"Steps"`

  // Key-value pairs that can be used to group and search for workflows. Tags are metadata attached to workflows for any purpose.
  Tags []*Tag `json:"Tags,omitempty"`

  // A unique identifier for the workflow.
  WorkflowId string `json:"WorkflowId,omitempty"`
}

// S3FileLocation Specifies the location for the file being copied. Only applicable for the Copy type of workflow steps.
type S3FileLocation struct {
  S3FileLocation *S3InputFileLocation `json:"S3FileLocation,omitempty"`
}

// S3InputFileLocation Specifies the details for a S3 file.
type S3InputFileLocation struct {

  // Specifies the S3 bucket that contains the file.
  Bucket string `json:"Bucket,omitempty"`

  // The name assigned to the file when it was created in S3. You use the object key to retrieve the object.
  Key string `json:"Key,omitempty"`
}

// S3Tag Specifies the key-value pair that are assigned to a file during the execution of a Tagging step.
type S3Tag struct {

  // The name assigned to the tag that you create.
  Key string `json:"Key"`

  // The value that corresponds to the key.
  Value string `json:"Value"`
}

// Tag Creates a key-value pair for a specific resource.
type Tag struct {

  // The name assigned to the tag that you create.
  Key string `json:"Key"`

  // Contains one or more values that you assigned to the key name you create.
  Value string `json:"Value"`
}

// TagStepDetails Details for a step that creates one or more tags.
type TagStepDetails struct {

  // The name of the step, used as an identifier.
  Name string `json:"Name,omitempty"`

  // Specifies which file to use as input to the workflow step.
  SourceFileLocation string `json:"SourceFileLocation,omitempty"`

  // Array that contains from 1 to 10 key/value pairs.
  Tags []*S3Tag `json:"Tags,omitempty"`
}

// WorkflowStep The basic building block of a workflow.
type WorkflowStep struct {

  // Details for a step that performs a file copy.
  CopyStepDetails *CopyStepDetails `json:"CopyStepDetails,omitempty"`

  // Details for a step that invokes a lambda function.
  CustomStepDetails *CustomStepDetails `json:"CustomStepDetails,omitempty"`

  // Details for a step that performs a file decryption.
  DecryptStepDetails *DecryptStepDetails `json:"DecryptStepDetails,omitempty"`

  // Details for a step that deletes the file.
  DeleteStepDetails *DeleteStepDetails `json:"DeleteStepDetails,omitempty"`

  // Details for a step that creates one or more tags.
  TagStepDetails *TagStepDetails `json:"TagStepDetails,omitempty"`
  Type string `json:"Type,omitempty"`
}

func (strct *CopyStepDetails) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DestinationFileLocation" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DestinationFileLocation\": ")
	if tmp, err := json.Marshal(strct.DestinationFileLocation); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OverwriteExisting" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OverwriteExisting\": ")
	if tmp, err := json.Marshal(strct.OverwriteExisting); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SourceFileLocation" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SourceFileLocation\": ")
	if tmp, err := json.Marshal(strct.SourceFileLocation); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CopyStepDetails) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DestinationFileLocation":
            if err := json.Unmarshal([]byte(v), &strct.DestinationFileLocation); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "OverwriteExisting":
            if err := json.Unmarshal([]byte(v), &strct.OverwriteExisting); err != nil {
                return err
             }
        case "SourceFileLocation":
            if err := json.Unmarshal([]byte(v), &strct.SourceFileLocation); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *CustomStepDetails) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SourceFileLocation" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SourceFileLocation\": ")
	if tmp, err := json.Marshal(strct.SourceFileLocation); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Target" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Target\": ")
	if tmp, err := json.Marshal(strct.Target); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TimeoutSeconds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TimeoutSeconds\": ")
	if tmp, err := json.Marshal(strct.TimeoutSeconds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CustomStepDetails) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "SourceFileLocation":
            if err := json.Unmarshal([]byte(v), &strct.SourceFileLocation); err != nil {
                return err
             }
        case "Target":
            if err := json.Unmarshal([]byte(v), &strct.Target); err != nil {
                return err
             }
        case "TimeoutSeconds":
            if err := json.Unmarshal([]byte(v), &strct.TimeoutSeconds); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *DecryptStepDetails) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DestinationFileLocation" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DestinationFileLocation\": ")
	if tmp, err := json.Marshal(strct.DestinationFileLocation); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OverwriteExisting" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OverwriteExisting\": ")
	if tmp, err := json.Marshal(strct.OverwriteExisting); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SourceFileLocation" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SourceFileLocation\": ")
	if tmp, err := json.Marshal(strct.SourceFileLocation); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DecryptStepDetails) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DestinationFileLocation":
            if err := json.Unmarshal([]byte(v), &strct.DestinationFileLocation); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "OverwriteExisting":
            if err := json.Unmarshal([]byte(v), &strct.OverwriteExisting); err != nil {
                return err
             }
        case "SourceFileLocation":
            if err := json.Unmarshal([]byte(v), &strct.SourceFileLocation); err != nil {
                return err
             }
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *DeleteStepDetails) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SourceFileLocation" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SourceFileLocation\": ")
	if tmp, err := json.Marshal(strct.SourceFileLocation); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DeleteStepDetails) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "SourceFileLocation":
            if err := json.Unmarshal([]byte(v), &strct.SourceFileLocation); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *EfsInputFileLocation) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "FileSystemId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FileSystemId\": ")
	if tmp, err := json.Marshal(strct.FileSystemId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Path" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Path\": ")
	if tmp, err := json.Marshal(strct.Path); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *EfsInputFileLocation) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "FileSystemId":
            if err := json.Unmarshal([]byte(v), &strct.FileSystemId); err != nil {
                return err
             }
        case "Path":
            if err := json.Unmarshal([]byte(v), &strct.Path); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *InputFileLocation) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "EfsFileLocation" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EfsFileLocation\": ")
	if tmp, err := json.Marshal(strct.EfsFileLocation); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "S3FileLocation" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3FileLocation\": ")
	if tmp, err := json.Marshal(strct.S3FileLocation); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *InputFileLocation) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "EfsFileLocation":
            if err := json.Unmarshal([]byte(v), &strct.EfsFileLocation); err != nil {
                return err
             }
        case "S3FileLocation":
            if err := json.Unmarshal([]byte(v), &strct.S3FileLocation); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Arn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Arn\": ")
	if tmp, err := json.Marshal(strct.Arn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OnExceptionSteps" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OnExceptionSteps\": ")
	if tmp, err := json.Marshal(strct.OnExceptionSteps); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Steps" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Steps" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Steps\": ")
	if tmp, err := json.Marshal(strct.Steps); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "WorkflowId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"WorkflowId\": ")
	if tmp, err := json.Marshal(strct.WorkflowId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    StepsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Arn":
            if err := json.Unmarshal([]byte(v), &strct.Arn); err != nil {
                return err
             }
        case "Description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "OnExceptionSteps":
            if err := json.Unmarshal([]byte(v), &strct.OnExceptionSteps); err != nil {
                return err
             }
        case "Steps":
            if err := json.Unmarshal([]byte(v), &strct.Steps); err != nil {
                return err
             }
            StepsReceived = true
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        case "WorkflowId":
            if err := json.Unmarshal([]byte(v), &strct.WorkflowId); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Steps (a required property) was received
    if !StepsReceived {
        return errors.New("\"Steps\" is required but was not present")
    }
    return nil
}

func (strct *S3FileLocation) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "S3FileLocation" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3FileLocation\": ")
	if tmp, err := json.Marshal(strct.S3FileLocation); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *S3FileLocation) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "S3FileLocation":
            if err := json.Unmarshal([]byte(v), &strct.S3FileLocation); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *S3InputFileLocation) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Bucket" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Bucket\": ")
	if tmp, err := json.Marshal(strct.Bucket); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *S3InputFileLocation) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Bucket":
            if err := json.Unmarshal([]byte(v), &strct.Bucket); err != nil {
                return err
             }
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *S3Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *S3Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *TagStepDetails) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SourceFileLocation" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SourceFileLocation\": ")
	if tmp, err := json.Marshal(strct.SourceFileLocation); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TagStepDetails) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "SourceFileLocation":
            if err := json.Unmarshal([]byte(v), &strct.SourceFileLocation); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *WorkflowStep) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CopyStepDetails" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CopyStepDetails\": ")
	if tmp, err := json.Marshal(strct.CopyStepDetails); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CustomStepDetails" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CustomStepDetails\": ")
	if tmp, err := json.Marshal(strct.CustomStepDetails); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DecryptStepDetails" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DecryptStepDetails\": ")
	if tmp, err := json.Marshal(strct.DecryptStepDetails); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DeleteStepDetails" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DeleteStepDetails\": ")
	if tmp, err := json.Marshal(strct.DeleteStepDetails); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TagStepDetails" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TagStepDetails\": ")
	if tmp, err := json.Marshal(strct.TagStepDetails); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *WorkflowStep) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CopyStepDetails":
            if err := json.Unmarshal([]byte(v), &strct.CopyStepDetails); err != nil {
                return err
             }
        case "CustomStepDetails":
            if err := json.Unmarshal([]byte(v), &strct.CustomStepDetails); err != nil {
                return err
             }
        case "DecryptStepDetails":
            if err := json.Unmarshal([]byte(v), &strct.DecryptStepDetails); err != nil {
                return err
             }
        case "DeleteStepDetails":
            if err := json.Unmarshal([]byte(v), &strct.DeleteStepDetails); err != nil {
                return err
             }
        case "TagStepDetails":
            if err := json.Unmarshal([]byte(v), &strct.TagStepDetails); err != nil {
                return err
             }
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}
