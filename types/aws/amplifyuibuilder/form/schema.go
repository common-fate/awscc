// Code generated by schema-generate. DO NOT EDIT.

package form

import (
    "fmt"
    "errors"
    "bytes"
    "encoding/json"
)

// FieldConfig 
type FieldConfig struct {
  Excluded bool `json:"Excluded,omitempty"`
  InputType *FieldInputConfig `json:"InputType,omitempty"`
  Label string `json:"Label,omitempty"`
  Position interface{} `json:"Position,omitempty"`
  Validations []*FieldValidationConfiguration `json:"Validations,omitempty"`
}

// FieldInputConfig 
type FieldInputConfig struct {
  DefaultChecked bool `json:"DefaultChecked,omitempty"`
  DefaultCountryCode string `json:"DefaultCountryCode,omitempty"`
  DefaultValue string `json:"DefaultValue,omitempty"`
  DescriptiveText string `json:"DescriptiveText,omitempty"`
  IsArray bool `json:"IsArray,omitempty"`
  MaxValue float64 `json:"MaxValue,omitempty"`
  MinValue float64 `json:"MinValue,omitempty"`
  Name string `json:"Name,omitempty"`
  Placeholder string `json:"Placeholder,omitempty"`
  ReadOnly bool `json:"ReadOnly,omitempty"`
  Required bool `json:"Required,omitempty"`
  Step float64 `json:"Step,omitempty"`
  Type string `json:"Type"`
  Value string `json:"Value,omitempty"`
  ValueMappings *ValueMappings `json:"ValueMappings,omitempty"`
}

// FieldValidationConfiguration 
type FieldValidationConfiguration struct {
  NumValues []float64 `json:"NumValues,omitempty"`
  StrValues []string `json:"StrValues,omitempty"`
  Type string `json:"Type"`
  ValidationMessage string `json:"ValidationMessage,omitempty"`
}

// FieldsMap 
type FieldsMap struct {
}

// FormButton 
type FormButton struct {
  Children string `json:"Children,omitempty"`
  Excluded bool `json:"Excluded,omitempty"`
  Position interface{} `json:"Position,omitempty"`
}

// FormCTA 
type FormCTA struct {
  Cancel *FormButton `json:"Cancel,omitempty"`
  Clear *FormButton `json:"Clear,omitempty"`
  Position string `json:"Position,omitempty"`
  Submit *FormButton `json:"Submit,omitempty"`
}

// FormDataTypeConfig 
type FormDataTypeConfig struct {
  DataSourceType string `json:"DataSourceType"`
  DataTypeName string `json:"DataTypeName"`
}

// FormInputValueProperty 
type FormInputValueProperty struct {
  Value string `json:"Value,omitempty"`
}

// FormStyle 
type FormStyle struct {
  HorizontalGap interface{} `json:"HorizontalGap,omitempty"`
  OuterPadding interface{} `json:"OuterPadding,omitempty"`
  VerticalGap interface{} `json:"VerticalGap,omitempty"`
}

// Resource Definition of AWS::AmplifyUIBuilder::Form Resource Type
type Resource struct {
  AppId string `json:"AppId,omitempty"`
  Cta *FormCTA `json:"Cta,omitempty"`
  DataType *FormDataTypeConfig `json:"DataType"`
  EnvironmentName string `json:"EnvironmentName,omitempty"`
  Fields *FieldsMap `json:"Fields"`
  FormActionType string `json:"FormActionType"`
  Id string `json:"Id,omitempty"`
  Name string `json:"Name"`
  SchemaVersion string `json:"SchemaVersion"`
  SectionalElements *SectionalElementMap `json:"SectionalElements"`
  Style *FormStyle `json:"Style"`
  Tags *Tags `json:"Tags,omitempty"`
}

// SectionalElement 
type SectionalElement struct {
  Excluded bool `json:"Excluded,omitempty"`
  Level float64 `json:"Level,omitempty"`
  Orientation string `json:"Orientation,omitempty"`
  Position interface{} `json:"Position,omitempty"`
  Text string `json:"Text,omitempty"`
  Type string `json:"Type"`
}

// SectionalElementMap 
type SectionalElementMap struct {
}

// Tags 
type Tags struct {
}

// ValueMapping 
type ValueMapping struct {
  DisplayValue *FormInputValueProperty `json:"DisplayValue,omitempty"`
  Value *FormInputValueProperty `json:"Value"`
}

// ValueMappings 
type ValueMappings struct {
  Values []*ValueMapping `json:"Values"`
}

func (strct *FieldConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Excluded" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Excluded\": ")
	if tmp, err := json.Marshal(strct.Excluded); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "InputType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InputType\": ")
	if tmp, err := json.Marshal(strct.InputType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Label" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Label\": ")
	if tmp, err := json.Marshal(strct.Label); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Position" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Position\": ")
	if tmp, err := json.Marshal(strct.Position); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Validations" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Validations\": ")
	if tmp, err := json.Marshal(strct.Validations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FieldConfig) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Excluded":
            if err := json.Unmarshal([]byte(v), &strct.Excluded); err != nil {
                return err
             }
        case "InputType":
            if err := json.Unmarshal([]byte(v), &strct.InputType); err != nil {
                return err
             }
        case "Label":
            if err := json.Unmarshal([]byte(v), &strct.Label); err != nil {
                return err
             }
        case "Position":
            if err := json.Unmarshal([]byte(v), &strct.Position); err != nil {
                return err
             }
        case "Validations":
            if err := json.Unmarshal([]byte(v), &strct.Validations); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *FieldInputConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DefaultChecked" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DefaultChecked\": ")
	if tmp, err := json.Marshal(strct.DefaultChecked); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DefaultCountryCode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DefaultCountryCode\": ")
	if tmp, err := json.Marshal(strct.DefaultCountryCode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DefaultValue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DefaultValue\": ")
	if tmp, err := json.Marshal(strct.DefaultValue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DescriptiveText" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DescriptiveText\": ")
	if tmp, err := json.Marshal(strct.DescriptiveText); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IsArray" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IsArray\": ")
	if tmp, err := json.Marshal(strct.IsArray); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MaxValue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaxValue\": ")
	if tmp, err := json.Marshal(strct.MaxValue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MinValue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MinValue\": ")
	if tmp, err := json.Marshal(strct.MinValue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Placeholder" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Placeholder\": ")
	if tmp, err := json.Marshal(strct.Placeholder); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ReadOnly" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ReadOnly\": ")
	if tmp, err := json.Marshal(strct.ReadOnly); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Required" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Required\": ")
	if tmp, err := json.Marshal(strct.Required); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Step" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Step\": ")
	if tmp, err := json.Marshal(strct.Step); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ValueMappings" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ValueMappings\": ")
	if tmp, err := json.Marshal(strct.ValueMappings); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FieldInputConfig) UnmarshalJSON(b []byte) error {
    TypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DefaultChecked":
            if err := json.Unmarshal([]byte(v), &strct.DefaultChecked); err != nil {
                return err
             }
        case "DefaultCountryCode":
            if err := json.Unmarshal([]byte(v), &strct.DefaultCountryCode); err != nil {
                return err
             }
        case "DefaultValue":
            if err := json.Unmarshal([]byte(v), &strct.DefaultValue); err != nil {
                return err
             }
        case "DescriptiveText":
            if err := json.Unmarshal([]byte(v), &strct.DescriptiveText); err != nil {
                return err
             }
        case "IsArray":
            if err := json.Unmarshal([]byte(v), &strct.IsArray); err != nil {
                return err
             }
        case "MaxValue":
            if err := json.Unmarshal([]byte(v), &strct.MaxValue); err != nil {
                return err
             }
        case "MinValue":
            if err := json.Unmarshal([]byte(v), &strct.MinValue); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "Placeholder":
            if err := json.Unmarshal([]byte(v), &strct.Placeholder); err != nil {
                return err
             }
        case "ReadOnly":
            if err := json.Unmarshal([]byte(v), &strct.ReadOnly); err != nil {
                return err
             }
        case "Required":
            if err := json.Unmarshal([]byte(v), &strct.Required); err != nil {
                return err
             }
        case "Step":
            if err := json.Unmarshal([]byte(v), &strct.Step); err != nil {
                return err
             }
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            TypeReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
        case "ValueMappings":
            if err := json.Unmarshal([]byte(v), &strct.ValueMappings); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Type (a required property) was received
    if !TypeReceived {
        return errors.New("\"Type\" is required but was not present")
    }
    return nil
}

func (strct *FieldValidationConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "NumValues" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NumValues\": ")
	if tmp, err := json.Marshal(strct.NumValues); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StrValues" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StrValues\": ")
	if tmp, err := json.Marshal(strct.StrValues); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ValidationMessage" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ValidationMessage\": ")
	if tmp, err := json.Marshal(strct.ValidationMessage); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FieldValidationConfiguration) UnmarshalJSON(b []byte) error {
    TypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "NumValues":
            if err := json.Unmarshal([]byte(v), &strct.NumValues); err != nil {
                return err
             }
        case "StrValues":
            if err := json.Unmarshal([]byte(v), &strct.StrValues); err != nil {
                return err
             }
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            TypeReceived = true
        case "ValidationMessage":
            if err := json.Unmarshal([]byte(v), &strct.ValidationMessage); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Type (a required property) was received
    if !TypeReceived {
        return errors.New("\"Type\" is required but was not present")
    }
    return nil
}

func (strct *FieldsMap) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FieldsMap) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *FormButton) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Children" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Children\": ")
	if tmp, err := json.Marshal(strct.Children); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Excluded" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Excluded\": ")
	if tmp, err := json.Marshal(strct.Excluded); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Position" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Position\": ")
	if tmp, err := json.Marshal(strct.Position); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FormButton) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Children":
            if err := json.Unmarshal([]byte(v), &strct.Children); err != nil {
                return err
             }
        case "Excluded":
            if err := json.Unmarshal([]byte(v), &strct.Excluded); err != nil {
                return err
             }
        case "Position":
            if err := json.Unmarshal([]byte(v), &strct.Position); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *FormCTA) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Cancel" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Cancel\": ")
	if tmp, err := json.Marshal(strct.Cancel); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Clear" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Clear\": ")
	if tmp, err := json.Marshal(strct.Clear); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Position" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Position\": ")
	if tmp, err := json.Marshal(strct.Position); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Submit" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Submit\": ")
	if tmp, err := json.Marshal(strct.Submit); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FormCTA) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Cancel":
            if err := json.Unmarshal([]byte(v), &strct.Cancel); err != nil {
                return err
             }
        case "Clear":
            if err := json.Unmarshal([]byte(v), &strct.Clear); err != nil {
                return err
             }
        case "Position":
            if err := json.Unmarshal([]byte(v), &strct.Position); err != nil {
                return err
             }
        case "Submit":
            if err := json.Unmarshal([]byte(v), &strct.Submit); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *FormDataTypeConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "DataSourceType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "DataSourceType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DataSourceType\": ")
	if tmp, err := json.Marshal(strct.DataSourceType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "DataTypeName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "DataTypeName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DataTypeName\": ")
	if tmp, err := json.Marshal(strct.DataTypeName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FormDataTypeConfig) UnmarshalJSON(b []byte) error {
    DataSourceTypeReceived := false
    DataTypeNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DataSourceType":
            if err := json.Unmarshal([]byte(v), &strct.DataSourceType); err != nil {
                return err
             }
            DataSourceTypeReceived = true
        case "DataTypeName":
            if err := json.Unmarshal([]byte(v), &strct.DataTypeName); err != nil {
                return err
             }
            DataTypeNameReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if DataSourceType (a required property) was received
    if !DataSourceTypeReceived {
        return errors.New("\"DataSourceType\" is required but was not present")
    }
    // check if DataTypeName (a required property) was received
    if !DataTypeNameReceived {
        return errors.New("\"DataTypeName\" is required but was not present")
    }
    return nil
}

func (strct *FormInputValueProperty) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FormInputValueProperty) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *FormStyle) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "HorizontalGap" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HorizontalGap\": ")
	if tmp, err := json.Marshal(strct.HorizontalGap); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OuterPadding" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OuterPadding\": ")
	if tmp, err := json.Marshal(strct.OuterPadding); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VerticalGap" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VerticalGap\": ")
	if tmp, err := json.Marshal(strct.VerticalGap); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FormStyle) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "HorizontalGap":
            if err := json.Unmarshal([]byte(v), &strct.HorizontalGap); err != nil {
                return err
             }
        case "OuterPadding":
            if err := json.Unmarshal([]byte(v), &strct.OuterPadding); err != nil {
                return err
             }
        case "VerticalGap":
            if err := json.Unmarshal([]byte(v), &strct.VerticalGap); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AppId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AppId\": ")
	if tmp, err := json.Marshal(strct.AppId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Cta" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Cta\": ")
	if tmp, err := json.Marshal(strct.Cta); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "DataType" field is required
    if strct.DataType == nil {
        return nil, errors.New("DataType is a required field")
    }
    // Marshal the "DataType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DataType\": ")
	if tmp, err := json.Marshal(strct.DataType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EnvironmentName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EnvironmentName\": ")
	if tmp, err := json.Marshal(strct.EnvironmentName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Fields" field is required
    if strct.Fields == nil {
        return nil, errors.New("Fields is a required field")
    }
    // Marshal the "Fields" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Fields\": ")
	if tmp, err := json.Marshal(strct.Fields); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "FormActionType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "FormActionType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FormActionType\": ")
	if tmp, err := json.Marshal(strct.FormActionType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Id" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "SchemaVersion" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "SchemaVersion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SchemaVersion\": ")
	if tmp, err := json.Marshal(strct.SchemaVersion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "SectionalElements" field is required
    if strct.SectionalElements == nil {
        return nil, errors.New("SectionalElements is a required field")
    }
    // Marshal the "SectionalElements" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SectionalElements\": ")
	if tmp, err := json.Marshal(strct.SectionalElements); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Style" field is required
    if strct.Style == nil {
        return nil, errors.New("Style is a required field")
    }
    // Marshal the "Style" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Style\": ")
	if tmp, err := json.Marshal(strct.Style); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    DataTypeReceived := false
    FieldsReceived := false
    FormActionTypeReceived := false
    NameReceived := false
    SchemaVersionReceived := false
    SectionalElementsReceived := false
    StyleReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AppId":
            if err := json.Unmarshal([]byte(v), &strct.AppId); err != nil {
                return err
             }
        case "Cta":
            if err := json.Unmarshal([]byte(v), &strct.Cta); err != nil {
                return err
             }
        case "DataType":
            if err := json.Unmarshal([]byte(v), &strct.DataType); err != nil {
                return err
             }
            DataTypeReceived = true
        case "EnvironmentName":
            if err := json.Unmarshal([]byte(v), &strct.EnvironmentName); err != nil {
                return err
             }
        case "Fields":
            if err := json.Unmarshal([]byte(v), &strct.Fields); err != nil {
                return err
             }
            FieldsReceived = true
        case "FormActionType":
            if err := json.Unmarshal([]byte(v), &strct.FormActionType); err != nil {
                return err
             }
            FormActionTypeReceived = true
        case "Id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        case "SchemaVersion":
            if err := json.Unmarshal([]byte(v), &strct.SchemaVersion); err != nil {
                return err
             }
            SchemaVersionReceived = true
        case "SectionalElements":
            if err := json.Unmarshal([]byte(v), &strct.SectionalElements); err != nil {
                return err
             }
            SectionalElementsReceived = true
        case "Style":
            if err := json.Unmarshal([]byte(v), &strct.Style); err != nil {
                return err
             }
            StyleReceived = true
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if DataType (a required property) was received
    if !DataTypeReceived {
        return errors.New("\"DataType\" is required but was not present")
    }
    // check if Fields (a required property) was received
    if !FieldsReceived {
        return errors.New("\"Fields\" is required but was not present")
    }
    // check if FormActionType (a required property) was received
    if !FormActionTypeReceived {
        return errors.New("\"FormActionType\" is required but was not present")
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    // check if SchemaVersion (a required property) was received
    if !SchemaVersionReceived {
        return errors.New("\"SchemaVersion\" is required but was not present")
    }
    // check if SectionalElements (a required property) was received
    if !SectionalElementsReceived {
        return errors.New("\"SectionalElements\" is required but was not present")
    }
    // check if Style (a required property) was received
    if !StyleReceived {
        return errors.New("\"Style\" is required but was not present")
    }
    return nil
}

func (strct *SectionalElement) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Excluded" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Excluded\": ")
	if tmp, err := json.Marshal(strct.Excluded); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Level" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Level\": ")
	if tmp, err := json.Marshal(strct.Level); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Orientation" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Orientation\": ")
	if tmp, err := json.Marshal(strct.Orientation); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Position" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Position\": ")
	if tmp, err := json.Marshal(strct.Position); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Text" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Text\": ")
	if tmp, err := json.Marshal(strct.Text); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SectionalElement) UnmarshalJSON(b []byte) error {
    TypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Excluded":
            if err := json.Unmarshal([]byte(v), &strct.Excluded); err != nil {
                return err
             }
        case "Level":
            if err := json.Unmarshal([]byte(v), &strct.Level); err != nil {
                return err
             }
        case "Orientation":
            if err := json.Unmarshal([]byte(v), &strct.Orientation); err != nil {
                return err
             }
        case "Position":
            if err := json.Unmarshal([]byte(v), &strct.Position); err != nil {
                return err
             }
        case "Text":
            if err := json.Unmarshal([]byte(v), &strct.Text); err != nil {
                return err
             }
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            TypeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Type (a required property) was received
    if !TypeReceived {
        return errors.New("\"Type\" is required but was not present")
    }
    return nil
}

func (strct *SectionalElementMap) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SectionalElementMap) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Tags) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tags) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ValueMapping) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DisplayValue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DisplayValue\": ")
	if tmp, err := json.Marshal(strct.DisplayValue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    if strct.Value == nil {
        return nil, errors.New("Value is a required field")
    }
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ValueMapping) UnmarshalJSON(b []byte) error {
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DisplayValue":
            if err := json.Unmarshal([]byte(v), &strct.DisplayValue); err != nil {
                return err
             }
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *ValueMappings) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Values" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Values" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Values\": ")
	if tmp, err := json.Marshal(strct.Values); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ValueMappings) UnmarshalJSON(b []byte) error {
    ValuesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Values":
            if err := json.Unmarshal([]byte(v), &strct.Values); err != nil {
                return err
             }
            ValuesReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Values (a required property) was received
    if !ValuesReceived {
        return errors.New("\"Values\" is required but was not present")
    }
    return nil
}
