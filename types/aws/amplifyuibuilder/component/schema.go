// Code generated by schema-generate. DO NOT EDIT.

package component

import (
    "errors"
    "bytes"
    "encoding/json"
    "fmt"
)

// ActionParameters 
type ActionParameters struct {
  Anchor *ComponentProperty `json:"Anchor,omitempty"`
  Fields *ComponentProperties `json:"Fields,omitempty"`
  Global *ComponentProperty `json:"Global,omitempty"`
  Id *ComponentProperty `json:"Id,omitempty"`
  Model string `json:"Model,omitempty"`
  State *MutationActionSetStateParameter `json:"State,omitempty"`
  Target *ComponentProperty `json:"Target,omitempty"`
  Type *ComponentProperty `json:"Type,omitempty"`
  Url *ComponentProperty `json:"Url,omitempty"`
}

// ComponentBindingProperties 
type ComponentBindingProperties struct {
}

// ComponentBindingPropertiesValue 
type ComponentBindingPropertiesValue struct {
  BindingProperties *ComponentBindingPropertiesValueProperties `json:"BindingProperties,omitempty"`
  DefaultValue string `json:"DefaultValue,omitempty"`
  Type string `json:"Type,omitempty"`
}

// ComponentBindingPropertiesValueProperties 
type ComponentBindingPropertiesValueProperties struct {
  Bucket string `json:"Bucket,omitempty"`
  DefaultValue string `json:"DefaultValue,omitempty"`
  Field string `json:"Field,omitempty"`
  Key string `json:"Key,omitempty"`
  Model string `json:"Model,omitempty"`
  Predicates []*Predicate `json:"Predicates,omitempty"`
  UserAttribute string `json:"UserAttribute,omitempty"`
}

// ComponentChild 
type ComponentChild struct {
  Children []*ComponentChild `json:"Children,omitempty"`
  ComponentType string `json:"ComponentType"`
  Events *ComponentEvents `json:"Events,omitempty"`
  Name string `json:"Name"`
  Properties *ComponentProperties `json:"Properties"`
}

// ComponentCollectionProperties 
type ComponentCollectionProperties struct {
}

// ComponentConditionProperty 
type ComponentConditionProperty struct {
  Else *ComponentProperty `json:"Else,omitempty"`
  Field string `json:"Field,omitempty"`
  Operand string `json:"Operand,omitempty"`
  OperandType string `json:"OperandType,omitempty"`
  Operator string `json:"Operator,omitempty"`
  Property string `json:"Property,omitempty"`
  Then *ComponentProperty `json:"Then,omitempty"`
}

// ComponentDataConfiguration 
type ComponentDataConfiguration struct {
  Identifiers []string `json:"Identifiers,omitempty"`
  Model string `json:"Model"`
  Predicate *Predicate `json:"Predicate,omitempty"`
  Sort []*SortProperty `json:"Sort,omitempty"`
}

// ComponentEvent 
type ComponentEvent struct {
  Action string `json:"Action,omitempty"`
  Parameters *ActionParameters `json:"Parameters,omitempty"`
}

// ComponentEvents 
type ComponentEvents struct {
}

// ComponentOverrides 
type ComponentOverrides struct {
}

// ComponentOverridesValue 
type ComponentOverridesValue struct {
}

// ComponentProperties 
type ComponentProperties struct {
}

// ComponentProperty 
type ComponentProperty struct {
  BindingProperties *ComponentPropertyBindingProperties `json:"BindingProperties,omitempty"`
  Bindings *FormBindings `json:"Bindings,omitempty"`
  CollectionBindingProperties *ComponentPropertyBindingProperties `json:"CollectionBindingProperties,omitempty"`
  ComponentName string `json:"ComponentName,omitempty"`
  Concat []*ComponentProperty `json:"Concat,omitempty"`
  Condition *ComponentConditionProperty `json:"Condition,omitempty"`
  Configured bool `json:"Configured,omitempty"`
  DefaultValue string `json:"DefaultValue,omitempty"`
  Event string `json:"Event,omitempty"`
  ImportedValue string `json:"ImportedValue,omitempty"`
  Model string `json:"Model,omitempty"`
  Property string `json:"Property,omitempty"`
  Type string `json:"Type,omitempty"`
  UserAttribute string `json:"UserAttribute,omitempty"`
  Value string `json:"Value,omitempty"`
}

// ComponentPropertyBindingProperties 
type ComponentPropertyBindingProperties struct {
  Field string `json:"Field,omitempty"`
  Property string `json:"Property"`
}

// ComponentVariant 
type ComponentVariant struct {
  Overrides *ComponentOverrides `json:"Overrides,omitempty"`
  VariantValues *ComponentVariantValues `json:"VariantValues,omitempty"`
}

// ComponentVariantValues 
type ComponentVariantValues struct {
}

// FormBindingElement 
type FormBindingElement struct {
  Element string `json:"Element"`
  Property string `json:"Property"`
}

// FormBindings 
type FormBindings struct {
}

// MutationActionSetStateParameter 
type MutationActionSetStateParameter struct {
  ComponentName string `json:"ComponentName"`
  Property string `json:"Property"`
  Set *ComponentProperty `json:"Set"`
}

// Predicate 
type Predicate struct {
  And []*Predicate `json:"And,omitempty"`
  Field string `json:"Field,omitempty"`
  Operand string `json:"Operand,omitempty"`
  Operator string `json:"Operator,omitempty"`
  Or []*Predicate `json:"Or,omitempty"`
}

// Resource Definition of AWS::AmplifyUIBuilder::Component Resource Type
type Resource struct {
  AppId string `json:"AppId,omitempty"`
  BindingProperties *ComponentBindingProperties `json:"BindingProperties"`
  Children []*ComponentChild `json:"Children,omitempty"`
  CollectionProperties *ComponentCollectionProperties `json:"CollectionProperties,omitempty"`
  ComponentType string `json:"ComponentType"`
  EnvironmentName string `json:"EnvironmentName,omitempty"`
  Events *ComponentEvents `json:"Events,omitempty"`
  Id string `json:"Id,omitempty"`
  Name string `json:"Name"`
  Overrides *ComponentOverrides `json:"Overrides"`
  Properties *ComponentProperties `json:"Properties"`
  SchemaVersion string `json:"SchemaVersion,omitempty"`
  SourceId string `json:"SourceId,omitempty"`
  Tags *Tags `json:"Tags,omitempty"`
  Variants []*ComponentVariant `json:"Variants"`
}

// SortProperty 
type SortProperty struct {
  Direction string `json:"Direction"`
  Field string `json:"Field"`
}

// Tags 
type Tags struct {
}

func (strct *ActionParameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Anchor" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Anchor\": ")
	if tmp, err := json.Marshal(strct.Anchor); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Fields" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Fields\": ")
	if tmp, err := json.Marshal(strct.Fields); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Global" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Global\": ")
	if tmp, err := json.Marshal(strct.Global); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Id" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Model" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Model\": ")
	if tmp, err := json.Marshal(strct.Model); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "State" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"State\": ")
	if tmp, err := json.Marshal(strct.State); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Target" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Target\": ")
	if tmp, err := json.Marshal(strct.Target); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Url" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Url\": ")
	if tmp, err := json.Marshal(strct.Url); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ActionParameters) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Anchor":
            if err := json.Unmarshal([]byte(v), &strct.Anchor); err != nil {
                return err
             }
        case "Fields":
            if err := json.Unmarshal([]byte(v), &strct.Fields); err != nil {
                return err
             }
        case "Global":
            if err := json.Unmarshal([]byte(v), &strct.Global); err != nil {
                return err
             }
        case "Id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
        case "Model":
            if err := json.Unmarshal([]byte(v), &strct.Model); err != nil {
                return err
             }
        case "State":
            if err := json.Unmarshal([]byte(v), &strct.State); err != nil {
                return err
             }
        case "Target":
            if err := json.Unmarshal([]byte(v), &strct.Target); err != nil {
                return err
             }
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
        case "Url":
            if err := json.Unmarshal([]byte(v), &strct.Url); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ComponentBindingProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ComponentBindingProperties) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ComponentBindingPropertiesValue) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "BindingProperties" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BindingProperties\": ")
	if tmp, err := json.Marshal(strct.BindingProperties); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DefaultValue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DefaultValue\": ")
	if tmp, err := json.Marshal(strct.DefaultValue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ComponentBindingPropertiesValue) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BindingProperties":
            if err := json.Unmarshal([]byte(v), &strct.BindingProperties); err != nil {
                return err
             }
        case "DefaultValue":
            if err := json.Unmarshal([]byte(v), &strct.DefaultValue); err != nil {
                return err
             }
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ComponentBindingPropertiesValueProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Bucket" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Bucket\": ")
	if tmp, err := json.Marshal(strct.Bucket); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DefaultValue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DefaultValue\": ")
	if tmp, err := json.Marshal(strct.DefaultValue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Field" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Field\": ")
	if tmp, err := json.Marshal(strct.Field); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Model" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Model\": ")
	if tmp, err := json.Marshal(strct.Model); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Predicates" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Predicates\": ")
	if tmp, err := json.Marshal(strct.Predicates); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "UserAttribute" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UserAttribute\": ")
	if tmp, err := json.Marshal(strct.UserAttribute); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ComponentBindingPropertiesValueProperties) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Bucket":
            if err := json.Unmarshal([]byte(v), &strct.Bucket); err != nil {
                return err
             }
        case "DefaultValue":
            if err := json.Unmarshal([]byte(v), &strct.DefaultValue); err != nil {
                return err
             }
        case "Field":
            if err := json.Unmarshal([]byte(v), &strct.Field); err != nil {
                return err
             }
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
        case "Model":
            if err := json.Unmarshal([]byte(v), &strct.Model); err != nil {
                return err
             }
        case "Predicates":
            if err := json.Unmarshal([]byte(v), &strct.Predicates); err != nil {
                return err
             }
        case "UserAttribute":
            if err := json.Unmarshal([]byte(v), &strct.UserAttribute); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ComponentChild) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Children" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Children\": ")
	if tmp, err := json.Marshal(strct.Children); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ComponentType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ComponentType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ComponentType\": ")
	if tmp, err := json.Marshal(strct.ComponentType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Events" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Events\": ")
	if tmp, err := json.Marshal(strct.Events); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Properties" field is required
    if strct.Properties == nil {
        return nil, errors.New("Properties is a required field")
    }
    // Marshal the "Properties" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Properties\": ")
	if tmp, err := json.Marshal(strct.Properties); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ComponentChild) UnmarshalJSON(b []byte) error {
    ComponentTypeReceived := false
    NameReceived := false
    PropertiesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Children":
            if err := json.Unmarshal([]byte(v), &strct.Children); err != nil {
                return err
             }
        case "ComponentType":
            if err := json.Unmarshal([]byte(v), &strct.ComponentType); err != nil {
                return err
             }
            ComponentTypeReceived = true
        case "Events":
            if err := json.Unmarshal([]byte(v), &strct.Events); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        case "Properties":
            if err := json.Unmarshal([]byte(v), &strct.Properties); err != nil {
                return err
             }
            PropertiesReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ComponentType (a required property) was received
    if !ComponentTypeReceived {
        return errors.New("\"ComponentType\" is required but was not present")
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    // check if Properties (a required property) was received
    if !PropertiesReceived {
        return errors.New("\"Properties\" is required but was not present")
    }
    return nil
}

func (strct *ComponentCollectionProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ComponentCollectionProperties) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ComponentConditionProperty) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Else" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Else\": ")
	if tmp, err := json.Marshal(strct.Else); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Field" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Field\": ")
	if tmp, err := json.Marshal(strct.Field); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Operand" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Operand\": ")
	if tmp, err := json.Marshal(strct.Operand); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OperandType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OperandType\": ")
	if tmp, err := json.Marshal(strct.OperandType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Operator" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Operator\": ")
	if tmp, err := json.Marshal(strct.Operator); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Property" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Property\": ")
	if tmp, err := json.Marshal(strct.Property); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Then" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Then\": ")
	if tmp, err := json.Marshal(strct.Then); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ComponentConditionProperty) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Else":
            if err := json.Unmarshal([]byte(v), &strct.Else); err != nil {
                return err
             }
        case "Field":
            if err := json.Unmarshal([]byte(v), &strct.Field); err != nil {
                return err
             }
        case "Operand":
            if err := json.Unmarshal([]byte(v), &strct.Operand); err != nil {
                return err
             }
        case "OperandType":
            if err := json.Unmarshal([]byte(v), &strct.OperandType); err != nil {
                return err
             }
        case "Operator":
            if err := json.Unmarshal([]byte(v), &strct.Operator); err != nil {
                return err
             }
        case "Property":
            if err := json.Unmarshal([]byte(v), &strct.Property); err != nil {
                return err
             }
        case "Then":
            if err := json.Unmarshal([]byte(v), &strct.Then); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ComponentDataConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Identifiers" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Identifiers\": ")
	if tmp, err := json.Marshal(strct.Identifiers); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Model" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Model" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Model\": ")
	if tmp, err := json.Marshal(strct.Model); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Predicate" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Predicate\": ")
	if tmp, err := json.Marshal(strct.Predicate); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Sort" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Sort\": ")
	if tmp, err := json.Marshal(strct.Sort); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ComponentDataConfiguration) UnmarshalJSON(b []byte) error {
    ModelReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Identifiers":
            if err := json.Unmarshal([]byte(v), &strct.Identifiers); err != nil {
                return err
             }
        case "Model":
            if err := json.Unmarshal([]byte(v), &strct.Model); err != nil {
                return err
             }
            ModelReceived = true
        case "Predicate":
            if err := json.Unmarshal([]byte(v), &strct.Predicate); err != nil {
                return err
             }
        case "Sort":
            if err := json.Unmarshal([]byte(v), &strct.Sort); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Model (a required property) was received
    if !ModelReceived {
        return errors.New("\"Model\" is required but was not present")
    }
    return nil
}

func (strct *ComponentEvent) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Action" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Action\": ")
	if tmp, err := json.Marshal(strct.Action); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Parameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Parameters\": ")
	if tmp, err := json.Marshal(strct.Parameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ComponentEvent) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Action":
            if err := json.Unmarshal([]byte(v), &strct.Action); err != nil {
                return err
             }
        case "Parameters":
            if err := json.Unmarshal([]byte(v), &strct.Parameters); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ComponentEvents) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ComponentEvents) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ComponentOverrides) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ComponentOverrides) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ComponentOverridesValue) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ComponentOverridesValue) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ComponentProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ComponentProperties) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ComponentProperty) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "BindingProperties" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BindingProperties\": ")
	if tmp, err := json.Marshal(strct.BindingProperties); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Bindings" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Bindings\": ")
	if tmp, err := json.Marshal(strct.Bindings); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CollectionBindingProperties" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CollectionBindingProperties\": ")
	if tmp, err := json.Marshal(strct.CollectionBindingProperties); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ComponentName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ComponentName\": ")
	if tmp, err := json.Marshal(strct.ComponentName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Concat" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Concat\": ")
	if tmp, err := json.Marshal(strct.Concat); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Condition" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Condition\": ")
	if tmp, err := json.Marshal(strct.Condition); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Configured" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Configured\": ")
	if tmp, err := json.Marshal(strct.Configured); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DefaultValue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DefaultValue\": ")
	if tmp, err := json.Marshal(strct.DefaultValue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Event" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Event\": ")
	if tmp, err := json.Marshal(strct.Event); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ImportedValue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ImportedValue\": ")
	if tmp, err := json.Marshal(strct.ImportedValue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Model" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Model\": ")
	if tmp, err := json.Marshal(strct.Model); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Property" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Property\": ")
	if tmp, err := json.Marshal(strct.Property); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "UserAttribute" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UserAttribute\": ")
	if tmp, err := json.Marshal(strct.UserAttribute); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ComponentProperty) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BindingProperties":
            if err := json.Unmarshal([]byte(v), &strct.BindingProperties); err != nil {
                return err
             }
        case "Bindings":
            if err := json.Unmarshal([]byte(v), &strct.Bindings); err != nil {
                return err
             }
        case "CollectionBindingProperties":
            if err := json.Unmarshal([]byte(v), &strct.CollectionBindingProperties); err != nil {
                return err
             }
        case "ComponentName":
            if err := json.Unmarshal([]byte(v), &strct.ComponentName); err != nil {
                return err
             }
        case "Concat":
            if err := json.Unmarshal([]byte(v), &strct.Concat); err != nil {
                return err
             }
        case "Condition":
            if err := json.Unmarshal([]byte(v), &strct.Condition); err != nil {
                return err
             }
        case "Configured":
            if err := json.Unmarshal([]byte(v), &strct.Configured); err != nil {
                return err
             }
        case "DefaultValue":
            if err := json.Unmarshal([]byte(v), &strct.DefaultValue); err != nil {
                return err
             }
        case "Event":
            if err := json.Unmarshal([]byte(v), &strct.Event); err != nil {
                return err
             }
        case "ImportedValue":
            if err := json.Unmarshal([]byte(v), &strct.ImportedValue); err != nil {
                return err
             }
        case "Model":
            if err := json.Unmarshal([]byte(v), &strct.Model); err != nil {
                return err
             }
        case "Property":
            if err := json.Unmarshal([]byte(v), &strct.Property); err != nil {
                return err
             }
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
        case "UserAttribute":
            if err := json.Unmarshal([]byte(v), &strct.UserAttribute); err != nil {
                return err
             }
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ComponentPropertyBindingProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Field" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Field\": ")
	if tmp, err := json.Marshal(strct.Field); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Property" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Property" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Property\": ")
	if tmp, err := json.Marshal(strct.Property); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ComponentPropertyBindingProperties) UnmarshalJSON(b []byte) error {
    PropertyReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Field":
            if err := json.Unmarshal([]byte(v), &strct.Field); err != nil {
                return err
             }
        case "Property":
            if err := json.Unmarshal([]byte(v), &strct.Property); err != nil {
                return err
             }
            PropertyReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Property (a required property) was received
    if !PropertyReceived {
        return errors.New("\"Property\" is required but was not present")
    }
    return nil
}

func (strct *ComponentVariant) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Overrides" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Overrides\": ")
	if tmp, err := json.Marshal(strct.Overrides); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VariantValues" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VariantValues\": ")
	if tmp, err := json.Marshal(strct.VariantValues); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ComponentVariant) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Overrides":
            if err := json.Unmarshal([]byte(v), &strct.Overrides); err != nil {
                return err
             }
        case "VariantValues":
            if err := json.Unmarshal([]byte(v), &strct.VariantValues); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ComponentVariantValues) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ComponentVariantValues) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *FormBindingElement) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Element" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Element" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Element\": ")
	if tmp, err := json.Marshal(strct.Element); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Property" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Property" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Property\": ")
	if tmp, err := json.Marshal(strct.Property); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FormBindingElement) UnmarshalJSON(b []byte) error {
    ElementReceived := false
    PropertyReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Element":
            if err := json.Unmarshal([]byte(v), &strct.Element); err != nil {
                return err
             }
            ElementReceived = true
        case "Property":
            if err := json.Unmarshal([]byte(v), &strct.Property); err != nil {
                return err
             }
            PropertyReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Element (a required property) was received
    if !ElementReceived {
        return errors.New("\"Element\" is required but was not present")
    }
    // check if Property (a required property) was received
    if !PropertyReceived {
        return errors.New("\"Property\" is required but was not present")
    }
    return nil
}

func (strct *FormBindings) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FormBindings) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *MutationActionSetStateParameter) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ComponentName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ComponentName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ComponentName\": ")
	if tmp, err := json.Marshal(strct.ComponentName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Property" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Property" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Property\": ")
	if tmp, err := json.Marshal(strct.Property); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Set" field is required
    if strct.Set == nil {
        return nil, errors.New("Set is a required field")
    }
    // Marshal the "Set" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Set\": ")
	if tmp, err := json.Marshal(strct.Set); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MutationActionSetStateParameter) UnmarshalJSON(b []byte) error {
    ComponentNameReceived := false
    PropertyReceived := false
    SetReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ComponentName":
            if err := json.Unmarshal([]byte(v), &strct.ComponentName); err != nil {
                return err
             }
            ComponentNameReceived = true
        case "Property":
            if err := json.Unmarshal([]byte(v), &strct.Property); err != nil {
                return err
             }
            PropertyReceived = true
        case "Set":
            if err := json.Unmarshal([]byte(v), &strct.Set); err != nil {
                return err
             }
            SetReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ComponentName (a required property) was received
    if !ComponentNameReceived {
        return errors.New("\"ComponentName\" is required but was not present")
    }
    // check if Property (a required property) was received
    if !PropertyReceived {
        return errors.New("\"Property\" is required but was not present")
    }
    // check if Set (a required property) was received
    if !SetReceived {
        return errors.New("\"Set\" is required but was not present")
    }
    return nil
}

func (strct *Predicate) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "And" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"And\": ")
	if tmp, err := json.Marshal(strct.And); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Field" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Field\": ")
	if tmp, err := json.Marshal(strct.Field); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Operand" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Operand\": ")
	if tmp, err := json.Marshal(strct.Operand); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Operator" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Operator\": ")
	if tmp, err := json.Marshal(strct.Operator); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Or" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Or\": ")
	if tmp, err := json.Marshal(strct.Or); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Predicate) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "And":
            if err := json.Unmarshal([]byte(v), &strct.And); err != nil {
                return err
             }
        case "Field":
            if err := json.Unmarshal([]byte(v), &strct.Field); err != nil {
                return err
             }
        case "Operand":
            if err := json.Unmarshal([]byte(v), &strct.Operand); err != nil {
                return err
             }
        case "Operator":
            if err := json.Unmarshal([]byte(v), &strct.Operator); err != nil {
                return err
             }
        case "Or":
            if err := json.Unmarshal([]byte(v), &strct.Or); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AppId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AppId\": ")
	if tmp, err := json.Marshal(strct.AppId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "BindingProperties" field is required
    if strct.BindingProperties == nil {
        return nil, errors.New("BindingProperties is a required field")
    }
    // Marshal the "BindingProperties" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BindingProperties\": ")
	if tmp, err := json.Marshal(strct.BindingProperties); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Children" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Children\": ")
	if tmp, err := json.Marshal(strct.Children); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CollectionProperties" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CollectionProperties\": ")
	if tmp, err := json.Marshal(strct.CollectionProperties); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ComponentType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ComponentType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ComponentType\": ")
	if tmp, err := json.Marshal(strct.ComponentType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EnvironmentName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EnvironmentName\": ")
	if tmp, err := json.Marshal(strct.EnvironmentName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Events" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Events\": ")
	if tmp, err := json.Marshal(strct.Events); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Id" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Overrides" field is required
    if strct.Overrides == nil {
        return nil, errors.New("Overrides is a required field")
    }
    // Marshal the "Overrides" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Overrides\": ")
	if tmp, err := json.Marshal(strct.Overrides); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Properties" field is required
    if strct.Properties == nil {
        return nil, errors.New("Properties is a required field")
    }
    // Marshal the "Properties" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Properties\": ")
	if tmp, err := json.Marshal(strct.Properties); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SchemaVersion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SchemaVersion\": ")
	if tmp, err := json.Marshal(strct.SchemaVersion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SourceId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SourceId\": ")
	if tmp, err := json.Marshal(strct.SourceId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Variants" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Variants" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Variants\": ")
	if tmp, err := json.Marshal(strct.Variants); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    BindingPropertiesReceived := false
    ComponentTypeReceived := false
    NameReceived := false
    OverridesReceived := false
    PropertiesReceived := false
    VariantsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AppId":
            if err := json.Unmarshal([]byte(v), &strct.AppId); err != nil {
                return err
             }
        case "BindingProperties":
            if err := json.Unmarshal([]byte(v), &strct.BindingProperties); err != nil {
                return err
             }
            BindingPropertiesReceived = true
        case "Children":
            if err := json.Unmarshal([]byte(v), &strct.Children); err != nil {
                return err
             }
        case "CollectionProperties":
            if err := json.Unmarshal([]byte(v), &strct.CollectionProperties); err != nil {
                return err
             }
        case "ComponentType":
            if err := json.Unmarshal([]byte(v), &strct.ComponentType); err != nil {
                return err
             }
            ComponentTypeReceived = true
        case "EnvironmentName":
            if err := json.Unmarshal([]byte(v), &strct.EnvironmentName); err != nil {
                return err
             }
        case "Events":
            if err := json.Unmarshal([]byte(v), &strct.Events); err != nil {
                return err
             }
        case "Id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        case "Overrides":
            if err := json.Unmarshal([]byte(v), &strct.Overrides); err != nil {
                return err
             }
            OverridesReceived = true
        case "Properties":
            if err := json.Unmarshal([]byte(v), &strct.Properties); err != nil {
                return err
             }
            PropertiesReceived = true
        case "SchemaVersion":
            if err := json.Unmarshal([]byte(v), &strct.SchemaVersion); err != nil {
                return err
             }
        case "SourceId":
            if err := json.Unmarshal([]byte(v), &strct.SourceId); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        case "Variants":
            if err := json.Unmarshal([]byte(v), &strct.Variants); err != nil {
                return err
             }
            VariantsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if BindingProperties (a required property) was received
    if !BindingPropertiesReceived {
        return errors.New("\"BindingProperties\" is required but was not present")
    }
    // check if ComponentType (a required property) was received
    if !ComponentTypeReceived {
        return errors.New("\"ComponentType\" is required but was not present")
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    // check if Overrides (a required property) was received
    if !OverridesReceived {
        return errors.New("\"Overrides\" is required but was not present")
    }
    // check if Properties (a required property) was received
    if !PropertiesReceived {
        return errors.New("\"Properties\" is required but was not present")
    }
    // check if Variants (a required property) was received
    if !VariantsReceived {
        return errors.New("\"Variants\" is required but was not present")
    }
    return nil
}

func (strct *SortProperty) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Direction" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Direction" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Direction\": ")
	if tmp, err := json.Marshal(strct.Direction); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Field" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Field" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Field\": ")
	if tmp, err := json.Marshal(strct.Field); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SortProperty) UnmarshalJSON(b []byte) error {
    DirectionReceived := false
    FieldReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Direction":
            if err := json.Unmarshal([]byte(v), &strct.Direction); err != nil {
                return err
             }
            DirectionReceived = true
        case "Field":
            if err := json.Unmarshal([]byte(v), &strct.Field); err != nil {
                return err
             }
            FieldReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Direction (a required property) was received
    if !DirectionReceived {
        return errors.New("\"Direction\" is required but was not present")
    }
    // check if Field (a required property) was received
    if !FieldReceived {
        return errors.New("\"Field\" is required but was not present")
    }
    return nil
}

func (strct *Tags) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tags) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}
