// Code generated by schema-generate. DO NOT EDIT.

package alarm

import (
    "errors"
    "bytes"
    "encoding/json"
    "fmt"
)

// Resource Resource Type definition for AWS::Lightsail::Alarm
type Resource struct {
  AlarmArn string `json:"AlarmArn,omitempty"`

  // The name for the alarm. Specify the name of an existing alarm to update, and overwrite the previous configuration of the alarm.
  AlarmName string `json:"AlarmName"`

  // The arithmetic operation to use when comparing the specified statistic to the threshold. The specified statistic value is used as the first operand.
  ComparisonOperator string `json:"ComparisonOperator"`

  // The contact protocols to use for the alarm, such as Email, SMS (text messaging), or both.
  ContactProtocols []string `json:"ContactProtocols,omitempty"`

  // The number of data points that must be not within the specified threshold to trigger the alarm. If you are setting an "M out of N" alarm, this value (datapointsToAlarm) is the M.
  DatapointsToAlarm int `json:"DatapointsToAlarm,omitempty"`

  // The number of most recent periods over which data is compared to the specified threshold. If you are setting an "M out of N" alarm, this value (evaluationPeriods) is the N.
  EvaluationPeriods int `json:"EvaluationPeriods"`

  // The name of the metric to associate with the alarm.
  MetricName string `json:"MetricName"`

  // The validation status of the SSL/TLS certificate.
  MonitoredResourceName string `json:"MonitoredResourceName"`

  // Indicates whether the alarm is enabled. Notifications are enabled by default if you don't specify this parameter.
  NotificationEnabled bool `json:"NotificationEnabled,omitempty"`

  // The alarm states that trigger a notification.
  NotificationTriggers []string `json:"NotificationTriggers,omitempty"`

  // The current state of the alarm.
  State string `json:"State,omitempty"`

  // The value against which the specified statistic is compared.
  Threshold float64 `json:"Threshold"`

  // Sets how this alarm will handle missing data points.
  TreatMissingData string `json:"TreatMissingData,omitempty"`
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AlarmArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AlarmArn\": ")
	if tmp, err := json.Marshal(strct.AlarmArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "AlarmName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AlarmName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AlarmName\": ")
	if tmp, err := json.Marshal(strct.AlarmName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ComparisonOperator" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ComparisonOperator" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ComparisonOperator\": ")
	if tmp, err := json.Marshal(strct.ComparisonOperator); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ContactProtocols" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ContactProtocols\": ")
	if tmp, err := json.Marshal(strct.ContactProtocols); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DatapointsToAlarm" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DatapointsToAlarm\": ")
	if tmp, err := json.Marshal(strct.DatapointsToAlarm); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "EvaluationPeriods" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "EvaluationPeriods" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EvaluationPeriods\": ")
	if tmp, err := json.Marshal(strct.EvaluationPeriods); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "MetricName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "MetricName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MetricName\": ")
	if tmp, err := json.Marshal(strct.MetricName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "MonitoredResourceName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "MonitoredResourceName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MonitoredResourceName\": ")
	if tmp, err := json.Marshal(strct.MonitoredResourceName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "NotificationEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NotificationEnabled\": ")
	if tmp, err := json.Marshal(strct.NotificationEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "NotificationTriggers" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NotificationTriggers\": ")
	if tmp, err := json.Marshal(strct.NotificationTriggers); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "State" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"State\": ")
	if tmp, err := json.Marshal(strct.State); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Threshold" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Threshold" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Threshold\": ")
	if tmp, err := json.Marshal(strct.Threshold); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TreatMissingData" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TreatMissingData\": ")
	if tmp, err := json.Marshal(strct.TreatMissingData); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    AlarmNameReceived := false
    ComparisonOperatorReceived := false
    EvaluationPeriodsReceived := false
    MetricNameReceived := false
    MonitoredResourceNameReceived := false
    ThresholdReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AlarmArn":
            if err := json.Unmarshal([]byte(v), &strct.AlarmArn); err != nil {
                return err
             }
        case "AlarmName":
            if err := json.Unmarshal([]byte(v), &strct.AlarmName); err != nil {
                return err
             }
            AlarmNameReceived = true
        case "ComparisonOperator":
            if err := json.Unmarshal([]byte(v), &strct.ComparisonOperator); err != nil {
                return err
             }
            ComparisonOperatorReceived = true
        case "ContactProtocols":
            if err := json.Unmarshal([]byte(v), &strct.ContactProtocols); err != nil {
                return err
             }
        case "DatapointsToAlarm":
            if err := json.Unmarshal([]byte(v), &strct.DatapointsToAlarm); err != nil {
                return err
             }
        case "EvaluationPeriods":
            if err := json.Unmarshal([]byte(v), &strct.EvaluationPeriods); err != nil {
                return err
             }
            EvaluationPeriodsReceived = true
        case "MetricName":
            if err := json.Unmarshal([]byte(v), &strct.MetricName); err != nil {
                return err
             }
            MetricNameReceived = true
        case "MonitoredResourceName":
            if err := json.Unmarshal([]byte(v), &strct.MonitoredResourceName); err != nil {
                return err
             }
            MonitoredResourceNameReceived = true
        case "NotificationEnabled":
            if err := json.Unmarshal([]byte(v), &strct.NotificationEnabled); err != nil {
                return err
             }
        case "NotificationTriggers":
            if err := json.Unmarshal([]byte(v), &strct.NotificationTriggers); err != nil {
                return err
             }
        case "State":
            if err := json.Unmarshal([]byte(v), &strct.State); err != nil {
                return err
             }
        case "Threshold":
            if err := json.Unmarshal([]byte(v), &strct.Threshold); err != nil {
                return err
             }
            ThresholdReceived = true
        case "TreatMissingData":
            if err := json.Unmarshal([]byte(v), &strct.TreatMissingData); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if AlarmName (a required property) was received
    if !AlarmNameReceived {
        return errors.New("\"AlarmName\" is required but was not present")
    }
    // check if ComparisonOperator (a required property) was received
    if !ComparisonOperatorReceived {
        return errors.New("\"ComparisonOperator\" is required but was not present")
    }
    // check if EvaluationPeriods (a required property) was received
    if !EvaluationPeriodsReceived {
        return errors.New("\"EvaluationPeriods\" is required but was not present")
    }
    // check if MetricName (a required property) was received
    if !MetricNameReceived {
        return errors.New("\"MetricName\" is required but was not present")
    }
    // check if MonitoredResourceName (a required property) was received
    if !MonitoredResourceNameReceived {
        return errors.New("\"MonitoredResourceName\" is required but was not present")
    }
    // check if Threshold (a required property) was received
    if !ThresholdReceived {
        return errors.New("\"Threshold\" is required but was not present")
    }
    return nil
}
