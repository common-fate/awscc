// Code generated by schema-generate. DO NOT EDIT.

package disk

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// AddOn A addon associate with a resource.
type AddOn struct {

  // The add-on type
  AddOnType string `json:"AddOnType"`
  AutoSnapshotAddOnRequest *AutoSnapshotAddOn `json:"AutoSnapshotAddOnRequest,omitempty"`

  // Status of the Addon
  Status string `json:"Status,omitempty"`
}

// AutoSnapshotAddOn An object that represents additional parameters when enabling or modifying the automatic snapshot add-on
type AutoSnapshotAddOn struct {

  // The daily time when an automatic snapshot will be created.
  SnapshotTimeOfDay string `json:"SnapshotTimeOfDay,omitempty"`
}

// Location Location of a resource.
type Location struct {

  // The Availability Zone in which to create your disk. Use the following format: us-east-2a (case sensitive). Be sure to add the include Availability Zones parameter to your request.
  AvailabilityZone string `json:"AvailabilityZone,omitempty"`

  // The Region Name in which to create your disk.
  RegionName string `json:"RegionName,omitempty"`
}

// Resource Resource Type definition for AWS::Lightsail::Disk
type Resource struct {

  // An array of objects representing the add-ons to enable for the new instance.
  AddOns []*AddOn `json:"AddOns,omitempty"`

  // Name of the attached Lightsail Instance
  AttachedTo string `json:"AttachedTo,omitempty"`

  // Attachment State of the Lightsail disk
  AttachmentState string `json:"AttachmentState,omitempty"`

  // The Availability Zone in which to create your instance. Use the following format: us-east-2a (case sensitive). Be sure to add the include Availability Zones parameter to your request.
  AvailabilityZone string `json:"AvailabilityZone,omitempty"`
  DiskArn string `json:"DiskArn,omitempty"`

  // The names to use for your new Lightsail disk.
  DiskName string `json:"DiskName"`

  // Iops of the Lightsail disk
  Iops int `json:"Iops,omitempty"`

  // Check is Disk is attached state
  IsAttached bool `json:"IsAttached,omitempty"`
  Location *Location `json:"Location,omitempty"`

  // Path of the  attached Disk
  Path string `json:"Path,omitempty"`

  // Resource type of Lightsail instance.
  ResourceType string `json:"ResourceType,omitempty"`

  // Size of the Lightsail disk
  SizeInGb int `json:"SizeInGb"`

  // State of the Lightsail disk
  State string `json:"State,omitempty"`

  // Support code to help identify any issues
  SupportCode string `json:"SupportCode,omitempty"`

  // An array of key-value pairs to apply to this resource.
  Tags []*Tag `json:"Tags,omitempty"`
}

// Tag A key-value pair to associate with a resource.
type Tag struct {

  // The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
  Key string `json:"Key"`

  // The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
  Value string `json:"Value,omitempty"`
}

func (strct *AddOn) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AddOnType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AddOnType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AddOnType\": ")
	if tmp, err := json.Marshal(strct.AddOnType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AutoSnapshotAddOnRequest" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AutoSnapshotAddOnRequest\": ")
	if tmp, err := json.Marshal(strct.AutoSnapshotAddOnRequest); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Status" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Status\": ")
	if tmp, err := json.Marshal(strct.Status); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AddOn) UnmarshalJSON(b []byte) error {
    AddOnTypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AddOnType":
            if err := json.Unmarshal([]byte(v), &strct.AddOnType); err != nil {
                return err
             }
            AddOnTypeReceived = true
        case "AutoSnapshotAddOnRequest":
            if err := json.Unmarshal([]byte(v), &strct.AutoSnapshotAddOnRequest); err != nil {
                return err
             }
        case "Status":
            if err := json.Unmarshal([]byte(v), &strct.Status); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if AddOnType (a required property) was received
    if !AddOnTypeReceived {
        return errors.New("\"AddOnType\" is required but was not present")
    }
    return nil
}

func (strct *AutoSnapshotAddOn) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "SnapshotTimeOfDay" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SnapshotTimeOfDay\": ")
	if tmp, err := json.Marshal(strct.SnapshotTimeOfDay); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AutoSnapshotAddOn) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "SnapshotTimeOfDay":
            if err := json.Unmarshal([]byte(v), &strct.SnapshotTimeOfDay); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Location) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AvailabilityZone" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AvailabilityZone\": ")
	if tmp, err := json.Marshal(strct.AvailabilityZone); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RegionName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RegionName\": ")
	if tmp, err := json.Marshal(strct.RegionName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Location) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AvailabilityZone":
            if err := json.Unmarshal([]byte(v), &strct.AvailabilityZone); err != nil {
                return err
             }
        case "RegionName":
            if err := json.Unmarshal([]byte(v), &strct.RegionName); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AddOns" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AddOns\": ")
	if tmp, err := json.Marshal(strct.AddOns); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AttachedTo" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AttachedTo\": ")
	if tmp, err := json.Marshal(strct.AttachedTo); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AttachmentState" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AttachmentState\": ")
	if tmp, err := json.Marshal(strct.AttachmentState); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AvailabilityZone" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AvailabilityZone\": ")
	if tmp, err := json.Marshal(strct.AvailabilityZone); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DiskArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DiskArn\": ")
	if tmp, err := json.Marshal(strct.DiskArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "DiskName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "DiskName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DiskName\": ")
	if tmp, err := json.Marshal(strct.DiskName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Iops" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Iops\": ")
	if tmp, err := json.Marshal(strct.Iops); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IsAttached" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IsAttached\": ")
	if tmp, err := json.Marshal(strct.IsAttached); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Location" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Location\": ")
	if tmp, err := json.Marshal(strct.Location); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Path" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Path\": ")
	if tmp, err := json.Marshal(strct.Path); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ResourceType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ResourceType\": ")
	if tmp, err := json.Marshal(strct.ResourceType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "SizeInGb" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "SizeInGb" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SizeInGb\": ")
	if tmp, err := json.Marshal(strct.SizeInGb); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "State" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"State\": ")
	if tmp, err := json.Marshal(strct.State); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SupportCode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SupportCode\": ")
	if tmp, err := json.Marshal(strct.SupportCode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    DiskNameReceived := false
    SizeInGbReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AddOns":
            if err := json.Unmarshal([]byte(v), &strct.AddOns); err != nil {
                return err
             }
        case "AttachedTo":
            if err := json.Unmarshal([]byte(v), &strct.AttachedTo); err != nil {
                return err
             }
        case "AttachmentState":
            if err := json.Unmarshal([]byte(v), &strct.AttachmentState); err != nil {
                return err
             }
        case "AvailabilityZone":
            if err := json.Unmarshal([]byte(v), &strct.AvailabilityZone); err != nil {
                return err
             }
        case "DiskArn":
            if err := json.Unmarshal([]byte(v), &strct.DiskArn); err != nil {
                return err
             }
        case "DiskName":
            if err := json.Unmarshal([]byte(v), &strct.DiskName); err != nil {
                return err
             }
            DiskNameReceived = true
        case "Iops":
            if err := json.Unmarshal([]byte(v), &strct.Iops); err != nil {
                return err
             }
        case "IsAttached":
            if err := json.Unmarshal([]byte(v), &strct.IsAttached); err != nil {
                return err
             }
        case "Location":
            if err := json.Unmarshal([]byte(v), &strct.Location); err != nil {
                return err
             }
        case "Path":
            if err := json.Unmarshal([]byte(v), &strct.Path); err != nil {
                return err
             }
        case "ResourceType":
            if err := json.Unmarshal([]byte(v), &strct.ResourceType); err != nil {
                return err
             }
        case "SizeInGb":
            if err := json.Unmarshal([]byte(v), &strct.SizeInGb); err != nil {
                return err
             }
            SizeInGbReceived = true
        case "State":
            if err := json.Unmarshal([]byte(v), &strct.State); err != nil {
                return err
             }
        case "SupportCode":
            if err := json.Unmarshal([]byte(v), &strct.SupportCode); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if DiskName (a required property) was received
    if !DiskNameReceived {
        return errors.New("\"DiskName\" is required but was not present")
    }
    // check if SizeInGb (a required property) was received
    if !SizeInGbReceived {
        return errors.New("\"SizeInGb\" is required but was not present")
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    return nil
}
