// Code generated by schema-generate. DO NOT EDIT.

package loadbalancer

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// Resource Resource Type definition for AWS::Lightsail::LoadBalancer
type Resource struct {

  // The names of the instances attached to the load balancer.
  AttachedInstances []string `json:"AttachedInstances,omitempty"`

  // The path you provided to perform the load balancer health check. If you didn't specify a health check path, Lightsail uses the root path of your website (e.g., "/").
  HealthCheckPath string `json:"HealthCheckPath,omitempty"`

  // The instance port where you're creating your load balancer.
  InstancePort int `json:"InstancePort"`

  // The IP address type for the load balancer. The possible values are ipv4 for IPv4 only, and dualstack for IPv4 and IPv6. The default value is dualstack.
  IpAddressType string `json:"IpAddressType,omitempty"`
  LoadBalancerArn string `json:"LoadBalancerArn,omitempty"`

  // The name of your load balancer.
  LoadBalancerName string `json:"LoadBalancerName"`

  // Configuration option to enable session stickiness.
  SessionStickinessEnabled bool `json:"SessionStickinessEnabled,omitempty"`

  // Configuration option to adjust session stickiness cookie duration parameter.
  SessionStickinessLBCookieDurationSeconds string `json:"SessionStickinessLBCookieDurationSeconds,omitempty"`

  // An array of key-value pairs to apply to this resource.
  Tags []*Tag `json:"Tags,omitempty"`

  // The name of the TLS policy to apply to the load balancer.
  TlsPolicyName string `json:"TlsPolicyName,omitempty"`
}

// Tag A key-value pair to associate with a resource.
type Tag struct {

  // The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
  Key string `json:"Key"`

  // The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
  Value string `json:"Value,omitempty"`
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AttachedInstances" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AttachedInstances\": ")
	if tmp, err := json.Marshal(strct.AttachedInstances); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "HealthCheckPath" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HealthCheckPath\": ")
	if tmp, err := json.Marshal(strct.HealthCheckPath); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "InstancePort" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "InstancePort" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InstancePort\": ")
	if tmp, err := json.Marshal(strct.InstancePort); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IpAddressType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IpAddressType\": ")
	if tmp, err := json.Marshal(strct.IpAddressType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LoadBalancerArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LoadBalancerArn\": ")
	if tmp, err := json.Marshal(strct.LoadBalancerArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "LoadBalancerName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "LoadBalancerName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LoadBalancerName\": ")
	if tmp, err := json.Marshal(strct.LoadBalancerName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SessionStickinessEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SessionStickinessEnabled\": ")
	if tmp, err := json.Marshal(strct.SessionStickinessEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SessionStickinessLBCookieDurationSeconds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SessionStickinessLBCookieDurationSeconds\": ")
	if tmp, err := json.Marshal(strct.SessionStickinessLBCookieDurationSeconds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TlsPolicyName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TlsPolicyName\": ")
	if tmp, err := json.Marshal(strct.TlsPolicyName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    InstancePortReceived := false
    LoadBalancerNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AttachedInstances":
            if err := json.Unmarshal([]byte(v), &strct.AttachedInstances); err != nil {
                return err
             }
        case "HealthCheckPath":
            if err := json.Unmarshal([]byte(v), &strct.HealthCheckPath); err != nil {
                return err
             }
        case "InstancePort":
            if err := json.Unmarshal([]byte(v), &strct.InstancePort); err != nil {
                return err
             }
            InstancePortReceived = true
        case "IpAddressType":
            if err := json.Unmarshal([]byte(v), &strct.IpAddressType); err != nil {
                return err
             }
        case "LoadBalancerArn":
            if err := json.Unmarshal([]byte(v), &strct.LoadBalancerArn); err != nil {
                return err
             }
        case "LoadBalancerName":
            if err := json.Unmarshal([]byte(v), &strct.LoadBalancerName); err != nil {
                return err
             }
            LoadBalancerNameReceived = true
        case "SessionStickinessEnabled":
            if err := json.Unmarshal([]byte(v), &strct.SessionStickinessEnabled); err != nil {
                return err
             }
        case "SessionStickinessLBCookieDurationSeconds":
            if err := json.Unmarshal([]byte(v), &strct.SessionStickinessLBCookieDurationSeconds); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        case "TlsPolicyName":
            if err := json.Unmarshal([]byte(v), &strct.TlsPolicyName); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if InstancePort (a required property) was received
    if !InstancePortReceived {
        return errors.New("\"InstancePort\" is required but was not present")
    }
    // check if LoadBalancerName (a required property) was received
    if !LoadBalancerNameReceived {
        return errors.New("\"LoadBalancerName\" is required but was not present")
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    return nil
}
