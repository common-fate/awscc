// Code generated by schema-generate. DO NOT EDIT.

package license

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// BorrowConfiguration 
type BorrowConfiguration struct {
  AllowEarlyCheckIn bool `json:"AllowEarlyCheckIn"`
  MaxTimeToLiveInMinutes int `json:"MaxTimeToLiveInMinutes"`
}

// ConsumptionConfiguration 
type ConsumptionConfiguration struct {
  BorrowConfiguration *BorrowConfiguration `json:"BorrowConfiguration,omitempty"`
  ProvisionalConfiguration *ProvisionalConfiguration `json:"ProvisionalConfiguration,omitempty"`
  RenewType string `json:"RenewType,omitempty"`
}

// Entitlement 
type Entitlement struct {
  AllowCheckIn bool `json:"AllowCheckIn,omitempty"`
  MaxCount int `json:"MaxCount,omitempty"`
  Name string `json:"Name"`
  Overage bool `json:"Overage,omitempty"`
  Unit string `json:"Unit"`
  Value string `json:"Value,omitempty"`
}

// IssuerData 
type IssuerData struct {
  Name string `json:"Name"`
  SignKey string `json:"SignKey,omitempty"`
}

// Metadata 
type Metadata struct {
  Name string `json:"Name"`
  Value string `json:"Value"`
}

// ProvisionalConfiguration 
type ProvisionalConfiguration struct {
  MaxTimeToLiveInMinutes int `json:"MaxTimeToLiveInMinutes"`
}

// Resource Resource Type definition for AWS::LicenseManager::License
type Resource struct {

  // Beneficiary of the license.
  Beneficiary string `json:"Beneficiary,omitempty"`
  ConsumptionConfiguration *ConsumptionConfiguration `json:"ConsumptionConfiguration"`
  Entitlements []*Entitlement `json:"Entitlements"`

  // Home region for the created license.
  HomeRegion string `json:"HomeRegion"`
  Issuer *IssuerData `json:"Issuer"`

  // Amazon Resource Name is a unique name for each resource.
  LicenseArn string `json:"LicenseArn,omitempty"`
  LicenseMetadata []*Metadata `json:"LicenseMetadata,omitempty"`

  // Name for the created license.
  LicenseName string `json:"LicenseName"`

  // Product name for the created license.
  ProductName string `json:"ProductName"`

  // ProductSKU of the license.
  ProductSKU string `json:"ProductSKU,omitempty"`
  Status string `json:"Status,omitempty"`
  Validity *ValidityDateFormat `json:"Validity"`

  // The version of the license.
  Version string `json:"Version,omitempty"`
}

// ValidityDateFormat 
type ValidityDateFormat struct {

  // Validity begin date for the license.
  Begin string `json:"Begin"`

  // Validity begin date for the license.
  End string `json:"End"`
}

func (strct *BorrowConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AllowEarlyCheckIn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AllowEarlyCheckIn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AllowEarlyCheckIn\": ")
	if tmp, err := json.Marshal(strct.AllowEarlyCheckIn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "MaxTimeToLiveInMinutes" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "MaxTimeToLiveInMinutes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaxTimeToLiveInMinutes\": ")
	if tmp, err := json.Marshal(strct.MaxTimeToLiveInMinutes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BorrowConfiguration) UnmarshalJSON(b []byte) error {
    AllowEarlyCheckInReceived := false
    MaxTimeToLiveInMinutesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AllowEarlyCheckIn":
            if err := json.Unmarshal([]byte(v), &strct.AllowEarlyCheckIn); err != nil {
                return err
             }
            AllowEarlyCheckInReceived = true
        case "MaxTimeToLiveInMinutes":
            if err := json.Unmarshal([]byte(v), &strct.MaxTimeToLiveInMinutes); err != nil {
                return err
             }
            MaxTimeToLiveInMinutesReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if AllowEarlyCheckIn (a required property) was received
    if !AllowEarlyCheckInReceived {
        return errors.New("\"AllowEarlyCheckIn\" is required but was not present")
    }
    // check if MaxTimeToLiveInMinutes (a required property) was received
    if !MaxTimeToLiveInMinutesReceived {
        return errors.New("\"MaxTimeToLiveInMinutes\" is required but was not present")
    }
    return nil
}

func (strct *ConsumptionConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "BorrowConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BorrowConfiguration\": ")
	if tmp, err := json.Marshal(strct.BorrowConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ProvisionalConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ProvisionalConfiguration\": ")
	if tmp, err := json.Marshal(strct.ProvisionalConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RenewType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RenewType\": ")
	if tmp, err := json.Marshal(strct.RenewType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ConsumptionConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BorrowConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.BorrowConfiguration); err != nil {
                return err
             }
        case "ProvisionalConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.ProvisionalConfiguration); err != nil {
                return err
             }
        case "RenewType":
            if err := json.Unmarshal([]byte(v), &strct.RenewType); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Entitlement) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AllowCheckIn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AllowCheckIn\": ")
	if tmp, err := json.Marshal(strct.AllowCheckIn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MaxCount" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaxCount\": ")
	if tmp, err := json.Marshal(strct.MaxCount); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Overage" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Overage\": ")
	if tmp, err := json.Marshal(strct.Overage); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Unit" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Unit" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Unit\": ")
	if tmp, err := json.Marshal(strct.Unit); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Entitlement) UnmarshalJSON(b []byte) error {
    NameReceived := false
    UnitReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AllowCheckIn":
            if err := json.Unmarshal([]byte(v), &strct.AllowCheckIn); err != nil {
                return err
             }
        case "MaxCount":
            if err := json.Unmarshal([]byte(v), &strct.MaxCount); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        case "Overage":
            if err := json.Unmarshal([]byte(v), &strct.Overage); err != nil {
                return err
             }
        case "Unit":
            if err := json.Unmarshal([]byte(v), &strct.Unit); err != nil {
                return err
             }
            UnitReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    // check if Unit (a required property) was received
    if !UnitReceived {
        return errors.New("\"Unit\" is required but was not present")
    }
    return nil
}

func (strct *IssuerData) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SignKey" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SignKey\": ")
	if tmp, err := json.Marshal(strct.SignKey); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *IssuerData) UnmarshalJSON(b []byte) error {
    NameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        case "SignKey":
            if err := json.Unmarshal([]byte(v), &strct.SignKey); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    return nil
}

func (strct *Metadata) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Metadata) UnmarshalJSON(b []byte) error {
    NameReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *ProvisionalConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "MaxTimeToLiveInMinutes" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "MaxTimeToLiveInMinutes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaxTimeToLiveInMinutes\": ")
	if tmp, err := json.Marshal(strct.MaxTimeToLiveInMinutes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ProvisionalConfiguration) UnmarshalJSON(b []byte) error {
    MaxTimeToLiveInMinutesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "MaxTimeToLiveInMinutes":
            if err := json.Unmarshal([]byte(v), &strct.MaxTimeToLiveInMinutes); err != nil {
                return err
             }
            MaxTimeToLiveInMinutesReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if MaxTimeToLiveInMinutes (a required property) was received
    if !MaxTimeToLiveInMinutesReceived {
        return errors.New("\"MaxTimeToLiveInMinutes\" is required but was not present")
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Beneficiary" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Beneficiary\": ")
	if tmp, err := json.Marshal(strct.Beneficiary); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ConsumptionConfiguration" field is required
    if strct.ConsumptionConfiguration == nil {
        return nil, errors.New("ConsumptionConfiguration is a required field")
    }
    // Marshal the "ConsumptionConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConsumptionConfiguration\": ")
	if tmp, err := json.Marshal(strct.ConsumptionConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Entitlements" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Entitlements" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Entitlements\": ")
	if tmp, err := json.Marshal(strct.Entitlements); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "HomeRegion" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "HomeRegion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HomeRegion\": ")
	if tmp, err := json.Marshal(strct.HomeRegion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Issuer" field is required
    if strct.Issuer == nil {
        return nil, errors.New("Issuer is a required field")
    }
    // Marshal the "Issuer" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Issuer\": ")
	if tmp, err := json.Marshal(strct.Issuer); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LicenseArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LicenseArn\": ")
	if tmp, err := json.Marshal(strct.LicenseArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LicenseMetadata" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LicenseMetadata\": ")
	if tmp, err := json.Marshal(strct.LicenseMetadata); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "LicenseName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "LicenseName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LicenseName\": ")
	if tmp, err := json.Marshal(strct.LicenseName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ProductName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ProductName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ProductName\": ")
	if tmp, err := json.Marshal(strct.ProductName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ProductSKU" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ProductSKU\": ")
	if tmp, err := json.Marshal(strct.ProductSKU); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Status" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Status\": ")
	if tmp, err := json.Marshal(strct.Status); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Validity" field is required
    if strct.Validity == nil {
        return nil, errors.New("Validity is a required field")
    }
    // Marshal the "Validity" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Validity\": ")
	if tmp, err := json.Marshal(strct.Validity); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Version" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Version\": ")
	if tmp, err := json.Marshal(strct.Version); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    ConsumptionConfigurationReceived := false
    EntitlementsReceived := false
    HomeRegionReceived := false
    IssuerReceived := false
    LicenseNameReceived := false
    ProductNameReceived := false
    ValidityReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Beneficiary":
            if err := json.Unmarshal([]byte(v), &strct.Beneficiary); err != nil {
                return err
             }
        case "ConsumptionConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.ConsumptionConfiguration); err != nil {
                return err
             }
            ConsumptionConfigurationReceived = true
        case "Entitlements":
            if err := json.Unmarshal([]byte(v), &strct.Entitlements); err != nil {
                return err
             }
            EntitlementsReceived = true
        case "HomeRegion":
            if err := json.Unmarshal([]byte(v), &strct.HomeRegion); err != nil {
                return err
             }
            HomeRegionReceived = true
        case "Issuer":
            if err := json.Unmarshal([]byte(v), &strct.Issuer); err != nil {
                return err
             }
            IssuerReceived = true
        case "LicenseArn":
            if err := json.Unmarshal([]byte(v), &strct.LicenseArn); err != nil {
                return err
             }
        case "LicenseMetadata":
            if err := json.Unmarshal([]byte(v), &strct.LicenseMetadata); err != nil {
                return err
             }
        case "LicenseName":
            if err := json.Unmarshal([]byte(v), &strct.LicenseName); err != nil {
                return err
             }
            LicenseNameReceived = true
        case "ProductName":
            if err := json.Unmarshal([]byte(v), &strct.ProductName); err != nil {
                return err
             }
            ProductNameReceived = true
        case "ProductSKU":
            if err := json.Unmarshal([]byte(v), &strct.ProductSKU); err != nil {
                return err
             }
        case "Status":
            if err := json.Unmarshal([]byte(v), &strct.Status); err != nil {
                return err
             }
        case "Validity":
            if err := json.Unmarshal([]byte(v), &strct.Validity); err != nil {
                return err
             }
            ValidityReceived = true
        case "Version":
            if err := json.Unmarshal([]byte(v), &strct.Version); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ConsumptionConfiguration (a required property) was received
    if !ConsumptionConfigurationReceived {
        return errors.New("\"ConsumptionConfiguration\" is required but was not present")
    }
    // check if Entitlements (a required property) was received
    if !EntitlementsReceived {
        return errors.New("\"Entitlements\" is required but was not present")
    }
    // check if HomeRegion (a required property) was received
    if !HomeRegionReceived {
        return errors.New("\"HomeRegion\" is required but was not present")
    }
    // check if Issuer (a required property) was received
    if !IssuerReceived {
        return errors.New("\"Issuer\" is required but was not present")
    }
    // check if LicenseName (a required property) was received
    if !LicenseNameReceived {
        return errors.New("\"LicenseName\" is required but was not present")
    }
    // check if ProductName (a required property) was received
    if !ProductNameReceived {
        return errors.New("\"ProductName\" is required but was not present")
    }
    // check if Validity (a required property) was received
    if !ValidityReceived {
        return errors.New("\"Validity\" is required but was not present")
    }
    return nil
}

func (strct *ValidityDateFormat) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Begin" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Begin" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Begin\": ")
	if tmp, err := json.Marshal(strct.Begin); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "End" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "End" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"End\": ")
	if tmp, err := json.Marshal(strct.End); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ValidityDateFormat) UnmarshalJSON(b []byte) error {
    BeginReceived := false
    EndReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Begin":
            if err := json.Unmarshal([]byte(v), &strct.Begin); err != nil {
                return err
             }
            BeginReceived = true
        case "End":
            if err := json.Unmarshal([]byte(v), &strct.End); err != nil {
                return err
             }
            EndReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Begin (a required property) was received
    if !BeginReceived {
        return errors.New("\"Begin\" is required but was not present")
    }
    // check if End (a required property) was received
    if !EndReceived {
        return errors.New("\"End\" is required but was not present")
    }
    return nil
}
