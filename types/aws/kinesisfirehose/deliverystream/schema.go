// Code generated by schema-generate. DO NOT EDIT.

package deliverystream

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// AmazonOpenSearchServerlessBufferingHints 
type AmazonOpenSearchServerlessBufferingHints struct {
  IntervalInSeconds int `json:"IntervalInSeconds,omitempty"`
  SizeInMBs int `json:"SizeInMBs,omitempty"`
}

// AmazonOpenSearchServerlessDestinationConfiguration 
type AmazonOpenSearchServerlessDestinationConfiguration struct {
  BufferingHints *AmazonOpenSearchServerlessBufferingHints `json:"BufferingHints,omitempty"`
  CloudWatchLoggingOptions *CloudWatchLoggingOptions `json:"CloudWatchLoggingOptions,omitempty"`
  CollectionEndpoint string `json:"CollectionEndpoint,omitempty"`
  IndexName string `json:"IndexName"`
  ProcessingConfiguration *ProcessingConfiguration `json:"ProcessingConfiguration,omitempty"`
  RetryOptions *AmazonOpenSearchServerlessRetryOptions `json:"RetryOptions,omitempty"`
  RoleARN string `json:"RoleARN"`
  S3BackupMode string `json:"S3BackupMode,omitempty"`
  S3Configuration *S3DestinationConfiguration `json:"S3Configuration"`
  VpcConfiguration *VpcConfiguration `json:"VpcConfiguration,omitempty"`
}

// AmazonOpenSearchServerlessRetryOptions 
type AmazonOpenSearchServerlessRetryOptions struct {
  DurationInSeconds int `json:"DurationInSeconds,omitempty"`
}

// AmazonopensearchserviceBufferingHints 
type AmazonopensearchserviceBufferingHints struct {
  IntervalInSeconds int `json:"IntervalInSeconds,omitempty"`
  SizeInMBs int `json:"SizeInMBs,omitempty"`
}

// AmazonopensearchserviceDestinationConfiguration 
type AmazonopensearchserviceDestinationConfiguration struct {
  BufferingHints *AmazonopensearchserviceBufferingHints `json:"BufferingHints,omitempty"`
  CloudWatchLoggingOptions *CloudWatchLoggingOptions `json:"CloudWatchLoggingOptions,omitempty"`
  ClusterEndpoint string `json:"ClusterEndpoint,omitempty"`
  DomainARN string `json:"DomainARN,omitempty"`
  IndexName string `json:"IndexName"`
  IndexRotationPeriod string `json:"IndexRotationPeriod,omitempty"`
  ProcessingConfiguration *ProcessingConfiguration `json:"ProcessingConfiguration,omitempty"`
  RetryOptions *AmazonopensearchserviceRetryOptions `json:"RetryOptions,omitempty"`
  RoleARN string `json:"RoleARN"`
  S3BackupMode string `json:"S3BackupMode,omitempty"`
  S3Configuration *S3DestinationConfiguration `json:"S3Configuration"`
  TypeName string `json:"TypeName,omitempty"`
  VpcConfiguration *VpcConfiguration `json:"VpcConfiguration,omitempty"`
}

// AmazonopensearchserviceRetryOptions 
type AmazonopensearchserviceRetryOptions struct {
  DurationInSeconds int `json:"DurationInSeconds,omitempty"`
}

// BufferingHints 
type BufferingHints struct {
  IntervalInSeconds int `json:"IntervalInSeconds,omitempty"`
  SizeInMBs int `json:"SizeInMBs,omitempty"`
}

// CloudWatchLoggingOptions 
type CloudWatchLoggingOptions struct {
  Enabled bool `json:"Enabled,omitempty"`
  LogGroupName string `json:"LogGroupName,omitempty"`
  LogStreamName string `json:"LogStreamName,omitempty"`
}

// ColumnToJsonKeyMappings 
type ColumnToJsonKeyMappings struct {
}

// CopyCommand 
type CopyCommand struct {
  CopyOptions string `json:"CopyOptions,omitempty"`
  DataTableColumns string `json:"DataTableColumns,omitempty"`
  DataTableName string `json:"DataTableName"`
}

// DataFormatConversionConfiguration 
type DataFormatConversionConfiguration struct {
  Enabled bool `json:"Enabled,omitempty"`
  InputFormatConfiguration *InputFormatConfiguration `json:"InputFormatConfiguration,omitempty"`
  OutputFormatConfiguration *OutputFormatConfiguration `json:"OutputFormatConfiguration,omitempty"`
  SchemaConfiguration *SchemaConfiguration `json:"SchemaConfiguration,omitempty"`
}

// DeliveryStreamEncryptionConfigurationInput 
type DeliveryStreamEncryptionConfigurationInput struct {
  KeyARN string `json:"KeyARN,omitempty"`
  KeyType string `json:"KeyType"`
}

// Deserializer 
type Deserializer struct {
  HiveJsonSerDe *HiveJsonSerDe `json:"HiveJsonSerDe,omitempty"`
  OpenXJsonSerDe *OpenXJsonSerDe `json:"OpenXJsonSerDe,omitempty"`
}

// DynamicPartitioningConfiguration 
type DynamicPartitioningConfiguration struct {
  Enabled bool `json:"Enabled,omitempty"`
  RetryOptions *RetryOptions `json:"RetryOptions,omitempty"`
}

// ElasticsearchBufferingHints 
type ElasticsearchBufferingHints struct {
  IntervalInSeconds int `json:"IntervalInSeconds,omitempty"`
  SizeInMBs int `json:"SizeInMBs,omitempty"`
}

// ElasticsearchDestinationConfiguration 
type ElasticsearchDestinationConfiguration struct {
  BufferingHints *ElasticsearchBufferingHints `json:"BufferingHints,omitempty"`
  CloudWatchLoggingOptions *CloudWatchLoggingOptions `json:"CloudWatchLoggingOptions,omitempty"`
  ClusterEndpoint string `json:"ClusterEndpoint,omitempty"`
  DomainARN string `json:"DomainARN,omitempty"`
  IndexName string `json:"IndexName"`
  IndexRotationPeriod string `json:"IndexRotationPeriod,omitempty"`
  ProcessingConfiguration *ProcessingConfiguration `json:"ProcessingConfiguration,omitempty"`
  RetryOptions *ElasticsearchRetryOptions `json:"RetryOptions,omitempty"`
  RoleARN string `json:"RoleARN"`
  S3BackupMode string `json:"S3BackupMode,omitempty"`
  S3Configuration *S3DestinationConfiguration `json:"S3Configuration"`
  TypeName string `json:"TypeName,omitempty"`
  VpcConfiguration *VpcConfiguration `json:"VpcConfiguration,omitempty"`
}

// ElasticsearchRetryOptions 
type ElasticsearchRetryOptions struct {
  DurationInSeconds int `json:"DurationInSeconds,omitempty"`
}

// EncryptionConfiguration 
type EncryptionConfiguration struct {
  KMSEncryptionConfig *KMSEncryptionConfig `json:"KMSEncryptionConfig,omitempty"`
  NoEncryptionConfig string `json:"NoEncryptionConfig,omitempty"`
}

// ExtendedS3DestinationConfiguration 
type ExtendedS3DestinationConfiguration struct {
  BucketARN string `json:"BucketARN"`
  BufferingHints *BufferingHints `json:"BufferingHints,omitempty"`
  CloudWatchLoggingOptions *CloudWatchLoggingOptions `json:"CloudWatchLoggingOptions,omitempty"`
  CompressionFormat string `json:"CompressionFormat,omitempty"`
  DataFormatConversionConfiguration *DataFormatConversionConfiguration `json:"DataFormatConversionConfiguration,omitempty"`
  DynamicPartitioningConfiguration *DynamicPartitioningConfiguration `json:"DynamicPartitioningConfiguration,omitempty"`
  EncryptionConfiguration *EncryptionConfiguration `json:"EncryptionConfiguration,omitempty"`
  ErrorOutputPrefix string `json:"ErrorOutputPrefix,omitempty"`
  Prefix string `json:"Prefix,omitempty"`
  ProcessingConfiguration *ProcessingConfiguration `json:"ProcessingConfiguration,omitempty"`
  RoleARN string `json:"RoleARN"`
  S3BackupConfiguration *S3DestinationConfiguration `json:"S3BackupConfiguration,omitempty"`
  S3BackupMode string `json:"S3BackupMode,omitempty"`
}

// HiveJsonSerDe 
type HiveJsonSerDe struct {
  TimestampFormats []string `json:"TimestampFormats,omitempty"`
}

// HttpEndpointCommonAttribute 
type HttpEndpointCommonAttribute struct {
  AttributeName string `json:"AttributeName"`
  AttributeValue string `json:"AttributeValue"`
}

// HttpEndpointConfiguration 
type HttpEndpointConfiguration struct {
  AccessKey string `json:"AccessKey,omitempty"`
  Name string `json:"Name,omitempty"`
  Url string `json:"Url"`
}

// HttpEndpointDestinationConfiguration 
type HttpEndpointDestinationConfiguration struct {
  BufferingHints *BufferingHints `json:"BufferingHints,omitempty"`
  CloudWatchLoggingOptions *CloudWatchLoggingOptions `json:"CloudWatchLoggingOptions,omitempty"`
  EndpointConfiguration *HttpEndpointConfiguration `json:"EndpointConfiguration"`
  ProcessingConfiguration *ProcessingConfiguration `json:"ProcessingConfiguration,omitempty"`
  RequestConfiguration *HttpEndpointRequestConfiguration `json:"RequestConfiguration,omitempty"`
  RetryOptions *RetryOptions `json:"RetryOptions,omitempty"`
  RoleARN string `json:"RoleARN,omitempty"`
  S3BackupMode string `json:"S3BackupMode,omitempty"`
  S3Configuration *S3DestinationConfiguration `json:"S3Configuration"`
}

// HttpEndpointRequestConfiguration 
type HttpEndpointRequestConfiguration struct {
  CommonAttributes []*HttpEndpointCommonAttribute `json:"CommonAttributes,omitempty"`
  ContentEncoding string `json:"ContentEncoding,omitempty"`
}

// InputFormatConfiguration 
type InputFormatConfiguration struct {
  Deserializer *Deserializer `json:"Deserializer,omitempty"`
}

// KMSEncryptionConfig 
type KMSEncryptionConfig struct {
  AWSKMSKeyARN string `json:"AWSKMSKeyARN"`
}

// KinesisStreamSourceConfiguration 
type KinesisStreamSourceConfiguration struct {
  KinesisStreamARN string `json:"KinesisStreamARN"`
  RoleARN string `json:"RoleARN"`
}

// OpenXJsonSerDe 
type OpenXJsonSerDe struct {
  CaseInsensitive bool `json:"CaseInsensitive,omitempty"`
  ColumnToJsonKeyMappings *ColumnToJsonKeyMappings `json:"ColumnToJsonKeyMappings,omitempty"`
  ConvertDotsInJsonKeysToUnderscores bool `json:"ConvertDotsInJsonKeysToUnderscores,omitempty"`
}

// OrcSerDe 
type OrcSerDe struct {
  BlockSizeBytes int `json:"BlockSizeBytes,omitempty"`
  BloomFilterColumns []string `json:"BloomFilterColumns,omitempty"`
  BloomFilterFalsePositiveProbability float64 `json:"BloomFilterFalsePositiveProbability,omitempty"`
  Compression string `json:"Compression,omitempty"`
  DictionaryKeyThreshold float64 `json:"DictionaryKeyThreshold,omitempty"`
  EnablePadding bool `json:"EnablePadding,omitempty"`
  FormatVersion string `json:"FormatVersion,omitempty"`
  PaddingTolerance float64 `json:"PaddingTolerance,omitempty"`
  RowIndexStride int `json:"RowIndexStride,omitempty"`
  StripeSizeBytes int `json:"StripeSizeBytes,omitempty"`
}

// OutputFormatConfiguration 
type OutputFormatConfiguration struct {
  Serializer *Serializer `json:"Serializer,omitempty"`
}

// ParquetSerDe 
type ParquetSerDe struct {
  BlockSizeBytes int `json:"BlockSizeBytes,omitempty"`
  Compression string `json:"Compression,omitempty"`
  EnableDictionaryCompression bool `json:"EnableDictionaryCompression,omitempty"`
  MaxPaddingBytes int `json:"MaxPaddingBytes,omitempty"`
  PageSizeBytes int `json:"PageSizeBytes,omitempty"`
  WriterVersion string `json:"WriterVersion,omitempty"`
}

// ProcessingConfiguration 
type ProcessingConfiguration struct {
  Enabled bool `json:"Enabled,omitempty"`
  Processors []*Processor `json:"Processors,omitempty"`
}

// Processor 
type Processor struct {
  Parameters []*ProcessorParameter `json:"Parameters,omitempty"`
  Type string `json:"Type"`
}

// ProcessorParameter 
type ProcessorParameter struct {
  ParameterName string `json:"ParameterName"`
  ParameterValue string `json:"ParameterValue"`
}

// RedshiftDestinationConfiguration 
type RedshiftDestinationConfiguration struct {
  CloudWatchLoggingOptions *CloudWatchLoggingOptions `json:"CloudWatchLoggingOptions,omitempty"`
  ClusterJDBCURL string `json:"ClusterJDBCURL"`
  CopyCommand *CopyCommand `json:"CopyCommand"`
  Password string `json:"Password"`
  ProcessingConfiguration *ProcessingConfiguration `json:"ProcessingConfiguration,omitempty"`
  RetryOptions *RedshiftRetryOptions `json:"RetryOptions,omitempty"`
  RoleARN string `json:"RoleARN"`
  S3BackupConfiguration *S3DestinationConfiguration `json:"S3BackupConfiguration,omitempty"`
  S3BackupMode string `json:"S3BackupMode,omitempty"`
  S3Configuration *S3DestinationConfiguration `json:"S3Configuration"`
  Username string `json:"Username"`
}

// RedshiftRetryOptions 
type RedshiftRetryOptions struct {
  DurationInSeconds int `json:"DurationInSeconds,omitempty"`
}

// Resource Resource Type definition for AWS::KinesisFirehose::DeliveryStream
type Resource struct {
  AmazonOpenSearchServerlessDestinationConfiguration *AmazonOpenSearchServerlessDestinationConfiguration `json:"AmazonOpenSearchServerlessDestinationConfiguration,omitempty"`
  AmazonopensearchserviceDestinationConfiguration *AmazonopensearchserviceDestinationConfiguration `json:"AmazonopensearchserviceDestinationConfiguration,omitempty"`
  Arn string `json:"Arn,omitempty"`
  DeliveryStreamEncryptionConfigurationInput *DeliveryStreamEncryptionConfigurationInput `json:"DeliveryStreamEncryptionConfigurationInput,omitempty"`
  DeliveryStreamName string `json:"DeliveryStreamName,omitempty"`
  DeliveryStreamType string `json:"DeliveryStreamType,omitempty"`
  ElasticsearchDestinationConfiguration *ElasticsearchDestinationConfiguration `json:"ElasticsearchDestinationConfiguration,omitempty"`
  ExtendedS3DestinationConfiguration *ExtendedS3DestinationConfiguration `json:"ExtendedS3DestinationConfiguration,omitempty"`
  HttpEndpointDestinationConfiguration *HttpEndpointDestinationConfiguration `json:"HttpEndpointDestinationConfiguration,omitempty"`
  KinesisStreamSourceConfiguration *KinesisStreamSourceConfiguration `json:"KinesisStreamSourceConfiguration,omitempty"`
  RedshiftDestinationConfiguration *RedshiftDestinationConfiguration `json:"RedshiftDestinationConfiguration,omitempty"`
  S3DestinationConfiguration *S3DestinationConfiguration `json:"S3DestinationConfiguration,omitempty"`
  SplunkDestinationConfiguration *SplunkDestinationConfiguration `json:"SplunkDestinationConfiguration,omitempty"`
  Tags []*Tag `json:"Tags,omitempty"`
}

// RetryOptions 
type RetryOptions struct {
  DurationInSeconds int `json:"DurationInSeconds,omitempty"`
}

// S3DestinationConfiguration 
type S3DestinationConfiguration struct {
  BucketARN string `json:"BucketARN"`
  BufferingHints *BufferingHints `json:"BufferingHints,omitempty"`
  CloudWatchLoggingOptions *CloudWatchLoggingOptions `json:"CloudWatchLoggingOptions,omitempty"`
  CompressionFormat string `json:"CompressionFormat,omitempty"`
  EncryptionConfiguration *EncryptionConfiguration `json:"EncryptionConfiguration,omitempty"`
  ErrorOutputPrefix string `json:"ErrorOutputPrefix,omitempty"`
  Prefix string `json:"Prefix,omitempty"`
  RoleARN string `json:"RoleARN"`
}

// SchemaConfiguration 
type SchemaConfiguration struct {
  CatalogId string `json:"CatalogId,omitempty"`
  DatabaseName string `json:"DatabaseName,omitempty"`
  Region string `json:"Region,omitempty"`
  RoleARN string `json:"RoleARN,omitempty"`
  TableName string `json:"TableName,omitempty"`
  VersionId string `json:"VersionId,omitempty"`
}

// Serializer 
type Serializer struct {
  OrcSerDe *OrcSerDe `json:"OrcSerDe,omitempty"`
  ParquetSerDe *ParquetSerDe `json:"ParquetSerDe,omitempty"`
}

// SplunkDestinationConfiguration 
type SplunkDestinationConfiguration struct {
  CloudWatchLoggingOptions *CloudWatchLoggingOptions `json:"CloudWatchLoggingOptions,omitempty"`
  HECAcknowledgmentTimeoutInSeconds int `json:"HECAcknowledgmentTimeoutInSeconds,omitempty"`
  HECEndpoint string `json:"HECEndpoint"`
  HECEndpointType string `json:"HECEndpointType"`
  HECToken string `json:"HECToken"`
  ProcessingConfiguration *ProcessingConfiguration `json:"ProcessingConfiguration,omitempty"`
  RetryOptions *SplunkRetryOptions `json:"RetryOptions,omitempty"`
  S3BackupMode string `json:"S3BackupMode,omitempty"`
  S3Configuration *S3DestinationConfiguration `json:"S3Configuration"`
}

// SplunkRetryOptions 
type SplunkRetryOptions struct {
  DurationInSeconds int `json:"DurationInSeconds,omitempty"`
}

// Tag 
type Tag struct {
  Key string `json:"Key"`
  Value string `json:"Value,omitempty"`
}

// VpcConfiguration 
type VpcConfiguration struct {
  RoleARN string `json:"RoleARN"`
  SecurityGroupIds []string `json:"SecurityGroupIds"`
  SubnetIds []string `json:"SubnetIds"`
}

func (strct *AmazonOpenSearchServerlessBufferingHints) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "IntervalInSeconds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IntervalInSeconds\": ")
	if tmp, err := json.Marshal(strct.IntervalInSeconds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SizeInMBs" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SizeInMBs\": ")
	if tmp, err := json.Marshal(strct.SizeInMBs); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AmazonOpenSearchServerlessBufferingHints) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "IntervalInSeconds":
            if err := json.Unmarshal([]byte(v), &strct.IntervalInSeconds); err != nil {
                return err
             }
        case "SizeInMBs":
            if err := json.Unmarshal([]byte(v), &strct.SizeInMBs); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *AmazonOpenSearchServerlessDestinationConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "BufferingHints" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BufferingHints\": ")
	if tmp, err := json.Marshal(strct.BufferingHints); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CloudWatchLoggingOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CloudWatchLoggingOptions\": ")
	if tmp, err := json.Marshal(strct.CloudWatchLoggingOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CollectionEndpoint" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CollectionEndpoint\": ")
	if tmp, err := json.Marshal(strct.CollectionEndpoint); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "IndexName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "IndexName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IndexName\": ")
	if tmp, err := json.Marshal(strct.IndexName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ProcessingConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ProcessingConfiguration\": ")
	if tmp, err := json.Marshal(strct.ProcessingConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RetryOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RetryOptions\": ")
	if tmp, err := json.Marshal(strct.RetryOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RoleARN" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RoleARN" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoleARN\": ")
	if tmp, err := json.Marshal(strct.RoleARN); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "S3BackupMode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3BackupMode\": ")
	if tmp, err := json.Marshal(strct.S3BackupMode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "S3Configuration" field is required
    if strct.S3Configuration == nil {
        return nil, errors.New("S3Configuration is a required field")
    }
    // Marshal the "S3Configuration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3Configuration\": ")
	if tmp, err := json.Marshal(strct.S3Configuration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VpcConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VpcConfiguration\": ")
	if tmp, err := json.Marshal(strct.VpcConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AmazonOpenSearchServerlessDestinationConfiguration) UnmarshalJSON(b []byte) error {
    IndexNameReceived := false
    RoleARNReceived := false
    S3ConfigurationReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BufferingHints":
            if err := json.Unmarshal([]byte(v), &strct.BufferingHints); err != nil {
                return err
             }
        case "CloudWatchLoggingOptions":
            if err := json.Unmarshal([]byte(v), &strct.CloudWatchLoggingOptions); err != nil {
                return err
             }
        case "CollectionEndpoint":
            if err := json.Unmarshal([]byte(v), &strct.CollectionEndpoint); err != nil {
                return err
             }
        case "IndexName":
            if err := json.Unmarshal([]byte(v), &strct.IndexName); err != nil {
                return err
             }
            IndexNameReceived = true
        case "ProcessingConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.ProcessingConfiguration); err != nil {
                return err
             }
        case "RetryOptions":
            if err := json.Unmarshal([]byte(v), &strct.RetryOptions); err != nil {
                return err
             }
        case "RoleARN":
            if err := json.Unmarshal([]byte(v), &strct.RoleARN); err != nil {
                return err
             }
            RoleARNReceived = true
        case "S3BackupMode":
            if err := json.Unmarshal([]byte(v), &strct.S3BackupMode); err != nil {
                return err
             }
        case "S3Configuration":
            if err := json.Unmarshal([]byte(v), &strct.S3Configuration); err != nil {
                return err
             }
            S3ConfigurationReceived = true
        case "VpcConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.VpcConfiguration); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if IndexName (a required property) was received
    if !IndexNameReceived {
        return errors.New("\"IndexName\" is required but was not present")
    }
    // check if RoleARN (a required property) was received
    if !RoleARNReceived {
        return errors.New("\"RoleARN\" is required but was not present")
    }
    // check if S3Configuration (a required property) was received
    if !S3ConfigurationReceived {
        return errors.New("\"S3Configuration\" is required but was not present")
    }
    return nil
}

func (strct *AmazonOpenSearchServerlessRetryOptions) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DurationInSeconds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DurationInSeconds\": ")
	if tmp, err := json.Marshal(strct.DurationInSeconds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AmazonOpenSearchServerlessRetryOptions) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DurationInSeconds":
            if err := json.Unmarshal([]byte(v), &strct.DurationInSeconds); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *AmazonopensearchserviceBufferingHints) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "IntervalInSeconds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IntervalInSeconds\": ")
	if tmp, err := json.Marshal(strct.IntervalInSeconds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SizeInMBs" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SizeInMBs\": ")
	if tmp, err := json.Marshal(strct.SizeInMBs); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AmazonopensearchserviceBufferingHints) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "IntervalInSeconds":
            if err := json.Unmarshal([]byte(v), &strct.IntervalInSeconds); err != nil {
                return err
             }
        case "SizeInMBs":
            if err := json.Unmarshal([]byte(v), &strct.SizeInMBs); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *AmazonopensearchserviceDestinationConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "BufferingHints" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BufferingHints\": ")
	if tmp, err := json.Marshal(strct.BufferingHints); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CloudWatchLoggingOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CloudWatchLoggingOptions\": ")
	if tmp, err := json.Marshal(strct.CloudWatchLoggingOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ClusterEndpoint" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ClusterEndpoint\": ")
	if tmp, err := json.Marshal(strct.ClusterEndpoint); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DomainARN" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DomainARN\": ")
	if tmp, err := json.Marshal(strct.DomainARN); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "IndexName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "IndexName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IndexName\": ")
	if tmp, err := json.Marshal(strct.IndexName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IndexRotationPeriod" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IndexRotationPeriod\": ")
	if tmp, err := json.Marshal(strct.IndexRotationPeriod); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ProcessingConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ProcessingConfiguration\": ")
	if tmp, err := json.Marshal(strct.ProcessingConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RetryOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RetryOptions\": ")
	if tmp, err := json.Marshal(strct.RetryOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RoleARN" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RoleARN" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoleARN\": ")
	if tmp, err := json.Marshal(strct.RoleARN); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "S3BackupMode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3BackupMode\": ")
	if tmp, err := json.Marshal(strct.S3BackupMode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "S3Configuration" field is required
    if strct.S3Configuration == nil {
        return nil, errors.New("S3Configuration is a required field")
    }
    // Marshal the "S3Configuration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3Configuration\": ")
	if tmp, err := json.Marshal(strct.S3Configuration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TypeName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TypeName\": ")
	if tmp, err := json.Marshal(strct.TypeName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VpcConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VpcConfiguration\": ")
	if tmp, err := json.Marshal(strct.VpcConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AmazonopensearchserviceDestinationConfiguration) UnmarshalJSON(b []byte) error {
    IndexNameReceived := false
    RoleARNReceived := false
    S3ConfigurationReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BufferingHints":
            if err := json.Unmarshal([]byte(v), &strct.BufferingHints); err != nil {
                return err
             }
        case "CloudWatchLoggingOptions":
            if err := json.Unmarshal([]byte(v), &strct.CloudWatchLoggingOptions); err != nil {
                return err
             }
        case "ClusterEndpoint":
            if err := json.Unmarshal([]byte(v), &strct.ClusterEndpoint); err != nil {
                return err
             }
        case "DomainARN":
            if err := json.Unmarshal([]byte(v), &strct.DomainARN); err != nil {
                return err
             }
        case "IndexName":
            if err := json.Unmarshal([]byte(v), &strct.IndexName); err != nil {
                return err
             }
            IndexNameReceived = true
        case "IndexRotationPeriod":
            if err := json.Unmarshal([]byte(v), &strct.IndexRotationPeriod); err != nil {
                return err
             }
        case "ProcessingConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.ProcessingConfiguration); err != nil {
                return err
             }
        case "RetryOptions":
            if err := json.Unmarshal([]byte(v), &strct.RetryOptions); err != nil {
                return err
             }
        case "RoleARN":
            if err := json.Unmarshal([]byte(v), &strct.RoleARN); err != nil {
                return err
             }
            RoleARNReceived = true
        case "S3BackupMode":
            if err := json.Unmarshal([]byte(v), &strct.S3BackupMode); err != nil {
                return err
             }
        case "S3Configuration":
            if err := json.Unmarshal([]byte(v), &strct.S3Configuration); err != nil {
                return err
             }
            S3ConfigurationReceived = true
        case "TypeName":
            if err := json.Unmarshal([]byte(v), &strct.TypeName); err != nil {
                return err
             }
        case "VpcConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.VpcConfiguration); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if IndexName (a required property) was received
    if !IndexNameReceived {
        return errors.New("\"IndexName\" is required but was not present")
    }
    // check if RoleARN (a required property) was received
    if !RoleARNReceived {
        return errors.New("\"RoleARN\" is required but was not present")
    }
    // check if S3Configuration (a required property) was received
    if !S3ConfigurationReceived {
        return errors.New("\"S3Configuration\" is required but was not present")
    }
    return nil
}

func (strct *AmazonopensearchserviceRetryOptions) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DurationInSeconds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DurationInSeconds\": ")
	if tmp, err := json.Marshal(strct.DurationInSeconds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AmazonopensearchserviceRetryOptions) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DurationInSeconds":
            if err := json.Unmarshal([]byte(v), &strct.DurationInSeconds); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *BufferingHints) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "IntervalInSeconds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IntervalInSeconds\": ")
	if tmp, err := json.Marshal(strct.IntervalInSeconds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SizeInMBs" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SizeInMBs\": ")
	if tmp, err := json.Marshal(strct.SizeInMBs); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BufferingHints) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "IntervalInSeconds":
            if err := json.Unmarshal([]byte(v), &strct.IntervalInSeconds); err != nil {
                return err
             }
        case "SizeInMBs":
            if err := json.Unmarshal([]byte(v), &strct.SizeInMBs); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *CloudWatchLoggingOptions) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Enabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LogGroupName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LogGroupName\": ")
	if tmp, err := json.Marshal(strct.LogGroupName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LogStreamName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LogStreamName\": ")
	if tmp, err := json.Marshal(strct.LogStreamName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CloudWatchLoggingOptions) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Enabled":
            if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
                return err
             }
        case "LogGroupName":
            if err := json.Unmarshal([]byte(v), &strct.LogGroupName); err != nil {
                return err
             }
        case "LogStreamName":
            if err := json.Unmarshal([]byte(v), &strct.LogStreamName); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *CopyCommand) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CopyOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CopyOptions\": ")
	if tmp, err := json.Marshal(strct.CopyOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DataTableColumns" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DataTableColumns\": ")
	if tmp, err := json.Marshal(strct.DataTableColumns); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "DataTableName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "DataTableName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DataTableName\": ")
	if tmp, err := json.Marshal(strct.DataTableName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CopyCommand) UnmarshalJSON(b []byte) error {
    DataTableNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CopyOptions":
            if err := json.Unmarshal([]byte(v), &strct.CopyOptions); err != nil {
                return err
             }
        case "DataTableColumns":
            if err := json.Unmarshal([]byte(v), &strct.DataTableColumns); err != nil {
                return err
             }
        case "DataTableName":
            if err := json.Unmarshal([]byte(v), &strct.DataTableName); err != nil {
                return err
             }
            DataTableNameReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if DataTableName (a required property) was received
    if !DataTableNameReceived {
        return errors.New("\"DataTableName\" is required but was not present")
    }
    return nil
}

func (strct *DataFormatConversionConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Enabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "InputFormatConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InputFormatConfiguration\": ")
	if tmp, err := json.Marshal(strct.InputFormatConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OutputFormatConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OutputFormatConfiguration\": ")
	if tmp, err := json.Marshal(strct.OutputFormatConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SchemaConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SchemaConfiguration\": ")
	if tmp, err := json.Marshal(strct.SchemaConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DataFormatConversionConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Enabled":
            if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
                return err
             }
        case "InputFormatConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.InputFormatConfiguration); err != nil {
                return err
             }
        case "OutputFormatConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.OutputFormatConfiguration); err != nil {
                return err
             }
        case "SchemaConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.SchemaConfiguration); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *DeliveryStreamEncryptionConfigurationInput) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "KeyARN" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KeyARN\": ")
	if tmp, err := json.Marshal(strct.KeyARN); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "KeyType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "KeyType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KeyType\": ")
	if tmp, err := json.Marshal(strct.KeyType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DeliveryStreamEncryptionConfigurationInput) UnmarshalJSON(b []byte) error {
    KeyTypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "KeyARN":
            if err := json.Unmarshal([]byte(v), &strct.KeyARN); err != nil {
                return err
             }
        case "KeyType":
            if err := json.Unmarshal([]byte(v), &strct.KeyType); err != nil {
                return err
             }
            KeyTypeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if KeyType (a required property) was received
    if !KeyTypeReceived {
        return errors.New("\"KeyType\" is required but was not present")
    }
    return nil
}

func (strct *Deserializer) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "HiveJsonSerDe" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HiveJsonSerDe\": ")
	if tmp, err := json.Marshal(strct.HiveJsonSerDe); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OpenXJsonSerDe" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OpenXJsonSerDe\": ")
	if tmp, err := json.Marshal(strct.OpenXJsonSerDe); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Deserializer) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "HiveJsonSerDe":
            if err := json.Unmarshal([]byte(v), &strct.HiveJsonSerDe); err != nil {
                return err
             }
        case "OpenXJsonSerDe":
            if err := json.Unmarshal([]byte(v), &strct.OpenXJsonSerDe); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *DynamicPartitioningConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Enabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RetryOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RetryOptions\": ")
	if tmp, err := json.Marshal(strct.RetryOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DynamicPartitioningConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Enabled":
            if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
                return err
             }
        case "RetryOptions":
            if err := json.Unmarshal([]byte(v), &strct.RetryOptions); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ElasticsearchBufferingHints) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "IntervalInSeconds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IntervalInSeconds\": ")
	if tmp, err := json.Marshal(strct.IntervalInSeconds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SizeInMBs" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SizeInMBs\": ")
	if tmp, err := json.Marshal(strct.SizeInMBs); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ElasticsearchBufferingHints) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "IntervalInSeconds":
            if err := json.Unmarshal([]byte(v), &strct.IntervalInSeconds); err != nil {
                return err
             }
        case "SizeInMBs":
            if err := json.Unmarshal([]byte(v), &strct.SizeInMBs); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ElasticsearchDestinationConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "BufferingHints" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BufferingHints\": ")
	if tmp, err := json.Marshal(strct.BufferingHints); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CloudWatchLoggingOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CloudWatchLoggingOptions\": ")
	if tmp, err := json.Marshal(strct.CloudWatchLoggingOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ClusterEndpoint" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ClusterEndpoint\": ")
	if tmp, err := json.Marshal(strct.ClusterEndpoint); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DomainARN" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DomainARN\": ")
	if tmp, err := json.Marshal(strct.DomainARN); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "IndexName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "IndexName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IndexName\": ")
	if tmp, err := json.Marshal(strct.IndexName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IndexRotationPeriod" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IndexRotationPeriod\": ")
	if tmp, err := json.Marshal(strct.IndexRotationPeriod); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ProcessingConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ProcessingConfiguration\": ")
	if tmp, err := json.Marshal(strct.ProcessingConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RetryOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RetryOptions\": ")
	if tmp, err := json.Marshal(strct.RetryOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RoleARN" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RoleARN" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoleARN\": ")
	if tmp, err := json.Marshal(strct.RoleARN); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "S3BackupMode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3BackupMode\": ")
	if tmp, err := json.Marshal(strct.S3BackupMode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "S3Configuration" field is required
    if strct.S3Configuration == nil {
        return nil, errors.New("S3Configuration is a required field")
    }
    // Marshal the "S3Configuration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3Configuration\": ")
	if tmp, err := json.Marshal(strct.S3Configuration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TypeName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TypeName\": ")
	if tmp, err := json.Marshal(strct.TypeName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VpcConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VpcConfiguration\": ")
	if tmp, err := json.Marshal(strct.VpcConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ElasticsearchDestinationConfiguration) UnmarshalJSON(b []byte) error {
    IndexNameReceived := false
    RoleARNReceived := false
    S3ConfigurationReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BufferingHints":
            if err := json.Unmarshal([]byte(v), &strct.BufferingHints); err != nil {
                return err
             }
        case "CloudWatchLoggingOptions":
            if err := json.Unmarshal([]byte(v), &strct.CloudWatchLoggingOptions); err != nil {
                return err
             }
        case "ClusterEndpoint":
            if err := json.Unmarshal([]byte(v), &strct.ClusterEndpoint); err != nil {
                return err
             }
        case "DomainARN":
            if err := json.Unmarshal([]byte(v), &strct.DomainARN); err != nil {
                return err
             }
        case "IndexName":
            if err := json.Unmarshal([]byte(v), &strct.IndexName); err != nil {
                return err
             }
            IndexNameReceived = true
        case "IndexRotationPeriod":
            if err := json.Unmarshal([]byte(v), &strct.IndexRotationPeriod); err != nil {
                return err
             }
        case "ProcessingConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.ProcessingConfiguration); err != nil {
                return err
             }
        case "RetryOptions":
            if err := json.Unmarshal([]byte(v), &strct.RetryOptions); err != nil {
                return err
             }
        case "RoleARN":
            if err := json.Unmarshal([]byte(v), &strct.RoleARN); err != nil {
                return err
             }
            RoleARNReceived = true
        case "S3BackupMode":
            if err := json.Unmarshal([]byte(v), &strct.S3BackupMode); err != nil {
                return err
             }
        case "S3Configuration":
            if err := json.Unmarshal([]byte(v), &strct.S3Configuration); err != nil {
                return err
             }
            S3ConfigurationReceived = true
        case "TypeName":
            if err := json.Unmarshal([]byte(v), &strct.TypeName); err != nil {
                return err
             }
        case "VpcConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.VpcConfiguration); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if IndexName (a required property) was received
    if !IndexNameReceived {
        return errors.New("\"IndexName\" is required but was not present")
    }
    // check if RoleARN (a required property) was received
    if !RoleARNReceived {
        return errors.New("\"RoleARN\" is required but was not present")
    }
    // check if S3Configuration (a required property) was received
    if !S3ConfigurationReceived {
        return errors.New("\"S3Configuration\" is required but was not present")
    }
    return nil
}

func (strct *ElasticsearchRetryOptions) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DurationInSeconds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DurationInSeconds\": ")
	if tmp, err := json.Marshal(strct.DurationInSeconds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ElasticsearchRetryOptions) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DurationInSeconds":
            if err := json.Unmarshal([]byte(v), &strct.DurationInSeconds); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *EncryptionConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "KMSEncryptionConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KMSEncryptionConfig\": ")
	if tmp, err := json.Marshal(strct.KMSEncryptionConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "NoEncryptionConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NoEncryptionConfig\": ")
	if tmp, err := json.Marshal(strct.NoEncryptionConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *EncryptionConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "KMSEncryptionConfig":
            if err := json.Unmarshal([]byte(v), &strct.KMSEncryptionConfig); err != nil {
                return err
             }
        case "NoEncryptionConfig":
            if err := json.Unmarshal([]byte(v), &strct.NoEncryptionConfig); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ExtendedS3DestinationConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "BucketARN" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "BucketARN" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BucketARN\": ")
	if tmp, err := json.Marshal(strct.BucketARN); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BufferingHints" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BufferingHints\": ")
	if tmp, err := json.Marshal(strct.BufferingHints); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CloudWatchLoggingOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CloudWatchLoggingOptions\": ")
	if tmp, err := json.Marshal(strct.CloudWatchLoggingOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CompressionFormat" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CompressionFormat\": ")
	if tmp, err := json.Marshal(strct.CompressionFormat); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DataFormatConversionConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DataFormatConversionConfiguration\": ")
	if tmp, err := json.Marshal(strct.DataFormatConversionConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DynamicPartitioningConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DynamicPartitioningConfiguration\": ")
	if tmp, err := json.Marshal(strct.DynamicPartitioningConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EncryptionConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EncryptionConfiguration\": ")
	if tmp, err := json.Marshal(strct.EncryptionConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ErrorOutputPrefix" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ErrorOutputPrefix\": ")
	if tmp, err := json.Marshal(strct.ErrorOutputPrefix); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Prefix" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Prefix\": ")
	if tmp, err := json.Marshal(strct.Prefix); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ProcessingConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ProcessingConfiguration\": ")
	if tmp, err := json.Marshal(strct.ProcessingConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RoleARN" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RoleARN" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoleARN\": ")
	if tmp, err := json.Marshal(strct.RoleARN); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "S3BackupConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3BackupConfiguration\": ")
	if tmp, err := json.Marshal(strct.S3BackupConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "S3BackupMode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3BackupMode\": ")
	if tmp, err := json.Marshal(strct.S3BackupMode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ExtendedS3DestinationConfiguration) UnmarshalJSON(b []byte) error {
    BucketARNReceived := false
    RoleARNReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BucketARN":
            if err := json.Unmarshal([]byte(v), &strct.BucketARN); err != nil {
                return err
             }
            BucketARNReceived = true
        case "BufferingHints":
            if err := json.Unmarshal([]byte(v), &strct.BufferingHints); err != nil {
                return err
             }
        case "CloudWatchLoggingOptions":
            if err := json.Unmarshal([]byte(v), &strct.CloudWatchLoggingOptions); err != nil {
                return err
             }
        case "CompressionFormat":
            if err := json.Unmarshal([]byte(v), &strct.CompressionFormat); err != nil {
                return err
             }
        case "DataFormatConversionConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.DataFormatConversionConfiguration); err != nil {
                return err
             }
        case "DynamicPartitioningConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.DynamicPartitioningConfiguration); err != nil {
                return err
             }
        case "EncryptionConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.EncryptionConfiguration); err != nil {
                return err
             }
        case "ErrorOutputPrefix":
            if err := json.Unmarshal([]byte(v), &strct.ErrorOutputPrefix); err != nil {
                return err
             }
        case "Prefix":
            if err := json.Unmarshal([]byte(v), &strct.Prefix); err != nil {
                return err
             }
        case "ProcessingConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.ProcessingConfiguration); err != nil {
                return err
             }
        case "RoleARN":
            if err := json.Unmarshal([]byte(v), &strct.RoleARN); err != nil {
                return err
             }
            RoleARNReceived = true
        case "S3BackupConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.S3BackupConfiguration); err != nil {
                return err
             }
        case "S3BackupMode":
            if err := json.Unmarshal([]byte(v), &strct.S3BackupMode); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if BucketARN (a required property) was received
    if !BucketARNReceived {
        return errors.New("\"BucketARN\" is required but was not present")
    }
    // check if RoleARN (a required property) was received
    if !RoleARNReceived {
        return errors.New("\"RoleARN\" is required but was not present")
    }
    return nil
}

func (strct *HiveJsonSerDe) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "TimestampFormats" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TimestampFormats\": ")
	if tmp, err := json.Marshal(strct.TimestampFormats); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *HiveJsonSerDe) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "TimestampFormats":
            if err := json.Unmarshal([]byte(v), &strct.TimestampFormats); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *HttpEndpointCommonAttribute) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AttributeName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AttributeName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AttributeName\": ")
	if tmp, err := json.Marshal(strct.AttributeName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "AttributeValue" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AttributeValue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AttributeValue\": ")
	if tmp, err := json.Marshal(strct.AttributeValue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *HttpEndpointCommonAttribute) UnmarshalJSON(b []byte) error {
    AttributeNameReceived := false
    AttributeValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AttributeName":
            if err := json.Unmarshal([]byte(v), &strct.AttributeName); err != nil {
                return err
             }
            AttributeNameReceived = true
        case "AttributeValue":
            if err := json.Unmarshal([]byte(v), &strct.AttributeValue); err != nil {
                return err
             }
            AttributeValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if AttributeName (a required property) was received
    if !AttributeNameReceived {
        return errors.New("\"AttributeName\" is required but was not present")
    }
    // check if AttributeValue (a required property) was received
    if !AttributeValueReceived {
        return errors.New("\"AttributeValue\" is required but was not present")
    }
    return nil
}

func (strct *HttpEndpointConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AccessKey" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AccessKey\": ")
	if tmp, err := json.Marshal(strct.AccessKey); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Url" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Url" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Url\": ")
	if tmp, err := json.Marshal(strct.Url); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *HttpEndpointConfiguration) UnmarshalJSON(b []byte) error {
    UrlReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AccessKey":
            if err := json.Unmarshal([]byte(v), &strct.AccessKey); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "Url":
            if err := json.Unmarshal([]byte(v), &strct.Url); err != nil {
                return err
             }
            UrlReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Url (a required property) was received
    if !UrlReceived {
        return errors.New("\"Url\" is required but was not present")
    }
    return nil
}

func (strct *HttpEndpointDestinationConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "BufferingHints" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BufferingHints\": ")
	if tmp, err := json.Marshal(strct.BufferingHints); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CloudWatchLoggingOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CloudWatchLoggingOptions\": ")
	if tmp, err := json.Marshal(strct.CloudWatchLoggingOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "EndpointConfiguration" field is required
    if strct.EndpointConfiguration == nil {
        return nil, errors.New("EndpointConfiguration is a required field")
    }
    // Marshal the "EndpointConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EndpointConfiguration\": ")
	if tmp, err := json.Marshal(strct.EndpointConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ProcessingConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ProcessingConfiguration\": ")
	if tmp, err := json.Marshal(strct.ProcessingConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RequestConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RequestConfiguration\": ")
	if tmp, err := json.Marshal(strct.RequestConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RetryOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RetryOptions\": ")
	if tmp, err := json.Marshal(strct.RetryOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RoleARN" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoleARN\": ")
	if tmp, err := json.Marshal(strct.RoleARN); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "S3BackupMode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3BackupMode\": ")
	if tmp, err := json.Marshal(strct.S3BackupMode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "S3Configuration" field is required
    if strct.S3Configuration == nil {
        return nil, errors.New("S3Configuration is a required field")
    }
    // Marshal the "S3Configuration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3Configuration\": ")
	if tmp, err := json.Marshal(strct.S3Configuration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *HttpEndpointDestinationConfiguration) UnmarshalJSON(b []byte) error {
    EndpointConfigurationReceived := false
    S3ConfigurationReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BufferingHints":
            if err := json.Unmarshal([]byte(v), &strct.BufferingHints); err != nil {
                return err
             }
        case "CloudWatchLoggingOptions":
            if err := json.Unmarshal([]byte(v), &strct.CloudWatchLoggingOptions); err != nil {
                return err
             }
        case "EndpointConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.EndpointConfiguration); err != nil {
                return err
             }
            EndpointConfigurationReceived = true
        case "ProcessingConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.ProcessingConfiguration); err != nil {
                return err
             }
        case "RequestConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.RequestConfiguration); err != nil {
                return err
             }
        case "RetryOptions":
            if err := json.Unmarshal([]byte(v), &strct.RetryOptions); err != nil {
                return err
             }
        case "RoleARN":
            if err := json.Unmarshal([]byte(v), &strct.RoleARN); err != nil {
                return err
             }
        case "S3BackupMode":
            if err := json.Unmarshal([]byte(v), &strct.S3BackupMode); err != nil {
                return err
             }
        case "S3Configuration":
            if err := json.Unmarshal([]byte(v), &strct.S3Configuration); err != nil {
                return err
             }
            S3ConfigurationReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if EndpointConfiguration (a required property) was received
    if !EndpointConfigurationReceived {
        return errors.New("\"EndpointConfiguration\" is required but was not present")
    }
    // check if S3Configuration (a required property) was received
    if !S3ConfigurationReceived {
        return errors.New("\"S3Configuration\" is required but was not present")
    }
    return nil
}

func (strct *HttpEndpointRequestConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CommonAttributes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CommonAttributes\": ")
	if tmp, err := json.Marshal(strct.CommonAttributes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ContentEncoding" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ContentEncoding\": ")
	if tmp, err := json.Marshal(strct.ContentEncoding); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *HttpEndpointRequestConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CommonAttributes":
            if err := json.Unmarshal([]byte(v), &strct.CommonAttributes); err != nil {
                return err
             }
        case "ContentEncoding":
            if err := json.Unmarshal([]byte(v), &strct.ContentEncoding); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *InputFormatConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Deserializer" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Deserializer\": ")
	if tmp, err := json.Marshal(strct.Deserializer); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *InputFormatConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Deserializer":
            if err := json.Unmarshal([]byte(v), &strct.Deserializer); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *KMSEncryptionConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AWSKMSKeyARN" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AWSKMSKeyARN" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AWSKMSKeyARN\": ")
	if tmp, err := json.Marshal(strct.AWSKMSKeyARN); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *KMSEncryptionConfig) UnmarshalJSON(b []byte) error {
    AWSKMSKeyARNReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AWSKMSKeyARN":
            if err := json.Unmarshal([]byte(v), &strct.AWSKMSKeyARN); err != nil {
                return err
             }
            AWSKMSKeyARNReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if AWSKMSKeyARN (a required property) was received
    if !AWSKMSKeyARNReceived {
        return errors.New("\"AWSKMSKeyARN\" is required but was not present")
    }
    return nil
}

func (strct *KinesisStreamSourceConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "KinesisStreamARN" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "KinesisStreamARN" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KinesisStreamARN\": ")
	if tmp, err := json.Marshal(strct.KinesisStreamARN); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RoleARN" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RoleARN" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoleARN\": ")
	if tmp, err := json.Marshal(strct.RoleARN); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *KinesisStreamSourceConfiguration) UnmarshalJSON(b []byte) error {
    KinesisStreamARNReceived := false
    RoleARNReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "KinesisStreamARN":
            if err := json.Unmarshal([]byte(v), &strct.KinesisStreamARN); err != nil {
                return err
             }
            KinesisStreamARNReceived = true
        case "RoleARN":
            if err := json.Unmarshal([]byte(v), &strct.RoleARN); err != nil {
                return err
             }
            RoleARNReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if KinesisStreamARN (a required property) was received
    if !KinesisStreamARNReceived {
        return errors.New("\"KinesisStreamARN\" is required but was not present")
    }
    // check if RoleARN (a required property) was received
    if !RoleARNReceived {
        return errors.New("\"RoleARN\" is required but was not present")
    }
    return nil
}

func (strct *OpenXJsonSerDe) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CaseInsensitive" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CaseInsensitive\": ")
	if tmp, err := json.Marshal(strct.CaseInsensitive); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ColumnToJsonKeyMappings" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ColumnToJsonKeyMappings\": ")
	if tmp, err := json.Marshal(strct.ColumnToJsonKeyMappings); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ConvertDotsInJsonKeysToUnderscores" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConvertDotsInJsonKeysToUnderscores\": ")
	if tmp, err := json.Marshal(strct.ConvertDotsInJsonKeysToUnderscores); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *OpenXJsonSerDe) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CaseInsensitive":
            if err := json.Unmarshal([]byte(v), &strct.CaseInsensitive); err != nil {
                return err
             }
        case "ColumnToJsonKeyMappings":
            if err := json.Unmarshal([]byte(v), &strct.ColumnToJsonKeyMappings); err != nil {
                return err
             }
        case "ConvertDotsInJsonKeysToUnderscores":
            if err := json.Unmarshal([]byte(v), &strct.ConvertDotsInJsonKeysToUnderscores); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *OrcSerDe) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "BlockSizeBytes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BlockSizeBytes\": ")
	if tmp, err := json.Marshal(strct.BlockSizeBytes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BloomFilterColumns" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BloomFilterColumns\": ")
	if tmp, err := json.Marshal(strct.BloomFilterColumns); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BloomFilterFalsePositiveProbability" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BloomFilterFalsePositiveProbability\": ")
	if tmp, err := json.Marshal(strct.BloomFilterFalsePositiveProbability); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Compression" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Compression\": ")
	if tmp, err := json.Marshal(strct.Compression); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DictionaryKeyThreshold" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DictionaryKeyThreshold\": ")
	if tmp, err := json.Marshal(strct.DictionaryKeyThreshold); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EnablePadding" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EnablePadding\": ")
	if tmp, err := json.Marshal(strct.EnablePadding); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FormatVersion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FormatVersion\": ")
	if tmp, err := json.Marshal(strct.FormatVersion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PaddingTolerance" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PaddingTolerance\": ")
	if tmp, err := json.Marshal(strct.PaddingTolerance); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RowIndexStride" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RowIndexStride\": ")
	if tmp, err := json.Marshal(strct.RowIndexStride); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StripeSizeBytes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StripeSizeBytes\": ")
	if tmp, err := json.Marshal(strct.StripeSizeBytes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *OrcSerDe) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BlockSizeBytes":
            if err := json.Unmarshal([]byte(v), &strct.BlockSizeBytes); err != nil {
                return err
             }
        case "BloomFilterColumns":
            if err := json.Unmarshal([]byte(v), &strct.BloomFilterColumns); err != nil {
                return err
             }
        case "BloomFilterFalsePositiveProbability":
            if err := json.Unmarshal([]byte(v), &strct.BloomFilterFalsePositiveProbability); err != nil {
                return err
             }
        case "Compression":
            if err := json.Unmarshal([]byte(v), &strct.Compression); err != nil {
                return err
             }
        case "DictionaryKeyThreshold":
            if err := json.Unmarshal([]byte(v), &strct.DictionaryKeyThreshold); err != nil {
                return err
             }
        case "EnablePadding":
            if err := json.Unmarshal([]byte(v), &strct.EnablePadding); err != nil {
                return err
             }
        case "FormatVersion":
            if err := json.Unmarshal([]byte(v), &strct.FormatVersion); err != nil {
                return err
             }
        case "PaddingTolerance":
            if err := json.Unmarshal([]byte(v), &strct.PaddingTolerance); err != nil {
                return err
             }
        case "RowIndexStride":
            if err := json.Unmarshal([]byte(v), &strct.RowIndexStride); err != nil {
                return err
             }
        case "StripeSizeBytes":
            if err := json.Unmarshal([]byte(v), &strct.StripeSizeBytes); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *OutputFormatConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Serializer" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Serializer\": ")
	if tmp, err := json.Marshal(strct.Serializer); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *OutputFormatConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Serializer":
            if err := json.Unmarshal([]byte(v), &strct.Serializer); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ParquetSerDe) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "BlockSizeBytes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BlockSizeBytes\": ")
	if tmp, err := json.Marshal(strct.BlockSizeBytes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Compression" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Compression\": ")
	if tmp, err := json.Marshal(strct.Compression); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EnableDictionaryCompression" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EnableDictionaryCompression\": ")
	if tmp, err := json.Marshal(strct.EnableDictionaryCompression); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MaxPaddingBytes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaxPaddingBytes\": ")
	if tmp, err := json.Marshal(strct.MaxPaddingBytes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PageSizeBytes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PageSizeBytes\": ")
	if tmp, err := json.Marshal(strct.PageSizeBytes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "WriterVersion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"WriterVersion\": ")
	if tmp, err := json.Marshal(strct.WriterVersion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ParquetSerDe) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BlockSizeBytes":
            if err := json.Unmarshal([]byte(v), &strct.BlockSizeBytes); err != nil {
                return err
             }
        case "Compression":
            if err := json.Unmarshal([]byte(v), &strct.Compression); err != nil {
                return err
             }
        case "EnableDictionaryCompression":
            if err := json.Unmarshal([]byte(v), &strct.EnableDictionaryCompression); err != nil {
                return err
             }
        case "MaxPaddingBytes":
            if err := json.Unmarshal([]byte(v), &strct.MaxPaddingBytes); err != nil {
                return err
             }
        case "PageSizeBytes":
            if err := json.Unmarshal([]byte(v), &strct.PageSizeBytes); err != nil {
                return err
             }
        case "WriterVersion":
            if err := json.Unmarshal([]byte(v), &strct.WriterVersion); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ProcessingConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Enabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Processors" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Processors\": ")
	if tmp, err := json.Marshal(strct.Processors); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ProcessingConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Enabled":
            if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
                return err
             }
        case "Processors":
            if err := json.Unmarshal([]byte(v), &strct.Processors); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Processor) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Parameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Parameters\": ")
	if tmp, err := json.Marshal(strct.Parameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Processor) UnmarshalJSON(b []byte) error {
    TypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Parameters":
            if err := json.Unmarshal([]byte(v), &strct.Parameters); err != nil {
                return err
             }
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            TypeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Type (a required property) was received
    if !TypeReceived {
        return errors.New("\"Type\" is required but was not present")
    }
    return nil
}

func (strct *ProcessorParameter) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ParameterName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ParameterName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ParameterName\": ")
	if tmp, err := json.Marshal(strct.ParameterName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ParameterValue" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ParameterValue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ParameterValue\": ")
	if tmp, err := json.Marshal(strct.ParameterValue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ProcessorParameter) UnmarshalJSON(b []byte) error {
    ParameterNameReceived := false
    ParameterValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ParameterName":
            if err := json.Unmarshal([]byte(v), &strct.ParameterName); err != nil {
                return err
             }
            ParameterNameReceived = true
        case "ParameterValue":
            if err := json.Unmarshal([]byte(v), &strct.ParameterValue); err != nil {
                return err
             }
            ParameterValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ParameterName (a required property) was received
    if !ParameterNameReceived {
        return errors.New("\"ParameterName\" is required but was not present")
    }
    // check if ParameterValue (a required property) was received
    if !ParameterValueReceived {
        return errors.New("\"ParameterValue\" is required but was not present")
    }
    return nil
}

func (strct *RedshiftDestinationConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CloudWatchLoggingOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CloudWatchLoggingOptions\": ")
	if tmp, err := json.Marshal(strct.CloudWatchLoggingOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ClusterJDBCURL" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ClusterJDBCURL" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ClusterJDBCURL\": ")
	if tmp, err := json.Marshal(strct.ClusterJDBCURL); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "CopyCommand" field is required
    if strct.CopyCommand == nil {
        return nil, errors.New("CopyCommand is a required field")
    }
    // Marshal the "CopyCommand" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CopyCommand\": ")
	if tmp, err := json.Marshal(strct.CopyCommand); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Password" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Password" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Password\": ")
	if tmp, err := json.Marshal(strct.Password); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ProcessingConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ProcessingConfiguration\": ")
	if tmp, err := json.Marshal(strct.ProcessingConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RetryOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RetryOptions\": ")
	if tmp, err := json.Marshal(strct.RetryOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RoleARN" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RoleARN" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoleARN\": ")
	if tmp, err := json.Marshal(strct.RoleARN); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "S3BackupConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3BackupConfiguration\": ")
	if tmp, err := json.Marshal(strct.S3BackupConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "S3BackupMode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3BackupMode\": ")
	if tmp, err := json.Marshal(strct.S3BackupMode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "S3Configuration" field is required
    if strct.S3Configuration == nil {
        return nil, errors.New("S3Configuration is a required field")
    }
    // Marshal the "S3Configuration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3Configuration\": ")
	if tmp, err := json.Marshal(strct.S3Configuration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Username" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Username" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Username\": ")
	if tmp, err := json.Marshal(strct.Username); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RedshiftDestinationConfiguration) UnmarshalJSON(b []byte) error {
    ClusterJDBCURLReceived := false
    CopyCommandReceived := false
    PasswordReceived := false
    RoleARNReceived := false
    S3ConfigurationReceived := false
    UsernameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CloudWatchLoggingOptions":
            if err := json.Unmarshal([]byte(v), &strct.CloudWatchLoggingOptions); err != nil {
                return err
             }
        case "ClusterJDBCURL":
            if err := json.Unmarshal([]byte(v), &strct.ClusterJDBCURL); err != nil {
                return err
             }
            ClusterJDBCURLReceived = true
        case "CopyCommand":
            if err := json.Unmarshal([]byte(v), &strct.CopyCommand); err != nil {
                return err
             }
            CopyCommandReceived = true
        case "Password":
            if err := json.Unmarshal([]byte(v), &strct.Password); err != nil {
                return err
             }
            PasswordReceived = true
        case "ProcessingConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.ProcessingConfiguration); err != nil {
                return err
             }
        case "RetryOptions":
            if err := json.Unmarshal([]byte(v), &strct.RetryOptions); err != nil {
                return err
             }
        case "RoleARN":
            if err := json.Unmarshal([]byte(v), &strct.RoleARN); err != nil {
                return err
             }
            RoleARNReceived = true
        case "S3BackupConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.S3BackupConfiguration); err != nil {
                return err
             }
        case "S3BackupMode":
            if err := json.Unmarshal([]byte(v), &strct.S3BackupMode); err != nil {
                return err
             }
        case "S3Configuration":
            if err := json.Unmarshal([]byte(v), &strct.S3Configuration); err != nil {
                return err
             }
            S3ConfigurationReceived = true
        case "Username":
            if err := json.Unmarshal([]byte(v), &strct.Username); err != nil {
                return err
             }
            UsernameReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ClusterJDBCURL (a required property) was received
    if !ClusterJDBCURLReceived {
        return errors.New("\"ClusterJDBCURL\" is required but was not present")
    }
    // check if CopyCommand (a required property) was received
    if !CopyCommandReceived {
        return errors.New("\"CopyCommand\" is required but was not present")
    }
    // check if Password (a required property) was received
    if !PasswordReceived {
        return errors.New("\"Password\" is required but was not present")
    }
    // check if RoleARN (a required property) was received
    if !RoleARNReceived {
        return errors.New("\"RoleARN\" is required but was not present")
    }
    // check if S3Configuration (a required property) was received
    if !S3ConfigurationReceived {
        return errors.New("\"S3Configuration\" is required but was not present")
    }
    // check if Username (a required property) was received
    if !UsernameReceived {
        return errors.New("\"Username\" is required but was not present")
    }
    return nil
}

func (strct *RedshiftRetryOptions) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DurationInSeconds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DurationInSeconds\": ")
	if tmp, err := json.Marshal(strct.DurationInSeconds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RedshiftRetryOptions) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DurationInSeconds":
            if err := json.Unmarshal([]byte(v), &strct.DurationInSeconds); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AmazonOpenSearchServerlessDestinationConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AmazonOpenSearchServerlessDestinationConfiguration\": ")
	if tmp, err := json.Marshal(strct.AmazonOpenSearchServerlessDestinationConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AmazonopensearchserviceDestinationConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AmazonopensearchserviceDestinationConfiguration\": ")
	if tmp, err := json.Marshal(strct.AmazonopensearchserviceDestinationConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Arn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Arn\": ")
	if tmp, err := json.Marshal(strct.Arn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DeliveryStreamEncryptionConfigurationInput" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DeliveryStreamEncryptionConfigurationInput\": ")
	if tmp, err := json.Marshal(strct.DeliveryStreamEncryptionConfigurationInput); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DeliveryStreamName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DeliveryStreamName\": ")
	if tmp, err := json.Marshal(strct.DeliveryStreamName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DeliveryStreamType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DeliveryStreamType\": ")
	if tmp, err := json.Marshal(strct.DeliveryStreamType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ElasticsearchDestinationConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ElasticsearchDestinationConfiguration\": ")
	if tmp, err := json.Marshal(strct.ElasticsearchDestinationConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ExtendedS3DestinationConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ExtendedS3DestinationConfiguration\": ")
	if tmp, err := json.Marshal(strct.ExtendedS3DestinationConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "HttpEndpointDestinationConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HttpEndpointDestinationConfiguration\": ")
	if tmp, err := json.Marshal(strct.HttpEndpointDestinationConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "KinesisStreamSourceConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KinesisStreamSourceConfiguration\": ")
	if tmp, err := json.Marshal(strct.KinesisStreamSourceConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RedshiftDestinationConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RedshiftDestinationConfiguration\": ")
	if tmp, err := json.Marshal(strct.RedshiftDestinationConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "S3DestinationConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3DestinationConfiguration\": ")
	if tmp, err := json.Marshal(strct.S3DestinationConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SplunkDestinationConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SplunkDestinationConfiguration\": ")
	if tmp, err := json.Marshal(strct.SplunkDestinationConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AmazonOpenSearchServerlessDestinationConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.AmazonOpenSearchServerlessDestinationConfiguration); err != nil {
                return err
             }
        case "AmazonopensearchserviceDestinationConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.AmazonopensearchserviceDestinationConfiguration); err != nil {
                return err
             }
        case "Arn":
            if err := json.Unmarshal([]byte(v), &strct.Arn); err != nil {
                return err
             }
        case "DeliveryStreamEncryptionConfigurationInput":
            if err := json.Unmarshal([]byte(v), &strct.DeliveryStreamEncryptionConfigurationInput); err != nil {
                return err
             }
        case "DeliveryStreamName":
            if err := json.Unmarshal([]byte(v), &strct.DeliveryStreamName); err != nil {
                return err
             }
        case "DeliveryStreamType":
            if err := json.Unmarshal([]byte(v), &strct.DeliveryStreamType); err != nil {
                return err
             }
        case "ElasticsearchDestinationConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.ElasticsearchDestinationConfiguration); err != nil {
                return err
             }
        case "ExtendedS3DestinationConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.ExtendedS3DestinationConfiguration); err != nil {
                return err
             }
        case "HttpEndpointDestinationConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.HttpEndpointDestinationConfiguration); err != nil {
                return err
             }
        case "KinesisStreamSourceConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.KinesisStreamSourceConfiguration); err != nil {
                return err
             }
        case "RedshiftDestinationConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.RedshiftDestinationConfiguration); err != nil {
                return err
             }
        case "S3DestinationConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.S3DestinationConfiguration); err != nil {
                return err
             }
        case "SplunkDestinationConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.SplunkDestinationConfiguration); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *RetryOptions) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DurationInSeconds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DurationInSeconds\": ")
	if tmp, err := json.Marshal(strct.DurationInSeconds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RetryOptions) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DurationInSeconds":
            if err := json.Unmarshal([]byte(v), &strct.DurationInSeconds); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *S3DestinationConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "BucketARN" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "BucketARN" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BucketARN\": ")
	if tmp, err := json.Marshal(strct.BucketARN); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BufferingHints" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BufferingHints\": ")
	if tmp, err := json.Marshal(strct.BufferingHints); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CloudWatchLoggingOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CloudWatchLoggingOptions\": ")
	if tmp, err := json.Marshal(strct.CloudWatchLoggingOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CompressionFormat" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CompressionFormat\": ")
	if tmp, err := json.Marshal(strct.CompressionFormat); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EncryptionConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EncryptionConfiguration\": ")
	if tmp, err := json.Marshal(strct.EncryptionConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ErrorOutputPrefix" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ErrorOutputPrefix\": ")
	if tmp, err := json.Marshal(strct.ErrorOutputPrefix); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Prefix" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Prefix\": ")
	if tmp, err := json.Marshal(strct.Prefix); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RoleARN" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RoleARN" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoleARN\": ")
	if tmp, err := json.Marshal(strct.RoleARN); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *S3DestinationConfiguration) UnmarshalJSON(b []byte) error {
    BucketARNReceived := false
    RoleARNReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BucketARN":
            if err := json.Unmarshal([]byte(v), &strct.BucketARN); err != nil {
                return err
             }
            BucketARNReceived = true
        case "BufferingHints":
            if err := json.Unmarshal([]byte(v), &strct.BufferingHints); err != nil {
                return err
             }
        case "CloudWatchLoggingOptions":
            if err := json.Unmarshal([]byte(v), &strct.CloudWatchLoggingOptions); err != nil {
                return err
             }
        case "CompressionFormat":
            if err := json.Unmarshal([]byte(v), &strct.CompressionFormat); err != nil {
                return err
             }
        case "EncryptionConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.EncryptionConfiguration); err != nil {
                return err
             }
        case "ErrorOutputPrefix":
            if err := json.Unmarshal([]byte(v), &strct.ErrorOutputPrefix); err != nil {
                return err
             }
        case "Prefix":
            if err := json.Unmarshal([]byte(v), &strct.Prefix); err != nil {
                return err
             }
        case "RoleARN":
            if err := json.Unmarshal([]byte(v), &strct.RoleARN); err != nil {
                return err
             }
            RoleARNReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if BucketARN (a required property) was received
    if !BucketARNReceived {
        return errors.New("\"BucketARN\" is required but was not present")
    }
    // check if RoleARN (a required property) was received
    if !RoleARNReceived {
        return errors.New("\"RoleARN\" is required but was not present")
    }
    return nil
}

func (strct *SchemaConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CatalogId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CatalogId\": ")
	if tmp, err := json.Marshal(strct.CatalogId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DatabaseName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DatabaseName\": ")
	if tmp, err := json.Marshal(strct.DatabaseName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Region" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Region\": ")
	if tmp, err := json.Marshal(strct.Region); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RoleARN" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoleARN\": ")
	if tmp, err := json.Marshal(strct.RoleARN); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TableName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TableName\": ")
	if tmp, err := json.Marshal(strct.TableName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VersionId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VersionId\": ")
	if tmp, err := json.Marshal(strct.VersionId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SchemaConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CatalogId":
            if err := json.Unmarshal([]byte(v), &strct.CatalogId); err != nil {
                return err
             }
        case "DatabaseName":
            if err := json.Unmarshal([]byte(v), &strct.DatabaseName); err != nil {
                return err
             }
        case "Region":
            if err := json.Unmarshal([]byte(v), &strct.Region); err != nil {
                return err
             }
        case "RoleARN":
            if err := json.Unmarshal([]byte(v), &strct.RoleARN); err != nil {
                return err
             }
        case "TableName":
            if err := json.Unmarshal([]byte(v), &strct.TableName); err != nil {
                return err
             }
        case "VersionId":
            if err := json.Unmarshal([]byte(v), &strct.VersionId); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Serializer) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "OrcSerDe" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OrcSerDe\": ")
	if tmp, err := json.Marshal(strct.OrcSerDe); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ParquetSerDe" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ParquetSerDe\": ")
	if tmp, err := json.Marshal(strct.ParquetSerDe); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Serializer) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "OrcSerDe":
            if err := json.Unmarshal([]byte(v), &strct.OrcSerDe); err != nil {
                return err
             }
        case "ParquetSerDe":
            if err := json.Unmarshal([]byte(v), &strct.ParquetSerDe); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *SplunkDestinationConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CloudWatchLoggingOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CloudWatchLoggingOptions\": ")
	if tmp, err := json.Marshal(strct.CloudWatchLoggingOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "HECAcknowledgmentTimeoutInSeconds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HECAcknowledgmentTimeoutInSeconds\": ")
	if tmp, err := json.Marshal(strct.HECAcknowledgmentTimeoutInSeconds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "HECEndpoint" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "HECEndpoint" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HECEndpoint\": ")
	if tmp, err := json.Marshal(strct.HECEndpoint); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "HECEndpointType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "HECEndpointType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HECEndpointType\": ")
	if tmp, err := json.Marshal(strct.HECEndpointType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "HECToken" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "HECToken" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HECToken\": ")
	if tmp, err := json.Marshal(strct.HECToken); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ProcessingConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ProcessingConfiguration\": ")
	if tmp, err := json.Marshal(strct.ProcessingConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RetryOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RetryOptions\": ")
	if tmp, err := json.Marshal(strct.RetryOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "S3BackupMode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3BackupMode\": ")
	if tmp, err := json.Marshal(strct.S3BackupMode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "S3Configuration" field is required
    if strct.S3Configuration == nil {
        return nil, errors.New("S3Configuration is a required field")
    }
    // Marshal the "S3Configuration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3Configuration\": ")
	if tmp, err := json.Marshal(strct.S3Configuration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SplunkDestinationConfiguration) UnmarshalJSON(b []byte) error {
    HECEndpointReceived := false
    HECEndpointTypeReceived := false
    HECTokenReceived := false
    S3ConfigurationReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CloudWatchLoggingOptions":
            if err := json.Unmarshal([]byte(v), &strct.CloudWatchLoggingOptions); err != nil {
                return err
             }
        case "HECAcknowledgmentTimeoutInSeconds":
            if err := json.Unmarshal([]byte(v), &strct.HECAcknowledgmentTimeoutInSeconds); err != nil {
                return err
             }
        case "HECEndpoint":
            if err := json.Unmarshal([]byte(v), &strct.HECEndpoint); err != nil {
                return err
             }
            HECEndpointReceived = true
        case "HECEndpointType":
            if err := json.Unmarshal([]byte(v), &strct.HECEndpointType); err != nil {
                return err
             }
            HECEndpointTypeReceived = true
        case "HECToken":
            if err := json.Unmarshal([]byte(v), &strct.HECToken); err != nil {
                return err
             }
            HECTokenReceived = true
        case "ProcessingConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.ProcessingConfiguration); err != nil {
                return err
             }
        case "RetryOptions":
            if err := json.Unmarshal([]byte(v), &strct.RetryOptions); err != nil {
                return err
             }
        case "S3BackupMode":
            if err := json.Unmarshal([]byte(v), &strct.S3BackupMode); err != nil {
                return err
             }
        case "S3Configuration":
            if err := json.Unmarshal([]byte(v), &strct.S3Configuration); err != nil {
                return err
             }
            S3ConfigurationReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if HECEndpoint (a required property) was received
    if !HECEndpointReceived {
        return errors.New("\"HECEndpoint\" is required but was not present")
    }
    // check if HECEndpointType (a required property) was received
    if !HECEndpointTypeReceived {
        return errors.New("\"HECEndpointType\" is required but was not present")
    }
    // check if HECToken (a required property) was received
    if !HECTokenReceived {
        return errors.New("\"HECToken\" is required but was not present")
    }
    // check if S3Configuration (a required property) was received
    if !S3ConfigurationReceived {
        return errors.New("\"S3Configuration\" is required but was not present")
    }
    return nil
}

func (strct *SplunkRetryOptions) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DurationInSeconds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DurationInSeconds\": ")
	if tmp, err := json.Marshal(strct.DurationInSeconds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SplunkRetryOptions) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DurationInSeconds":
            if err := json.Unmarshal([]byte(v), &strct.DurationInSeconds); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    return nil
}

func (strct *VpcConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "RoleARN" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RoleARN" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoleARN\": ")
	if tmp, err := json.Marshal(strct.RoleARN); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "SecurityGroupIds" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "SecurityGroupIds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SecurityGroupIds\": ")
	if tmp, err := json.Marshal(strct.SecurityGroupIds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "SubnetIds" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "SubnetIds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SubnetIds\": ")
	if tmp, err := json.Marshal(strct.SubnetIds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *VpcConfiguration) UnmarshalJSON(b []byte) error {
    RoleARNReceived := false
    SecurityGroupIdsReceived := false
    SubnetIdsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "RoleARN":
            if err := json.Unmarshal([]byte(v), &strct.RoleARN); err != nil {
                return err
             }
            RoleARNReceived = true
        case "SecurityGroupIds":
            if err := json.Unmarshal([]byte(v), &strct.SecurityGroupIds); err != nil {
                return err
             }
            SecurityGroupIdsReceived = true
        case "SubnetIds":
            if err := json.Unmarshal([]byte(v), &strct.SubnetIds); err != nil {
                return err
             }
            SubnetIdsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if RoleARN (a required property) was received
    if !RoleARNReceived {
        return errors.New("\"RoleARN\" is required but was not present")
    }
    // check if SecurityGroupIds (a required property) was received
    if !SecurityGroupIdsReceived {
        return errors.New("\"SecurityGroupIds\" is required but was not present")
    }
    // check if SubnetIds (a required property) was received
    if !SubnetIdsReceived {
        return errors.New("\"SubnetIds\" is required but was not present")
    }
    return nil
}
