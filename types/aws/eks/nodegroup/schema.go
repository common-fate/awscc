// Code generated by schema-generate. DO NOT EDIT.

package nodegroup

import (
    "fmt"
    "errors"
    "bytes"
    "encoding/json"
)

// Labels The Kubernetes labels to be applied to the nodes in the node group when they are created.
type Labels struct {
}

// LaunchTemplateSpecification An object representing a launch template specification for AWS EKS Nodegroup.
type LaunchTemplateSpecification struct {
  Id string `json:"Id,omitempty"`
  Name string `json:"Name,omitempty"`
  Version string `json:"Version,omitempty"`
}

// RemoteAccess An object representing a remote access configuration specification for AWS EKS Nodegroup.
type RemoteAccess struct {
  Ec2SshKey string `json:"Ec2SshKey"`
  SourceSecurityGroups []string `json:"SourceSecurityGroups,omitempty"`
}

// Resource Resource schema for AWS::EKS::Nodegroup
type Resource struct {

  // The AMI type for your node group.
  AmiType string `json:"AmiType,omitempty"`
  Arn string `json:"Arn,omitempty"`

  // The capacity type of your managed node group.
  CapacityType string `json:"CapacityType,omitempty"`

  // Name of the cluster to create the node group in.
  ClusterName string `json:"ClusterName"`

  // The root device disk size (in GiB) for your node group instances.
  DiskSize int `json:"DiskSize,omitempty"`

  // Force the update if the existing node group's pods are unable to be drained due to a pod disruption budget issue.
  ForceUpdateEnabled bool `json:"ForceUpdateEnabled,omitempty"`
  Id string `json:"Id,omitempty"`

  // Specify the instance types for a node group.
  InstanceTypes []string `json:"InstanceTypes,omitempty"`

  // The Kubernetes labels to be applied to the nodes in the node group when they are created.
  Labels *Labels `json:"Labels,omitempty"`

  // An object representing a node group's launch template specification.
  LaunchTemplate *LaunchTemplateSpecification `json:"LaunchTemplate,omitempty"`

  // The Amazon Resource Name (ARN) of the IAM role to associate with your node group.
  NodeRole string `json:"NodeRole"`

  // The unique name to give your node group.
  NodegroupName string `json:"NodegroupName,omitempty"`

  // The AMI version of the Amazon EKS-optimized AMI to use with your node group.
  ReleaseVersion string `json:"ReleaseVersion,omitempty"`

  // The remote access (SSH) configuration to use with your node group.
  RemoteAccess *RemoteAccess `json:"RemoteAccess,omitempty"`

  // The scaling configuration details for the Auto Scaling group that is created for your node group.
  ScalingConfig *ScalingConfig `json:"ScalingConfig,omitempty"`

  // The subnets to use for the Auto Scaling group that is created for your node group.
  Subnets []string `json:"Subnets"`

  // The metadata, as key-value pairs, to apply to the node group to assist with categorization and organization. Follows same schema as Labels for consistency.
  Tags *Tags `json:"Tags,omitempty"`

  // The Kubernetes taints to be applied to the nodes in the node group when they are created.
  Taints []*Taint `json:"Taints,omitempty"`

  // The node group update configuration.
  UpdateConfig *UpdateConfig `json:"UpdateConfig,omitempty"`

  // The Kubernetes version to use for your managed nodes.
  Version string `json:"Version,omitempty"`
}

// ScalingConfig An object representing a auto scaling group specification for AWS EKS Nodegroup.
type ScalingConfig struct {
  DesiredSize int `json:"DesiredSize,omitempty"`
  MaxSize int `json:"MaxSize,omitempty"`
  MinSize int `json:"MinSize,omitempty"`
}

// Tags The metadata, as key-value pairs, to apply to the node group to assist with categorization and organization. Follows same schema as Labels for consistency.
type Tags struct {
}

// Taint An object representing a Taint specification for AWS EKS Nodegroup.
type Taint struct {
  Effect string `json:"Effect,omitempty"`
  Key string `json:"Key,omitempty"`
  Value string `json:"Value,omitempty"`
}

// UpdateConfig The node group update configuration.
type UpdateConfig struct {

  // The maximum number of nodes unavailable at once during a version update. Nodes will be updated in parallel. This value or maxUnavailablePercentage is required to have a value.The maximum number is 100. 
  MaxUnavailable float64 `json:"MaxUnavailable,omitempty"`

  // The maximum percentage of nodes unavailable during a version update. This percentage of nodes will be updated in parallel, up to 100 nodes at once. This value or maxUnavailable is required to have a value.
  MaxUnavailablePercentage float64 `json:"MaxUnavailablePercentage,omitempty"`
}

func (strct *Labels) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Labels) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *LaunchTemplateSpecification) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Id" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Version" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Version\": ")
	if tmp, err := json.Marshal(strct.Version); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LaunchTemplateSpecification) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "Version":
            if err := json.Unmarshal([]byte(v), &strct.Version); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *RemoteAccess) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Ec2SshKey" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Ec2SshKey" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Ec2SshKey\": ")
	if tmp, err := json.Marshal(strct.Ec2SshKey); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SourceSecurityGroups" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SourceSecurityGroups\": ")
	if tmp, err := json.Marshal(strct.SourceSecurityGroups); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RemoteAccess) UnmarshalJSON(b []byte) error {
    Ec2SshKeyReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Ec2SshKey":
            if err := json.Unmarshal([]byte(v), &strct.Ec2SshKey); err != nil {
                return err
             }
            Ec2SshKeyReceived = true
        case "SourceSecurityGroups":
            if err := json.Unmarshal([]byte(v), &strct.SourceSecurityGroups); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Ec2SshKey (a required property) was received
    if !Ec2SshKeyReceived {
        return errors.New("\"Ec2SshKey\" is required but was not present")
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AmiType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AmiType\": ")
	if tmp, err := json.Marshal(strct.AmiType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Arn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Arn\": ")
	if tmp, err := json.Marshal(strct.Arn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CapacityType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CapacityType\": ")
	if tmp, err := json.Marshal(strct.CapacityType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ClusterName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ClusterName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ClusterName\": ")
	if tmp, err := json.Marshal(strct.ClusterName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DiskSize" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DiskSize\": ")
	if tmp, err := json.Marshal(strct.DiskSize); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ForceUpdateEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ForceUpdateEnabled\": ")
	if tmp, err := json.Marshal(strct.ForceUpdateEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Id" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "InstanceTypes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InstanceTypes\": ")
	if tmp, err := json.Marshal(strct.InstanceTypes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Labels" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Labels\": ")
	if tmp, err := json.Marshal(strct.Labels); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LaunchTemplate" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LaunchTemplate\": ")
	if tmp, err := json.Marshal(strct.LaunchTemplate); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "NodeRole" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "NodeRole" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NodeRole\": ")
	if tmp, err := json.Marshal(strct.NodeRole); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "NodegroupName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NodegroupName\": ")
	if tmp, err := json.Marshal(strct.NodegroupName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ReleaseVersion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ReleaseVersion\": ")
	if tmp, err := json.Marshal(strct.ReleaseVersion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RemoteAccess" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RemoteAccess\": ")
	if tmp, err := json.Marshal(strct.RemoteAccess); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ScalingConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ScalingConfig\": ")
	if tmp, err := json.Marshal(strct.ScalingConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Subnets" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Subnets" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Subnets\": ")
	if tmp, err := json.Marshal(strct.Subnets); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Taints" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Taints\": ")
	if tmp, err := json.Marshal(strct.Taints); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "UpdateConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UpdateConfig\": ")
	if tmp, err := json.Marshal(strct.UpdateConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Version" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Version\": ")
	if tmp, err := json.Marshal(strct.Version); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    ClusterNameReceived := false
    NodeRoleReceived := false
    SubnetsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AmiType":
            if err := json.Unmarshal([]byte(v), &strct.AmiType); err != nil {
                return err
             }
        case "Arn":
            if err := json.Unmarshal([]byte(v), &strct.Arn); err != nil {
                return err
             }
        case "CapacityType":
            if err := json.Unmarshal([]byte(v), &strct.CapacityType); err != nil {
                return err
             }
        case "ClusterName":
            if err := json.Unmarshal([]byte(v), &strct.ClusterName); err != nil {
                return err
             }
            ClusterNameReceived = true
        case "DiskSize":
            if err := json.Unmarshal([]byte(v), &strct.DiskSize); err != nil {
                return err
             }
        case "ForceUpdateEnabled":
            if err := json.Unmarshal([]byte(v), &strct.ForceUpdateEnabled); err != nil {
                return err
             }
        case "Id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
        case "InstanceTypes":
            if err := json.Unmarshal([]byte(v), &strct.InstanceTypes); err != nil {
                return err
             }
        case "Labels":
            if err := json.Unmarshal([]byte(v), &strct.Labels); err != nil {
                return err
             }
        case "LaunchTemplate":
            if err := json.Unmarshal([]byte(v), &strct.LaunchTemplate); err != nil {
                return err
             }
        case "NodeRole":
            if err := json.Unmarshal([]byte(v), &strct.NodeRole); err != nil {
                return err
             }
            NodeRoleReceived = true
        case "NodegroupName":
            if err := json.Unmarshal([]byte(v), &strct.NodegroupName); err != nil {
                return err
             }
        case "ReleaseVersion":
            if err := json.Unmarshal([]byte(v), &strct.ReleaseVersion); err != nil {
                return err
             }
        case "RemoteAccess":
            if err := json.Unmarshal([]byte(v), &strct.RemoteAccess); err != nil {
                return err
             }
        case "ScalingConfig":
            if err := json.Unmarshal([]byte(v), &strct.ScalingConfig); err != nil {
                return err
             }
        case "Subnets":
            if err := json.Unmarshal([]byte(v), &strct.Subnets); err != nil {
                return err
             }
            SubnetsReceived = true
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        case "Taints":
            if err := json.Unmarshal([]byte(v), &strct.Taints); err != nil {
                return err
             }
        case "UpdateConfig":
            if err := json.Unmarshal([]byte(v), &strct.UpdateConfig); err != nil {
                return err
             }
        case "Version":
            if err := json.Unmarshal([]byte(v), &strct.Version); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ClusterName (a required property) was received
    if !ClusterNameReceived {
        return errors.New("\"ClusterName\" is required but was not present")
    }
    // check if NodeRole (a required property) was received
    if !NodeRoleReceived {
        return errors.New("\"NodeRole\" is required but was not present")
    }
    // check if Subnets (a required property) was received
    if !SubnetsReceived {
        return errors.New("\"Subnets\" is required but was not present")
    }
    return nil
}

func (strct *ScalingConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DesiredSize" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DesiredSize\": ")
	if tmp, err := json.Marshal(strct.DesiredSize); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MaxSize" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaxSize\": ")
	if tmp, err := json.Marshal(strct.MaxSize); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MinSize" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MinSize\": ")
	if tmp, err := json.Marshal(strct.MinSize); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ScalingConfig) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DesiredSize":
            if err := json.Unmarshal([]byte(v), &strct.DesiredSize); err != nil {
                return err
             }
        case "MaxSize":
            if err := json.Unmarshal([]byte(v), &strct.MaxSize); err != nil {
                return err
             }
        case "MinSize":
            if err := json.Unmarshal([]byte(v), &strct.MinSize); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Tags) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tags) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Taint) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Effect" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Effect\": ")
	if tmp, err := json.Marshal(strct.Effect); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Taint) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Effect":
            if err := json.Unmarshal([]byte(v), &strct.Effect); err != nil {
                return err
             }
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *UpdateConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "MaxUnavailable" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaxUnavailable\": ")
	if tmp, err := json.Marshal(strct.MaxUnavailable); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MaxUnavailablePercentage" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaxUnavailablePercentage\": ")
	if tmp, err := json.Marshal(strct.MaxUnavailablePercentage); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *UpdateConfig) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "MaxUnavailable":
            if err := json.Unmarshal([]byte(v), &strct.MaxUnavailable); err != nil {
                return err
             }
        case "MaxUnavailablePercentage":
            if err := json.Unmarshal([]byte(v), &strct.MaxUnavailablePercentage); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}
