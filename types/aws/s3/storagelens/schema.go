// Code generated by schema-generate. DO NOT EDIT.

package storagelens

import (
    "bytes"
    "errors"
    "encoding/json"
    "fmt"
)

// AccountLevel Account-level metrics configurations.
type AccountLevel struct {
  ActivityMetrics *ActivityMetrics `json:"ActivityMetrics,omitempty"`
  AdvancedCostOptimizationMetrics *AdvancedCostOptimizationMetrics `json:"AdvancedCostOptimizationMetrics,omitempty"`
  AdvancedDataProtectionMetrics *AdvancedDataProtectionMetrics `json:"AdvancedDataProtectionMetrics,omitempty"`
  BucketLevel *BucketLevel `json:"BucketLevel"`
  DetailedStatusCodesMetrics *DetailedStatusCodesMetrics `json:"DetailedStatusCodesMetrics,omitempty"`
}

// ActivityMetrics Enables activity metrics.
type ActivityMetrics struct {

  // Specifies whether activity metrics are enabled or disabled.
  IsEnabled bool `json:"IsEnabled,omitempty"`
}

// AdvancedCostOptimizationMetrics Enables advanced cost optimization metrics.
type AdvancedCostOptimizationMetrics struct {

  // Specifies whether advanced cost optimization metrics are enabled or disabled.
  IsEnabled bool `json:"IsEnabled,omitempty"`
}

// AdvancedDataProtectionMetrics Enables advanced data protection metrics.
type AdvancedDataProtectionMetrics struct {

  // Specifies whether advanced data protection metrics are enabled or disabled.
  IsEnabled bool `json:"IsEnabled,omitempty"`
}

// AwsOrg The AWS Organizations ARN to use in the Amazon S3 Storage Lens configuration.
type AwsOrg struct {
  Arn string `json:"Arn"`
}

// BucketLevel Bucket-level metrics configurations.
type BucketLevel struct {
  ActivityMetrics *ActivityMetrics `json:"ActivityMetrics,omitempty"`
  AdvancedCostOptimizationMetrics *AdvancedCostOptimizationMetrics `json:"AdvancedCostOptimizationMetrics,omitempty"`
  AdvancedDataProtectionMetrics *AdvancedDataProtectionMetrics `json:"AdvancedDataProtectionMetrics,omitempty"`
  DetailedStatusCodesMetrics *DetailedStatusCodesMetrics `json:"DetailedStatusCodesMetrics,omitempty"`
  PrefixLevel *PrefixLevel `json:"PrefixLevel,omitempty"`
}

// BucketsAndRegions S3 buckets and Regions to include/exclude in the Amazon S3 Storage Lens configuration.
type BucketsAndRegions struct {
  Buckets []string `json:"Buckets,omitempty"`
  Regions []string `json:"Regions,omitempty"`
}

// CloudWatchMetrics CloudWatch metrics settings for the Amazon S3 Storage Lens metrics export.
type CloudWatchMetrics struct {

  // Specifies whether CloudWatch metrics are enabled or disabled.
  IsEnabled bool `json:"IsEnabled"`
}

// DataExport Specifies how Amazon S3 Storage Lens metrics should be exported.
type DataExport struct {
  CloudWatchMetrics *CloudWatchMetrics `json:"CloudWatchMetrics,omitempty"`
  S3BucketDestination *S3BucketDestination `json:"S3BucketDestination,omitempty"`
}

// DetailedStatusCodesMetrics Enables detailed status codes metrics.
type DetailedStatusCodesMetrics struct {

  // Specifies whether detailed status codes metrics are enabled or disabled.
  IsEnabled bool `json:"IsEnabled,omitempty"`
}

// Encryption Configures the server-side encryption for Amazon S3 Storage Lens report files with either S3-managed keys (SSE-S3) or KMS-managed keys (SSE-KMS).
type Encryption struct {
}

// PrefixLevel Prefix-level metrics configurations.
type PrefixLevel struct {
  StorageMetrics *PrefixLevelStorageMetrics `json:"StorageMetrics"`
}

// PrefixLevelStorageMetrics 
type PrefixLevelStorageMetrics struct {

  // Specifies whether prefix-level storage metrics are enabled or disabled.
  IsEnabled bool `json:"IsEnabled,omitempty"`
  SelectionCriteria *SelectionCriteria `json:"SelectionCriteria,omitempty"`
}

// Resource The AWS::S3::StorageLens resource is an Amazon S3 resource type that you can use to create Storage Lens configurations.
type Resource struct {
  StorageLensConfiguration *StorageLensConfiguration `json:"StorageLensConfiguration"`

  // A set of tags (key-value pairs) for this Amazon S3 Storage Lens configuration.
  Tags []*Tag `json:"Tags,omitempty"`
}

// S3BucketDestination S3 bucket destination settings for the Amazon S3 Storage Lens metrics export.
type S3BucketDestination struct {

  // The AWS account ID that owns the destination S3 bucket.
  AccountId string `json:"AccountId"`

  // The ARN of the bucket to which Amazon S3 Storage Lens exports will be placed.
  Arn string `json:"Arn"`
  Encryption *Encryption `json:"Encryption,omitempty"`

  // Specifies the file format to use when exporting Amazon S3 Storage Lens metrics export.
  Format string `json:"Format"`

  // The version of the output schema to use when exporting Amazon S3 Storage Lens metrics.
  OutputSchemaVersion string `json:"OutputSchemaVersion"`

  // The prefix to use for Amazon S3 Storage Lens export.
  Prefix string `json:"Prefix,omitempty"`
}

// SSEKMS AWS KMS server-side encryption.
type SSEKMS struct {

  // The ARN of the KMS key to use for encryption.
  KeyId string `json:"KeyId"`
}

// SelectionCriteria Selection criteria for prefix-level metrics.
type SelectionCriteria struct {

  // Delimiter to divide S3 key into hierarchy of prefixes.
  Delimiter string `json:"Delimiter,omitempty"`

  // Max depth of prefixes of S3 key that Amazon S3 Storage Lens will analyze.
  MaxDepth int `json:"MaxDepth,omitempty"`

  // The minimum storage bytes threshold for the prefixes to be included in the analysis.
  MinStorageBytesPercentage float64 `json:"MinStorageBytesPercentage,omitempty"`
}

// StorageLensConfiguration Specifies the details of Amazon S3 Storage Lens configuration.
type StorageLensConfiguration struct {
  AccountLevel *AccountLevel `json:"AccountLevel"`
  AwsOrg *AwsOrg `json:"AwsOrg,omitempty"`
  DataExport *DataExport `json:"DataExport,omitempty"`
  Exclude *BucketsAndRegions `json:"Exclude,omitempty"`
  Id string `json:"Id"`
  Include *BucketsAndRegions `json:"Include,omitempty"`

  // Specifies whether the Amazon S3 Storage Lens configuration is enabled or disabled.
  IsEnabled bool `json:"IsEnabled"`

  // The ARN for the Amazon S3 Storage Lens configuration.
  StorageLensArn string `json:"StorageLensArn,omitempty"`
}

// Tag 
type Tag struct {
  Key string `json:"Key"`
  Value string `json:"Value"`
}

func (strct *AccountLevel) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ActivityMetrics" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ActivityMetrics\": ")
	if tmp, err := json.Marshal(strct.ActivityMetrics); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AdvancedCostOptimizationMetrics" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AdvancedCostOptimizationMetrics\": ")
	if tmp, err := json.Marshal(strct.AdvancedCostOptimizationMetrics); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AdvancedDataProtectionMetrics" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AdvancedDataProtectionMetrics\": ")
	if tmp, err := json.Marshal(strct.AdvancedDataProtectionMetrics); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "BucketLevel" field is required
    if strct.BucketLevel == nil {
        return nil, errors.New("BucketLevel is a required field")
    }
    // Marshal the "BucketLevel" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BucketLevel\": ")
	if tmp, err := json.Marshal(strct.BucketLevel); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DetailedStatusCodesMetrics" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DetailedStatusCodesMetrics\": ")
	if tmp, err := json.Marshal(strct.DetailedStatusCodesMetrics); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AccountLevel) UnmarshalJSON(b []byte) error {
    BucketLevelReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ActivityMetrics":
            if err := json.Unmarshal([]byte(v), &strct.ActivityMetrics); err != nil {
                return err
             }
        case "AdvancedCostOptimizationMetrics":
            if err := json.Unmarshal([]byte(v), &strct.AdvancedCostOptimizationMetrics); err != nil {
                return err
             }
        case "AdvancedDataProtectionMetrics":
            if err := json.Unmarshal([]byte(v), &strct.AdvancedDataProtectionMetrics); err != nil {
                return err
             }
        case "BucketLevel":
            if err := json.Unmarshal([]byte(v), &strct.BucketLevel); err != nil {
                return err
             }
            BucketLevelReceived = true
        case "DetailedStatusCodesMetrics":
            if err := json.Unmarshal([]byte(v), &strct.DetailedStatusCodesMetrics); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if BucketLevel (a required property) was received
    if !BucketLevelReceived {
        return errors.New("\"BucketLevel\" is required but was not present")
    }
    return nil
}

func (strct *ActivityMetrics) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "IsEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IsEnabled\": ")
	if tmp, err := json.Marshal(strct.IsEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ActivityMetrics) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "IsEnabled":
            if err := json.Unmarshal([]byte(v), &strct.IsEnabled); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *AdvancedCostOptimizationMetrics) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "IsEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IsEnabled\": ")
	if tmp, err := json.Marshal(strct.IsEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AdvancedCostOptimizationMetrics) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "IsEnabled":
            if err := json.Unmarshal([]byte(v), &strct.IsEnabled); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *AdvancedDataProtectionMetrics) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "IsEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IsEnabled\": ")
	if tmp, err := json.Marshal(strct.IsEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AdvancedDataProtectionMetrics) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "IsEnabled":
            if err := json.Unmarshal([]byte(v), &strct.IsEnabled); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *AwsOrg) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Arn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Arn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Arn\": ")
	if tmp, err := json.Marshal(strct.Arn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AwsOrg) UnmarshalJSON(b []byte) error {
    ArnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Arn":
            if err := json.Unmarshal([]byte(v), &strct.Arn); err != nil {
                return err
             }
            ArnReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Arn (a required property) was received
    if !ArnReceived {
        return errors.New("\"Arn\" is required but was not present")
    }
    return nil
}

func (strct *BucketLevel) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ActivityMetrics" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ActivityMetrics\": ")
	if tmp, err := json.Marshal(strct.ActivityMetrics); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AdvancedCostOptimizationMetrics" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AdvancedCostOptimizationMetrics\": ")
	if tmp, err := json.Marshal(strct.AdvancedCostOptimizationMetrics); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AdvancedDataProtectionMetrics" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AdvancedDataProtectionMetrics\": ")
	if tmp, err := json.Marshal(strct.AdvancedDataProtectionMetrics); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DetailedStatusCodesMetrics" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DetailedStatusCodesMetrics\": ")
	if tmp, err := json.Marshal(strct.DetailedStatusCodesMetrics); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PrefixLevel" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PrefixLevel\": ")
	if tmp, err := json.Marshal(strct.PrefixLevel); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BucketLevel) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ActivityMetrics":
            if err := json.Unmarshal([]byte(v), &strct.ActivityMetrics); err != nil {
                return err
             }
        case "AdvancedCostOptimizationMetrics":
            if err := json.Unmarshal([]byte(v), &strct.AdvancedCostOptimizationMetrics); err != nil {
                return err
             }
        case "AdvancedDataProtectionMetrics":
            if err := json.Unmarshal([]byte(v), &strct.AdvancedDataProtectionMetrics); err != nil {
                return err
             }
        case "DetailedStatusCodesMetrics":
            if err := json.Unmarshal([]byte(v), &strct.DetailedStatusCodesMetrics); err != nil {
                return err
             }
        case "PrefixLevel":
            if err := json.Unmarshal([]byte(v), &strct.PrefixLevel); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *BucketsAndRegions) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Buckets" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Buckets\": ")
	if tmp, err := json.Marshal(strct.Buckets); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Regions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Regions\": ")
	if tmp, err := json.Marshal(strct.Regions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BucketsAndRegions) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Buckets":
            if err := json.Unmarshal([]byte(v), &strct.Buckets); err != nil {
                return err
             }
        case "Regions":
            if err := json.Unmarshal([]byte(v), &strct.Regions); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *CloudWatchMetrics) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "IsEnabled" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "IsEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IsEnabled\": ")
	if tmp, err := json.Marshal(strct.IsEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CloudWatchMetrics) UnmarshalJSON(b []byte) error {
    IsEnabledReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "IsEnabled":
            if err := json.Unmarshal([]byte(v), &strct.IsEnabled); err != nil {
                return err
             }
            IsEnabledReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if IsEnabled (a required property) was received
    if !IsEnabledReceived {
        return errors.New("\"IsEnabled\" is required but was not present")
    }
    return nil
}

func (strct *DataExport) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CloudWatchMetrics" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CloudWatchMetrics\": ")
	if tmp, err := json.Marshal(strct.CloudWatchMetrics); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "S3BucketDestination" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3BucketDestination\": ")
	if tmp, err := json.Marshal(strct.S3BucketDestination); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DataExport) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CloudWatchMetrics":
            if err := json.Unmarshal([]byte(v), &strct.CloudWatchMetrics); err != nil {
                return err
             }
        case "S3BucketDestination":
            if err := json.Unmarshal([]byte(v), &strct.S3BucketDestination); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *DetailedStatusCodesMetrics) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "IsEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IsEnabled\": ")
	if tmp, err := json.Marshal(strct.IsEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DetailedStatusCodesMetrics) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "IsEnabled":
            if err := json.Unmarshal([]byte(v), &strct.IsEnabled); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *PrefixLevel) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "StorageMetrics" field is required
    if strct.StorageMetrics == nil {
        return nil, errors.New("StorageMetrics is a required field")
    }
    // Marshal the "StorageMetrics" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StorageMetrics\": ")
	if tmp, err := json.Marshal(strct.StorageMetrics); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PrefixLevel) UnmarshalJSON(b []byte) error {
    StorageMetricsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "StorageMetrics":
            if err := json.Unmarshal([]byte(v), &strct.StorageMetrics); err != nil {
                return err
             }
            StorageMetricsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if StorageMetrics (a required property) was received
    if !StorageMetricsReceived {
        return errors.New("\"StorageMetrics\" is required but was not present")
    }
    return nil
}

func (strct *PrefixLevelStorageMetrics) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "IsEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IsEnabled\": ")
	if tmp, err := json.Marshal(strct.IsEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SelectionCriteria" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SelectionCriteria\": ")
	if tmp, err := json.Marshal(strct.SelectionCriteria); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PrefixLevelStorageMetrics) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "IsEnabled":
            if err := json.Unmarshal([]byte(v), &strct.IsEnabled); err != nil {
                return err
             }
        case "SelectionCriteria":
            if err := json.Unmarshal([]byte(v), &strct.SelectionCriteria); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "StorageLensConfiguration" field is required
    if strct.StorageLensConfiguration == nil {
        return nil, errors.New("StorageLensConfiguration is a required field")
    }
    // Marshal the "StorageLensConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StorageLensConfiguration\": ")
	if tmp, err := json.Marshal(strct.StorageLensConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    StorageLensConfigurationReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "StorageLensConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.StorageLensConfiguration); err != nil {
                return err
             }
            StorageLensConfigurationReceived = true
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if StorageLensConfiguration (a required property) was received
    if !StorageLensConfigurationReceived {
        return errors.New("\"StorageLensConfiguration\" is required but was not present")
    }
    return nil
}

func (strct *S3BucketDestination) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AccountId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AccountId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AccountId\": ")
	if tmp, err := json.Marshal(strct.AccountId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Arn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Arn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Arn\": ")
	if tmp, err := json.Marshal(strct.Arn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Encryption" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Encryption\": ")
	if tmp, err := json.Marshal(strct.Encryption); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Format" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Format" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Format\": ")
	if tmp, err := json.Marshal(strct.Format); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "OutputSchemaVersion" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "OutputSchemaVersion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OutputSchemaVersion\": ")
	if tmp, err := json.Marshal(strct.OutputSchemaVersion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Prefix" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Prefix\": ")
	if tmp, err := json.Marshal(strct.Prefix); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *S3BucketDestination) UnmarshalJSON(b []byte) error {
    AccountIdReceived := false
    ArnReceived := false
    FormatReceived := false
    OutputSchemaVersionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AccountId":
            if err := json.Unmarshal([]byte(v), &strct.AccountId); err != nil {
                return err
             }
            AccountIdReceived = true
        case "Arn":
            if err := json.Unmarshal([]byte(v), &strct.Arn); err != nil {
                return err
             }
            ArnReceived = true
        case "Encryption":
            if err := json.Unmarshal([]byte(v), &strct.Encryption); err != nil {
                return err
             }
        case "Format":
            if err := json.Unmarshal([]byte(v), &strct.Format); err != nil {
                return err
             }
            FormatReceived = true
        case "OutputSchemaVersion":
            if err := json.Unmarshal([]byte(v), &strct.OutputSchemaVersion); err != nil {
                return err
             }
            OutputSchemaVersionReceived = true
        case "Prefix":
            if err := json.Unmarshal([]byte(v), &strct.Prefix); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if AccountId (a required property) was received
    if !AccountIdReceived {
        return errors.New("\"AccountId\" is required but was not present")
    }
    // check if Arn (a required property) was received
    if !ArnReceived {
        return errors.New("\"Arn\" is required but was not present")
    }
    // check if Format (a required property) was received
    if !FormatReceived {
        return errors.New("\"Format\" is required but was not present")
    }
    // check if OutputSchemaVersion (a required property) was received
    if !OutputSchemaVersionReceived {
        return errors.New("\"OutputSchemaVersion\" is required but was not present")
    }
    return nil
}

func (strct *SSEKMS) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "KeyId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "KeyId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KeyId\": ")
	if tmp, err := json.Marshal(strct.KeyId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SSEKMS) UnmarshalJSON(b []byte) error {
    KeyIdReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "KeyId":
            if err := json.Unmarshal([]byte(v), &strct.KeyId); err != nil {
                return err
             }
            KeyIdReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if KeyId (a required property) was received
    if !KeyIdReceived {
        return errors.New("\"KeyId\" is required but was not present")
    }
    return nil
}

func (strct *SelectionCriteria) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Delimiter" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Delimiter\": ")
	if tmp, err := json.Marshal(strct.Delimiter); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MaxDepth" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaxDepth\": ")
	if tmp, err := json.Marshal(strct.MaxDepth); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MinStorageBytesPercentage" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MinStorageBytesPercentage\": ")
	if tmp, err := json.Marshal(strct.MinStorageBytesPercentage); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SelectionCriteria) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Delimiter":
            if err := json.Unmarshal([]byte(v), &strct.Delimiter); err != nil {
                return err
             }
        case "MaxDepth":
            if err := json.Unmarshal([]byte(v), &strct.MaxDepth); err != nil {
                return err
             }
        case "MinStorageBytesPercentage":
            if err := json.Unmarshal([]byte(v), &strct.MinStorageBytesPercentage); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *StorageLensConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AccountLevel" field is required
    if strct.AccountLevel == nil {
        return nil, errors.New("AccountLevel is a required field")
    }
    // Marshal the "AccountLevel" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AccountLevel\": ")
	if tmp, err := json.Marshal(strct.AccountLevel); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AwsOrg" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AwsOrg\": ")
	if tmp, err := json.Marshal(strct.AwsOrg); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DataExport" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DataExport\": ")
	if tmp, err := json.Marshal(strct.DataExport); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Exclude" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Exclude\": ")
	if tmp, err := json.Marshal(strct.Exclude); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Id" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Id" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Include" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Include\": ")
	if tmp, err := json.Marshal(strct.Include); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "IsEnabled" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "IsEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IsEnabled\": ")
	if tmp, err := json.Marshal(strct.IsEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StorageLensArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StorageLensArn\": ")
	if tmp, err := json.Marshal(strct.StorageLensArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *StorageLensConfiguration) UnmarshalJSON(b []byte) error {
    AccountLevelReceived := false
    IdReceived := false
    IsEnabledReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AccountLevel":
            if err := json.Unmarshal([]byte(v), &strct.AccountLevel); err != nil {
                return err
             }
            AccountLevelReceived = true
        case "AwsOrg":
            if err := json.Unmarshal([]byte(v), &strct.AwsOrg); err != nil {
                return err
             }
        case "DataExport":
            if err := json.Unmarshal([]byte(v), &strct.DataExport); err != nil {
                return err
             }
        case "Exclude":
            if err := json.Unmarshal([]byte(v), &strct.Exclude); err != nil {
                return err
             }
        case "Id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
            IdReceived = true
        case "Include":
            if err := json.Unmarshal([]byte(v), &strct.Include); err != nil {
                return err
             }
        case "IsEnabled":
            if err := json.Unmarshal([]byte(v), &strct.IsEnabled); err != nil {
                return err
             }
            IsEnabledReceived = true
        case "StorageLensArn":
            if err := json.Unmarshal([]byte(v), &strct.StorageLensArn); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if AccountLevel (a required property) was received
    if !AccountLevelReceived {
        return errors.New("\"AccountLevel\" is required but was not present")
    }
    // check if Id (a required property) was received
    if !IdReceived {
        return errors.New("\"Id\" is required but was not present")
    }
    // check if IsEnabled (a required property) was received
    if !IsEnabledReceived {
        return errors.New("\"IsEnabled\" is required but was not present")
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}
