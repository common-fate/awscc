// Code generated by schema-generate. DO NOT EDIT.

package bucket

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// AbortIncompleteMultipartUpload Specifies the days since the initiation of an incomplete multipart upload that Amazon S3 will wait before permanently removing all parts of the upload.
type AbortIncompleteMultipartUpload struct {

  // Specifies the number of days after which Amazon S3 aborts an incomplete multipart upload.
  DaysAfterInitiation int `json:"DaysAfterInitiation"`
}

// AccelerateConfiguration 
type AccelerateConfiguration struct {

  // Configures the transfer acceleration state for an Amazon S3 bucket.
  AccelerationStatus string `json:"AccelerationStatus"`
}

// AccessControlTranslation Specify this only in a cross-account scenario (where source and destination bucket owners are not the same), and you want to change replica ownership to the AWS account that owns the destination bucket. If this is not specified in the replication configuration, the replicas are owned by same AWS account that owns the source object.
type AccessControlTranslation struct {
  Owner string `json:"Owner"`
}

// AnalyticsConfiguration Specifies the configuration and any analyses for the analytics filter of an Amazon S3 bucket.
type AnalyticsConfiguration struct {

  // The ID that identifies the analytics configuration.
  Id string `json:"Id"`

  // The prefix that an object must have to be included in the analytics results.
  Prefix string `json:"Prefix,omitempty"`
  StorageClassAnalysis *StorageClassAnalysis `json:"StorageClassAnalysis"`
  TagFilters []*TagFilter `json:"TagFilters,omitempty"`
}

// BucketEncryption Specifies default encryption for a bucket using server-side encryption with either Amazon S3-managed keys (SSE-S3) or AWS KMS-managed keys (SSE-KMS).
type BucketEncryption struct {

  // Specifies the default server-side-encryption configuration.
  ServerSideEncryptionConfiguration []*ServerSideEncryptionRule `json:"ServerSideEncryptionConfiguration"`
}

// CorsConfiguration 
type CorsConfiguration struct {
  CorsRules []*CorsRule `json:"CorsRules"`
}

// CorsRule A set of origins and methods (cross-origin access that you want to allow). You can add up to 100 rules to the configuration.
type CorsRule struct {

  // Headers that are specified in the Access-Control-Request-Headers header.
  AllowedHeaders []string `json:"AllowedHeaders,omitempty"`

  // An HTTP method that you allow the origin to execute.
  AllowedMethods []string `json:"AllowedMethods"`

  // One or more origins you want customers to be able to access the bucket from.
  AllowedOrigins []string `json:"AllowedOrigins"`

  // One or more headers in the response that you want customers to be able to access from their applications (for example, from a JavaScript XMLHttpRequest object).
  ExposedHeaders []string `json:"ExposedHeaders,omitempty"`

  // A unique identifier for this rule.
  Id string `json:"Id,omitempty"`

  // The time in seconds that your browser is to cache the preflight response for the specified resource.
  MaxAge int `json:"MaxAge,omitempty"`
}

// DataExport Specifies how data related to the storage class analysis for an Amazon S3 bucket should be exported.
type DataExport struct {
  Destination *Destination `json:"Destination"`

  // The version of the output schema to use when exporting data.
  OutputSchemaVersion string `json:"OutputSchemaVersion"`
}

// DefaultRetention The default retention period that you want to apply to new objects placed in the specified bucket.
type DefaultRetention struct {
  Days int `json:"Days,omitempty"`
  Mode string `json:"Mode,omitempty"`
  Years int `json:"Years,omitempty"`
}

// DeleteMarkerReplication 
type DeleteMarkerReplication struct {
  Status string `json:"Status,omitempty"`
}

// Destination Specifies information about where to publish analysis or configuration results for an Amazon S3 bucket and S3 Replication Time Control (S3 RTC).
type Destination struct {

  // The account ID that owns the destination S3 bucket. 
  BucketAccountId string `json:"BucketAccountId,omitempty"`

  // The Amazon Resource Name (ARN) of the bucket to which data is exported.
  BucketArn string `json:"BucketArn"`

  // Specifies the file format used when exporting data to Amazon S3.
  Format string `json:"Format"`

  // The prefix to use when exporting data. The prefix is prepended to all results.
  Prefix string `json:"Prefix,omitempty"`
}

// EncryptionConfiguration Specifies encryption-related information for an Amazon S3 bucket that is a destination for replicated objects.
type EncryptionConfiguration struct {

  // Specifies the ID (Key ARN or Alias ARN) of the customer managed customer master key (CMK) stored in AWS Key Management Service (KMS) for the destination bucket.
  ReplicaKmsKeyID string `json:"ReplicaKmsKeyID"`
}

// EventBridgeConfiguration Describes the Amazon EventBridge notification configuration for an Amazon S3 bucket.
type EventBridgeConfiguration struct {

  // Specifies whether to send notifications to Amazon EventBridge when events occur in an Amazon S3 bucket.
  EventBridgeEnabled bool `json:"EventBridgeEnabled"`
}

// FilterRule Specifies the Amazon S3 object key name to filter on and whether to filter on the suffix or prefix of the key name.
type FilterRule struct {
  Name string `json:"Name"`
  Value string `json:"Value"`
}

// IntelligentTieringConfiguration 
type IntelligentTieringConfiguration struct {

  // The ID used to identify the S3 Intelligent-Tiering configuration.
  Id string `json:"Id"`

  // An object key name prefix that identifies the subset of objects to which the rule applies.
  Prefix string `json:"Prefix,omitempty"`

  // Specifies the status of the configuration.
  Status string `json:"Status"`

  // A container for a key-value pair.
  TagFilters []*TagFilter `json:"TagFilters,omitempty"`

  // Specifies a list of S3 Intelligent-Tiering storage class tiers in the configuration. At least one tier must be defined in the list. At most, you can specify two tiers in the list, one for each available AccessTier: ARCHIVE_ACCESS and DEEP_ARCHIVE_ACCESS.
  Tierings []*Tiering `json:"Tierings"`
}

// InventoryConfiguration 
type InventoryConfiguration struct {
  Destination *Destination `json:"Destination"`

  // Specifies whether the inventory is enabled or disabled.
  Enabled bool `json:"Enabled"`

  // The ID used to identify the inventory configuration.
  Id string `json:"Id"`

  // Object versions to include in the inventory list.
  IncludedObjectVersions string `json:"IncludedObjectVersions"`

  // Contains the optional fields that are included in the inventory results.
  OptionalFields []string `json:"OptionalFields,omitempty"`

  // The prefix that is prepended to all inventory results.
  Prefix string `json:"Prefix,omitempty"`

  // Specifies the schedule for generating inventory results.
  ScheduleFrequency string `json:"ScheduleFrequency"`
}

// LambdaConfiguration Describes the AWS Lambda functions to invoke and the events for which to invoke them.
type LambdaConfiguration struct {

  // The Amazon S3 bucket event for which to invoke the AWS Lambda function.
  Event string `json:"Event"`

  // The filtering rules that determine which objects invoke the AWS Lambda function.
  Filter *NotificationFilter `json:"Filter,omitempty"`

  // The Amazon Resource Name (ARN) of the AWS Lambda function that Amazon S3 invokes when the specified event type occurs.
  Function string `json:"Function"`
}

// LifecycleConfiguration 
type LifecycleConfiguration struct {

  // A lifecycle rule for individual objects in an Amazon S3 bucket.
  Rules []*Rule `json:"Rules"`
}

// LoggingConfiguration 
type LoggingConfiguration struct {

  // The name of an Amazon S3 bucket where Amazon S3 store server access log files. You can store log files in any bucket that you own. By default, logs are stored in the bucket where the LoggingConfiguration property is defined.
  DestinationBucketName string `json:"DestinationBucketName,omitempty"`
  LogFilePrefix string `json:"LogFilePrefix,omitempty"`
}

// Metrics 
type Metrics struct {
  EventThreshold *ReplicationTimeValue `json:"EventThreshold,omitempty"`
  Status string `json:"Status"`
}

// MetricsConfiguration 
type MetricsConfiguration struct {
  AccessPointArn string `json:"AccessPointArn,omitempty"`
  Id string `json:"Id"`
  Prefix string `json:"Prefix,omitempty"`
  TagFilters []*TagFilter `json:"TagFilters,omitempty"`
}

// NoncurrentVersionExpiration Container for the expiration rule that describes when noncurrent objects are expired. If your bucket is versioning-enabled (or versioning is suspended), you can set this action to request that Amazon S3 expire noncurrent object versions at a specific period in the object's lifetime
type NoncurrentVersionExpiration struct {

  // Specified the number of newer noncurrent and current versions that must exists before performing the associated action
  NewerNoncurrentVersions int `json:"NewerNoncurrentVersions,omitempty"`

  // Specified the number of days an object is noncurrent before Amazon S3 can perform the associated action
  NoncurrentDays int `json:"NoncurrentDays"`
}

// NoncurrentVersionTransition Container for the transition rule that describes when noncurrent objects transition to the STANDARD_IA, ONEZONE_IA, INTELLIGENT_TIERING, GLACIER_IR, GLACIER, or DEEP_ARCHIVE storage class. If your bucket is versioning-enabled (or versioning is suspended), you can set this action to request that Amazon S3 transition noncurrent object versions to the STANDARD_IA, ONEZONE_IA, INTELLIGENT_TIERING, GLACIER_IR, GLACIER, or DEEP_ARCHIVE storage class at a specific period in the object's lifetime.
type NoncurrentVersionTransition struct {

  // Specified the number of newer noncurrent and current versions that must exists before performing the associated action
  NewerNoncurrentVersions int `json:"NewerNoncurrentVersions,omitempty"`

  // The class of storage used to store the object.
  StorageClass string `json:"StorageClass"`

  // Specifies the number of days an object is noncurrent before Amazon S3 can perform the associated action.
  TransitionInDays int `json:"TransitionInDays"`
}

// NotificationConfiguration Describes the notification configuration for an Amazon S3 bucket.
type NotificationConfiguration struct {
  EventBridgeConfiguration *EventBridgeConfiguration `json:"EventBridgeConfiguration,omitempty"`
  LambdaConfigurations []*LambdaConfiguration `json:"LambdaConfigurations,omitempty"`
  QueueConfigurations []*QueueConfiguration `json:"QueueConfigurations,omitempty"`
  TopicConfigurations []*TopicConfiguration `json:"TopicConfigurations,omitempty"`
}

// NotificationFilter Specifies object key name filtering rules.
type NotificationFilter struct {
  S3Key *S3KeyFilter `json:"S3Key"`
}

// ObjectLockConfiguration 
type ObjectLockConfiguration struct {
  ObjectLockEnabled string `json:"ObjectLockEnabled,omitempty"`
  Rule *ObjectLockRule `json:"Rule,omitempty"`
}

// ObjectLockRule The Object Lock rule in place for the specified object.
type ObjectLockRule struct {
  DefaultRetention *DefaultRetention `json:"DefaultRetention,omitempty"`
}

// OwnershipControls 
type OwnershipControls struct {
  Rules []*OwnershipControlsRule `json:"Rules"`
}

// OwnershipControlsRule 
type OwnershipControlsRule struct {

  // Specifies an object ownership rule.
  ObjectOwnership string `json:"ObjectOwnership,omitempty"`
}

// PublicAccessBlockConfiguration Configuration that defines how Amazon S3 handles public access.
type PublicAccessBlockConfiguration struct {

  // Specifies whether Amazon S3 should block public access control lists (ACLs) for this bucket and objects in this bucket. Setting this element to TRUE causes the following behavior:
  // - PUT Bucket acl and PUT Object acl calls fail if the specified ACL is public.
  //  - PUT Object calls fail if the request includes a public ACL.
  // Enabling this setting doesn't affect existing policies or ACLs.
  BlockPublicAcls bool `json:"BlockPublicAcls,omitempty"`

  // Specifies whether Amazon S3 should block public bucket policies for this bucket. Setting this element to TRUE causes Amazon S3 to reject calls to PUT Bucket policy if the specified bucket policy allows public access.
  // Enabling this setting doesn't affect existing bucket policies.
  BlockPublicPolicy bool `json:"BlockPublicPolicy,omitempty"`

  // Specifies whether Amazon S3 should ignore public ACLs for this bucket and objects in this bucket. Setting this element to TRUE causes Amazon S3 to ignore all public ACLs on this bucket and objects in this bucket.
  // Enabling this setting doesn't affect the persistence of any existing ACLs and doesn't prevent new public ACLs from being set.
  IgnorePublicAcls bool `json:"IgnorePublicAcls,omitempty"`

  // Specifies whether Amazon S3 should restrict public bucket policies for this bucket. Setting this element to TRUE restricts access to this bucket to only AWS services and authorized users within this account if the bucket has a public policy.
  // Enabling this setting doesn't affect previously stored bucket policies, except that public and cross-account access within any public bucket policy, including non-public delegation to specific accounts, is blocked.
  RestrictPublicBuckets bool `json:"RestrictPublicBuckets,omitempty"`
}

// QueueConfiguration The Amazon Simple Queue Service queues to publish messages to and the events for which to publish messages.
type QueueConfiguration struct {

  // The Amazon S3 bucket event about which you want to publish messages to Amazon SQS.
  Event string `json:"Event"`

  // The filtering rules that determine which objects trigger notifications.
  Filter *NotificationFilter `json:"Filter,omitempty"`

  // The Amazon Resource Name (ARN) of the Amazon SQS queue to which Amazon S3 publishes a message when it detects events of the specified type.
  Queue string `json:"Queue"`
}

// RedirectAllRequestsTo Specifies the redirect behavior of all requests to a website endpoint of an Amazon S3 bucket.
type RedirectAllRequestsTo struct {

  // Name of the host where requests are redirected.
  HostName string `json:"HostName"`

  // Protocol to use when redirecting requests. The default is the protocol that is used in the original request.
  Protocol string `json:"Protocol,omitempty"`
}

// RedirectRule Specifies how requests are redirected. In the event of an error, you can specify a different error code to return.
type RedirectRule struct {

  // The host name to use in the redirect request.
  HostName string `json:"HostName,omitempty"`

  // The HTTP redirect code to use on the response. Not required if one of the siblings is present.
  HttpRedirectCode string `json:"HttpRedirectCode,omitempty"`

  // Protocol to use when redirecting requests. The default is the protocol that is used in the original request.
  Protocol string `json:"Protocol,omitempty"`

  // The object key prefix to use in the redirect request.
  ReplaceKeyPrefixWith string `json:"ReplaceKeyPrefixWith,omitempty"`

  // The specific object key to use in the redirect request.d
  ReplaceKeyWith string `json:"ReplaceKeyWith,omitempty"`
}

// ReplicaModifications 
type ReplicaModifications struct {

  // Specifies whether Amazon S3 replicates modifications on replicas.
  Status string `json:"Status"`
}

// ReplicationConfiguration A container for replication rules. You can add up to 1,000 rules. The maximum size of a replication configuration is 2 MB.
type ReplicationConfiguration struct {

  // The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that Amazon S3 assumes when replicating objects.
  Role string `json:"Role"`

  // A container for one or more replication rules.
  Rules []*ReplicationRule `json:"Rules"`
}

// ReplicationDestination Specifies which Amazon S3 bucket to store replicated objects in and their storage class.
type ReplicationDestination struct {
  AccessControlTranslation *AccessControlTranslation `json:"AccessControlTranslation,omitempty"`
  Account string `json:"Account,omitempty"`
  Bucket string `json:"Bucket"`
  EncryptionConfiguration *EncryptionConfiguration `json:"EncryptionConfiguration,omitempty"`
  Metrics *Metrics `json:"Metrics,omitempty"`
  ReplicationTime *ReplicationTime `json:"ReplicationTime,omitempty"`

  // The storage class to use when replicating objects, such as S3 Standard or reduced redundancy.
  StorageClass string `json:"StorageClass,omitempty"`
}

// ReplicationRule Specifies which Amazon S3 objects to replicate and where to store the replicas.
type ReplicationRule struct {
  DeleteMarkerReplication *DeleteMarkerReplication `json:"DeleteMarkerReplication,omitempty"`
  Destination *ReplicationDestination `json:"Destination"`
  Filter *ReplicationRuleFilter `json:"Filter,omitempty"`

  // A unique identifier for the rule.
  Id string `json:"Id,omitempty"`

  // An object key name prefix that identifies the object or objects to which the rule applies.
  Prefix string `json:"Prefix,omitempty"`
  Priority int `json:"Priority,omitempty"`
  SourceSelectionCriteria *SourceSelectionCriteria `json:"SourceSelectionCriteria,omitempty"`

  // Specifies whether the rule is enabled.
  Status string `json:"Status"`
}

// ReplicationRuleAndOperator 
type ReplicationRuleAndOperator struct {
  Prefix string `json:"Prefix,omitempty"`
  TagFilters []*TagFilter `json:"TagFilters,omitempty"`
}

// ReplicationRuleFilter 
type ReplicationRuleFilter struct {
  And *ReplicationRuleAndOperator `json:"And,omitempty"`
  Prefix string `json:"Prefix,omitempty"`
  TagFilter *TagFilter `json:"TagFilter,omitempty"`
}

// ReplicationTime 
type ReplicationTime struct {
  Status string `json:"Status"`
  Time *ReplicationTimeValue `json:"Time"`
}

// ReplicationTimeValue 
type ReplicationTimeValue struct {
  Minutes int `json:"Minutes"`
}

// Resource Resource Type definition for AWS::S3::Bucket
type Resource struct {

  // Configuration for the transfer acceleration state.
  AccelerateConfiguration *AccelerateConfiguration `json:"AccelerateConfiguration,omitempty"`

  // A canned access control list (ACL) that grants predefined permissions to the bucket.
  AccessControl string `json:"AccessControl,omitempty"`

  // The configuration and any analyses for the analytics filter of an Amazon S3 bucket.
  AnalyticsConfigurations []*AnalyticsConfiguration `json:"AnalyticsConfigurations,omitempty"`

  // The Amazon Resource Name (ARN) of the specified bucket.
  Arn string `json:"Arn,omitempty"`
  BucketEncryption *BucketEncryption `json:"BucketEncryption,omitempty"`

  // A name for the bucket. If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the bucket name.
  BucketName string `json:"BucketName,omitempty"`

  // Rules that define cross-origin resource sharing of objects in this bucket.
  CorsConfiguration *CorsConfiguration `json:"CorsConfiguration,omitempty"`

  // The IPv4 DNS name of the specified bucket.
  DomainName string `json:"DomainName,omitempty"`

  // The IPv6 DNS name of the specified bucket. For more information about dual-stack endpoints, see [Using Amazon S3 Dual-Stack Endpoints](https://docs.aws.amazon.com/AmazonS3/latest/dev/dual-stack-endpoints.html).
  DualStackDomainName string `json:"DualStackDomainName,omitempty"`

  // Specifies the S3 Intelligent-Tiering configuration for an Amazon S3 bucket.
  IntelligentTieringConfigurations []*IntelligentTieringConfiguration `json:"IntelligentTieringConfigurations,omitempty"`

  // The inventory configuration for an Amazon S3 bucket.
  InventoryConfigurations []*InventoryConfiguration `json:"InventoryConfigurations,omitempty"`

  // Rules that define how Amazon S3 manages objects during their lifetime.
  LifecycleConfiguration *LifecycleConfiguration `json:"LifecycleConfiguration,omitempty"`

  // Settings that define where logs are stored.
  LoggingConfiguration *LoggingConfiguration `json:"LoggingConfiguration,omitempty"`

  // Settings that define a metrics configuration for the CloudWatch request metrics from the bucket.
  MetricsConfigurations []*MetricsConfiguration `json:"MetricsConfigurations,omitempty"`

  // Configuration that defines how Amazon S3 handles bucket notifications.
  NotificationConfiguration *NotificationConfiguration `json:"NotificationConfiguration,omitempty"`

  // Places an Object Lock configuration on the specified bucket.
  ObjectLockConfiguration *ObjectLockConfiguration `json:"ObjectLockConfiguration,omitempty"`

  // Indicates whether this bucket has an Object Lock configuration enabled.
  ObjectLockEnabled bool `json:"ObjectLockEnabled,omitempty"`

  // Specifies the container element for object ownership rules.
  OwnershipControls *OwnershipControls `json:"OwnershipControls,omitempty"`
  PublicAccessBlockConfiguration *PublicAccessBlockConfiguration `json:"PublicAccessBlockConfiguration,omitempty"`

  // Returns the regional domain name of the specified bucket.
  RegionalDomainName string `json:"RegionalDomainName,omitempty"`

  // Configuration for replicating objects in an S3 bucket.
  ReplicationConfiguration *ReplicationConfiguration `json:"ReplicationConfiguration,omitempty"`

  // An arbitrary set of tags (key-value pairs) for this S3 bucket.
  Tags []*Tag `json:"Tags,omitempty"`
  VersioningConfiguration *VersioningConfiguration `json:"VersioningConfiguration,omitempty"`
  WebsiteConfiguration *WebsiteConfiguration `json:"WebsiteConfiguration,omitempty"`

  // The Amazon S3 website endpoint for the specified bucket.
  WebsiteURL string `json:"WebsiteURL,omitempty"`
}

// RoutingRule Specifies the redirect behavior and when a redirect is applied.
type RoutingRule struct {

  // Container for redirect information. You can redirect requests to another host, to another page, or with another protocol. In the event of an error, you can specify a different error code to return.
  RedirectRule *RedirectRule `json:"RedirectRule"`
  RoutingRuleCondition *RoutingRuleCondition `json:"RoutingRuleCondition,omitempty"`
}

// RoutingRuleCondition A container for describing a condition that must be met for the specified redirect to apply.You must specify at least one of HttpErrorCodeReturnedEquals and KeyPrefixEquals
type RoutingRuleCondition struct {

  // The HTTP error code when the redirect is applied. 
  HttpErrorCodeReturnedEquals string `json:"HttpErrorCodeReturnedEquals,omitempty"`

  // The object key name prefix when the redirect is applied.
  KeyPrefixEquals string `json:"KeyPrefixEquals,omitempty"`
}

// Rule You must specify at least one of the following properties: AbortIncompleteMultipartUpload, ExpirationDate, ExpirationInDays, NoncurrentVersionExpirationInDays, NoncurrentVersionTransition, NoncurrentVersionTransitions, Transition, or Transitions.
type Rule struct {
  AbortIncompleteMultipartUpload *AbortIncompleteMultipartUpload `json:"AbortIncompleteMultipartUpload,omitempty"`
  ExpirationDate string `json:"ExpirationDate,omitempty"`
  ExpirationInDays int `json:"ExpirationInDays,omitempty"`
  ExpiredObjectDeleteMarker bool `json:"ExpiredObjectDeleteMarker,omitempty"`
  Id string `json:"Id,omitempty"`
  NoncurrentVersionExpiration *NoncurrentVersionExpiration `json:"NoncurrentVersionExpiration,omitempty"`
  NoncurrentVersionExpirationInDays int `json:"NoncurrentVersionExpirationInDays,omitempty"`
  NoncurrentVersionTransition *NoncurrentVersionTransition `json:"NoncurrentVersionTransition,omitempty"`
  NoncurrentVersionTransitions []*NoncurrentVersionTransition `json:"NoncurrentVersionTransitions,omitempty"`
  ObjectSizeGreaterThan string `json:"ObjectSizeGreaterThan,omitempty"`
  ObjectSizeLessThan string `json:"ObjectSizeLessThan,omitempty"`
  Prefix string `json:"Prefix,omitempty"`
  Status string `json:"Status"`
  TagFilters []*TagFilter `json:"TagFilters,omitempty"`
  Transition *Transition `json:"Transition,omitempty"`
  Transitions []*Transition `json:"Transitions,omitempty"`
}

// S3KeyFilter A container for object key name prefix and suffix filtering rules.
type S3KeyFilter struct {
  Rules []*FilterRule `json:"Rules"`
}

// ServerSideEncryptionByDefault Specifies the default server-side encryption to apply to new objects in the bucket. If a PUT Object request doesn't specify any server-side encryption, this default encryption will be applied.
type ServerSideEncryptionByDefault struct {

  // "KMSMasterKeyID" can only be used when you set the value of SSEAlgorithm as aws:kms.
  KMSMasterKeyID string `json:"KMSMasterKeyID,omitempty"`
  SSEAlgorithm string `json:"SSEAlgorithm"`
}

// ServerSideEncryptionRule Specifies the default server-side encryption configuration.
type ServerSideEncryptionRule struct {

  // Specifies whether Amazon S3 should use an S3 Bucket Key with server-side encryption using KMS (SSE-KMS) for new objects in the bucket. Existing objects are not affected. Setting the BucketKeyEnabled element to true causes Amazon S3 to use an S3 Bucket Key. By default, S3 Bucket Key is not enabled.
  BucketKeyEnabled bool `json:"BucketKeyEnabled,omitempty"`
  ServerSideEncryptionByDefault *ServerSideEncryptionByDefault `json:"ServerSideEncryptionByDefault,omitempty"`
}

// SourceSelectionCriteria A container that describes additional filters for identifying the source objects that you want to replicate.
type SourceSelectionCriteria struct {

  // A filter that you can specify for selection for modifications on replicas.
  ReplicaModifications *ReplicaModifications `json:"ReplicaModifications,omitempty"`

  // A container for filter information for the selection of Amazon S3 objects encrypted with AWS KMS.
  SseKmsEncryptedObjects *SseKmsEncryptedObjects `json:"SseKmsEncryptedObjects,omitempty"`
}

// SseKmsEncryptedObjects A container for filter information for the selection of S3 objects encrypted with AWS KMS.
type SseKmsEncryptedObjects struct {

  // Specifies whether Amazon S3 replicates objects created with server-side encryption using a customer master key (CMK) stored in AWS Key Management Service.
  Status string `json:"Status"`
}

// StorageClassAnalysis Specifies data related to access patterns to be collected and made available to analyze the tradeoffs between different storage classes for an Amazon S3 bucket.
type StorageClassAnalysis struct {
  DataExport *DataExport `json:"DataExport,omitempty"`
}

// Tag 
type Tag struct {
  Key string `json:"Key"`
  Value string `json:"Value"`
}

// TagFilter Tags to use to identify a subset of objects for an Amazon S3 bucket.
type TagFilter struct {
  Key string `json:"Key"`
  Value string `json:"Value"`
}

// Tiering 
type Tiering struct {

  // S3 Intelligent-Tiering access tier. See Storage class for automatically optimizing frequently and infrequently accessed objects for a list of access tiers in the S3 Intelligent-Tiering storage class.
  AccessTier string `json:"AccessTier"`

  // The number of consecutive days of no access after which an object will be eligible to be transitioned to the corresponding tier. The minimum number of days specified for Archive Access tier must be at least 90 days and Deep Archive Access tier must be at least 180 days. The maximum can be up to 2 years (730 days).
  Days int `json:"Days"`
}

// TopicConfiguration The topic to which notifications are sent and the events for which notifications are generated.
type TopicConfiguration struct {

  // The Amazon S3 bucket event about which to send notifications.
  Event string `json:"Event"`

  // The filtering rules that determine for which objects to send notifications.
  Filter *NotificationFilter `json:"Filter,omitempty"`

  // The Amazon Resource Name (ARN) of the Amazon SNS topic to which Amazon S3 publishes a message when it detects events of the specified type.
  Topic string `json:"Topic"`
}

// Transition You must specify at least one of "TransitionDate" and "TransitionInDays"
type Transition struct {
  StorageClass string `json:"StorageClass"`
  TransitionDate string `json:"TransitionDate,omitempty"`
  TransitionInDays int `json:"TransitionInDays,omitempty"`
}

// VersioningConfiguration Describes the versioning state of an Amazon S3 bucket.
type VersioningConfiguration struct {

  // The versioning state of the bucket.
  Status string `json:"Status"`
}

// WebsiteConfiguration Specifies website configuration parameters for an Amazon S3 bucket.
type WebsiteConfiguration struct {

  // The name of the error document for the website.
  ErrorDocument string `json:"ErrorDocument,omitempty"`

  // The name of the index document for the website.
  IndexDocument string `json:"IndexDocument,omitempty"`
  RedirectAllRequestsTo *RedirectAllRequestsTo `json:"RedirectAllRequestsTo,omitempty"`
  RoutingRules []*RoutingRule `json:"RoutingRules,omitempty"`
}

func (strct *AbortIncompleteMultipartUpload) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "DaysAfterInitiation" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "DaysAfterInitiation" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DaysAfterInitiation\": ")
	if tmp, err := json.Marshal(strct.DaysAfterInitiation); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AbortIncompleteMultipartUpload) UnmarshalJSON(b []byte) error {
    DaysAfterInitiationReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DaysAfterInitiation":
            if err := json.Unmarshal([]byte(v), &strct.DaysAfterInitiation); err != nil {
                return err
             }
            DaysAfterInitiationReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if DaysAfterInitiation (a required property) was received
    if !DaysAfterInitiationReceived {
        return errors.New("\"DaysAfterInitiation\" is required but was not present")
    }
    return nil
}

func (strct *AccelerateConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AccelerationStatus" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AccelerationStatus" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AccelerationStatus\": ")
	if tmp, err := json.Marshal(strct.AccelerationStatus); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AccelerateConfiguration) UnmarshalJSON(b []byte) error {
    AccelerationStatusReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AccelerationStatus":
            if err := json.Unmarshal([]byte(v), &strct.AccelerationStatus); err != nil {
                return err
             }
            AccelerationStatusReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if AccelerationStatus (a required property) was received
    if !AccelerationStatusReceived {
        return errors.New("\"AccelerationStatus\" is required but was not present")
    }
    return nil
}

func (strct *AccessControlTranslation) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Owner" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Owner" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Owner\": ")
	if tmp, err := json.Marshal(strct.Owner); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AccessControlTranslation) UnmarshalJSON(b []byte) error {
    OwnerReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Owner":
            if err := json.Unmarshal([]byte(v), &strct.Owner); err != nil {
                return err
             }
            OwnerReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Owner (a required property) was received
    if !OwnerReceived {
        return errors.New("\"Owner\" is required but was not present")
    }
    return nil
}

func (strct *AnalyticsConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Id" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Id" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Prefix" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Prefix\": ")
	if tmp, err := json.Marshal(strct.Prefix); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "StorageClassAnalysis" field is required
    if strct.StorageClassAnalysis == nil {
        return nil, errors.New("StorageClassAnalysis is a required field")
    }
    // Marshal the "StorageClassAnalysis" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StorageClassAnalysis\": ")
	if tmp, err := json.Marshal(strct.StorageClassAnalysis); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TagFilters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TagFilters\": ")
	if tmp, err := json.Marshal(strct.TagFilters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AnalyticsConfiguration) UnmarshalJSON(b []byte) error {
    IdReceived := false
    StorageClassAnalysisReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
            IdReceived = true
        case "Prefix":
            if err := json.Unmarshal([]byte(v), &strct.Prefix); err != nil {
                return err
             }
        case "StorageClassAnalysis":
            if err := json.Unmarshal([]byte(v), &strct.StorageClassAnalysis); err != nil {
                return err
             }
            StorageClassAnalysisReceived = true
        case "TagFilters":
            if err := json.Unmarshal([]byte(v), &strct.TagFilters); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Id (a required property) was received
    if !IdReceived {
        return errors.New("\"Id\" is required but was not present")
    }
    // check if StorageClassAnalysis (a required property) was received
    if !StorageClassAnalysisReceived {
        return errors.New("\"StorageClassAnalysis\" is required but was not present")
    }
    return nil
}

func (strct *BucketEncryption) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ServerSideEncryptionConfiguration" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ServerSideEncryptionConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ServerSideEncryptionConfiguration\": ")
	if tmp, err := json.Marshal(strct.ServerSideEncryptionConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BucketEncryption) UnmarshalJSON(b []byte) error {
    ServerSideEncryptionConfigurationReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ServerSideEncryptionConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.ServerSideEncryptionConfiguration); err != nil {
                return err
             }
            ServerSideEncryptionConfigurationReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ServerSideEncryptionConfiguration (a required property) was received
    if !ServerSideEncryptionConfigurationReceived {
        return errors.New("\"ServerSideEncryptionConfiguration\" is required but was not present")
    }
    return nil
}

func (strct *CorsConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "CorsRules" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "CorsRules" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CorsRules\": ")
	if tmp, err := json.Marshal(strct.CorsRules); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CorsConfiguration) UnmarshalJSON(b []byte) error {
    CorsRulesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CorsRules":
            if err := json.Unmarshal([]byte(v), &strct.CorsRules); err != nil {
                return err
             }
            CorsRulesReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if CorsRules (a required property) was received
    if !CorsRulesReceived {
        return errors.New("\"CorsRules\" is required but was not present")
    }
    return nil
}

func (strct *CorsRule) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AllowedHeaders" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AllowedHeaders\": ")
	if tmp, err := json.Marshal(strct.AllowedHeaders); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "AllowedMethods" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AllowedMethods" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AllowedMethods\": ")
	if tmp, err := json.Marshal(strct.AllowedMethods); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "AllowedOrigins" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AllowedOrigins" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AllowedOrigins\": ")
	if tmp, err := json.Marshal(strct.AllowedOrigins); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ExposedHeaders" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ExposedHeaders\": ")
	if tmp, err := json.Marshal(strct.ExposedHeaders); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Id" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MaxAge" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaxAge\": ")
	if tmp, err := json.Marshal(strct.MaxAge); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CorsRule) UnmarshalJSON(b []byte) error {
    AllowedMethodsReceived := false
    AllowedOriginsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AllowedHeaders":
            if err := json.Unmarshal([]byte(v), &strct.AllowedHeaders); err != nil {
                return err
             }
        case "AllowedMethods":
            if err := json.Unmarshal([]byte(v), &strct.AllowedMethods); err != nil {
                return err
             }
            AllowedMethodsReceived = true
        case "AllowedOrigins":
            if err := json.Unmarshal([]byte(v), &strct.AllowedOrigins); err != nil {
                return err
             }
            AllowedOriginsReceived = true
        case "ExposedHeaders":
            if err := json.Unmarshal([]byte(v), &strct.ExposedHeaders); err != nil {
                return err
             }
        case "Id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
        case "MaxAge":
            if err := json.Unmarshal([]byte(v), &strct.MaxAge); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if AllowedMethods (a required property) was received
    if !AllowedMethodsReceived {
        return errors.New("\"AllowedMethods\" is required but was not present")
    }
    // check if AllowedOrigins (a required property) was received
    if !AllowedOriginsReceived {
        return errors.New("\"AllowedOrigins\" is required but was not present")
    }
    return nil
}

func (strct *DataExport) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Destination" field is required
    if strct.Destination == nil {
        return nil, errors.New("Destination is a required field")
    }
    // Marshal the "Destination" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Destination\": ")
	if tmp, err := json.Marshal(strct.Destination); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "OutputSchemaVersion" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "OutputSchemaVersion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OutputSchemaVersion\": ")
	if tmp, err := json.Marshal(strct.OutputSchemaVersion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DataExport) UnmarshalJSON(b []byte) error {
    DestinationReceived := false
    OutputSchemaVersionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Destination":
            if err := json.Unmarshal([]byte(v), &strct.Destination); err != nil {
                return err
             }
            DestinationReceived = true
        case "OutputSchemaVersion":
            if err := json.Unmarshal([]byte(v), &strct.OutputSchemaVersion); err != nil {
                return err
             }
            OutputSchemaVersionReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Destination (a required property) was received
    if !DestinationReceived {
        return errors.New("\"Destination\" is required but was not present")
    }
    // check if OutputSchemaVersion (a required property) was received
    if !OutputSchemaVersionReceived {
        return errors.New("\"OutputSchemaVersion\" is required but was not present")
    }
    return nil
}

func (strct *DefaultRetention) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Days" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Days\": ")
	if tmp, err := json.Marshal(strct.Days); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Mode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Mode\": ")
	if tmp, err := json.Marshal(strct.Mode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Years" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Years\": ")
	if tmp, err := json.Marshal(strct.Years); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DefaultRetention) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Days":
            if err := json.Unmarshal([]byte(v), &strct.Days); err != nil {
                return err
             }
        case "Mode":
            if err := json.Unmarshal([]byte(v), &strct.Mode); err != nil {
                return err
             }
        case "Years":
            if err := json.Unmarshal([]byte(v), &strct.Years); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *DeleteMarkerReplication) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Status" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Status\": ")
	if tmp, err := json.Marshal(strct.Status); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DeleteMarkerReplication) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Status":
            if err := json.Unmarshal([]byte(v), &strct.Status); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Destination) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "BucketAccountId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BucketAccountId\": ")
	if tmp, err := json.Marshal(strct.BucketAccountId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "BucketArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "BucketArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BucketArn\": ")
	if tmp, err := json.Marshal(strct.BucketArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Format" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Format" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Format\": ")
	if tmp, err := json.Marshal(strct.Format); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Prefix" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Prefix\": ")
	if tmp, err := json.Marshal(strct.Prefix); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Destination) UnmarshalJSON(b []byte) error {
    BucketArnReceived := false
    FormatReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BucketAccountId":
            if err := json.Unmarshal([]byte(v), &strct.BucketAccountId); err != nil {
                return err
             }
        case "BucketArn":
            if err := json.Unmarshal([]byte(v), &strct.BucketArn); err != nil {
                return err
             }
            BucketArnReceived = true
        case "Format":
            if err := json.Unmarshal([]byte(v), &strct.Format); err != nil {
                return err
             }
            FormatReceived = true
        case "Prefix":
            if err := json.Unmarshal([]byte(v), &strct.Prefix); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if BucketArn (a required property) was received
    if !BucketArnReceived {
        return errors.New("\"BucketArn\" is required but was not present")
    }
    // check if Format (a required property) was received
    if !FormatReceived {
        return errors.New("\"Format\" is required but was not present")
    }
    return nil
}

func (strct *EncryptionConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ReplicaKmsKeyID" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ReplicaKmsKeyID" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ReplicaKmsKeyID\": ")
	if tmp, err := json.Marshal(strct.ReplicaKmsKeyID); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *EncryptionConfiguration) UnmarshalJSON(b []byte) error {
    ReplicaKmsKeyIDReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ReplicaKmsKeyID":
            if err := json.Unmarshal([]byte(v), &strct.ReplicaKmsKeyID); err != nil {
                return err
             }
            ReplicaKmsKeyIDReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ReplicaKmsKeyID (a required property) was received
    if !ReplicaKmsKeyIDReceived {
        return errors.New("\"ReplicaKmsKeyID\" is required but was not present")
    }
    return nil
}

func (strct *EventBridgeConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "EventBridgeEnabled" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "EventBridgeEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EventBridgeEnabled\": ")
	if tmp, err := json.Marshal(strct.EventBridgeEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *EventBridgeConfiguration) UnmarshalJSON(b []byte) error {
    EventBridgeEnabledReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "EventBridgeEnabled":
            if err := json.Unmarshal([]byte(v), &strct.EventBridgeEnabled); err != nil {
                return err
             }
            EventBridgeEnabledReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if EventBridgeEnabled (a required property) was received
    if !EventBridgeEnabledReceived {
        return errors.New("\"EventBridgeEnabled\" is required but was not present")
    }
    return nil
}

func (strct *FilterRule) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FilterRule) UnmarshalJSON(b []byte) error {
    NameReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *IntelligentTieringConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Id" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Id" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Prefix" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Prefix\": ")
	if tmp, err := json.Marshal(strct.Prefix); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Status" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Status" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Status\": ")
	if tmp, err := json.Marshal(strct.Status); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TagFilters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TagFilters\": ")
	if tmp, err := json.Marshal(strct.TagFilters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Tierings" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Tierings" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tierings\": ")
	if tmp, err := json.Marshal(strct.Tierings); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *IntelligentTieringConfiguration) UnmarshalJSON(b []byte) error {
    IdReceived := false
    StatusReceived := false
    TieringsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
            IdReceived = true
        case "Prefix":
            if err := json.Unmarshal([]byte(v), &strct.Prefix); err != nil {
                return err
             }
        case "Status":
            if err := json.Unmarshal([]byte(v), &strct.Status); err != nil {
                return err
             }
            StatusReceived = true
        case "TagFilters":
            if err := json.Unmarshal([]byte(v), &strct.TagFilters); err != nil {
                return err
             }
        case "Tierings":
            if err := json.Unmarshal([]byte(v), &strct.Tierings); err != nil {
                return err
             }
            TieringsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Id (a required property) was received
    if !IdReceived {
        return errors.New("\"Id\" is required but was not present")
    }
    // check if Status (a required property) was received
    if !StatusReceived {
        return errors.New("\"Status\" is required but was not present")
    }
    // check if Tierings (a required property) was received
    if !TieringsReceived {
        return errors.New("\"Tierings\" is required but was not present")
    }
    return nil
}

func (strct *InventoryConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Destination" field is required
    if strct.Destination == nil {
        return nil, errors.New("Destination is a required field")
    }
    // Marshal the "Destination" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Destination\": ")
	if tmp, err := json.Marshal(strct.Destination); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Enabled" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Enabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Id" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Id" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "IncludedObjectVersions" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "IncludedObjectVersions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IncludedObjectVersions\": ")
	if tmp, err := json.Marshal(strct.IncludedObjectVersions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OptionalFields" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OptionalFields\": ")
	if tmp, err := json.Marshal(strct.OptionalFields); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Prefix" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Prefix\": ")
	if tmp, err := json.Marshal(strct.Prefix); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ScheduleFrequency" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ScheduleFrequency" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ScheduleFrequency\": ")
	if tmp, err := json.Marshal(strct.ScheduleFrequency); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *InventoryConfiguration) UnmarshalJSON(b []byte) error {
    DestinationReceived := false
    EnabledReceived := false
    IdReceived := false
    IncludedObjectVersionsReceived := false
    ScheduleFrequencyReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Destination":
            if err := json.Unmarshal([]byte(v), &strct.Destination); err != nil {
                return err
             }
            DestinationReceived = true
        case "Enabled":
            if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
                return err
             }
            EnabledReceived = true
        case "Id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
            IdReceived = true
        case "IncludedObjectVersions":
            if err := json.Unmarshal([]byte(v), &strct.IncludedObjectVersions); err != nil {
                return err
             }
            IncludedObjectVersionsReceived = true
        case "OptionalFields":
            if err := json.Unmarshal([]byte(v), &strct.OptionalFields); err != nil {
                return err
             }
        case "Prefix":
            if err := json.Unmarshal([]byte(v), &strct.Prefix); err != nil {
                return err
             }
        case "ScheduleFrequency":
            if err := json.Unmarshal([]byte(v), &strct.ScheduleFrequency); err != nil {
                return err
             }
            ScheduleFrequencyReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Destination (a required property) was received
    if !DestinationReceived {
        return errors.New("\"Destination\" is required but was not present")
    }
    // check if Enabled (a required property) was received
    if !EnabledReceived {
        return errors.New("\"Enabled\" is required but was not present")
    }
    // check if Id (a required property) was received
    if !IdReceived {
        return errors.New("\"Id\" is required but was not present")
    }
    // check if IncludedObjectVersions (a required property) was received
    if !IncludedObjectVersionsReceived {
        return errors.New("\"IncludedObjectVersions\" is required but was not present")
    }
    // check if ScheduleFrequency (a required property) was received
    if !ScheduleFrequencyReceived {
        return errors.New("\"ScheduleFrequency\" is required but was not present")
    }
    return nil
}

func (strct *LambdaConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Event" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Event" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Event\": ")
	if tmp, err := json.Marshal(strct.Event); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Filter" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Filter\": ")
	if tmp, err := json.Marshal(strct.Filter); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Function" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Function" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Function\": ")
	if tmp, err := json.Marshal(strct.Function); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LambdaConfiguration) UnmarshalJSON(b []byte) error {
    EventReceived := false
    FunctionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Event":
            if err := json.Unmarshal([]byte(v), &strct.Event); err != nil {
                return err
             }
            EventReceived = true
        case "Filter":
            if err := json.Unmarshal([]byte(v), &strct.Filter); err != nil {
                return err
             }
        case "Function":
            if err := json.Unmarshal([]byte(v), &strct.Function); err != nil {
                return err
             }
            FunctionReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Event (a required property) was received
    if !EventReceived {
        return errors.New("\"Event\" is required but was not present")
    }
    // check if Function (a required property) was received
    if !FunctionReceived {
        return errors.New("\"Function\" is required but was not present")
    }
    return nil
}

func (strct *LifecycleConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Rules" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Rules" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Rules\": ")
	if tmp, err := json.Marshal(strct.Rules); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LifecycleConfiguration) UnmarshalJSON(b []byte) error {
    RulesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Rules":
            if err := json.Unmarshal([]byte(v), &strct.Rules); err != nil {
                return err
             }
            RulesReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Rules (a required property) was received
    if !RulesReceived {
        return errors.New("\"Rules\" is required but was not present")
    }
    return nil
}

func (strct *LoggingConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DestinationBucketName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DestinationBucketName\": ")
	if tmp, err := json.Marshal(strct.DestinationBucketName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LogFilePrefix" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LogFilePrefix\": ")
	if tmp, err := json.Marshal(strct.LogFilePrefix); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LoggingConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DestinationBucketName":
            if err := json.Unmarshal([]byte(v), &strct.DestinationBucketName); err != nil {
                return err
             }
        case "LogFilePrefix":
            if err := json.Unmarshal([]byte(v), &strct.LogFilePrefix); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Metrics) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "EventThreshold" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EventThreshold\": ")
	if tmp, err := json.Marshal(strct.EventThreshold); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Status" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Status" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Status\": ")
	if tmp, err := json.Marshal(strct.Status); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Metrics) UnmarshalJSON(b []byte) error {
    StatusReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "EventThreshold":
            if err := json.Unmarshal([]byte(v), &strct.EventThreshold); err != nil {
                return err
             }
        case "Status":
            if err := json.Unmarshal([]byte(v), &strct.Status); err != nil {
                return err
             }
            StatusReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Status (a required property) was received
    if !StatusReceived {
        return errors.New("\"Status\" is required but was not present")
    }
    return nil
}

func (strct *MetricsConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AccessPointArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AccessPointArn\": ")
	if tmp, err := json.Marshal(strct.AccessPointArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Id" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Id" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Prefix" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Prefix\": ")
	if tmp, err := json.Marshal(strct.Prefix); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TagFilters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TagFilters\": ")
	if tmp, err := json.Marshal(strct.TagFilters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MetricsConfiguration) UnmarshalJSON(b []byte) error {
    IdReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AccessPointArn":
            if err := json.Unmarshal([]byte(v), &strct.AccessPointArn); err != nil {
                return err
             }
        case "Id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
            IdReceived = true
        case "Prefix":
            if err := json.Unmarshal([]byte(v), &strct.Prefix); err != nil {
                return err
             }
        case "TagFilters":
            if err := json.Unmarshal([]byte(v), &strct.TagFilters); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Id (a required property) was received
    if !IdReceived {
        return errors.New("\"Id\" is required but was not present")
    }
    return nil
}

func (strct *NoncurrentVersionExpiration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "NewerNoncurrentVersions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NewerNoncurrentVersions\": ")
	if tmp, err := json.Marshal(strct.NewerNoncurrentVersions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "NoncurrentDays" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "NoncurrentDays" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NoncurrentDays\": ")
	if tmp, err := json.Marshal(strct.NoncurrentDays); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *NoncurrentVersionExpiration) UnmarshalJSON(b []byte) error {
    NoncurrentDaysReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "NewerNoncurrentVersions":
            if err := json.Unmarshal([]byte(v), &strct.NewerNoncurrentVersions); err != nil {
                return err
             }
        case "NoncurrentDays":
            if err := json.Unmarshal([]byte(v), &strct.NoncurrentDays); err != nil {
                return err
             }
            NoncurrentDaysReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if NoncurrentDays (a required property) was received
    if !NoncurrentDaysReceived {
        return errors.New("\"NoncurrentDays\" is required but was not present")
    }
    return nil
}

func (strct *NoncurrentVersionTransition) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "NewerNoncurrentVersions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NewerNoncurrentVersions\": ")
	if tmp, err := json.Marshal(strct.NewerNoncurrentVersions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "StorageClass" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "StorageClass" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StorageClass\": ")
	if tmp, err := json.Marshal(strct.StorageClass); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TransitionInDays" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TransitionInDays" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TransitionInDays\": ")
	if tmp, err := json.Marshal(strct.TransitionInDays); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *NoncurrentVersionTransition) UnmarshalJSON(b []byte) error {
    StorageClassReceived := false
    TransitionInDaysReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "NewerNoncurrentVersions":
            if err := json.Unmarshal([]byte(v), &strct.NewerNoncurrentVersions); err != nil {
                return err
             }
        case "StorageClass":
            if err := json.Unmarshal([]byte(v), &strct.StorageClass); err != nil {
                return err
             }
            StorageClassReceived = true
        case "TransitionInDays":
            if err := json.Unmarshal([]byte(v), &strct.TransitionInDays); err != nil {
                return err
             }
            TransitionInDaysReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if StorageClass (a required property) was received
    if !StorageClassReceived {
        return errors.New("\"StorageClass\" is required but was not present")
    }
    // check if TransitionInDays (a required property) was received
    if !TransitionInDaysReceived {
        return errors.New("\"TransitionInDays\" is required but was not present")
    }
    return nil
}

func (strct *NotificationConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "EventBridgeConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EventBridgeConfiguration\": ")
	if tmp, err := json.Marshal(strct.EventBridgeConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LambdaConfigurations" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LambdaConfigurations\": ")
	if tmp, err := json.Marshal(strct.LambdaConfigurations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "QueueConfigurations" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"QueueConfigurations\": ")
	if tmp, err := json.Marshal(strct.QueueConfigurations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TopicConfigurations" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TopicConfigurations\": ")
	if tmp, err := json.Marshal(strct.TopicConfigurations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *NotificationConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "EventBridgeConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.EventBridgeConfiguration); err != nil {
                return err
             }
        case "LambdaConfigurations":
            if err := json.Unmarshal([]byte(v), &strct.LambdaConfigurations); err != nil {
                return err
             }
        case "QueueConfigurations":
            if err := json.Unmarshal([]byte(v), &strct.QueueConfigurations); err != nil {
                return err
             }
        case "TopicConfigurations":
            if err := json.Unmarshal([]byte(v), &strct.TopicConfigurations); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *NotificationFilter) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "S3Key" field is required
    if strct.S3Key == nil {
        return nil, errors.New("S3Key is a required field")
    }
    // Marshal the "S3Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3Key\": ")
	if tmp, err := json.Marshal(strct.S3Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *NotificationFilter) UnmarshalJSON(b []byte) error {
    S3KeyReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "S3Key":
            if err := json.Unmarshal([]byte(v), &strct.S3Key); err != nil {
                return err
             }
            S3KeyReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if S3Key (a required property) was received
    if !S3KeyReceived {
        return errors.New("\"S3Key\" is required but was not present")
    }
    return nil
}

func (strct *ObjectLockConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ObjectLockEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ObjectLockEnabled\": ")
	if tmp, err := json.Marshal(strct.ObjectLockEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Rule" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Rule\": ")
	if tmp, err := json.Marshal(strct.Rule); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ObjectLockConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ObjectLockEnabled":
            if err := json.Unmarshal([]byte(v), &strct.ObjectLockEnabled); err != nil {
                return err
             }
        case "Rule":
            if err := json.Unmarshal([]byte(v), &strct.Rule); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ObjectLockRule) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DefaultRetention" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DefaultRetention\": ")
	if tmp, err := json.Marshal(strct.DefaultRetention); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ObjectLockRule) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DefaultRetention":
            if err := json.Unmarshal([]byte(v), &strct.DefaultRetention); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *OwnershipControls) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Rules" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Rules" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Rules\": ")
	if tmp, err := json.Marshal(strct.Rules); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *OwnershipControls) UnmarshalJSON(b []byte) error {
    RulesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Rules":
            if err := json.Unmarshal([]byte(v), &strct.Rules); err != nil {
                return err
             }
            RulesReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Rules (a required property) was received
    if !RulesReceived {
        return errors.New("\"Rules\" is required but was not present")
    }
    return nil
}

func (strct *OwnershipControlsRule) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ObjectOwnership" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ObjectOwnership\": ")
	if tmp, err := json.Marshal(strct.ObjectOwnership); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *OwnershipControlsRule) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ObjectOwnership":
            if err := json.Unmarshal([]byte(v), &strct.ObjectOwnership); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *PublicAccessBlockConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "BlockPublicAcls" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BlockPublicAcls\": ")
	if tmp, err := json.Marshal(strct.BlockPublicAcls); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BlockPublicPolicy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BlockPublicPolicy\": ")
	if tmp, err := json.Marshal(strct.BlockPublicPolicy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IgnorePublicAcls" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IgnorePublicAcls\": ")
	if tmp, err := json.Marshal(strct.IgnorePublicAcls); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RestrictPublicBuckets" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RestrictPublicBuckets\": ")
	if tmp, err := json.Marshal(strct.RestrictPublicBuckets); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PublicAccessBlockConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BlockPublicAcls":
            if err := json.Unmarshal([]byte(v), &strct.BlockPublicAcls); err != nil {
                return err
             }
        case "BlockPublicPolicy":
            if err := json.Unmarshal([]byte(v), &strct.BlockPublicPolicy); err != nil {
                return err
             }
        case "IgnorePublicAcls":
            if err := json.Unmarshal([]byte(v), &strct.IgnorePublicAcls); err != nil {
                return err
             }
        case "RestrictPublicBuckets":
            if err := json.Unmarshal([]byte(v), &strct.RestrictPublicBuckets); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *QueueConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Event" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Event" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Event\": ")
	if tmp, err := json.Marshal(strct.Event); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Filter" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Filter\": ")
	if tmp, err := json.Marshal(strct.Filter); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Queue" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Queue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Queue\": ")
	if tmp, err := json.Marshal(strct.Queue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *QueueConfiguration) UnmarshalJSON(b []byte) error {
    EventReceived := false
    QueueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Event":
            if err := json.Unmarshal([]byte(v), &strct.Event); err != nil {
                return err
             }
            EventReceived = true
        case "Filter":
            if err := json.Unmarshal([]byte(v), &strct.Filter); err != nil {
                return err
             }
        case "Queue":
            if err := json.Unmarshal([]byte(v), &strct.Queue); err != nil {
                return err
             }
            QueueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Event (a required property) was received
    if !EventReceived {
        return errors.New("\"Event\" is required but was not present")
    }
    // check if Queue (a required property) was received
    if !QueueReceived {
        return errors.New("\"Queue\" is required but was not present")
    }
    return nil
}

func (strct *RedirectAllRequestsTo) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "HostName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "HostName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HostName\": ")
	if tmp, err := json.Marshal(strct.HostName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Protocol" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Protocol\": ")
	if tmp, err := json.Marshal(strct.Protocol); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RedirectAllRequestsTo) UnmarshalJSON(b []byte) error {
    HostNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "HostName":
            if err := json.Unmarshal([]byte(v), &strct.HostName); err != nil {
                return err
             }
            HostNameReceived = true
        case "Protocol":
            if err := json.Unmarshal([]byte(v), &strct.Protocol); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if HostName (a required property) was received
    if !HostNameReceived {
        return errors.New("\"HostName\" is required but was not present")
    }
    return nil
}

func (strct *RedirectRule) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "HostName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HostName\": ")
	if tmp, err := json.Marshal(strct.HostName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "HttpRedirectCode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HttpRedirectCode\": ")
	if tmp, err := json.Marshal(strct.HttpRedirectCode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Protocol" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Protocol\": ")
	if tmp, err := json.Marshal(strct.Protocol); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ReplaceKeyPrefixWith" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ReplaceKeyPrefixWith\": ")
	if tmp, err := json.Marshal(strct.ReplaceKeyPrefixWith); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ReplaceKeyWith" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ReplaceKeyWith\": ")
	if tmp, err := json.Marshal(strct.ReplaceKeyWith); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RedirectRule) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "HostName":
            if err := json.Unmarshal([]byte(v), &strct.HostName); err != nil {
                return err
             }
        case "HttpRedirectCode":
            if err := json.Unmarshal([]byte(v), &strct.HttpRedirectCode); err != nil {
                return err
             }
        case "Protocol":
            if err := json.Unmarshal([]byte(v), &strct.Protocol); err != nil {
                return err
             }
        case "ReplaceKeyPrefixWith":
            if err := json.Unmarshal([]byte(v), &strct.ReplaceKeyPrefixWith); err != nil {
                return err
             }
        case "ReplaceKeyWith":
            if err := json.Unmarshal([]byte(v), &strct.ReplaceKeyWith); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ReplicaModifications) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Status" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Status" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Status\": ")
	if tmp, err := json.Marshal(strct.Status); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ReplicaModifications) UnmarshalJSON(b []byte) error {
    StatusReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Status":
            if err := json.Unmarshal([]byte(v), &strct.Status); err != nil {
                return err
             }
            StatusReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Status (a required property) was received
    if !StatusReceived {
        return errors.New("\"Status\" is required but was not present")
    }
    return nil
}

func (strct *ReplicationConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Role" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Role" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Role\": ")
	if tmp, err := json.Marshal(strct.Role); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Rules" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Rules" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Rules\": ")
	if tmp, err := json.Marshal(strct.Rules); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ReplicationConfiguration) UnmarshalJSON(b []byte) error {
    RoleReceived := false
    RulesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Role":
            if err := json.Unmarshal([]byte(v), &strct.Role); err != nil {
                return err
             }
            RoleReceived = true
        case "Rules":
            if err := json.Unmarshal([]byte(v), &strct.Rules); err != nil {
                return err
             }
            RulesReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Role (a required property) was received
    if !RoleReceived {
        return errors.New("\"Role\" is required but was not present")
    }
    // check if Rules (a required property) was received
    if !RulesReceived {
        return errors.New("\"Rules\" is required but was not present")
    }
    return nil
}

func (strct *ReplicationDestination) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AccessControlTranslation" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AccessControlTranslation\": ")
	if tmp, err := json.Marshal(strct.AccessControlTranslation); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Account" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Account\": ")
	if tmp, err := json.Marshal(strct.Account); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Bucket" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Bucket" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Bucket\": ")
	if tmp, err := json.Marshal(strct.Bucket); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EncryptionConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EncryptionConfiguration\": ")
	if tmp, err := json.Marshal(strct.EncryptionConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Metrics" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Metrics\": ")
	if tmp, err := json.Marshal(strct.Metrics); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ReplicationTime" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ReplicationTime\": ")
	if tmp, err := json.Marshal(strct.ReplicationTime); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StorageClass" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StorageClass\": ")
	if tmp, err := json.Marshal(strct.StorageClass); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ReplicationDestination) UnmarshalJSON(b []byte) error {
    BucketReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AccessControlTranslation":
            if err := json.Unmarshal([]byte(v), &strct.AccessControlTranslation); err != nil {
                return err
             }
        case "Account":
            if err := json.Unmarshal([]byte(v), &strct.Account); err != nil {
                return err
             }
        case "Bucket":
            if err := json.Unmarshal([]byte(v), &strct.Bucket); err != nil {
                return err
             }
            BucketReceived = true
        case "EncryptionConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.EncryptionConfiguration); err != nil {
                return err
             }
        case "Metrics":
            if err := json.Unmarshal([]byte(v), &strct.Metrics); err != nil {
                return err
             }
        case "ReplicationTime":
            if err := json.Unmarshal([]byte(v), &strct.ReplicationTime); err != nil {
                return err
             }
        case "StorageClass":
            if err := json.Unmarshal([]byte(v), &strct.StorageClass); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Bucket (a required property) was received
    if !BucketReceived {
        return errors.New("\"Bucket\" is required but was not present")
    }
    return nil
}

func (strct *ReplicationRule) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DeleteMarkerReplication" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DeleteMarkerReplication\": ")
	if tmp, err := json.Marshal(strct.DeleteMarkerReplication); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Destination" field is required
    if strct.Destination == nil {
        return nil, errors.New("Destination is a required field")
    }
    // Marshal the "Destination" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Destination\": ")
	if tmp, err := json.Marshal(strct.Destination); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Filter" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Filter\": ")
	if tmp, err := json.Marshal(strct.Filter); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Id" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Prefix" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Prefix\": ")
	if tmp, err := json.Marshal(strct.Prefix); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Priority" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Priority\": ")
	if tmp, err := json.Marshal(strct.Priority); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SourceSelectionCriteria" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SourceSelectionCriteria\": ")
	if tmp, err := json.Marshal(strct.SourceSelectionCriteria); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Status" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Status" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Status\": ")
	if tmp, err := json.Marshal(strct.Status); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ReplicationRule) UnmarshalJSON(b []byte) error {
    DestinationReceived := false
    StatusReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DeleteMarkerReplication":
            if err := json.Unmarshal([]byte(v), &strct.DeleteMarkerReplication); err != nil {
                return err
             }
        case "Destination":
            if err := json.Unmarshal([]byte(v), &strct.Destination); err != nil {
                return err
             }
            DestinationReceived = true
        case "Filter":
            if err := json.Unmarshal([]byte(v), &strct.Filter); err != nil {
                return err
             }
        case "Id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
        case "Prefix":
            if err := json.Unmarshal([]byte(v), &strct.Prefix); err != nil {
                return err
             }
        case "Priority":
            if err := json.Unmarshal([]byte(v), &strct.Priority); err != nil {
                return err
             }
        case "SourceSelectionCriteria":
            if err := json.Unmarshal([]byte(v), &strct.SourceSelectionCriteria); err != nil {
                return err
             }
        case "Status":
            if err := json.Unmarshal([]byte(v), &strct.Status); err != nil {
                return err
             }
            StatusReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Destination (a required property) was received
    if !DestinationReceived {
        return errors.New("\"Destination\" is required but was not present")
    }
    // check if Status (a required property) was received
    if !StatusReceived {
        return errors.New("\"Status\" is required but was not present")
    }
    return nil
}

func (strct *ReplicationRuleAndOperator) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Prefix" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Prefix\": ")
	if tmp, err := json.Marshal(strct.Prefix); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TagFilters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TagFilters\": ")
	if tmp, err := json.Marshal(strct.TagFilters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ReplicationRuleAndOperator) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Prefix":
            if err := json.Unmarshal([]byte(v), &strct.Prefix); err != nil {
                return err
             }
        case "TagFilters":
            if err := json.Unmarshal([]byte(v), &strct.TagFilters); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ReplicationRuleFilter) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "And" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"And\": ")
	if tmp, err := json.Marshal(strct.And); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Prefix" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Prefix\": ")
	if tmp, err := json.Marshal(strct.Prefix); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TagFilter" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TagFilter\": ")
	if tmp, err := json.Marshal(strct.TagFilter); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ReplicationRuleFilter) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "And":
            if err := json.Unmarshal([]byte(v), &strct.And); err != nil {
                return err
             }
        case "Prefix":
            if err := json.Unmarshal([]byte(v), &strct.Prefix); err != nil {
                return err
             }
        case "TagFilter":
            if err := json.Unmarshal([]byte(v), &strct.TagFilter); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ReplicationTime) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Status" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Status" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Status\": ")
	if tmp, err := json.Marshal(strct.Status); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Time" field is required
    if strct.Time == nil {
        return nil, errors.New("Time is a required field")
    }
    // Marshal the "Time" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Time\": ")
	if tmp, err := json.Marshal(strct.Time); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ReplicationTime) UnmarshalJSON(b []byte) error {
    StatusReceived := false
    TimeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Status":
            if err := json.Unmarshal([]byte(v), &strct.Status); err != nil {
                return err
             }
            StatusReceived = true
        case "Time":
            if err := json.Unmarshal([]byte(v), &strct.Time); err != nil {
                return err
             }
            TimeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Status (a required property) was received
    if !StatusReceived {
        return errors.New("\"Status\" is required but was not present")
    }
    // check if Time (a required property) was received
    if !TimeReceived {
        return errors.New("\"Time\" is required but was not present")
    }
    return nil
}

func (strct *ReplicationTimeValue) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Minutes" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Minutes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Minutes\": ")
	if tmp, err := json.Marshal(strct.Minutes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ReplicationTimeValue) UnmarshalJSON(b []byte) error {
    MinutesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Minutes":
            if err := json.Unmarshal([]byte(v), &strct.Minutes); err != nil {
                return err
             }
            MinutesReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Minutes (a required property) was received
    if !MinutesReceived {
        return errors.New("\"Minutes\" is required but was not present")
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AccelerateConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AccelerateConfiguration\": ")
	if tmp, err := json.Marshal(strct.AccelerateConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AccessControl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AccessControl\": ")
	if tmp, err := json.Marshal(strct.AccessControl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AnalyticsConfigurations" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AnalyticsConfigurations\": ")
	if tmp, err := json.Marshal(strct.AnalyticsConfigurations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Arn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Arn\": ")
	if tmp, err := json.Marshal(strct.Arn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BucketEncryption" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BucketEncryption\": ")
	if tmp, err := json.Marshal(strct.BucketEncryption); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BucketName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BucketName\": ")
	if tmp, err := json.Marshal(strct.BucketName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CorsConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CorsConfiguration\": ")
	if tmp, err := json.Marshal(strct.CorsConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DomainName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DomainName\": ")
	if tmp, err := json.Marshal(strct.DomainName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DualStackDomainName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DualStackDomainName\": ")
	if tmp, err := json.Marshal(strct.DualStackDomainName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IntelligentTieringConfigurations" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IntelligentTieringConfigurations\": ")
	if tmp, err := json.Marshal(strct.IntelligentTieringConfigurations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "InventoryConfigurations" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InventoryConfigurations\": ")
	if tmp, err := json.Marshal(strct.InventoryConfigurations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LifecycleConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LifecycleConfiguration\": ")
	if tmp, err := json.Marshal(strct.LifecycleConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LoggingConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LoggingConfiguration\": ")
	if tmp, err := json.Marshal(strct.LoggingConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MetricsConfigurations" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MetricsConfigurations\": ")
	if tmp, err := json.Marshal(strct.MetricsConfigurations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "NotificationConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NotificationConfiguration\": ")
	if tmp, err := json.Marshal(strct.NotificationConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ObjectLockConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ObjectLockConfiguration\": ")
	if tmp, err := json.Marshal(strct.ObjectLockConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ObjectLockEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ObjectLockEnabled\": ")
	if tmp, err := json.Marshal(strct.ObjectLockEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OwnershipControls" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OwnershipControls\": ")
	if tmp, err := json.Marshal(strct.OwnershipControls); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PublicAccessBlockConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PublicAccessBlockConfiguration\": ")
	if tmp, err := json.Marshal(strct.PublicAccessBlockConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RegionalDomainName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RegionalDomainName\": ")
	if tmp, err := json.Marshal(strct.RegionalDomainName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ReplicationConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ReplicationConfiguration\": ")
	if tmp, err := json.Marshal(strct.ReplicationConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VersioningConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VersioningConfiguration\": ")
	if tmp, err := json.Marshal(strct.VersioningConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "WebsiteConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"WebsiteConfiguration\": ")
	if tmp, err := json.Marshal(strct.WebsiteConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "WebsiteURL" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"WebsiteURL\": ")
	if tmp, err := json.Marshal(strct.WebsiteURL); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AccelerateConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.AccelerateConfiguration); err != nil {
                return err
             }
        case "AccessControl":
            if err := json.Unmarshal([]byte(v), &strct.AccessControl); err != nil {
                return err
             }
        case "AnalyticsConfigurations":
            if err := json.Unmarshal([]byte(v), &strct.AnalyticsConfigurations); err != nil {
                return err
             }
        case "Arn":
            if err := json.Unmarshal([]byte(v), &strct.Arn); err != nil {
                return err
             }
        case "BucketEncryption":
            if err := json.Unmarshal([]byte(v), &strct.BucketEncryption); err != nil {
                return err
             }
        case "BucketName":
            if err := json.Unmarshal([]byte(v), &strct.BucketName); err != nil {
                return err
             }
        case "CorsConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.CorsConfiguration); err != nil {
                return err
             }
        case "DomainName":
            if err := json.Unmarshal([]byte(v), &strct.DomainName); err != nil {
                return err
             }
        case "DualStackDomainName":
            if err := json.Unmarshal([]byte(v), &strct.DualStackDomainName); err != nil {
                return err
             }
        case "IntelligentTieringConfigurations":
            if err := json.Unmarshal([]byte(v), &strct.IntelligentTieringConfigurations); err != nil {
                return err
             }
        case "InventoryConfigurations":
            if err := json.Unmarshal([]byte(v), &strct.InventoryConfigurations); err != nil {
                return err
             }
        case "LifecycleConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.LifecycleConfiguration); err != nil {
                return err
             }
        case "LoggingConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.LoggingConfiguration); err != nil {
                return err
             }
        case "MetricsConfigurations":
            if err := json.Unmarshal([]byte(v), &strct.MetricsConfigurations); err != nil {
                return err
             }
        case "NotificationConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.NotificationConfiguration); err != nil {
                return err
             }
        case "ObjectLockConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.ObjectLockConfiguration); err != nil {
                return err
             }
        case "ObjectLockEnabled":
            if err := json.Unmarshal([]byte(v), &strct.ObjectLockEnabled); err != nil {
                return err
             }
        case "OwnershipControls":
            if err := json.Unmarshal([]byte(v), &strct.OwnershipControls); err != nil {
                return err
             }
        case "PublicAccessBlockConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.PublicAccessBlockConfiguration); err != nil {
                return err
             }
        case "RegionalDomainName":
            if err := json.Unmarshal([]byte(v), &strct.RegionalDomainName); err != nil {
                return err
             }
        case "ReplicationConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.ReplicationConfiguration); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        case "VersioningConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.VersioningConfiguration); err != nil {
                return err
             }
        case "WebsiteConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.WebsiteConfiguration); err != nil {
                return err
             }
        case "WebsiteURL":
            if err := json.Unmarshal([]byte(v), &strct.WebsiteURL); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *RoutingRule) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "RedirectRule" field is required
    if strct.RedirectRule == nil {
        return nil, errors.New("RedirectRule is a required field")
    }
    // Marshal the "RedirectRule" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RedirectRule\": ")
	if tmp, err := json.Marshal(strct.RedirectRule); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RoutingRuleCondition" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoutingRuleCondition\": ")
	if tmp, err := json.Marshal(strct.RoutingRuleCondition); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RoutingRule) UnmarshalJSON(b []byte) error {
    RedirectRuleReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "RedirectRule":
            if err := json.Unmarshal([]byte(v), &strct.RedirectRule); err != nil {
                return err
             }
            RedirectRuleReceived = true
        case "RoutingRuleCondition":
            if err := json.Unmarshal([]byte(v), &strct.RoutingRuleCondition); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if RedirectRule (a required property) was received
    if !RedirectRuleReceived {
        return errors.New("\"RedirectRule\" is required but was not present")
    }
    return nil
}

func (strct *RoutingRuleCondition) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "HttpErrorCodeReturnedEquals" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HttpErrorCodeReturnedEquals\": ")
	if tmp, err := json.Marshal(strct.HttpErrorCodeReturnedEquals); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "KeyPrefixEquals" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KeyPrefixEquals\": ")
	if tmp, err := json.Marshal(strct.KeyPrefixEquals); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RoutingRuleCondition) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "HttpErrorCodeReturnedEquals":
            if err := json.Unmarshal([]byte(v), &strct.HttpErrorCodeReturnedEquals); err != nil {
                return err
             }
        case "KeyPrefixEquals":
            if err := json.Unmarshal([]byte(v), &strct.KeyPrefixEquals); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Rule) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AbortIncompleteMultipartUpload" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AbortIncompleteMultipartUpload\": ")
	if tmp, err := json.Marshal(strct.AbortIncompleteMultipartUpload); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ExpirationDate" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ExpirationDate\": ")
	if tmp, err := json.Marshal(strct.ExpirationDate); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ExpirationInDays" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ExpirationInDays\": ")
	if tmp, err := json.Marshal(strct.ExpirationInDays); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ExpiredObjectDeleteMarker" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ExpiredObjectDeleteMarker\": ")
	if tmp, err := json.Marshal(strct.ExpiredObjectDeleteMarker); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Id" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "NoncurrentVersionExpiration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NoncurrentVersionExpiration\": ")
	if tmp, err := json.Marshal(strct.NoncurrentVersionExpiration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "NoncurrentVersionExpirationInDays" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NoncurrentVersionExpirationInDays\": ")
	if tmp, err := json.Marshal(strct.NoncurrentVersionExpirationInDays); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "NoncurrentVersionTransition" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NoncurrentVersionTransition\": ")
	if tmp, err := json.Marshal(strct.NoncurrentVersionTransition); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "NoncurrentVersionTransitions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NoncurrentVersionTransitions\": ")
	if tmp, err := json.Marshal(strct.NoncurrentVersionTransitions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ObjectSizeGreaterThan" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ObjectSizeGreaterThan\": ")
	if tmp, err := json.Marshal(strct.ObjectSizeGreaterThan); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ObjectSizeLessThan" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ObjectSizeLessThan\": ")
	if tmp, err := json.Marshal(strct.ObjectSizeLessThan); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Prefix" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Prefix\": ")
	if tmp, err := json.Marshal(strct.Prefix); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Status" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Status" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Status\": ")
	if tmp, err := json.Marshal(strct.Status); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TagFilters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TagFilters\": ")
	if tmp, err := json.Marshal(strct.TagFilters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Transition" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Transition\": ")
	if tmp, err := json.Marshal(strct.Transition); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Transitions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Transitions\": ")
	if tmp, err := json.Marshal(strct.Transitions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Rule) UnmarshalJSON(b []byte) error {
    StatusReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AbortIncompleteMultipartUpload":
            if err := json.Unmarshal([]byte(v), &strct.AbortIncompleteMultipartUpload); err != nil {
                return err
             }
        case "ExpirationDate":
            if err := json.Unmarshal([]byte(v), &strct.ExpirationDate); err != nil {
                return err
             }
        case "ExpirationInDays":
            if err := json.Unmarshal([]byte(v), &strct.ExpirationInDays); err != nil {
                return err
             }
        case "ExpiredObjectDeleteMarker":
            if err := json.Unmarshal([]byte(v), &strct.ExpiredObjectDeleteMarker); err != nil {
                return err
             }
        case "Id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
        case "NoncurrentVersionExpiration":
            if err := json.Unmarshal([]byte(v), &strct.NoncurrentVersionExpiration); err != nil {
                return err
             }
        case "NoncurrentVersionExpirationInDays":
            if err := json.Unmarshal([]byte(v), &strct.NoncurrentVersionExpirationInDays); err != nil {
                return err
             }
        case "NoncurrentVersionTransition":
            if err := json.Unmarshal([]byte(v), &strct.NoncurrentVersionTransition); err != nil {
                return err
             }
        case "NoncurrentVersionTransitions":
            if err := json.Unmarshal([]byte(v), &strct.NoncurrentVersionTransitions); err != nil {
                return err
             }
        case "ObjectSizeGreaterThan":
            if err := json.Unmarshal([]byte(v), &strct.ObjectSizeGreaterThan); err != nil {
                return err
             }
        case "ObjectSizeLessThan":
            if err := json.Unmarshal([]byte(v), &strct.ObjectSizeLessThan); err != nil {
                return err
             }
        case "Prefix":
            if err := json.Unmarshal([]byte(v), &strct.Prefix); err != nil {
                return err
             }
        case "Status":
            if err := json.Unmarshal([]byte(v), &strct.Status); err != nil {
                return err
             }
            StatusReceived = true
        case "TagFilters":
            if err := json.Unmarshal([]byte(v), &strct.TagFilters); err != nil {
                return err
             }
        case "Transition":
            if err := json.Unmarshal([]byte(v), &strct.Transition); err != nil {
                return err
             }
        case "Transitions":
            if err := json.Unmarshal([]byte(v), &strct.Transitions); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Status (a required property) was received
    if !StatusReceived {
        return errors.New("\"Status\" is required but was not present")
    }
    return nil
}

func (strct *S3KeyFilter) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Rules" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Rules" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Rules\": ")
	if tmp, err := json.Marshal(strct.Rules); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *S3KeyFilter) UnmarshalJSON(b []byte) error {
    RulesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Rules":
            if err := json.Unmarshal([]byte(v), &strct.Rules); err != nil {
                return err
             }
            RulesReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Rules (a required property) was received
    if !RulesReceived {
        return errors.New("\"Rules\" is required but was not present")
    }
    return nil
}

func (strct *ServerSideEncryptionByDefault) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "KMSMasterKeyID" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KMSMasterKeyID\": ")
	if tmp, err := json.Marshal(strct.KMSMasterKeyID); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "SSEAlgorithm" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "SSEAlgorithm" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SSEAlgorithm\": ")
	if tmp, err := json.Marshal(strct.SSEAlgorithm); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ServerSideEncryptionByDefault) UnmarshalJSON(b []byte) error {
    SSEAlgorithmReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "KMSMasterKeyID":
            if err := json.Unmarshal([]byte(v), &strct.KMSMasterKeyID); err != nil {
                return err
             }
        case "SSEAlgorithm":
            if err := json.Unmarshal([]byte(v), &strct.SSEAlgorithm); err != nil {
                return err
             }
            SSEAlgorithmReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if SSEAlgorithm (a required property) was received
    if !SSEAlgorithmReceived {
        return errors.New("\"SSEAlgorithm\" is required but was not present")
    }
    return nil
}

func (strct *ServerSideEncryptionRule) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "BucketKeyEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BucketKeyEnabled\": ")
	if tmp, err := json.Marshal(strct.BucketKeyEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ServerSideEncryptionByDefault" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ServerSideEncryptionByDefault\": ")
	if tmp, err := json.Marshal(strct.ServerSideEncryptionByDefault); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ServerSideEncryptionRule) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BucketKeyEnabled":
            if err := json.Unmarshal([]byte(v), &strct.BucketKeyEnabled); err != nil {
                return err
             }
        case "ServerSideEncryptionByDefault":
            if err := json.Unmarshal([]byte(v), &strct.ServerSideEncryptionByDefault); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *SourceSelectionCriteria) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ReplicaModifications" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ReplicaModifications\": ")
	if tmp, err := json.Marshal(strct.ReplicaModifications); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SseKmsEncryptedObjects" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SseKmsEncryptedObjects\": ")
	if tmp, err := json.Marshal(strct.SseKmsEncryptedObjects); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SourceSelectionCriteria) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ReplicaModifications":
            if err := json.Unmarshal([]byte(v), &strct.ReplicaModifications); err != nil {
                return err
             }
        case "SseKmsEncryptedObjects":
            if err := json.Unmarshal([]byte(v), &strct.SseKmsEncryptedObjects); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *SseKmsEncryptedObjects) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Status" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Status" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Status\": ")
	if tmp, err := json.Marshal(strct.Status); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SseKmsEncryptedObjects) UnmarshalJSON(b []byte) error {
    StatusReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Status":
            if err := json.Unmarshal([]byte(v), &strct.Status); err != nil {
                return err
             }
            StatusReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Status (a required property) was received
    if !StatusReceived {
        return errors.New("\"Status\" is required but was not present")
    }
    return nil
}

func (strct *StorageClassAnalysis) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DataExport" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DataExport\": ")
	if tmp, err := json.Marshal(strct.DataExport); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *StorageClassAnalysis) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DataExport":
            if err := json.Unmarshal([]byte(v), &strct.DataExport); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *TagFilter) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TagFilter) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *Tiering) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AccessTier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AccessTier" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AccessTier\": ")
	if tmp, err := json.Marshal(strct.AccessTier); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Days" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Days" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Days\": ")
	if tmp, err := json.Marshal(strct.Days); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tiering) UnmarshalJSON(b []byte) error {
    AccessTierReceived := false
    DaysReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AccessTier":
            if err := json.Unmarshal([]byte(v), &strct.AccessTier); err != nil {
                return err
             }
            AccessTierReceived = true
        case "Days":
            if err := json.Unmarshal([]byte(v), &strct.Days); err != nil {
                return err
             }
            DaysReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if AccessTier (a required property) was received
    if !AccessTierReceived {
        return errors.New("\"AccessTier\" is required but was not present")
    }
    // check if Days (a required property) was received
    if !DaysReceived {
        return errors.New("\"Days\" is required but was not present")
    }
    return nil
}

func (strct *TopicConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Event" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Event" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Event\": ")
	if tmp, err := json.Marshal(strct.Event); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Filter" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Filter\": ")
	if tmp, err := json.Marshal(strct.Filter); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Topic" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Topic" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Topic\": ")
	if tmp, err := json.Marshal(strct.Topic); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TopicConfiguration) UnmarshalJSON(b []byte) error {
    EventReceived := false
    TopicReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Event":
            if err := json.Unmarshal([]byte(v), &strct.Event); err != nil {
                return err
             }
            EventReceived = true
        case "Filter":
            if err := json.Unmarshal([]byte(v), &strct.Filter); err != nil {
                return err
             }
        case "Topic":
            if err := json.Unmarshal([]byte(v), &strct.Topic); err != nil {
                return err
             }
            TopicReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Event (a required property) was received
    if !EventReceived {
        return errors.New("\"Event\" is required but was not present")
    }
    // check if Topic (a required property) was received
    if !TopicReceived {
        return errors.New("\"Topic\" is required but was not present")
    }
    return nil
}

func (strct *Transition) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "StorageClass" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "StorageClass" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StorageClass\": ")
	if tmp, err := json.Marshal(strct.StorageClass); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TransitionDate" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TransitionDate\": ")
	if tmp, err := json.Marshal(strct.TransitionDate); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TransitionInDays" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TransitionInDays\": ")
	if tmp, err := json.Marshal(strct.TransitionInDays); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Transition) UnmarshalJSON(b []byte) error {
    StorageClassReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "StorageClass":
            if err := json.Unmarshal([]byte(v), &strct.StorageClass); err != nil {
                return err
             }
            StorageClassReceived = true
        case "TransitionDate":
            if err := json.Unmarshal([]byte(v), &strct.TransitionDate); err != nil {
                return err
             }
        case "TransitionInDays":
            if err := json.Unmarshal([]byte(v), &strct.TransitionInDays); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if StorageClass (a required property) was received
    if !StorageClassReceived {
        return errors.New("\"StorageClass\" is required but was not present")
    }
    return nil
}

func (strct *VersioningConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Status" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Status" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Status\": ")
	if tmp, err := json.Marshal(strct.Status); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *VersioningConfiguration) UnmarshalJSON(b []byte) error {
    StatusReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Status":
            if err := json.Unmarshal([]byte(v), &strct.Status); err != nil {
                return err
             }
            StatusReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Status (a required property) was received
    if !StatusReceived {
        return errors.New("\"Status\" is required but was not present")
    }
    return nil
}

func (strct *WebsiteConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ErrorDocument" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ErrorDocument\": ")
	if tmp, err := json.Marshal(strct.ErrorDocument); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IndexDocument" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IndexDocument\": ")
	if tmp, err := json.Marshal(strct.IndexDocument); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RedirectAllRequestsTo" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RedirectAllRequestsTo\": ")
	if tmp, err := json.Marshal(strct.RedirectAllRequestsTo); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RoutingRules" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoutingRules\": ")
	if tmp, err := json.Marshal(strct.RoutingRules); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *WebsiteConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ErrorDocument":
            if err := json.Unmarshal([]byte(v), &strct.ErrorDocument); err != nil {
                return err
             }
        case "IndexDocument":
            if err := json.Unmarshal([]byte(v), &strct.IndexDocument); err != nil {
                return err
             }
        case "RedirectAllRequestsTo":
            if err := json.Unmarshal([]byte(v), &strct.RedirectAllRequestsTo); err != nil {
                return err
             }
        case "RoutingRules":
            if err := json.Unmarshal([]byte(v), &strct.RoutingRules); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}
