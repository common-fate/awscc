// Code generated by schema-generate. DO NOT EDIT.

package samplingrule

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// Attributes Matches attributes derived from the request.
type Attributes struct {
}

// Resource This schema provides construct and validation rules for AWS-XRay SamplingRule resource parameters.
type Resource struct {
  RuleARN string `json:"RuleARN,omitempty"`
  RuleName string `json:"RuleName,omitempty"`
  SamplingRule *SamplingRule `json:"SamplingRule,omitempty"`
  SamplingRuleRecord *SamplingRuleRecord `json:"SamplingRuleRecord,omitempty"`
  SamplingRuleUpdate *SamplingRuleUpdate `json:"SamplingRuleUpdate,omitempty"`
  Tags []*TagsItems `json:"Tags,omitempty"`
}

// SamplingRule 
type SamplingRule struct {

  // Matches attributes derived from the request.
  Attributes *Attributes `json:"Attributes,omitempty"`

  // The percentage of matching requests to instrument, after the reservoir is exhausted.
  FixedRate float64 `json:"FixedRate,omitempty"`

  // Matches the HTTP method from a request URL.
  HTTPMethod string `json:"HTTPMethod,omitempty"`

  // Matches the hostname from a request URL.
  Host string `json:"Host,omitempty"`

  // The priority of the sampling rule.
  Priority int `json:"Priority,omitempty"`

  // A fixed number of matching requests to instrument per second, prior to applying the fixed rate. The reservoir is not used directly by services, but applies to all services using the rule collectively.
  ReservoirSize int `json:"ReservoirSize,omitempty"`

  // Matches the ARN of the AWS resource on which the service runs.
  ResourceARN string `json:"ResourceARN,omitempty"`
  RuleARN string `json:"RuleARN,omitempty"`
  RuleName string `json:"RuleName,omitempty"`

  // Matches the name that the service uses to identify itself in segments.
  ServiceName string `json:"ServiceName,omitempty"`

  // Matches the origin that the service uses to identify its type in segments.
  ServiceType string `json:"ServiceType,omitempty"`

  // Matches the path from a request URL.
  URLPath string `json:"URLPath,omitempty"`

  // The version of the sampling rule format (1)
  Version int `json:"Version,omitempty"`
}

// SamplingRuleRecord 
type SamplingRuleRecord struct {

  // When the rule was created, in Unix time seconds.
  CreatedAt string `json:"CreatedAt,omitempty"`

  // When the rule was modified, in Unix time seconds.
  ModifiedAt string `json:"ModifiedAt,omitempty"`
  SamplingRule *SamplingRule `json:"SamplingRule,omitempty"`
}

// SamplingRuleUpdate 
type SamplingRuleUpdate struct {

  // Matches attributes derived from the request.
  Attributes *Attributes `json:"Attributes,omitempty"`

  // The percentage of matching requests to instrument, after the reservoir is exhausted.
  FixedRate float64 `json:"FixedRate,omitempty"`

  // Matches the HTTP method from a request URL.
  HTTPMethod string `json:"HTTPMethod,omitempty"`

  // Matches the hostname from a request URL.
  Host string `json:"Host,omitempty"`

  // The priority of the sampling rule.
  Priority int `json:"Priority,omitempty"`

  // A fixed number of matching requests to instrument per second, prior to applying the fixed rate. The reservoir is not used directly by services, but applies to all services using the rule collectively.
  ReservoirSize int `json:"ReservoirSize,omitempty"`

  // Matches the ARN of the AWS resource on which the service runs.
  ResourceARN string `json:"ResourceARN,omitempty"`
  RuleARN string `json:"RuleARN,omitempty"`
  RuleName string `json:"RuleName,omitempty"`

  // Matches the name that the service uses to identify itself in segments.
  ServiceName string `json:"ServiceName,omitempty"`

  // Matches the origin that the service uses to identify its type in segments.
  ServiceType string `json:"ServiceType,omitempty"`

  // Matches the path from a request URL.
  URLPath string `json:"URLPath,omitempty"`
}

// TagsItems 
type TagsItems struct {
  Key string `json:"Key"`
  Value string `json:"Value"`
}

func (strct *Attributes) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Attributes) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "RuleARN" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RuleARN\": ")
	if tmp, err := json.Marshal(strct.RuleARN); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RuleName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RuleName\": ")
	if tmp, err := json.Marshal(strct.RuleName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SamplingRule" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SamplingRule\": ")
	if tmp, err := json.Marshal(strct.SamplingRule); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SamplingRuleRecord" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SamplingRuleRecord\": ")
	if tmp, err := json.Marshal(strct.SamplingRuleRecord); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SamplingRuleUpdate" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SamplingRuleUpdate\": ")
	if tmp, err := json.Marshal(strct.SamplingRuleUpdate); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "RuleARN":
            if err := json.Unmarshal([]byte(v), &strct.RuleARN); err != nil {
                return err
             }
        case "RuleName":
            if err := json.Unmarshal([]byte(v), &strct.RuleName); err != nil {
                return err
             }
        case "SamplingRule":
            if err := json.Unmarshal([]byte(v), &strct.SamplingRule); err != nil {
                return err
             }
        case "SamplingRuleRecord":
            if err := json.Unmarshal([]byte(v), &strct.SamplingRuleRecord); err != nil {
                return err
             }
        case "SamplingRuleUpdate":
            if err := json.Unmarshal([]byte(v), &strct.SamplingRuleUpdate); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *SamplingRule) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Attributes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Attributes\": ")
	if tmp, err := json.Marshal(strct.Attributes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FixedRate" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FixedRate\": ")
	if tmp, err := json.Marshal(strct.FixedRate); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "HTTPMethod" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HTTPMethod\": ")
	if tmp, err := json.Marshal(strct.HTTPMethod); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Host" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Host\": ")
	if tmp, err := json.Marshal(strct.Host); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Priority" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Priority\": ")
	if tmp, err := json.Marshal(strct.Priority); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ReservoirSize" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ReservoirSize\": ")
	if tmp, err := json.Marshal(strct.ReservoirSize); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ResourceARN" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ResourceARN\": ")
	if tmp, err := json.Marshal(strct.ResourceARN); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RuleARN" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RuleARN\": ")
	if tmp, err := json.Marshal(strct.RuleARN); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RuleName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RuleName\": ")
	if tmp, err := json.Marshal(strct.RuleName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ServiceName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ServiceName\": ")
	if tmp, err := json.Marshal(strct.ServiceName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ServiceType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ServiceType\": ")
	if tmp, err := json.Marshal(strct.ServiceType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "URLPath" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"URLPath\": ")
	if tmp, err := json.Marshal(strct.URLPath); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Version" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Version\": ")
	if tmp, err := json.Marshal(strct.Version); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SamplingRule) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Attributes":
            if err := json.Unmarshal([]byte(v), &strct.Attributes); err != nil {
                return err
             }
        case "FixedRate":
            if err := json.Unmarshal([]byte(v), &strct.FixedRate); err != nil {
                return err
             }
        case "HTTPMethod":
            if err := json.Unmarshal([]byte(v), &strct.HTTPMethod); err != nil {
                return err
             }
        case "Host":
            if err := json.Unmarshal([]byte(v), &strct.Host); err != nil {
                return err
             }
        case "Priority":
            if err := json.Unmarshal([]byte(v), &strct.Priority); err != nil {
                return err
             }
        case "ReservoirSize":
            if err := json.Unmarshal([]byte(v), &strct.ReservoirSize); err != nil {
                return err
             }
        case "ResourceARN":
            if err := json.Unmarshal([]byte(v), &strct.ResourceARN); err != nil {
                return err
             }
        case "RuleARN":
            if err := json.Unmarshal([]byte(v), &strct.RuleARN); err != nil {
                return err
             }
        case "RuleName":
            if err := json.Unmarshal([]byte(v), &strct.RuleName); err != nil {
                return err
             }
        case "ServiceName":
            if err := json.Unmarshal([]byte(v), &strct.ServiceName); err != nil {
                return err
             }
        case "ServiceType":
            if err := json.Unmarshal([]byte(v), &strct.ServiceType); err != nil {
                return err
             }
        case "URLPath":
            if err := json.Unmarshal([]byte(v), &strct.URLPath); err != nil {
                return err
             }
        case "Version":
            if err := json.Unmarshal([]byte(v), &strct.Version); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *SamplingRuleRecord) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CreatedAt" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CreatedAt\": ")
	if tmp, err := json.Marshal(strct.CreatedAt); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ModifiedAt" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ModifiedAt\": ")
	if tmp, err := json.Marshal(strct.ModifiedAt); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SamplingRule" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SamplingRule\": ")
	if tmp, err := json.Marshal(strct.SamplingRule); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SamplingRuleRecord) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CreatedAt":
            if err := json.Unmarshal([]byte(v), &strct.CreatedAt); err != nil {
                return err
             }
        case "ModifiedAt":
            if err := json.Unmarshal([]byte(v), &strct.ModifiedAt); err != nil {
                return err
             }
        case "SamplingRule":
            if err := json.Unmarshal([]byte(v), &strct.SamplingRule); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *SamplingRuleUpdate) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Attributes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Attributes\": ")
	if tmp, err := json.Marshal(strct.Attributes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FixedRate" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FixedRate\": ")
	if tmp, err := json.Marshal(strct.FixedRate); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "HTTPMethod" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HTTPMethod\": ")
	if tmp, err := json.Marshal(strct.HTTPMethod); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Host" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Host\": ")
	if tmp, err := json.Marshal(strct.Host); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Priority" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Priority\": ")
	if tmp, err := json.Marshal(strct.Priority); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ReservoirSize" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ReservoirSize\": ")
	if tmp, err := json.Marshal(strct.ReservoirSize); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ResourceARN" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ResourceARN\": ")
	if tmp, err := json.Marshal(strct.ResourceARN); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RuleARN" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RuleARN\": ")
	if tmp, err := json.Marshal(strct.RuleARN); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RuleName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RuleName\": ")
	if tmp, err := json.Marshal(strct.RuleName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ServiceName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ServiceName\": ")
	if tmp, err := json.Marshal(strct.ServiceName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ServiceType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ServiceType\": ")
	if tmp, err := json.Marshal(strct.ServiceType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "URLPath" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"URLPath\": ")
	if tmp, err := json.Marshal(strct.URLPath); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SamplingRuleUpdate) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Attributes":
            if err := json.Unmarshal([]byte(v), &strct.Attributes); err != nil {
                return err
             }
        case "FixedRate":
            if err := json.Unmarshal([]byte(v), &strct.FixedRate); err != nil {
                return err
             }
        case "HTTPMethod":
            if err := json.Unmarshal([]byte(v), &strct.HTTPMethod); err != nil {
                return err
             }
        case "Host":
            if err := json.Unmarshal([]byte(v), &strct.Host); err != nil {
                return err
             }
        case "Priority":
            if err := json.Unmarshal([]byte(v), &strct.Priority); err != nil {
                return err
             }
        case "ReservoirSize":
            if err := json.Unmarshal([]byte(v), &strct.ReservoirSize); err != nil {
                return err
             }
        case "ResourceARN":
            if err := json.Unmarshal([]byte(v), &strct.ResourceARN); err != nil {
                return err
             }
        case "RuleARN":
            if err := json.Unmarshal([]byte(v), &strct.RuleARN); err != nil {
                return err
             }
        case "RuleName":
            if err := json.Unmarshal([]byte(v), &strct.RuleName); err != nil {
                return err
             }
        case "ServiceName":
            if err := json.Unmarshal([]byte(v), &strct.ServiceName); err != nil {
                return err
             }
        case "ServiceType":
            if err := json.Unmarshal([]byte(v), &strct.ServiceType); err != nil {
                return err
             }
        case "URLPath":
            if err := json.Unmarshal([]byte(v), &strct.URLPath); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *TagsItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TagsItems) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}
