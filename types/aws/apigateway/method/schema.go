// Code generated by schema-generate. DO NOT EDIT.

package method

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// Integration 
type Integration struct {

  // A list of request parameters whose values API Gateway caches.
  CacheKeyParameters []string `json:"CacheKeyParameters,omitempty"`

  // An API-specific tag group of related cached parameters.
  CacheNamespace string `json:"CacheNamespace,omitempty"`

  // The ID of the VpcLink used for the integration when connectionType=VPC_LINK, otherwise undefined.
  ConnectionId string `json:"ConnectionId,omitempty"`

  // The type of the network connection to the integration endpoint.
  ConnectionType string `json:"ConnectionType,omitempty"`

  // Specifies how to handle request payload content type conversions.
  ContentHandling string `json:"ContentHandling,omitempty"`

  // The credentials that are required for the integration.
  Credentials string `json:"Credentials,omitempty"`

  // The integration's HTTP method type.
  IntegrationHttpMethod string `json:"IntegrationHttpMethod,omitempty"`

  // The response that API Gateway provides after a method's backend completes processing a request.
  IntegrationResponses []*IntegrationResponse `json:"IntegrationResponses,omitempty"`

  // Indicates when API Gateway passes requests to the targeted backend.
  PassthroughBehavior string `json:"PassthroughBehavior,omitempty"`

  // The request parameters that API Gateway sends with the backend request.
  RequestParameters *RequestParameters `json:"RequestParameters,omitempty"`

  // A map of Apache Velocity templates that are applied on the request payload.
  RequestTemplates *RequestTemplates `json:"RequestTemplates,omitempty"`

  // Custom timeout between 50 and 29,000 milliseconds.
  TimeoutInMillis int `json:"TimeoutInMillis,omitempty"`

  // The type of backend that your method is running.
  Type string `json:"Type"`

  // The Uniform Resource Identifier (URI) for the integration.
  Uri string `json:"Uri,omitempty"`
}

// IntegrationResponse 
type IntegrationResponse struct {

  // Specifies how to handle request payload content type conversions.
  ContentHandling string `json:"ContentHandling,omitempty"`

  // The response parameters from the backend response that API Gateway sends to the method response.
  ResponseParameters *ResponseParameters `json:"ResponseParameters,omitempty"`

  // The templates that are used to transform the integration response body. Specify templates as key-value pairs (string-to-string mappings), with a content type as the key and a template as the value.
  ResponseTemplates *ResponseTemplates `json:"ResponseTemplates,omitempty"`

  // A regular expression that specifies which error strings or status codes from the backend map to the integration response.
  SelectionPattern string `json:"SelectionPattern,omitempty"`

  // The status code that API Gateway uses to map the integration response to a MethodResponse status code.
  StatusCode string `json:"StatusCode"`
}

// MethodResponse 
type MethodResponse struct {

  // The resources used for the response's content type. Specify response models as key-value pairs (string-to-string maps), with a content type as the key and a Model resource name as the value.
  ResponseModels *ResponseModels `json:"ResponseModels,omitempty"`

  // Response parameters that API Gateway sends to the client that called a method. Specify response parameters as key-value pairs (string-to-Boolean maps), with a destination as the key and a Boolean as the value.
  ResponseParameters *ResponseParameters `json:"ResponseParameters,omitempty"`

  // The method response's status code, which you map to an IntegrationResponse.
  StatusCode string `json:"StatusCode"`
}

// RequestModels The resources that are used for the request's content type. Specify request models as key-value pairs (string-to-string mapping), with a content type as the key and a Model resource name as the value.
type RequestModels struct {
}

// RequestParameters The request parameters that API Gateway accepts. Specify request parameters as key-value pairs (string-to-Boolean mapping), with a source as the key and a Boolean as the value.
type RequestParameters struct {
}

// RequestTemplates A map of Apache Velocity templates that are applied on the request payload.
type RequestTemplates struct {
}

// Resource Resource Type definition for AWS::ApiGateway::Method
type Resource struct {

  // Indicates whether the method requires clients to submit a valid API key.
  ApiKeyRequired bool `json:"ApiKeyRequired,omitempty"`

  // A list of authorization scopes configured on the method.
  AuthorizationScopes []string `json:"AuthorizationScopes,omitempty"`

  // The method's authorization type.
  AuthorizationType string `json:"AuthorizationType,omitempty"`

  // The identifier of the authorizer to use on this method.
  AuthorizerId string `json:"AuthorizerId,omitempty"`

  // The backend system that the method calls when it receives a request.
  HttpMethod string `json:"HttpMethod"`

  // The backend system that the method calls when it receives a request.
  Integration *Integration `json:"Integration,omitempty"`

  // The responses that can be sent to the client who calls the method.
  MethodResponses []*MethodResponse `json:"MethodResponses,omitempty"`

  // A friendly operation name for the method.
  OperationName string `json:"OperationName,omitempty"`

  // The resources that are used for the request's content type. Specify request models as key-value pairs (string-to-string mapping), with a content type as the key and a Model resource name as the value.
  RequestModels *RequestModels `json:"RequestModels,omitempty"`

  // The request parameters that API Gateway accepts. Specify request parameters as key-value pairs (string-to-Boolean mapping), with a source as the key and a Boolean as the value.
  RequestParameters *RequestParameters `json:"RequestParameters,omitempty"`

  // The ID of the associated request validator.
  RequestValidatorId string `json:"RequestValidatorId,omitempty"`

  // The ID of an API Gateway resource.
  ResourceId string `json:"ResourceId"`

  // The ID of the RestApi resource in which API Gateway creates the method.
  RestApiId string `json:"RestApiId"`
}

// ResponseModels The resources used for the response's content type. Specify response models as key-value pairs (string-to-string maps), with a content type as the key and a Model resource name as the value.
type ResponseModels struct {
}

// ResponseParameters Response parameters that API Gateway sends to the client that called a method. Specify response parameters as key-value pairs (string-to-Boolean maps), with a destination as the key and a Boolean as the value.
type ResponseParameters struct {
}

// ResponseTemplates The templates that are used to transform the integration response body. Specify templates as key-value pairs (string-to-string mappings), with a content type as the key and a template as the value.
type ResponseTemplates struct {
}

func (strct *Integration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CacheKeyParameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CacheKeyParameters\": ")
	if tmp, err := json.Marshal(strct.CacheKeyParameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CacheNamespace" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CacheNamespace\": ")
	if tmp, err := json.Marshal(strct.CacheNamespace); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ConnectionId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConnectionId\": ")
	if tmp, err := json.Marshal(strct.ConnectionId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ConnectionType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConnectionType\": ")
	if tmp, err := json.Marshal(strct.ConnectionType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ContentHandling" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ContentHandling\": ")
	if tmp, err := json.Marshal(strct.ContentHandling); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Credentials" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Credentials\": ")
	if tmp, err := json.Marshal(strct.Credentials); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IntegrationHttpMethod" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IntegrationHttpMethod\": ")
	if tmp, err := json.Marshal(strct.IntegrationHttpMethod); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IntegrationResponses" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IntegrationResponses\": ")
	if tmp, err := json.Marshal(strct.IntegrationResponses); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PassthroughBehavior" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PassthroughBehavior\": ")
	if tmp, err := json.Marshal(strct.PassthroughBehavior); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RequestParameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RequestParameters\": ")
	if tmp, err := json.Marshal(strct.RequestParameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RequestTemplates" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RequestTemplates\": ")
	if tmp, err := json.Marshal(strct.RequestTemplates); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TimeoutInMillis" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TimeoutInMillis\": ")
	if tmp, err := json.Marshal(strct.TimeoutInMillis); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Uri" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Uri\": ")
	if tmp, err := json.Marshal(strct.Uri); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Integration) UnmarshalJSON(b []byte) error {
    TypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CacheKeyParameters":
            if err := json.Unmarshal([]byte(v), &strct.CacheKeyParameters); err != nil {
                return err
             }
        case "CacheNamespace":
            if err := json.Unmarshal([]byte(v), &strct.CacheNamespace); err != nil {
                return err
             }
        case "ConnectionId":
            if err := json.Unmarshal([]byte(v), &strct.ConnectionId); err != nil {
                return err
             }
        case "ConnectionType":
            if err := json.Unmarshal([]byte(v), &strct.ConnectionType); err != nil {
                return err
             }
        case "ContentHandling":
            if err := json.Unmarshal([]byte(v), &strct.ContentHandling); err != nil {
                return err
             }
        case "Credentials":
            if err := json.Unmarshal([]byte(v), &strct.Credentials); err != nil {
                return err
             }
        case "IntegrationHttpMethod":
            if err := json.Unmarshal([]byte(v), &strct.IntegrationHttpMethod); err != nil {
                return err
             }
        case "IntegrationResponses":
            if err := json.Unmarshal([]byte(v), &strct.IntegrationResponses); err != nil {
                return err
             }
        case "PassthroughBehavior":
            if err := json.Unmarshal([]byte(v), &strct.PassthroughBehavior); err != nil {
                return err
             }
        case "RequestParameters":
            if err := json.Unmarshal([]byte(v), &strct.RequestParameters); err != nil {
                return err
             }
        case "RequestTemplates":
            if err := json.Unmarshal([]byte(v), &strct.RequestTemplates); err != nil {
                return err
             }
        case "TimeoutInMillis":
            if err := json.Unmarshal([]byte(v), &strct.TimeoutInMillis); err != nil {
                return err
             }
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            TypeReceived = true
        case "Uri":
            if err := json.Unmarshal([]byte(v), &strct.Uri); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Type (a required property) was received
    if !TypeReceived {
        return errors.New("\"Type\" is required but was not present")
    }
    return nil
}

func (strct *IntegrationResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ContentHandling" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ContentHandling\": ")
	if tmp, err := json.Marshal(strct.ContentHandling); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ResponseParameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ResponseParameters\": ")
	if tmp, err := json.Marshal(strct.ResponseParameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ResponseTemplates" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ResponseTemplates\": ")
	if tmp, err := json.Marshal(strct.ResponseTemplates); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SelectionPattern" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SelectionPattern\": ")
	if tmp, err := json.Marshal(strct.SelectionPattern); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "StatusCode" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "StatusCode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StatusCode\": ")
	if tmp, err := json.Marshal(strct.StatusCode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *IntegrationResponse) UnmarshalJSON(b []byte) error {
    StatusCodeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ContentHandling":
            if err := json.Unmarshal([]byte(v), &strct.ContentHandling); err != nil {
                return err
             }
        case "ResponseParameters":
            if err := json.Unmarshal([]byte(v), &strct.ResponseParameters); err != nil {
                return err
             }
        case "ResponseTemplates":
            if err := json.Unmarshal([]byte(v), &strct.ResponseTemplates); err != nil {
                return err
             }
        case "SelectionPattern":
            if err := json.Unmarshal([]byte(v), &strct.SelectionPattern); err != nil {
                return err
             }
        case "StatusCode":
            if err := json.Unmarshal([]byte(v), &strct.StatusCode); err != nil {
                return err
             }
            StatusCodeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if StatusCode (a required property) was received
    if !StatusCodeReceived {
        return errors.New("\"StatusCode\" is required but was not present")
    }
    return nil
}

func (strct *MethodResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ResponseModels" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ResponseModels\": ")
	if tmp, err := json.Marshal(strct.ResponseModels); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ResponseParameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ResponseParameters\": ")
	if tmp, err := json.Marshal(strct.ResponseParameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "StatusCode" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "StatusCode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StatusCode\": ")
	if tmp, err := json.Marshal(strct.StatusCode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MethodResponse) UnmarshalJSON(b []byte) error {
    StatusCodeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ResponseModels":
            if err := json.Unmarshal([]byte(v), &strct.ResponseModels); err != nil {
                return err
             }
        case "ResponseParameters":
            if err := json.Unmarshal([]byte(v), &strct.ResponseParameters); err != nil {
                return err
             }
        case "StatusCode":
            if err := json.Unmarshal([]byte(v), &strct.StatusCode); err != nil {
                return err
             }
            StatusCodeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if StatusCode (a required property) was received
    if !StatusCodeReceived {
        return errors.New("\"StatusCode\" is required but was not present")
    }
    return nil
}

func (strct *RequestModels) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RequestModels) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *RequestParameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RequestParameters) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *RequestTemplates) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RequestTemplates) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ApiKeyRequired" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ApiKeyRequired\": ")
	if tmp, err := json.Marshal(strct.ApiKeyRequired); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AuthorizationScopes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AuthorizationScopes\": ")
	if tmp, err := json.Marshal(strct.AuthorizationScopes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AuthorizationType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AuthorizationType\": ")
	if tmp, err := json.Marshal(strct.AuthorizationType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AuthorizerId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AuthorizerId\": ")
	if tmp, err := json.Marshal(strct.AuthorizerId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "HttpMethod" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "HttpMethod" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HttpMethod\": ")
	if tmp, err := json.Marshal(strct.HttpMethod); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Integration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Integration\": ")
	if tmp, err := json.Marshal(strct.Integration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MethodResponses" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MethodResponses\": ")
	if tmp, err := json.Marshal(strct.MethodResponses); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OperationName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OperationName\": ")
	if tmp, err := json.Marshal(strct.OperationName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RequestModels" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RequestModels\": ")
	if tmp, err := json.Marshal(strct.RequestModels); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RequestParameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RequestParameters\": ")
	if tmp, err := json.Marshal(strct.RequestParameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RequestValidatorId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RequestValidatorId\": ")
	if tmp, err := json.Marshal(strct.RequestValidatorId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ResourceId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ResourceId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ResourceId\": ")
	if tmp, err := json.Marshal(strct.ResourceId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RestApiId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RestApiId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RestApiId\": ")
	if tmp, err := json.Marshal(strct.RestApiId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    HttpMethodReceived := false
    ResourceIdReceived := false
    RestApiIdReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ApiKeyRequired":
            if err := json.Unmarshal([]byte(v), &strct.ApiKeyRequired); err != nil {
                return err
             }
        case "AuthorizationScopes":
            if err := json.Unmarshal([]byte(v), &strct.AuthorizationScopes); err != nil {
                return err
             }
        case "AuthorizationType":
            if err := json.Unmarshal([]byte(v), &strct.AuthorizationType); err != nil {
                return err
             }
        case "AuthorizerId":
            if err := json.Unmarshal([]byte(v), &strct.AuthorizerId); err != nil {
                return err
             }
        case "HttpMethod":
            if err := json.Unmarshal([]byte(v), &strct.HttpMethod); err != nil {
                return err
             }
            HttpMethodReceived = true
        case "Integration":
            if err := json.Unmarshal([]byte(v), &strct.Integration); err != nil {
                return err
             }
        case "MethodResponses":
            if err := json.Unmarshal([]byte(v), &strct.MethodResponses); err != nil {
                return err
             }
        case "OperationName":
            if err := json.Unmarshal([]byte(v), &strct.OperationName); err != nil {
                return err
             }
        case "RequestModels":
            if err := json.Unmarshal([]byte(v), &strct.RequestModels); err != nil {
                return err
             }
        case "RequestParameters":
            if err := json.Unmarshal([]byte(v), &strct.RequestParameters); err != nil {
                return err
             }
        case "RequestValidatorId":
            if err := json.Unmarshal([]byte(v), &strct.RequestValidatorId); err != nil {
                return err
             }
        case "ResourceId":
            if err := json.Unmarshal([]byte(v), &strct.ResourceId); err != nil {
                return err
             }
            ResourceIdReceived = true
        case "RestApiId":
            if err := json.Unmarshal([]byte(v), &strct.RestApiId); err != nil {
                return err
             }
            RestApiIdReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if HttpMethod (a required property) was received
    if !HttpMethodReceived {
        return errors.New("\"HttpMethod\" is required but was not present")
    }
    // check if ResourceId (a required property) was received
    if !ResourceIdReceived {
        return errors.New("\"ResourceId\" is required but was not present")
    }
    // check if RestApiId (a required property) was received
    if !RestApiIdReceived {
        return errors.New("\"RestApiId\" is required but was not present")
    }
    return nil
}

func (strct *ResponseModels) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ResponseModels) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ResponseParameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ResponseParameters) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ResponseTemplates) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ResponseTemplates) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}
