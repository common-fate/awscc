// Code generated by schema-generate. DO NOT EDIT.

package deployment

import (
    "encoding/json"
    "fmt"
    "errors"
    "bytes"
)

// AccessLogSetting 
type AccessLogSetting struct {

  // The Amazon Resource Name (ARN) of the CloudWatch Logs log group or Kinesis Data Firehose delivery stream to receive access logs. If you specify a Kinesis Data Firehose delivery stream, the stream name must begin with amazon-apigateway-. 
  DestinationArn string `json:"DestinationArn,omitempty"`

  // A single line format of the access logs of data, as specified by selected $context variables. The format must include at least $context.requestId. 
  Format string `json:"Format,omitempty"`
}

// CanarySetting 
type CanarySetting struct {

  // The percent (0-100) of traffic diverted to a canary deployment.
  PercentTraffic float64 `json:"PercentTraffic,omitempty"`

  // Stage variables overridden for a canary release deployment, including new stage variables introduced in the canary. These stage variables are represented as a string-to-string map between stage variable names and their values. 
  StageVariableOverrides *StageVariableOverrides `json:"StageVariableOverrides,omitempty"`

  // Whether the canary deployment uses the stage cache or not.
  UseStageCache bool `json:"UseStageCache,omitempty"`
}

// DeploymentCanarySettings 
type DeploymentCanarySettings struct {

  // The percentage (0-100) of traffic diverted to a canary deployment.
  PercentTraffic float64 `json:"PercentTraffic,omitempty"`

  // Stage variables overridden for a canary release deployment, including new stage variables introduced in the canary. These stage variables are represented as a string-to-string map between stage variable names and their values. Duplicates are not allowed.
  StageVariableOverrides *StageVariableOverrides `json:"StageVariableOverrides,omitempty"`

  // Whether the canary deployment uses the stage cache.
  UseStageCache bool `json:"UseStageCache,omitempty"`
}

// MethodSetting 
type MethodSetting struct {

  // Indicates whether the cached responses are encrypted
  CacheDataEncrypted bool `json:"CacheDataEncrypted,omitempty"`

  // The time-to-live (TTL) period, in seconds, that specifies how long API Gateway caches responses. 
  CacheTtlInSeconds int `json:"CacheTtlInSeconds,omitempty"`

  // Indicates whether responses are cached and returned for requests. You must enable a cache cluster on the stage to cache responses.
  CachingEnabled bool `json:"CachingEnabled,omitempty"`

  // Indicates whether data trace logging is enabled for methods in the stage. API Gateway pushes these logs to Amazon CloudWatch Logs. 
  DataTraceEnabled bool `json:"DataTraceEnabled,omitempty"`

  // The HTTP method.
  HttpMethod string `json:"HttpMethod,omitempty"`

  // The logging level for this method. For valid values, see the loggingLevel property of the Stage resource in the Amazon API Gateway API Reference. 
  LoggingLevel string `json:"LoggingLevel,omitempty"`

  // Indicates whether Amazon CloudWatch metrics are enabled for methods in the stage.
  MetricsEnabled bool `json:"MetricsEnabled,omitempty"`

  // The resource path for this method. Forward slashes (/) are encoded as ~1 and the initial slash must include a forward slash. 
  ResourcePath string `json:"ResourcePath,omitempty"`

  // The number of burst requests per second that API Gateway permits across all APIs, stages, and methods in your AWS account.
  ThrottlingBurstLimit int `json:"ThrottlingBurstLimit,omitempty"`

  // The number of steady-state requests per second that API Gateway permits across all APIs, stages, and methods in your AWS account.
  ThrottlingRateLimit float64 `json:"ThrottlingRateLimit,omitempty"`
}

// Resource Resource Type definition for AWS::ApiGateway::Deployment
type Resource struct {

  // Specifies settings for the canary deployment.
  DeploymentCanarySettings *DeploymentCanarySettings `json:"DeploymentCanarySettings,omitempty"`

  // Primary Id for this resource
  DeploymentId string `json:"DeploymentId,omitempty"`

  // A description of the purpose of the API Gateway deployment.
  Description string `json:"Description,omitempty"`

  // The ID of the RestApi resource to deploy. 
  RestApiId string `json:"RestApiId"`

  // Configures the stage that API Gateway creates with this deployment.
  StageDescription *StageDescription `json:"StageDescription,omitempty"`

  // A name for the stage that API Gateway creates with this deployment. Use only alphanumeric characters.
  StageName string `json:"StageName,omitempty"`
}

// StageDescription 
type StageDescription struct {

  // Specifies settings for logging access in this stage.
  AccessLogSetting *AccessLogSetting `json:"AccessLogSetting,omitempty"`

  // Indicates whether cache clustering is enabled for the stage.
  CacheClusterEnabled bool `json:"CacheClusterEnabled,omitempty"`

  // The size of the stage's cache cluster.
  CacheClusterSize string `json:"CacheClusterSize,omitempty"`

  // The time-to-live (TTL) period, in seconds, that specifies how long API Gateway caches responses. 
  CacheDataEncrypted bool `json:"CacheDataEncrypted,omitempty"`

  // The time-to-live (TTL) period, in seconds, that specifies how long API Gateway caches responses. 
  CacheTtlInSeconds int `json:"CacheTtlInSeconds,omitempty"`

  // Indicates whether responses are cached and returned for requests. You must enable a cache cluster on the stage to cache responses.
  CachingEnabled bool `json:"CachingEnabled,omitempty"`

  // Specifies settings for the canary deployment in this stage.
  CanarySetting *CanarySetting `json:"CanarySetting,omitempty"`

  // The identifier of the client certificate that API Gateway uses to call your integration endpoints in the stage. 
  ClientCertificateId string `json:"ClientCertificateId,omitempty"`

  // Indicates whether data trace logging is enabled for methods in the stage. API Gateway pushes these logs to Amazon CloudWatch Logs. 
  DataTraceEnabled bool `json:"DataTraceEnabled,omitempty"`

  // A description of the purpose of the stage.
  Description string `json:"Description,omitempty"`

  // The version identifier of the API documentation snapshot.
  DocumentationVersion string `json:"DocumentationVersion,omitempty"`

  // The logging level for this method. For valid values, see the loggingLevel property of the Stage resource in the Amazon API Gateway API Reference. 
  LoggingLevel string `json:"LoggingLevel,omitempty"`

  // Configures settings for all of the stage's methods.
  MethodSettings []*MethodSetting `json:"MethodSettings,omitempty"`

  // Indicates whether Amazon CloudWatch metrics are enabled for methods in the stage.
  MetricsEnabled bool `json:"MetricsEnabled,omitempty"`

  // An array of arbitrary tags (key-value pairs) to associate with the stage.
  Tags []*Tag `json:"Tags,omitempty"`

  // The number of burst requests per second that API Gateway permits across all APIs, stages, and methods in your AWS account.
  ThrottlingBurstLimit int `json:"ThrottlingBurstLimit,omitempty"`

  // The number of steady-state requests per second that API Gateway permits across all APIs, stages, and methods in your AWS account.
  ThrottlingRateLimit float64 `json:"ThrottlingRateLimit,omitempty"`

  // Specifies whether active tracing with X-ray is enabled for this stage.
  TracingEnabled bool `json:"TracingEnabled,omitempty"`

  // A map that defines the stage variables. Variable names must consist of alphanumeric characters, and the values must match the following regular expression: [A-Za-z0-9-._~:/?#&=,]+. 
  Variables *Variables `json:"Variables,omitempty"`
}

// StageVariableOverrides Stage variables overridden for a canary release deployment, including new stage variables introduced in the canary. These stage variables are represented as a string-to-string map between stage variable names and their values. 
type StageVariableOverrides struct {
}

// Tag 
type Tag struct {

  // The key name of the tag
  Key string `json:"Key"`

  // The value for the tag
  Value string `json:"Value"`
}

// Variables A map that defines the stage variables. Variable names must consist of alphanumeric characters, and the values must match the following regular expression: [A-Za-z0-9-._~:/?#&=,]+. 
type Variables struct {
}

func (strct *AccessLogSetting) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DestinationArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DestinationArn\": ")
	if tmp, err := json.Marshal(strct.DestinationArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Format" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Format\": ")
	if tmp, err := json.Marshal(strct.Format); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AccessLogSetting) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DestinationArn":
            if err := json.Unmarshal([]byte(v), &strct.DestinationArn); err != nil {
                return err
             }
        case "Format":
            if err := json.Unmarshal([]byte(v), &strct.Format); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *CanarySetting) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "PercentTraffic" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PercentTraffic\": ")
	if tmp, err := json.Marshal(strct.PercentTraffic); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StageVariableOverrides" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StageVariableOverrides\": ")
	if tmp, err := json.Marshal(strct.StageVariableOverrides); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "UseStageCache" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UseStageCache\": ")
	if tmp, err := json.Marshal(strct.UseStageCache); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CanarySetting) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "PercentTraffic":
            if err := json.Unmarshal([]byte(v), &strct.PercentTraffic); err != nil {
                return err
             }
        case "StageVariableOverrides":
            if err := json.Unmarshal([]byte(v), &strct.StageVariableOverrides); err != nil {
                return err
             }
        case "UseStageCache":
            if err := json.Unmarshal([]byte(v), &strct.UseStageCache); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *DeploymentCanarySettings) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "PercentTraffic" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PercentTraffic\": ")
	if tmp, err := json.Marshal(strct.PercentTraffic); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StageVariableOverrides" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StageVariableOverrides\": ")
	if tmp, err := json.Marshal(strct.StageVariableOverrides); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "UseStageCache" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UseStageCache\": ")
	if tmp, err := json.Marshal(strct.UseStageCache); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DeploymentCanarySettings) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "PercentTraffic":
            if err := json.Unmarshal([]byte(v), &strct.PercentTraffic); err != nil {
                return err
             }
        case "StageVariableOverrides":
            if err := json.Unmarshal([]byte(v), &strct.StageVariableOverrides); err != nil {
                return err
             }
        case "UseStageCache":
            if err := json.Unmarshal([]byte(v), &strct.UseStageCache); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *MethodSetting) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CacheDataEncrypted" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CacheDataEncrypted\": ")
	if tmp, err := json.Marshal(strct.CacheDataEncrypted); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CacheTtlInSeconds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CacheTtlInSeconds\": ")
	if tmp, err := json.Marshal(strct.CacheTtlInSeconds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CachingEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CachingEnabled\": ")
	if tmp, err := json.Marshal(strct.CachingEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DataTraceEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DataTraceEnabled\": ")
	if tmp, err := json.Marshal(strct.DataTraceEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "HttpMethod" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HttpMethod\": ")
	if tmp, err := json.Marshal(strct.HttpMethod); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LoggingLevel" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LoggingLevel\": ")
	if tmp, err := json.Marshal(strct.LoggingLevel); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MetricsEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MetricsEnabled\": ")
	if tmp, err := json.Marshal(strct.MetricsEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ResourcePath" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ResourcePath\": ")
	if tmp, err := json.Marshal(strct.ResourcePath); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ThrottlingBurstLimit" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ThrottlingBurstLimit\": ")
	if tmp, err := json.Marshal(strct.ThrottlingBurstLimit); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ThrottlingRateLimit" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ThrottlingRateLimit\": ")
	if tmp, err := json.Marshal(strct.ThrottlingRateLimit); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MethodSetting) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CacheDataEncrypted":
            if err := json.Unmarshal([]byte(v), &strct.CacheDataEncrypted); err != nil {
                return err
             }
        case "CacheTtlInSeconds":
            if err := json.Unmarshal([]byte(v), &strct.CacheTtlInSeconds); err != nil {
                return err
             }
        case "CachingEnabled":
            if err := json.Unmarshal([]byte(v), &strct.CachingEnabled); err != nil {
                return err
             }
        case "DataTraceEnabled":
            if err := json.Unmarshal([]byte(v), &strct.DataTraceEnabled); err != nil {
                return err
             }
        case "HttpMethod":
            if err := json.Unmarshal([]byte(v), &strct.HttpMethod); err != nil {
                return err
             }
        case "LoggingLevel":
            if err := json.Unmarshal([]byte(v), &strct.LoggingLevel); err != nil {
                return err
             }
        case "MetricsEnabled":
            if err := json.Unmarshal([]byte(v), &strct.MetricsEnabled); err != nil {
                return err
             }
        case "ResourcePath":
            if err := json.Unmarshal([]byte(v), &strct.ResourcePath); err != nil {
                return err
             }
        case "ThrottlingBurstLimit":
            if err := json.Unmarshal([]byte(v), &strct.ThrottlingBurstLimit); err != nil {
                return err
             }
        case "ThrottlingRateLimit":
            if err := json.Unmarshal([]byte(v), &strct.ThrottlingRateLimit); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DeploymentCanarySettings" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DeploymentCanarySettings\": ")
	if tmp, err := json.Marshal(strct.DeploymentCanarySettings); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DeploymentId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DeploymentId\": ")
	if tmp, err := json.Marshal(strct.DeploymentId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RestApiId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RestApiId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RestApiId\": ")
	if tmp, err := json.Marshal(strct.RestApiId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StageDescription" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StageDescription\": ")
	if tmp, err := json.Marshal(strct.StageDescription); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StageName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StageName\": ")
	if tmp, err := json.Marshal(strct.StageName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    RestApiIdReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DeploymentCanarySettings":
            if err := json.Unmarshal([]byte(v), &strct.DeploymentCanarySettings); err != nil {
                return err
             }
        case "DeploymentId":
            if err := json.Unmarshal([]byte(v), &strct.DeploymentId); err != nil {
                return err
             }
        case "Description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "RestApiId":
            if err := json.Unmarshal([]byte(v), &strct.RestApiId); err != nil {
                return err
             }
            RestApiIdReceived = true
        case "StageDescription":
            if err := json.Unmarshal([]byte(v), &strct.StageDescription); err != nil {
                return err
             }
        case "StageName":
            if err := json.Unmarshal([]byte(v), &strct.StageName); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if RestApiId (a required property) was received
    if !RestApiIdReceived {
        return errors.New("\"RestApiId\" is required but was not present")
    }
    return nil
}

func (strct *StageDescription) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AccessLogSetting" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AccessLogSetting\": ")
	if tmp, err := json.Marshal(strct.AccessLogSetting); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CacheClusterEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CacheClusterEnabled\": ")
	if tmp, err := json.Marshal(strct.CacheClusterEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CacheClusterSize" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CacheClusterSize\": ")
	if tmp, err := json.Marshal(strct.CacheClusterSize); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CacheDataEncrypted" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CacheDataEncrypted\": ")
	if tmp, err := json.Marshal(strct.CacheDataEncrypted); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CacheTtlInSeconds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CacheTtlInSeconds\": ")
	if tmp, err := json.Marshal(strct.CacheTtlInSeconds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CachingEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CachingEnabled\": ")
	if tmp, err := json.Marshal(strct.CachingEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CanarySetting" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CanarySetting\": ")
	if tmp, err := json.Marshal(strct.CanarySetting); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ClientCertificateId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ClientCertificateId\": ")
	if tmp, err := json.Marshal(strct.ClientCertificateId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DataTraceEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DataTraceEnabled\": ")
	if tmp, err := json.Marshal(strct.DataTraceEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DocumentationVersion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DocumentationVersion\": ")
	if tmp, err := json.Marshal(strct.DocumentationVersion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LoggingLevel" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LoggingLevel\": ")
	if tmp, err := json.Marshal(strct.LoggingLevel); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MethodSettings" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MethodSettings\": ")
	if tmp, err := json.Marshal(strct.MethodSettings); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MetricsEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MetricsEnabled\": ")
	if tmp, err := json.Marshal(strct.MetricsEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ThrottlingBurstLimit" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ThrottlingBurstLimit\": ")
	if tmp, err := json.Marshal(strct.ThrottlingBurstLimit); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ThrottlingRateLimit" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ThrottlingRateLimit\": ")
	if tmp, err := json.Marshal(strct.ThrottlingRateLimit); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TracingEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TracingEnabled\": ")
	if tmp, err := json.Marshal(strct.TracingEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Variables" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Variables\": ")
	if tmp, err := json.Marshal(strct.Variables); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *StageDescription) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AccessLogSetting":
            if err := json.Unmarshal([]byte(v), &strct.AccessLogSetting); err != nil {
                return err
             }
        case "CacheClusterEnabled":
            if err := json.Unmarshal([]byte(v), &strct.CacheClusterEnabled); err != nil {
                return err
             }
        case "CacheClusterSize":
            if err := json.Unmarshal([]byte(v), &strct.CacheClusterSize); err != nil {
                return err
             }
        case "CacheDataEncrypted":
            if err := json.Unmarshal([]byte(v), &strct.CacheDataEncrypted); err != nil {
                return err
             }
        case "CacheTtlInSeconds":
            if err := json.Unmarshal([]byte(v), &strct.CacheTtlInSeconds); err != nil {
                return err
             }
        case "CachingEnabled":
            if err := json.Unmarshal([]byte(v), &strct.CachingEnabled); err != nil {
                return err
             }
        case "CanarySetting":
            if err := json.Unmarshal([]byte(v), &strct.CanarySetting); err != nil {
                return err
             }
        case "ClientCertificateId":
            if err := json.Unmarshal([]byte(v), &strct.ClientCertificateId); err != nil {
                return err
             }
        case "DataTraceEnabled":
            if err := json.Unmarshal([]byte(v), &strct.DataTraceEnabled); err != nil {
                return err
             }
        case "Description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "DocumentationVersion":
            if err := json.Unmarshal([]byte(v), &strct.DocumentationVersion); err != nil {
                return err
             }
        case "LoggingLevel":
            if err := json.Unmarshal([]byte(v), &strct.LoggingLevel); err != nil {
                return err
             }
        case "MethodSettings":
            if err := json.Unmarshal([]byte(v), &strct.MethodSettings); err != nil {
                return err
             }
        case "MetricsEnabled":
            if err := json.Unmarshal([]byte(v), &strct.MetricsEnabled); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        case "ThrottlingBurstLimit":
            if err := json.Unmarshal([]byte(v), &strct.ThrottlingBurstLimit); err != nil {
                return err
             }
        case "ThrottlingRateLimit":
            if err := json.Unmarshal([]byte(v), &strct.ThrottlingRateLimit); err != nil {
                return err
             }
        case "TracingEnabled":
            if err := json.Unmarshal([]byte(v), &strct.TracingEnabled); err != nil {
                return err
             }
        case "Variables":
            if err := json.Unmarshal([]byte(v), &strct.Variables); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *StageVariableOverrides) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *StageVariableOverrides) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *Variables) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Variables) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}
