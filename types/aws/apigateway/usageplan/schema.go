// Code generated by schema-generate. DO NOT EDIT.

package usageplan

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// ApiStage 
type ApiStage struct {

  // The ID of an API that is in the specified Stage property that you want to associate with the usage plan.
  ApiId string `json:"ApiId,omitempty"`

  // The name of the stage to associate with the usage plan.
  Stage string `json:"Stage,omitempty"`

  // Map containing method-level throttling information for an API stage in a usage plan. The key for the map is the path and method for which to configure custom throttling, for example, '/pets/GET'. Duplicates are not allowed.
  Throttle *Throttle `json:"Throttle,omitempty"`
}

// QuotaSettings 
type QuotaSettings struct {

  // The maximum number of requests that users can make within the specified time period.
  Limit int `json:"Limit,omitempty"`

  // For the initial time period, the number of requests to subtract from the specified limit. When you first implement a usage plan, the plan might start in the middle of the week or month. With this property, you can decrease the limit for this initial time period.
  Offset int `json:"Offset,omitempty"`

  // The time period for which the maximum limit of requests applies, such as DAY or WEEK. For valid values, see the period property for the UsagePlan resource in the Amazon API Gateway REST API Reference.
  Period string `json:"Period,omitempty"`
}

// Resource Resource Type definition for AWS::ApiGateway::UsagePlan
type Resource struct {

  // The API stages to associate with this usage plan.
  ApiStages []*ApiStage `json:"ApiStages,omitempty"`

  // A description of the usage plan.
  Description string `json:"Description,omitempty"`

  // The provider-assigned unique ID for this managed resource.
  Id string `json:"Id,omitempty"`

  // Configures the number of requests that users can make within a given interval.
  Quota *QuotaSettings `json:"Quota,omitempty"`

  // An array of arbitrary tags (key-value pairs) to associate with the usage plan.
  Tags []*Tag `json:"Tags,omitempty"`

  // Configures the overall request rate (average requests per second) and burst capacity.
  Throttle *ThrottleSettings `json:"Throttle,omitempty"`

  // A name for the usage plan.
  UsagePlanName string `json:"UsagePlanName,omitempty"`
}

// Tag 
type Tag struct {

  // The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
  Key string `json:"Key"`

  // The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
  Value string `json:"Value"`
}

// Throttle Map containing method-level throttling information for an API stage in a usage plan. The key for the map is the path and method for which to configure custom throttling, for example, '/pets/GET'. Duplicates are not allowed.
type Throttle struct {
}

// ThrottleSettings 
type ThrottleSettings struct {

  // The maximum API request rate limit over a time ranging from one to a few seconds. The maximum API request rate limit depends on whether the underlying token bucket is at its full capacity.
  BurstLimit int `json:"BurstLimit,omitempty"`

  // The API request steady-state rate limit (average requests per second over an extended period of time).
  RateLimit float64 `json:"RateLimit,omitempty"`
}

func (strct *ApiStage) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ApiId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ApiId\": ")
	if tmp, err := json.Marshal(strct.ApiId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Stage" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Stage\": ")
	if tmp, err := json.Marshal(strct.Stage); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Throttle" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Throttle\": ")
	if tmp, err := json.Marshal(strct.Throttle); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ApiStage) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ApiId":
            if err := json.Unmarshal([]byte(v), &strct.ApiId); err != nil {
                return err
             }
        case "Stage":
            if err := json.Unmarshal([]byte(v), &strct.Stage); err != nil {
                return err
             }
        case "Throttle":
            if err := json.Unmarshal([]byte(v), &strct.Throttle); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *QuotaSettings) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Limit" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Limit\": ")
	if tmp, err := json.Marshal(strct.Limit); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Offset" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Offset\": ")
	if tmp, err := json.Marshal(strct.Offset); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Period" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Period\": ")
	if tmp, err := json.Marshal(strct.Period); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *QuotaSettings) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Limit":
            if err := json.Unmarshal([]byte(v), &strct.Limit); err != nil {
                return err
             }
        case "Offset":
            if err := json.Unmarshal([]byte(v), &strct.Offset); err != nil {
                return err
             }
        case "Period":
            if err := json.Unmarshal([]byte(v), &strct.Period); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ApiStages" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ApiStages\": ")
	if tmp, err := json.Marshal(strct.ApiStages); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Id" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Quota" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Quota\": ")
	if tmp, err := json.Marshal(strct.Quota); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Throttle" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Throttle\": ")
	if tmp, err := json.Marshal(strct.Throttle); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "UsagePlanName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UsagePlanName\": ")
	if tmp, err := json.Marshal(strct.UsagePlanName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ApiStages":
            if err := json.Unmarshal([]byte(v), &strct.ApiStages); err != nil {
                return err
             }
        case "Description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "Id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
        case "Quota":
            if err := json.Unmarshal([]byte(v), &strct.Quota); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        case "Throttle":
            if err := json.Unmarshal([]byte(v), &strct.Throttle); err != nil {
                return err
             }
        case "UsagePlanName":
            if err := json.Unmarshal([]byte(v), &strct.UsagePlanName); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *Throttle) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Throttle) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ThrottleSettings) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "BurstLimit" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BurstLimit\": ")
	if tmp, err := json.Marshal(strct.BurstLimit); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RateLimit" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RateLimit\": ")
	if tmp, err := json.Marshal(strct.RateLimit); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ThrottleSettings) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BurstLimit":
            if err := json.Unmarshal([]byte(v), &strct.BurstLimit); err != nil {
                return err
             }
        case "RateLimit":
            if err := json.Unmarshal([]byte(v), &strct.RateLimit); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}
