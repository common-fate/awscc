// Code generated by schema-generate. DO NOT EDIT.

package job

import (
    "errors"
    "bytes"
    "encoding/json"
    "fmt"
)

// AllowedStatistics 
type AllowedStatistics struct {
  Statistics []string `json:"Statistics"`
}

// ColumnSelector 
type ColumnSelector struct {
  Name string `json:"Name,omitempty"`
  Regex string `json:"Regex,omitempty"`
}

// ColumnStatisticsConfiguration 
type ColumnStatisticsConfiguration struct {
  Selectors []*ColumnSelector `json:"Selectors,omitempty"`
  Statistics *StatisticsConfiguration `json:"Statistics"`
}

// CsvOutputOptions Output Csv options
type CsvOutputOptions struct {
  Delimiter string `json:"Delimiter,omitempty"`
}

// DataCatalogOutput 
type DataCatalogOutput struct {
  CatalogId string `json:"CatalogId,omitempty"`
  DatabaseName string `json:"DatabaseName"`
  DatabaseOptions *DatabaseTableOutputOptions `json:"DatabaseOptions,omitempty"`
  Overwrite bool `json:"Overwrite,omitempty"`
  S3Options *S3TableOutputOptions `json:"S3Options,omitempty"`
  TableName string `json:"TableName"`
}

// DatabaseOutput 
type DatabaseOutput struct {
  DatabaseOptions *DatabaseTableOutputOptions `json:"DatabaseOptions"`

  // Database table name
  DatabaseOutputMode string `json:"DatabaseOutputMode,omitempty"`

  // Glue connection name
  GlueConnectionName string `json:"GlueConnectionName"`
}

// DatabaseTableOutputOptions 
type DatabaseTableOutputOptions struct {
  TableName string `json:"TableName"`
  TempDirectory *S3Location `json:"TempDirectory,omitempty"`
}

// EntityDetectorConfiguration 
type EntityDetectorConfiguration struct {
  AllowedStatistics *AllowedStatistics `json:"AllowedStatistics,omitempty"`
  EntityTypes []string `json:"EntityTypes"`
}

// JobSample Job Sample
type JobSample struct {
  Mode string `json:"Mode,omitempty"`
  Size int `json:"Size,omitempty"`
}

// Output 
type Output struct {
  CompressionFormat string `json:"CompressionFormat,omitempty"`
  Format string `json:"Format,omitempty"`
  FormatOptions *OutputFormatOptions `json:"FormatOptions,omitempty"`
  Location *S3Location `json:"Location"`
  MaxOutputFiles int `json:"MaxOutputFiles,omitempty"`
  Overwrite bool `json:"Overwrite,omitempty"`
  PartitionColumns []string `json:"PartitionColumns,omitempty"`
}

// OutputFormatOptions Format options for job Output
type OutputFormatOptions struct {
  Csv *CsvOutputOptions `json:"Csv,omitempty"`
}

// OutputLocation Output location
type OutputLocation struct {
  Bucket string `json:"Bucket"`
  BucketOwner string `json:"BucketOwner,omitempty"`
  Key string `json:"Key,omitempty"`
}

// ParameterMap 
type ParameterMap struct {
}

// ProfileConfiguration 
type ProfileConfiguration struct {
  ColumnStatisticsConfigurations []*ColumnStatisticsConfiguration `json:"ColumnStatisticsConfigurations,omitempty"`
  DatasetStatisticsConfiguration *StatisticsConfiguration `json:"DatasetStatisticsConfiguration,omitempty"`
  EntityDetectorConfiguration *EntityDetectorConfiguration `json:"EntityDetectorConfiguration,omitempty"`
  ProfileColumns []*ColumnSelector `json:"ProfileColumns,omitempty"`
}

// Recipe 
type Recipe struct {

  // Recipe name
  Name string `json:"Name"`

  // Recipe version
  Version string `json:"Version,omitempty"`
}

// Resource Resource schema for AWS::DataBrew::Job.
type Resource struct {
  DataCatalogOutputs []*DataCatalogOutput `json:"DataCatalogOutputs,omitempty"`
  DatabaseOutputs []*DatabaseOutput `json:"DatabaseOutputs,omitempty"`

  // Dataset name
  DatasetName string `json:"DatasetName,omitempty"`

  // Encryption Key Arn
  EncryptionKeyArn string `json:"EncryptionKeyArn,omitempty"`

  // Encryption mode
  EncryptionMode string `json:"EncryptionMode,omitempty"`

  // Job Sample
  JobSample *JobSample `json:"JobSample,omitempty"`

  // Log subscription
  LogSubscription string `json:"LogSubscription,omitempty"`

  // Max capacity
  MaxCapacity int `json:"MaxCapacity,omitempty"`

  // Max retries
  MaxRetries int `json:"MaxRetries,omitempty"`

  // Job name
  Name string `json:"Name"`

  // Output location
  OutputLocation *OutputLocation `json:"OutputLocation,omitempty"`
  Outputs []*Output `json:"Outputs,omitempty"`

  // Profile Job configuration
  ProfileConfiguration *ProfileConfiguration `json:"ProfileConfiguration,omitempty"`

  // Project name
  ProjectName string `json:"ProjectName,omitempty"`
  Recipe *Recipe `json:"Recipe,omitempty"`

  // Role arn
  RoleArn string `json:"RoleArn"`
  Tags []*Tag `json:"Tags,omitempty"`

  // Timeout
  Timeout int `json:"Timeout,omitempty"`

  // Job type
  Type string `json:"Type"`

  // Data quality rules configuration
  ValidationConfigurations []*ValidationConfiguration `json:"ValidationConfigurations,omitempty"`
}

// S3Location S3 Output location
type S3Location struct {
  Bucket string `json:"Bucket"`
  BucketOwner string `json:"BucketOwner,omitempty"`
  Key string `json:"Key,omitempty"`
}

// S3TableOutputOptions 
type S3TableOutputOptions struct {
  Location *S3Location `json:"Location"`
}

// StatisticOverride 
type StatisticOverride struct {
  Parameters *ParameterMap `json:"Parameters"`
  Statistic string `json:"Statistic"`
}

// StatisticsConfiguration 
type StatisticsConfiguration struct {
  IncludedStatistics []string `json:"IncludedStatistics,omitempty"`
  Overrides []*StatisticOverride `json:"Overrides,omitempty"`
}

// Tag A key-value pair to associate with a resource.
type Tag struct {
  Key string `json:"Key"`
  Value string `json:"Value"`
}

// ValidationConfiguration Configuration to attach Rulesets to the job
type ValidationConfiguration struct {

  // Arn of the Ruleset
  RulesetArn string `json:"RulesetArn"`
  ValidationMode string `json:"ValidationMode,omitempty"`
}

func (strct *AllowedStatistics) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Statistics" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Statistics" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Statistics\": ")
	if tmp, err := json.Marshal(strct.Statistics); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AllowedStatistics) UnmarshalJSON(b []byte) error {
    StatisticsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Statistics":
            if err := json.Unmarshal([]byte(v), &strct.Statistics); err != nil {
                return err
             }
            StatisticsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Statistics (a required property) was received
    if !StatisticsReceived {
        return errors.New("\"Statistics\" is required but was not present")
    }
    return nil
}

func (strct *ColumnSelector) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Regex" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Regex\": ")
	if tmp, err := json.Marshal(strct.Regex); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ColumnSelector) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "Regex":
            if err := json.Unmarshal([]byte(v), &strct.Regex); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ColumnStatisticsConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Selectors" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Selectors\": ")
	if tmp, err := json.Marshal(strct.Selectors); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Statistics" field is required
    if strct.Statistics == nil {
        return nil, errors.New("Statistics is a required field")
    }
    // Marshal the "Statistics" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Statistics\": ")
	if tmp, err := json.Marshal(strct.Statistics); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ColumnStatisticsConfiguration) UnmarshalJSON(b []byte) error {
    StatisticsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Selectors":
            if err := json.Unmarshal([]byte(v), &strct.Selectors); err != nil {
                return err
             }
        case "Statistics":
            if err := json.Unmarshal([]byte(v), &strct.Statistics); err != nil {
                return err
             }
            StatisticsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Statistics (a required property) was received
    if !StatisticsReceived {
        return errors.New("\"Statistics\" is required but was not present")
    }
    return nil
}

func (strct *CsvOutputOptions) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Delimiter" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Delimiter\": ")
	if tmp, err := json.Marshal(strct.Delimiter); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CsvOutputOptions) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Delimiter":
            if err := json.Unmarshal([]byte(v), &strct.Delimiter); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *DataCatalogOutput) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CatalogId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CatalogId\": ")
	if tmp, err := json.Marshal(strct.CatalogId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "DatabaseName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "DatabaseName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DatabaseName\": ")
	if tmp, err := json.Marshal(strct.DatabaseName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DatabaseOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DatabaseOptions\": ")
	if tmp, err := json.Marshal(strct.DatabaseOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Overwrite" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Overwrite\": ")
	if tmp, err := json.Marshal(strct.Overwrite); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "S3Options" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3Options\": ")
	if tmp, err := json.Marshal(strct.S3Options); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TableName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TableName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TableName\": ")
	if tmp, err := json.Marshal(strct.TableName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DataCatalogOutput) UnmarshalJSON(b []byte) error {
    DatabaseNameReceived := false
    TableNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CatalogId":
            if err := json.Unmarshal([]byte(v), &strct.CatalogId); err != nil {
                return err
             }
        case "DatabaseName":
            if err := json.Unmarshal([]byte(v), &strct.DatabaseName); err != nil {
                return err
             }
            DatabaseNameReceived = true
        case "DatabaseOptions":
            if err := json.Unmarshal([]byte(v), &strct.DatabaseOptions); err != nil {
                return err
             }
        case "Overwrite":
            if err := json.Unmarshal([]byte(v), &strct.Overwrite); err != nil {
                return err
             }
        case "S3Options":
            if err := json.Unmarshal([]byte(v), &strct.S3Options); err != nil {
                return err
             }
        case "TableName":
            if err := json.Unmarshal([]byte(v), &strct.TableName); err != nil {
                return err
             }
            TableNameReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if DatabaseName (a required property) was received
    if !DatabaseNameReceived {
        return errors.New("\"DatabaseName\" is required but was not present")
    }
    // check if TableName (a required property) was received
    if !TableNameReceived {
        return errors.New("\"TableName\" is required but was not present")
    }
    return nil
}

func (strct *DatabaseOutput) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "DatabaseOptions" field is required
    if strct.DatabaseOptions == nil {
        return nil, errors.New("DatabaseOptions is a required field")
    }
    // Marshal the "DatabaseOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DatabaseOptions\": ")
	if tmp, err := json.Marshal(strct.DatabaseOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DatabaseOutputMode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DatabaseOutputMode\": ")
	if tmp, err := json.Marshal(strct.DatabaseOutputMode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "GlueConnectionName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "GlueConnectionName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"GlueConnectionName\": ")
	if tmp, err := json.Marshal(strct.GlueConnectionName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DatabaseOutput) UnmarshalJSON(b []byte) error {
    DatabaseOptionsReceived := false
    GlueConnectionNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DatabaseOptions":
            if err := json.Unmarshal([]byte(v), &strct.DatabaseOptions); err != nil {
                return err
             }
            DatabaseOptionsReceived = true
        case "DatabaseOutputMode":
            if err := json.Unmarshal([]byte(v), &strct.DatabaseOutputMode); err != nil {
                return err
             }
        case "GlueConnectionName":
            if err := json.Unmarshal([]byte(v), &strct.GlueConnectionName); err != nil {
                return err
             }
            GlueConnectionNameReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if DatabaseOptions (a required property) was received
    if !DatabaseOptionsReceived {
        return errors.New("\"DatabaseOptions\" is required but was not present")
    }
    // check if GlueConnectionName (a required property) was received
    if !GlueConnectionNameReceived {
        return errors.New("\"GlueConnectionName\" is required but was not present")
    }
    return nil
}

func (strct *DatabaseTableOutputOptions) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "TableName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TableName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TableName\": ")
	if tmp, err := json.Marshal(strct.TableName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TempDirectory" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TempDirectory\": ")
	if tmp, err := json.Marshal(strct.TempDirectory); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DatabaseTableOutputOptions) UnmarshalJSON(b []byte) error {
    TableNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "TableName":
            if err := json.Unmarshal([]byte(v), &strct.TableName); err != nil {
                return err
             }
            TableNameReceived = true
        case "TempDirectory":
            if err := json.Unmarshal([]byte(v), &strct.TempDirectory); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if TableName (a required property) was received
    if !TableNameReceived {
        return errors.New("\"TableName\" is required but was not present")
    }
    return nil
}

func (strct *EntityDetectorConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AllowedStatistics" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AllowedStatistics\": ")
	if tmp, err := json.Marshal(strct.AllowedStatistics); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "EntityTypes" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "EntityTypes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EntityTypes\": ")
	if tmp, err := json.Marshal(strct.EntityTypes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *EntityDetectorConfiguration) UnmarshalJSON(b []byte) error {
    EntityTypesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AllowedStatistics":
            if err := json.Unmarshal([]byte(v), &strct.AllowedStatistics); err != nil {
                return err
             }
        case "EntityTypes":
            if err := json.Unmarshal([]byte(v), &strct.EntityTypes); err != nil {
                return err
             }
            EntityTypesReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if EntityTypes (a required property) was received
    if !EntityTypesReceived {
        return errors.New("\"EntityTypes\" is required but was not present")
    }
    return nil
}

func (strct *JobSample) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Mode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Mode\": ")
	if tmp, err := json.Marshal(strct.Mode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Size" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Size\": ")
	if tmp, err := json.Marshal(strct.Size); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *JobSample) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Mode":
            if err := json.Unmarshal([]byte(v), &strct.Mode); err != nil {
                return err
             }
        case "Size":
            if err := json.Unmarshal([]byte(v), &strct.Size); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Output) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CompressionFormat" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CompressionFormat\": ")
	if tmp, err := json.Marshal(strct.CompressionFormat); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Format" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Format\": ")
	if tmp, err := json.Marshal(strct.Format); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FormatOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FormatOptions\": ")
	if tmp, err := json.Marshal(strct.FormatOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Location" field is required
    if strct.Location == nil {
        return nil, errors.New("Location is a required field")
    }
    // Marshal the "Location" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Location\": ")
	if tmp, err := json.Marshal(strct.Location); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MaxOutputFiles" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaxOutputFiles\": ")
	if tmp, err := json.Marshal(strct.MaxOutputFiles); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Overwrite" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Overwrite\": ")
	if tmp, err := json.Marshal(strct.Overwrite); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PartitionColumns" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PartitionColumns\": ")
	if tmp, err := json.Marshal(strct.PartitionColumns); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Output) UnmarshalJSON(b []byte) error {
    LocationReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CompressionFormat":
            if err := json.Unmarshal([]byte(v), &strct.CompressionFormat); err != nil {
                return err
             }
        case "Format":
            if err := json.Unmarshal([]byte(v), &strct.Format); err != nil {
                return err
             }
        case "FormatOptions":
            if err := json.Unmarshal([]byte(v), &strct.FormatOptions); err != nil {
                return err
             }
        case "Location":
            if err := json.Unmarshal([]byte(v), &strct.Location); err != nil {
                return err
             }
            LocationReceived = true
        case "MaxOutputFiles":
            if err := json.Unmarshal([]byte(v), &strct.MaxOutputFiles); err != nil {
                return err
             }
        case "Overwrite":
            if err := json.Unmarshal([]byte(v), &strct.Overwrite); err != nil {
                return err
             }
        case "PartitionColumns":
            if err := json.Unmarshal([]byte(v), &strct.PartitionColumns); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Location (a required property) was received
    if !LocationReceived {
        return errors.New("\"Location\" is required but was not present")
    }
    return nil
}

func (strct *OutputFormatOptions) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Csv" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Csv\": ")
	if tmp, err := json.Marshal(strct.Csv); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *OutputFormatOptions) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Csv":
            if err := json.Unmarshal([]byte(v), &strct.Csv); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *OutputLocation) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Bucket" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Bucket" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Bucket\": ")
	if tmp, err := json.Marshal(strct.Bucket); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BucketOwner" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BucketOwner\": ")
	if tmp, err := json.Marshal(strct.BucketOwner); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *OutputLocation) UnmarshalJSON(b []byte) error {
    BucketReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Bucket":
            if err := json.Unmarshal([]byte(v), &strct.Bucket); err != nil {
                return err
             }
            BucketReceived = true
        case "BucketOwner":
            if err := json.Unmarshal([]byte(v), &strct.BucketOwner); err != nil {
                return err
             }
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Bucket (a required property) was received
    if !BucketReceived {
        return errors.New("\"Bucket\" is required but was not present")
    }
    return nil
}

func (strct *ParameterMap) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ParameterMap) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ProfileConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ColumnStatisticsConfigurations" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ColumnStatisticsConfigurations\": ")
	if tmp, err := json.Marshal(strct.ColumnStatisticsConfigurations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DatasetStatisticsConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DatasetStatisticsConfiguration\": ")
	if tmp, err := json.Marshal(strct.DatasetStatisticsConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EntityDetectorConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EntityDetectorConfiguration\": ")
	if tmp, err := json.Marshal(strct.EntityDetectorConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ProfileColumns" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ProfileColumns\": ")
	if tmp, err := json.Marshal(strct.ProfileColumns); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ProfileConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ColumnStatisticsConfigurations":
            if err := json.Unmarshal([]byte(v), &strct.ColumnStatisticsConfigurations); err != nil {
                return err
             }
        case "DatasetStatisticsConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.DatasetStatisticsConfiguration); err != nil {
                return err
             }
        case "EntityDetectorConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.EntityDetectorConfiguration); err != nil {
                return err
             }
        case "ProfileColumns":
            if err := json.Unmarshal([]byte(v), &strct.ProfileColumns); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Recipe) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Version" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Version\": ")
	if tmp, err := json.Marshal(strct.Version); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Recipe) UnmarshalJSON(b []byte) error {
    NameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        case "Version":
            if err := json.Unmarshal([]byte(v), &strct.Version); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DataCatalogOutputs" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DataCatalogOutputs\": ")
	if tmp, err := json.Marshal(strct.DataCatalogOutputs); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DatabaseOutputs" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DatabaseOutputs\": ")
	if tmp, err := json.Marshal(strct.DatabaseOutputs); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DatasetName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DatasetName\": ")
	if tmp, err := json.Marshal(strct.DatasetName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EncryptionKeyArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EncryptionKeyArn\": ")
	if tmp, err := json.Marshal(strct.EncryptionKeyArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EncryptionMode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EncryptionMode\": ")
	if tmp, err := json.Marshal(strct.EncryptionMode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "JobSample" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"JobSample\": ")
	if tmp, err := json.Marshal(strct.JobSample); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LogSubscription" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LogSubscription\": ")
	if tmp, err := json.Marshal(strct.LogSubscription); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MaxCapacity" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaxCapacity\": ")
	if tmp, err := json.Marshal(strct.MaxCapacity); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MaxRetries" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaxRetries\": ")
	if tmp, err := json.Marshal(strct.MaxRetries); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OutputLocation" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OutputLocation\": ")
	if tmp, err := json.Marshal(strct.OutputLocation); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Outputs" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Outputs\": ")
	if tmp, err := json.Marshal(strct.Outputs); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ProfileConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ProfileConfiguration\": ")
	if tmp, err := json.Marshal(strct.ProfileConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ProjectName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ProjectName\": ")
	if tmp, err := json.Marshal(strct.ProjectName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Recipe" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Recipe\": ")
	if tmp, err := json.Marshal(strct.Recipe); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RoleArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoleArn\": ")
	if tmp, err := json.Marshal(strct.RoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Timeout" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Timeout\": ")
	if tmp, err := json.Marshal(strct.Timeout); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ValidationConfigurations" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ValidationConfigurations\": ")
	if tmp, err := json.Marshal(strct.ValidationConfigurations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    NameReceived := false
    RoleArnReceived := false
    TypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DataCatalogOutputs":
            if err := json.Unmarshal([]byte(v), &strct.DataCatalogOutputs); err != nil {
                return err
             }
        case "DatabaseOutputs":
            if err := json.Unmarshal([]byte(v), &strct.DatabaseOutputs); err != nil {
                return err
             }
        case "DatasetName":
            if err := json.Unmarshal([]byte(v), &strct.DatasetName); err != nil {
                return err
             }
        case "EncryptionKeyArn":
            if err := json.Unmarshal([]byte(v), &strct.EncryptionKeyArn); err != nil {
                return err
             }
        case "EncryptionMode":
            if err := json.Unmarshal([]byte(v), &strct.EncryptionMode); err != nil {
                return err
             }
        case "JobSample":
            if err := json.Unmarshal([]byte(v), &strct.JobSample); err != nil {
                return err
             }
        case "LogSubscription":
            if err := json.Unmarshal([]byte(v), &strct.LogSubscription); err != nil {
                return err
             }
        case "MaxCapacity":
            if err := json.Unmarshal([]byte(v), &strct.MaxCapacity); err != nil {
                return err
             }
        case "MaxRetries":
            if err := json.Unmarshal([]byte(v), &strct.MaxRetries); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        case "OutputLocation":
            if err := json.Unmarshal([]byte(v), &strct.OutputLocation); err != nil {
                return err
             }
        case "Outputs":
            if err := json.Unmarshal([]byte(v), &strct.Outputs); err != nil {
                return err
             }
        case "ProfileConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.ProfileConfiguration); err != nil {
                return err
             }
        case "ProjectName":
            if err := json.Unmarshal([]byte(v), &strct.ProjectName); err != nil {
                return err
             }
        case "Recipe":
            if err := json.Unmarshal([]byte(v), &strct.Recipe); err != nil {
                return err
             }
        case "RoleArn":
            if err := json.Unmarshal([]byte(v), &strct.RoleArn); err != nil {
                return err
             }
            RoleArnReceived = true
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        case "Timeout":
            if err := json.Unmarshal([]byte(v), &strct.Timeout); err != nil {
                return err
             }
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            TypeReceived = true
        case "ValidationConfigurations":
            if err := json.Unmarshal([]byte(v), &strct.ValidationConfigurations); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    // check if RoleArn (a required property) was received
    if !RoleArnReceived {
        return errors.New("\"RoleArn\" is required but was not present")
    }
    // check if Type (a required property) was received
    if !TypeReceived {
        return errors.New("\"Type\" is required but was not present")
    }
    return nil
}

func (strct *S3Location) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Bucket" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Bucket" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Bucket\": ")
	if tmp, err := json.Marshal(strct.Bucket); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BucketOwner" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BucketOwner\": ")
	if tmp, err := json.Marshal(strct.BucketOwner); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *S3Location) UnmarshalJSON(b []byte) error {
    BucketReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Bucket":
            if err := json.Unmarshal([]byte(v), &strct.Bucket); err != nil {
                return err
             }
            BucketReceived = true
        case "BucketOwner":
            if err := json.Unmarshal([]byte(v), &strct.BucketOwner); err != nil {
                return err
             }
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Bucket (a required property) was received
    if !BucketReceived {
        return errors.New("\"Bucket\" is required but was not present")
    }
    return nil
}

func (strct *S3TableOutputOptions) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Location" field is required
    if strct.Location == nil {
        return nil, errors.New("Location is a required field")
    }
    // Marshal the "Location" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Location\": ")
	if tmp, err := json.Marshal(strct.Location); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *S3TableOutputOptions) UnmarshalJSON(b []byte) error {
    LocationReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Location":
            if err := json.Unmarshal([]byte(v), &strct.Location); err != nil {
                return err
             }
            LocationReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Location (a required property) was received
    if !LocationReceived {
        return errors.New("\"Location\" is required but was not present")
    }
    return nil
}

func (strct *StatisticOverride) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Parameters" field is required
    if strct.Parameters == nil {
        return nil, errors.New("Parameters is a required field")
    }
    // Marshal the "Parameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Parameters\": ")
	if tmp, err := json.Marshal(strct.Parameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Statistic" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Statistic" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Statistic\": ")
	if tmp, err := json.Marshal(strct.Statistic); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *StatisticOverride) UnmarshalJSON(b []byte) error {
    ParametersReceived := false
    StatisticReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Parameters":
            if err := json.Unmarshal([]byte(v), &strct.Parameters); err != nil {
                return err
             }
            ParametersReceived = true
        case "Statistic":
            if err := json.Unmarshal([]byte(v), &strct.Statistic); err != nil {
                return err
             }
            StatisticReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Parameters (a required property) was received
    if !ParametersReceived {
        return errors.New("\"Parameters\" is required but was not present")
    }
    // check if Statistic (a required property) was received
    if !StatisticReceived {
        return errors.New("\"Statistic\" is required but was not present")
    }
    return nil
}

func (strct *StatisticsConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "IncludedStatistics" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IncludedStatistics\": ")
	if tmp, err := json.Marshal(strct.IncludedStatistics); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Overrides" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Overrides\": ")
	if tmp, err := json.Marshal(strct.Overrides); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *StatisticsConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "IncludedStatistics":
            if err := json.Unmarshal([]byte(v), &strct.IncludedStatistics); err != nil {
                return err
             }
        case "Overrides":
            if err := json.Unmarshal([]byte(v), &strct.Overrides); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *ValidationConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "RulesetArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RulesetArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RulesetArn\": ")
	if tmp, err := json.Marshal(strct.RulesetArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ValidationMode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ValidationMode\": ")
	if tmp, err := json.Marshal(strct.ValidationMode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ValidationConfiguration) UnmarshalJSON(b []byte) error {
    RulesetArnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "RulesetArn":
            if err := json.Unmarshal([]byte(v), &strct.RulesetArn); err != nil {
                return err
             }
            RulesetArnReceived = true
        case "ValidationMode":
            if err := json.Unmarshal([]byte(v), &strct.ValidationMode); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if RulesetArn (a required property) was received
    if !RulesetArnReceived {
        return errors.New("\"RulesetArn\" is required but was not present")
    }
    return nil
}
