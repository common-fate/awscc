// Code generated by schema-generate. DO NOT EDIT.

package recipe

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// Action 
type Action struct {

  // Step action operation
  Operation string `json:"Operation"`
  Parameters interface{} `json:"Parameters,omitempty"`
}

// ConditionExpression Condition expressions applied to the step action
type ConditionExpression struct {

  // Input condition to be applied to the target column
  Condition string `json:"Condition"`

  // Name of the target column
  TargetColumn string `json:"TargetColumn"`

  // Value of the condition
  Value string `json:"Value,omitempty"`
}

// DataCatalogInputDefinition 
type DataCatalogInputDefinition struct {

  // Catalog id
  CatalogId string `json:"CatalogId,omitempty"`

  // Database name
  DatabaseName string `json:"DatabaseName,omitempty"`

  // Table name
  TableName string `json:"TableName,omitempty"`
  TempDirectory *S3Location `json:"TempDirectory,omitempty"`
}

// Input Input
type Input struct {
  DataCatalogInputDefinition *DataCatalogInputDefinition `json:"DataCatalogInputDefinition,omitempty"`
  S3InputDefinition *S3Location `json:"S3InputDefinition,omitempty"`
}

// ParameterMap 
type ParameterMap struct {
}

// RecipeParameters 
type RecipeParameters struct {
  AggregateFunction string `json:"AggregateFunction,omitempty"`
  Base string `json:"Base,omitempty"`
  CaseStatement string `json:"CaseStatement,omitempty"`
  CategoryMap string `json:"CategoryMap,omitempty"`
  CharsToRemove string `json:"CharsToRemove,omitempty"`
  CollapseConsecutiveWhitespace string `json:"CollapseConsecutiveWhitespace,omitempty"`
  ColumnDataType string `json:"ColumnDataType,omitempty"`
  ColumnRange string `json:"ColumnRange,omitempty"`
  Count string `json:"Count,omitempty"`
  CustomCharacters string `json:"CustomCharacters,omitempty"`
  CustomStopWords string `json:"CustomStopWords,omitempty"`
  CustomValue string `json:"CustomValue,omitempty"`
  DatasetsColumns string `json:"DatasetsColumns,omitempty"`
  DateAddValue string `json:"DateAddValue,omitempty"`
  DateTimeFormat string `json:"DateTimeFormat,omitempty"`
  DateTimeParameters string `json:"DateTimeParameters,omitempty"`
  DeleteOtherRows string `json:"DeleteOtherRows,omitempty"`
  Delimiter string `json:"Delimiter,omitempty"`
  EndPattern string `json:"EndPattern,omitempty"`
  EndPosition string `json:"EndPosition,omitempty"`
  EndValue string `json:"EndValue,omitempty"`
  ExpandContractions string `json:"ExpandContractions,omitempty"`
  Exponent string `json:"Exponent,omitempty"`
  FalseString string `json:"FalseString,omitempty"`
  GroupByAggFunctionOptions string `json:"GroupByAggFunctionOptions,omitempty"`
  GroupByColumns string `json:"GroupByColumns,omitempty"`
  HiddenColumns string `json:"HiddenColumns,omitempty"`
  IgnoreCase string `json:"IgnoreCase,omitempty"`
  IncludeInSplit string `json:"IncludeInSplit,omitempty"`

  // Input
  Input *Input `json:"Input,omitempty"`
  Interval string `json:"Interval,omitempty"`
  IsText string `json:"IsText,omitempty"`
  JoinKeys string `json:"JoinKeys,omitempty"`
  JoinType string `json:"JoinType,omitempty"`
  LeftColumns string `json:"LeftColumns,omitempty"`
  Limit string `json:"Limit,omitempty"`
  LowerBound string `json:"LowerBound,omitempty"`
  MapType string `json:"MapType,omitempty"`
  ModeType string `json:"ModeType,omitempty"`
  MultiLine bool `json:"MultiLine,omitempty"`
  NumRows string `json:"NumRows,omitempty"`
  NumRowsAfter string `json:"NumRowsAfter,omitempty"`
  NumRowsBefore string `json:"NumRowsBefore,omitempty"`
  OrderByColumn string `json:"OrderByColumn,omitempty"`
  OrderByColumns string `json:"OrderByColumns,omitempty"`
  Other string `json:"Other,omitempty"`
  Pattern string `json:"Pattern,omitempty"`
  PatternOption1 string `json:"PatternOption1,omitempty"`
  PatternOption2 string `json:"PatternOption2,omitempty"`
  PatternOptions string `json:"PatternOptions,omitempty"`
  Period string `json:"Period,omitempty"`
  Position string `json:"Position,omitempty"`
  RemoveAllPunctuation string `json:"RemoveAllPunctuation,omitempty"`
  RemoveAllQuotes string `json:"RemoveAllQuotes,omitempty"`
  RemoveAllWhitespace string `json:"RemoveAllWhitespace,omitempty"`
  RemoveCustomCharacters string `json:"RemoveCustomCharacters,omitempty"`
  RemoveCustomValue string `json:"RemoveCustomValue,omitempty"`
  RemoveLeadingAndTrailingPunctuation string `json:"RemoveLeadingAndTrailingPunctuation,omitempty"`
  RemoveLeadingAndTrailingQuotes string `json:"RemoveLeadingAndTrailingQuotes,omitempty"`
  RemoveLeadingAndTrailingWhitespace string `json:"RemoveLeadingAndTrailingWhitespace,omitempty"`
  RemoveLetters string `json:"RemoveLetters,omitempty"`
  RemoveNumbers string `json:"RemoveNumbers,omitempty"`
  RemoveSourceColumn string `json:"RemoveSourceColumn,omitempty"`
  RemoveSpecialCharacters string `json:"RemoveSpecialCharacters,omitempty"`
  RightColumns string `json:"RightColumns,omitempty"`
  SampleSize string `json:"SampleSize,omitempty"`
  SampleType string `json:"SampleType,omitempty"`
  SecondInput string `json:"SecondInput,omitempty"`
  SecondaryInputs []*SecondaryInput `json:"SecondaryInputs,omitempty"`
  SheetIndexes []int `json:"SheetIndexes,omitempty"`
  SheetNames []string `json:"SheetNames,omitempty"`
  SourceColumn string `json:"SourceColumn,omitempty"`
  SourceColumn1 string `json:"SourceColumn1,omitempty"`
  SourceColumn2 string `json:"SourceColumn2,omitempty"`
  SourceColumns string `json:"SourceColumns,omitempty"`
  StartColumnIndex string `json:"StartColumnIndex,omitempty"`
  StartPattern string `json:"StartPattern,omitempty"`
  StartPosition string `json:"StartPosition,omitempty"`
  StartValue string `json:"StartValue,omitempty"`
  StemmingMode string `json:"StemmingMode,omitempty"`
  StepCount string `json:"StepCount,omitempty"`
  StepIndex string `json:"StepIndex,omitempty"`
  StopWordsMode string `json:"StopWordsMode,omitempty"`
  Strategy string `json:"Strategy,omitempty"`
  TargetColumn string `json:"TargetColumn,omitempty"`
  TargetColumnNames string `json:"TargetColumnNames,omitempty"`
  TargetDateFormat string `json:"TargetDateFormat,omitempty"`
  TargetIndex string `json:"TargetIndex,omitempty"`
  TimeZone string `json:"TimeZone,omitempty"`
  TokenizerPattern string `json:"TokenizerPattern,omitempty"`
  TrueString string `json:"TrueString,omitempty"`
  UdfLang string `json:"UdfLang,omitempty"`
  Units string `json:"Units,omitempty"`
  UnpivotColumn string `json:"UnpivotColumn,omitempty"`
  UpperBound string `json:"UpperBound,omitempty"`
  UseNewDataFrame string `json:"UseNewDataFrame,omitempty"`
  Value string `json:"Value,omitempty"`
  Value1 string `json:"Value1,omitempty"`
  Value2 string `json:"Value2,omitempty"`
  ValueColumn string `json:"ValueColumn,omitempty"`
  ViewFrame string `json:"ViewFrame,omitempty"`
}

// RecipeStep 
type RecipeStep struct {
  Action *Action `json:"Action"`

  // Condition expressions applied to the step action
  ConditionExpressions []*ConditionExpression `json:"ConditionExpressions,omitempty"`
}

// Resource Resource schema for AWS::DataBrew::Recipe.
type Resource struct {

  // Description of the recipe
  Description string `json:"Description,omitempty"`

  // Recipe name
  Name string `json:"Name"`
  Steps []*StepsItems `json:"Steps"`
  Tags []*Tag `json:"Tags,omitempty"`
}

// S3Location Input location
type S3Location struct {
  Bucket string `json:"Bucket"`
  Key string `json:"Key,omitempty"`
}

// SecondaryInput Secondary input
type SecondaryInput struct {
  DataCatalogInputDefinition *DataCatalogInputDefinition `json:"DataCatalogInputDefinition,omitempty"`
  S3InputDefinition *S3Location `json:"S3InputDefinition,omitempty"`
}

// StepsItems 
type StepsItems struct {
}

// Tag A key-value pair to associate with a resource.
type Tag struct {
  Key string `json:"Key"`
  Value string `json:"Value"`
}

func (strct *Action) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Operation" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Operation" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Operation\": ")
	if tmp, err := json.Marshal(strct.Operation); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Parameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Parameters\": ")
	if tmp, err := json.Marshal(strct.Parameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Action) UnmarshalJSON(b []byte) error {
    OperationReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Operation":
            if err := json.Unmarshal([]byte(v), &strct.Operation); err != nil {
                return err
             }
            OperationReceived = true
        case "Parameters":
            if err := json.Unmarshal([]byte(v), &strct.Parameters); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Operation (a required property) was received
    if !OperationReceived {
        return errors.New("\"Operation\" is required but was not present")
    }
    return nil
}

func (strct *ConditionExpression) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Condition" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Condition" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Condition\": ")
	if tmp, err := json.Marshal(strct.Condition); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TargetColumn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TargetColumn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TargetColumn\": ")
	if tmp, err := json.Marshal(strct.TargetColumn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ConditionExpression) UnmarshalJSON(b []byte) error {
    ConditionReceived := false
    TargetColumnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Condition":
            if err := json.Unmarshal([]byte(v), &strct.Condition); err != nil {
                return err
             }
            ConditionReceived = true
        case "TargetColumn":
            if err := json.Unmarshal([]byte(v), &strct.TargetColumn); err != nil {
                return err
             }
            TargetColumnReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Condition (a required property) was received
    if !ConditionReceived {
        return errors.New("\"Condition\" is required but was not present")
    }
    // check if TargetColumn (a required property) was received
    if !TargetColumnReceived {
        return errors.New("\"TargetColumn\" is required but was not present")
    }
    return nil
}

func (strct *DataCatalogInputDefinition) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CatalogId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CatalogId\": ")
	if tmp, err := json.Marshal(strct.CatalogId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DatabaseName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DatabaseName\": ")
	if tmp, err := json.Marshal(strct.DatabaseName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TableName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TableName\": ")
	if tmp, err := json.Marshal(strct.TableName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TempDirectory" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TempDirectory\": ")
	if tmp, err := json.Marshal(strct.TempDirectory); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DataCatalogInputDefinition) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CatalogId":
            if err := json.Unmarshal([]byte(v), &strct.CatalogId); err != nil {
                return err
             }
        case "DatabaseName":
            if err := json.Unmarshal([]byte(v), &strct.DatabaseName); err != nil {
                return err
             }
        case "TableName":
            if err := json.Unmarshal([]byte(v), &strct.TableName); err != nil {
                return err
             }
        case "TempDirectory":
            if err := json.Unmarshal([]byte(v), &strct.TempDirectory); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Input) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DataCatalogInputDefinition" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DataCatalogInputDefinition\": ")
	if tmp, err := json.Marshal(strct.DataCatalogInputDefinition); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "S3InputDefinition" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3InputDefinition\": ")
	if tmp, err := json.Marshal(strct.S3InputDefinition); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Input) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DataCatalogInputDefinition":
            if err := json.Unmarshal([]byte(v), &strct.DataCatalogInputDefinition); err != nil {
                return err
             }
        case "S3InputDefinition":
            if err := json.Unmarshal([]byte(v), &strct.S3InputDefinition); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ParameterMap) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ParameterMap) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *RecipeParameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AggregateFunction" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AggregateFunction\": ")
	if tmp, err := json.Marshal(strct.AggregateFunction); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Base" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Base\": ")
	if tmp, err := json.Marshal(strct.Base); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CaseStatement" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CaseStatement\": ")
	if tmp, err := json.Marshal(strct.CaseStatement); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CategoryMap" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CategoryMap\": ")
	if tmp, err := json.Marshal(strct.CategoryMap); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CharsToRemove" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CharsToRemove\": ")
	if tmp, err := json.Marshal(strct.CharsToRemove); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CollapseConsecutiveWhitespace" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CollapseConsecutiveWhitespace\": ")
	if tmp, err := json.Marshal(strct.CollapseConsecutiveWhitespace); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ColumnDataType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ColumnDataType\": ")
	if tmp, err := json.Marshal(strct.ColumnDataType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ColumnRange" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ColumnRange\": ")
	if tmp, err := json.Marshal(strct.ColumnRange); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Count" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Count\": ")
	if tmp, err := json.Marshal(strct.Count); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CustomCharacters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CustomCharacters\": ")
	if tmp, err := json.Marshal(strct.CustomCharacters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CustomStopWords" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CustomStopWords\": ")
	if tmp, err := json.Marshal(strct.CustomStopWords); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CustomValue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CustomValue\": ")
	if tmp, err := json.Marshal(strct.CustomValue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DatasetsColumns" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DatasetsColumns\": ")
	if tmp, err := json.Marshal(strct.DatasetsColumns); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DateAddValue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DateAddValue\": ")
	if tmp, err := json.Marshal(strct.DateAddValue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DateTimeFormat" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DateTimeFormat\": ")
	if tmp, err := json.Marshal(strct.DateTimeFormat); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DateTimeParameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DateTimeParameters\": ")
	if tmp, err := json.Marshal(strct.DateTimeParameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DeleteOtherRows" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DeleteOtherRows\": ")
	if tmp, err := json.Marshal(strct.DeleteOtherRows); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Delimiter" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Delimiter\": ")
	if tmp, err := json.Marshal(strct.Delimiter); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EndPattern" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EndPattern\": ")
	if tmp, err := json.Marshal(strct.EndPattern); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EndPosition" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EndPosition\": ")
	if tmp, err := json.Marshal(strct.EndPosition); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EndValue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EndValue\": ")
	if tmp, err := json.Marshal(strct.EndValue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ExpandContractions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ExpandContractions\": ")
	if tmp, err := json.Marshal(strct.ExpandContractions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Exponent" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Exponent\": ")
	if tmp, err := json.Marshal(strct.Exponent); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FalseString" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FalseString\": ")
	if tmp, err := json.Marshal(strct.FalseString); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "GroupByAggFunctionOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"GroupByAggFunctionOptions\": ")
	if tmp, err := json.Marshal(strct.GroupByAggFunctionOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "GroupByColumns" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"GroupByColumns\": ")
	if tmp, err := json.Marshal(strct.GroupByColumns); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "HiddenColumns" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HiddenColumns\": ")
	if tmp, err := json.Marshal(strct.HiddenColumns); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IgnoreCase" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IgnoreCase\": ")
	if tmp, err := json.Marshal(strct.IgnoreCase); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IncludeInSplit" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IncludeInSplit\": ")
	if tmp, err := json.Marshal(strct.IncludeInSplit); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Input" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Input\": ")
	if tmp, err := json.Marshal(strct.Input); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Interval" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Interval\": ")
	if tmp, err := json.Marshal(strct.Interval); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IsText" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IsText\": ")
	if tmp, err := json.Marshal(strct.IsText); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "JoinKeys" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"JoinKeys\": ")
	if tmp, err := json.Marshal(strct.JoinKeys); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "JoinType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"JoinType\": ")
	if tmp, err := json.Marshal(strct.JoinType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LeftColumns" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LeftColumns\": ")
	if tmp, err := json.Marshal(strct.LeftColumns); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Limit" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Limit\": ")
	if tmp, err := json.Marshal(strct.Limit); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LowerBound" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LowerBound\": ")
	if tmp, err := json.Marshal(strct.LowerBound); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MapType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MapType\": ")
	if tmp, err := json.Marshal(strct.MapType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ModeType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ModeType\": ")
	if tmp, err := json.Marshal(strct.ModeType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MultiLine" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MultiLine\": ")
	if tmp, err := json.Marshal(strct.MultiLine); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "NumRows" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NumRows\": ")
	if tmp, err := json.Marshal(strct.NumRows); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "NumRowsAfter" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NumRowsAfter\": ")
	if tmp, err := json.Marshal(strct.NumRowsAfter); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "NumRowsBefore" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NumRowsBefore\": ")
	if tmp, err := json.Marshal(strct.NumRowsBefore); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OrderByColumn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OrderByColumn\": ")
	if tmp, err := json.Marshal(strct.OrderByColumn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OrderByColumns" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OrderByColumns\": ")
	if tmp, err := json.Marshal(strct.OrderByColumns); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Other" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Other\": ")
	if tmp, err := json.Marshal(strct.Other); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Pattern" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Pattern\": ")
	if tmp, err := json.Marshal(strct.Pattern); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PatternOption1" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PatternOption1\": ")
	if tmp, err := json.Marshal(strct.PatternOption1); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PatternOption2" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PatternOption2\": ")
	if tmp, err := json.Marshal(strct.PatternOption2); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PatternOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PatternOptions\": ")
	if tmp, err := json.Marshal(strct.PatternOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Period" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Period\": ")
	if tmp, err := json.Marshal(strct.Period); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Position" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Position\": ")
	if tmp, err := json.Marshal(strct.Position); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RemoveAllPunctuation" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RemoveAllPunctuation\": ")
	if tmp, err := json.Marshal(strct.RemoveAllPunctuation); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RemoveAllQuotes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RemoveAllQuotes\": ")
	if tmp, err := json.Marshal(strct.RemoveAllQuotes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RemoveAllWhitespace" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RemoveAllWhitespace\": ")
	if tmp, err := json.Marshal(strct.RemoveAllWhitespace); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RemoveCustomCharacters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RemoveCustomCharacters\": ")
	if tmp, err := json.Marshal(strct.RemoveCustomCharacters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RemoveCustomValue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RemoveCustomValue\": ")
	if tmp, err := json.Marshal(strct.RemoveCustomValue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RemoveLeadingAndTrailingPunctuation" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RemoveLeadingAndTrailingPunctuation\": ")
	if tmp, err := json.Marshal(strct.RemoveLeadingAndTrailingPunctuation); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RemoveLeadingAndTrailingQuotes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RemoveLeadingAndTrailingQuotes\": ")
	if tmp, err := json.Marshal(strct.RemoveLeadingAndTrailingQuotes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RemoveLeadingAndTrailingWhitespace" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RemoveLeadingAndTrailingWhitespace\": ")
	if tmp, err := json.Marshal(strct.RemoveLeadingAndTrailingWhitespace); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RemoveLetters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RemoveLetters\": ")
	if tmp, err := json.Marshal(strct.RemoveLetters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RemoveNumbers" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RemoveNumbers\": ")
	if tmp, err := json.Marshal(strct.RemoveNumbers); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RemoveSourceColumn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RemoveSourceColumn\": ")
	if tmp, err := json.Marshal(strct.RemoveSourceColumn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RemoveSpecialCharacters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RemoveSpecialCharacters\": ")
	if tmp, err := json.Marshal(strct.RemoveSpecialCharacters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RightColumns" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RightColumns\": ")
	if tmp, err := json.Marshal(strct.RightColumns); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SampleSize" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SampleSize\": ")
	if tmp, err := json.Marshal(strct.SampleSize); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SampleType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SampleType\": ")
	if tmp, err := json.Marshal(strct.SampleType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SecondInput" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SecondInput\": ")
	if tmp, err := json.Marshal(strct.SecondInput); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SecondaryInputs" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SecondaryInputs\": ")
	if tmp, err := json.Marshal(strct.SecondaryInputs); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SheetIndexes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SheetIndexes\": ")
	if tmp, err := json.Marshal(strct.SheetIndexes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SheetNames" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SheetNames\": ")
	if tmp, err := json.Marshal(strct.SheetNames); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SourceColumn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SourceColumn\": ")
	if tmp, err := json.Marshal(strct.SourceColumn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SourceColumn1" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SourceColumn1\": ")
	if tmp, err := json.Marshal(strct.SourceColumn1); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SourceColumn2" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SourceColumn2\": ")
	if tmp, err := json.Marshal(strct.SourceColumn2); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SourceColumns" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SourceColumns\": ")
	if tmp, err := json.Marshal(strct.SourceColumns); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StartColumnIndex" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StartColumnIndex\": ")
	if tmp, err := json.Marshal(strct.StartColumnIndex); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StartPattern" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StartPattern\": ")
	if tmp, err := json.Marshal(strct.StartPattern); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StartPosition" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StartPosition\": ")
	if tmp, err := json.Marshal(strct.StartPosition); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StartValue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StartValue\": ")
	if tmp, err := json.Marshal(strct.StartValue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StemmingMode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StemmingMode\": ")
	if tmp, err := json.Marshal(strct.StemmingMode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StepCount" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StepCount\": ")
	if tmp, err := json.Marshal(strct.StepCount); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StepIndex" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StepIndex\": ")
	if tmp, err := json.Marshal(strct.StepIndex); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StopWordsMode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StopWordsMode\": ")
	if tmp, err := json.Marshal(strct.StopWordsMode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Strategy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Strategy\": ")
	if tmp, err := json.Marshal(strct.Strategy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TargetColumn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TargetColumn\": ")
	if tmp, err := json.Marshal(strct.TargetColumn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TargetColumnNames" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TargetColumnNames\": ")
	if tmp, err := json.Marshal(strct.TargetColumnNames); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TargetDateFormat" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TargetDateFormat\": ")
	if tmp, err := json.Marshal(strct.TargetDateFormat); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TargetIndex" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TargetIndex\": ")
	if tmp, err := json.Marshal(strct.TargetIndex); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TimeZone" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TimeZone\": ")
	if tmp, err := json.Marshal(strct.TimeZone); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TokenizerPattern" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TokenizerPattern\": ")
	if tmp, err := json.Marshal(strct.TokenizerPattern); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TrueString" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TrueString\": ")
	if tmp, err := json.Marshal(strct.TrueString); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "UdfLang" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UdfLang\": ")
	if tmp, err := json.Marshal(strct.UdfLang); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Units" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Units\": ")
	if tmp, err := json.Marshal(strct.Units); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "UnpivotColumn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UnpivotColumn\": ")
	if tmp, err := json.Marshal(strct.UnpivotColumn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "UpperBound" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UpperBound\": ")
	if tmp, err := json.Marshal(strct.UpperBound); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "UseNewDataFrame" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UseNewDataFrame\": ")
	if tmp, err := json.Marshal(strct.UseNewDataFrame); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Value1" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value1\": ")
	if tmp, err := json.Marshal(strct.Value1); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Value2" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value2\": ")
	if tmp, err := json.Marshal(strct.Value2); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ValueColumn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ValueColumn\": ")
	if tmp, err := json.Marshal(strct.ValueColumn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ViewFrame" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ViewFrame\": ")
	if tmp, err := json.Marshal(strct.ViewFrame); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RecipeParameters) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AggregateFunction":
            if err := json.Unmarshal([]byte(v), &strct.AggregateFunction); err != nil {
                return err
             }
        case "Base":
            if err := json.Unmarshal([]byte(v), &strct.Base); err != nil {
                return err
             }
        case "CaseStatement":
            if err := json.Unmarshal([]byte(v), &strct.CaseStatement); err != nil {
                return err
             }
        case "CategoryMap":
            if err := json.Unmarshal([]byte(v), &strct.CategoryMap); err != nil {
                return err
             }
        case "CharsToRemove":
            if err := json.Unmarshal([]byte(v), &strct.CharsToRemove); err != nil {
                return err
             }
        case "CollapseConsecutiveWhitespace":
            if err := json.Unmarshal([]byte(v), &strct.CollapseConsecutiveWhitespace); err != nil {
                return err
             }
        case "ColumnDataType":
            if err := json.Unmarshal([]byte(v), &strct.ColumnDataType); err != nil {
                return err
             }
        case "ColumnRange":
            if err := json.Unmarshal([]byte(v), &strct.ColumnRange); err != nil {
                return err
             }
        case "Count":
            if err := json.Unmarshal([]byte(v), &strct.Count); err != nil {
                return err
             }
        case "CustomCharacters":
            if err := json.Unmarshal([]byte(v), &strct.CustomCharacters); err != nil {
                return err
             }
        case "CustomStopWords":
            if err := json.Unmarshal([]byte(v), &strct.CustomStopWords); err != nil {
                return err
             }
        case "CustomValue":
            if err := json.Unmarshal([]byte(v), &strct.CustomValue); err != nil {
                return err
             }
        case "DatasetsColumns":
            if err := json.Unmarshal([]byte(v), &strct.DatasetsColumns); err != nil {
                return err
             }
        case "DateAddValue":
            if err := json.Unmarshal([]byte(v), &strct.DateAddValue); err != nil {
                return err
             }
        case "DateTimeFormat":
            if err := json.Unmarshal([]byte(v), &strct.DateTimeFormat); err != nil {
                return err
             }
        case "DateTimeParameters":
            if err := json.Unmarshal([]byte(v), &strct.DateTimeParameters); err != nil {
                return err
             }
        case "DeleteOtherRows":
            if err := json.Unmarshal([]byte(v), &strct.DeleteOtherRows); err != nil {
                return err
             }
        case "Delimiter":
            if err := json.Unmarshal([]byte(v), &strct.Delimiter); err != nil {
                return err
             }
        case "EndPattern":
            if err := json.Unmarshal([]byte(v), &strct.EndPattern); err != nil {
                return err
             }
        case "EndPosition":
            if err := json.Unmarshal([]byte(v), &strct.EndPosition); err != nil {
                return err
             }
        case "EndValue":
            if err := json.Unmarshal([]byte(v), &strct.EndValue); err != nil {
                return err
             }
        case "ExpandContractions":
            if err := json.Unmarshal([]byte(v), &strct.ExpandContractions); err != nil {
                return err
             }
        case "Exponent":
            if err := json.Unmarshal([]byte(v), &strct.Exponent); err != nil {
                return err
             }
        case "FalseString":
            if err := json.Unmarshal([]byte(v), &strct.FalseString); err != nil {
                return err
             }
        case "GroupByAggFunctionOptions":
            if err := json.Unmarshal([]byte(v), &strct.GroupByAggFunctionOptions); err != nil {
                return err
             }
        case "GroupByColumns":
            if err := json.Unmarshal([]byte(v), &strct.GroupByColumns); err != nil {
                return err
             }
        case "HiddenColumns":
            if err := json.Unmarshal([]byte(v), &strct.HiddenColumns); err != nil {
                return err
             }
        case "IgnoreCase":
            if err := json.Unmarshal([]byte(v), &strct.IgnoreCase); err != nil {
                return err
             }
        case "IncludeInSplit":
            if err := json.Unmarshal([]byte(v), &strct.IncludeInSplit); err != nil {
                return err
             }
        case "Input":
            if err := json.Unmarshal([]byte(v), &strct.Input); err != nil {
                return err
             }
        case "Interval":
            if err := json.Unmarshal([]byte(v), &strct.Interval); err != nil {
                return err
             }
        case "IsText":
            if err := json.Unmarshal([]byte(v), &strct.IsText); err != nil {
                return err
             }
        case "JoinKeys":
            if err := json.Unmarshal([]byte(v), &strct.JoinKeys); err != nil {
                return err
             }
        case "JoinType":
            if err := json.Unmarshal([]byte(v), &strct.JoinType); err != nil {
                return err
             }
        case "LeftColumns":
            if err := json.Unmarshal([]byte(v), &strct.LeftColumns); err != nil {
                return err
             }
        case "Limit":
            if err := json.Unmarshal([]byte(v), &strct.Limit); err != nil {
                return err
             }
        case "LowerBound":
            if err := json.Unmarshal([]byte(v), &strct.LowerBound); err != nil {
                return err
             }
        case "MapType":
            if err := json.Unmarshal([]byte(v), &strct.MapType); err != nil {
                return err
             }
        case "ModeType":
            if err := json.Unmarshal([]byte(v), &strct.ModeType); err != nil {
                return err
             }
        case "MultiLine":
            if err := json.Unmarshal([]byte(v), &strct.MultiLine); err != nil {
                return err
             }
        case "NumRows":
            if err := json.Unmarshal([]byte(v), &strct.NumRows); err != nil {
                return err
             }
        case "NumRowsAfter":
            if err := json.Unmarshal([]byte(v), &strct.NumRowsAfter); err != nil {
                return err
             }
        case "NumRowsBefore":
            if err := json.Unmarshal([]byte(v), &strct.NumRowsBefore); err != nil {
                return err
             }
        case "OrderByColumn":
            if err := json.Unmarshal([]byte(v), &strct.OrderByColumn); err != nil {
                return err
             }
        case "OrderByColumns":
            if err := json.Unmarshal([]byte(v), &strct.OrderByColumns); err != nil {
                return err
             }
        case "Other":
            if err := json.Unmarshal([]byte(v), &strct.Other); err != nil {
                return err
             }
        case "Pattern":
            if err := json.Unmarshal([]byte(v), &strct.Pattern); err != nil {
                return err
             }
        case "PatternOption1":
            if err := json.Unmarshal([]byte(v), &strct.PatternOption1); err != nil {
                return err
             }
        case "PatternOption2":
            if err := json.Unmarshal([]byte(v), &strct.PatternOption2); err != nil {
                return err
             }
        case "PatternOptions":
            if err := json.Unmarshal([]byte(v), &strct.PatternOptions); err != nil {
                return err
             }
        case "Period":
            if err := json.Unmarshal([]byte(v), &strct.Period); err != nil {
                return err
             }
        case "Position":
            if err := json.Unmarshal([]byte(v), &strct.Position); err != nil {
                return err
             }
        case "RemoveAllPunctuation":
            if err := json.Unmarshal([]byte(v), &strct.RemoveAllPunctuation); err != nil {
                return err
             }
        case "RemoveAllQuotes":
            if err := json.Unmarshal([]byte(v), &strct.RemoveAllQuotes); err != nil {
                return err
             }
        case "RemoveAllWhitespace":
            if err := json.Unmarshal([]byte(v), &strct.RemoveAllWhitespace); err != nil {
                return err
             }
        case "RemoveCustomCharacters":
            if err := json.Unmarshal([]byte(v), &strct.RemoveCustomCharacters); err != nil {
                return err
             }
        case "RemoveCustomValue":
            if err := json.Unmarshal([]byte(v), &strct.RemoveCustomValue); err != nil {
                return err
             }
        case "RemoveLeadingAndTrailingPunctuation":
            if err := json.Unmarshal([]byte(v), &strct.RemoveLeadingAndTrailingPunctuation); err != nil {
                return err
             }
        case "RemoveLeadingAndTrailingQuotes":
            if err := json.Unmarshal([]byte(v), &strct.RemoveLeadingAndTrailingQuotes); err != nil {
                return err
             }
        case "RemoveLeadingAndTrailingWhitespace":
            if err := json.Unmarshal([]byte(v), &strct.RemoveLeadingAndTrailingWhitespace); err != nil {
                return err
             }
        case "RemoveLetters":
            if err := json.Unmarshal([]byte(v), &strct.RemoveLetters); err != nil {
                return err
             }
        case "RemoveNumbers":
            if err := json.Unmarshal([]byte(v), &strct.RemoveNumbers); err != nil {
                return err
             }
        case "RemoveSourceColumn":
            if err := json.Unmarshal([]byte(v), &strct.RemoveSourceColumn); err != nil {
                return err
             }
        case "RemoveSpecialCharacters":
            if err := json.Unmarshal([]byte(v), &strct.RemoveSpecialCharacters); err != nil {
                return err
             }
        case "RightColumns":
            if err := json.Unmarshal([]byte(v), &strct.RightColumns); err != nil {
                return err
             }
        case "SampleSize":
            if err := json.Unmarshal([]byte(v), &strct.SampleSize); err != nil {
                return err
             }
        case "SampleType":
            if err := json.Unmarshal([]byte(v), &strct.SampleType); err != nil {
                return err
             }
        case "SecondInput":
            if err := json.Unmarshal([]byte(v), &strct.SecondInput); err != nil {
                return err
             }
        case "SecondaryInputs":
            if err := json.Unmarshal([]byte(v), &strct.SecondaryInputs); err != nil {
                return err
             }
        case "SheetIndexes":
            if err := json.Unmarshal([]byte(v), &strct.SheetIndexes); err != nil {
                return err
             }
        case "SheetNames":
            if err := json.Unmarshal([]byte(v), &strct.SheetNames); err != nil {
                return err
             }
        case "SourceColumn":
            if err := json.Unmarshal([]byte(v), &strct.SourceColumn); err != nil {
                return err
             }
        case "SourceColumn1":
            if err := json.Unmarshal([]byte(v), &strct.SourceColumn1); err != nil {
                return err
             }
        case "SourceColumn2":
            if err := json.Unmarshal([]byte(v), &strct.SourceColumn2); err != nil {
                return err
             }
        case "SourceColumns":
            if err := json.Unmarshal([]byte(v), &strct.SourceColumns); err != nil {
                return err
             }
        case "StartColumnIndex":
            if err := json.Unmarshal([]byte(v), &strct.StartColumnIndex); err != nil {
                return err
             }
        case "StartPattern":
            if err := json.Unmarshal([]byte(v), &strct.StartPattern); err != nil {
                return err
             }
        case "StartPosition":
            if err := json.Unmarshal([]byte(v), &strct.StartPosition); err != nil {
                return err
             }
        case "StartValue":
            if err := json.Unmarshal([]byte(v), &strct.StartValue); err != nil {
                return err
             }
        case "StemmingMode":
            if err := json.Unmarshal([]byte(v), &strct.StemmingMode); err != nil {
                return err
             }
        case "StepCount":
            if err := json.Unmarshal([]byte(v), &strct.StepCount); err != nil {
                return err
             }
        case "StepIndex":
            if err := json.Unmarshal([]byte(v), &strct.StepIndex); err != nil {
                return err
             }
        case "StopWordsMode":
            if err := json.Unmarshal([]byte(v), &strct.StopWordsMode); err != nil {
                return err
             }
        case "Strategy":
            if err := json.Unmarshal([]byte(v), &strct.Strategy); err != nil {
                return err
             }
        case "TargetColumn":
            if err := json.Unmarshal([]byte(v), &strct.TargetColumn); err != nil {
                return err
             }
        case "TargetColumnNames":
            if err := json.Unmarshal([]byte(v), &strct.TargetColumnNames); err != nil {
                return err
             }
        case "TargetDateFormat":
            if err := json.Unmarshal([]byte(v), &strct.TargetDateFormat); err != nil {
                return err
             }
        case "TargetIndex":
            if err := json.Unmarshal([]byte(v), &strct.TargetIndex); err != nil {
                return err
             }
        case "TimeZone":
            if err := json.Unmarshal([]byte(v), &strct.TimeZone); err != nil {
                return err
             }
        case "TokenizerPattern":
            if err := json.Unmarshal([]byte(v), &strct.TokenizerPattern); err != nil {
                return err
             }
        case "TrueString":
            if err := json.Unmarshal([]byte(v), &strct.TrueString); err != nil {
                return err
             }
        case "UdfLang":
            if err := json.Unmarshal([]byte(v), &strct.UdfLang); err != nil {
                return err
             }
        case "Units":
            if err := json.Unmarshal([]byte(v), &strct.Units); err != nil {
                return err
             }
        case "UnpivotColumn":
            if err := json.Unmarshal([]byte(v), &strct.UnpivotColumn); err != nil {
                return err
             }
        case "UpperBound":
            if err := json.Unmarshal([]byte(v), &strct.UpperBound); err != nil {
                return err
             }
        case "UseNewDataFrame":
            if err := json.Unmarshal([]byte(v), &strct.UseNewDataFrame); err != nil {
                return err
             }
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
        case "Value1":
            if err := json.Unmarshal([]byte(v), &strct.Value1); err != nil {
                return err
             }
        case "Value2":
            if err := json.Unmarshal([]byte(v), &strct.Value2); err != nil {
                return err
             }
        case "ValueColumn":
            if err := json.Unmarshal([]byte(v), &strct.ValueColumn); err != nil {
                return err
             }
        case "ViewFrame":
            if err := json.Unmarshal([]byte(v), &strct.ViewFrame); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *RecipeStep) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Action" field is required
    if strct.Action == nil {
        return nil, errors.New("Action is a required field")
    }
    // Marshal the "Action" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Action\": ")
	if tmp, err := json.Marshal(strct.Action); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ConditionExpressions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConditionExpressions\": ")
	if tmp, err := json.Marshal(strct.ConditionExpressions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RecipeStep) UnmarshalJSON(b []byte) error {
    ActionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Action":
            if err := json.Unmarshal([]byte(v), &strct.Action); err != nil {
                return err
             }
            ActionReceived = true
        case "ConditionExpressions":
            if err := json.Unmarshal([]byte(v), &strct.ConditionExpressions); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Action (a required property) was received
    if !ActionReceived {
        return errors.New("\"Action\" is required but was not present")
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Steps" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Steps" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Steps\": ")
	if tmp, err := json.Marshal(strct.Steps); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    NameReceived := false
    StepsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        case "Steps":
            if err := json.Unmarshal([]byte(v), &strct.Steps); err != nil {
                return err
             }
            StepsReceived = true
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    // check if Steps (a required property) was received
    if !StepsReceived {
        return errors.New("\"Steps\" is required but was not present")
    }
    return nil
}

func (strct *S3Location) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Bucket" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Bucket" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Bucket\": ")
	if tmp, err := json.Marshal(strct.Bucket); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *S3Location) UnmarshalJSON(b []byte) error {
    BucketReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Bucket":
            if err := json.Unmarshal([]byte(v), &strct.Bucket); err != nil {
                return err
             }
            BucketReceived = true
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Bucket (a required property) was received
    if !BucketReceived {
        return errors.New("\"Bucket\" is required but was not present")
    }
    return nil
}

func (strct *SecondaryInput) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DataCatalogInputDefinition" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DataCatalogInputDefinition\": ")
	if tmp, err := json.Marshal(strct.DataCatalogInputDefinition); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "S3InputDefinition" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3InputDefinition\": ")
	if tmp, err := json.Marshal(strct.S3InputDefinition); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SecondaryInput) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DataCatalogInputDefinition":
            if err := json.Unmarshal([]byte(v), &strct.DataCatalogInputDefinition); err != nil {
                return err
             }
        case "S3InputDefinition":
            if err := json.Unmarshal([]byte(v), &strct.S3InputDefinition); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}
