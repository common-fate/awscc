// Code generated by schema-generate. DO NOT EDIT.

package dataset

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// CsvOptions Csv options
type CsvOptions struct {
  Delimiter string `json:"Delimiter,omitempty"`
  HeaderRow bool `json:"HeaderRow,omitempty"`
}

// DataCatalogInputDefinition 
type DataCatalogInputDefinition struct {

  // Catalog id
  CatalogId string `json:"CatalogId,omitempty"`

  // Database name
  DatabaseName string `json:"DatabaseName,omitempty"`

  // Table name
  TableName string `json:"TableName,omitempty"`
  TempDirectory *S3Location `json:"TempDirectory,omitempty"`
}

// DatabaseInputDefinition 
type DatabaseInputDefinition struct {

  // Database table name
  DatabaseTableName string `json:"DatabaseTableName,omitempty"`

  // Glue connection name
  GlueConnectionName string `json:"GlueConnectionName"`

  // Custom SQL to run against the provided AWS Glue connection. This SQL will be used as the input for DataBrew projects and jobs.
  QueryString string `json:"QueryString,omitempty"`
  TempDirectory *S3Location `json:"TempDirectory,omitempty"`
}

// DatasetParameter 
type DatasetParameter struct {

  // Add the value of this parameter as a column in a dataset.
  CreateColumn bool `json:"CreateColumn,omitempty"`
  DatetimeOptions *DatetimeOptions `json:"DatetimeOptions,omitempty"`
  Filter *FilterExpression `json:"Filter,omitempty"`
  Name string `json:"Name"`

  // Parameter type
  Type string `json:"Type"`
}

// DatetimeOptions 
type DatetimeOptions struct {

  // Date/time format of a date parameter
  Format string `json:"Format"`

  // Locale code for a date parameter
  LocaleCode string `json:"LocaleCode,omitempty"`

  // Timezone offset
  TimezoneOffset string `json:"TimezoneOffset,omitempty"`
}

// ExcelOptions 
type ExcelOptions struct {
  HeaderRow bool `json:"HeaderRow,omitempty"`
  SheetIndexes []int `json:"SheetIndexes,omitempty"`
  SheetNames []string `json:"SheetNames,omitempty"`
}

// FilesLimit 
type FilesLimit struct {

  // Maximum number of files
  MaxFiles int `json:"MaxFiles"`

  // Order
  Order string `json:"Order,omitempty"`

  // Ordered by
  OrderedBy string `json:"OrderedBy,omitempty"`
}

// FilterExpression 
type FilterExpression struct {

  // Filtering expression for a parameter
  Expression string `json:"Expression"`
  ValuesMap []*FilterValue `json:"ValuesMap"`
}

// FilterValue A key-value pair to associate expression variable names with their values
type FilterValue struct {
  Value string `json:"Value"`

  // Variable name
  ValueReference string `json:"ValueReference"`
}

// FormatOptions Format options for dataset
type FormatOptions struct {
  Csv *CsvOptions `json:"Csv,omitempty"`
  Excel *ExcelOptions `json:"Excel,omitempty"`
  Json *JsonOptions `json:"Json,omitempty"`
}

// Input Input
type Input struct {
  DataCatalogInputDefinition *DataCatalogInputDefinition `json:"DataCatalogInputDefinition,omitempty"`
  DatabaseInputDefinition *DatabaseInputDefinition `json:"DatabaseInputDefinition,omitempty"`
  Metadata *Metadata `json:"Metadata,omitempty"`
  S3InputDefinition *S3Location `json:"S3InputDefinition,omitempty"`
}

// JsonOptions Json options
type JsonOptions struct {
  MultiLine bool `json:"MultiLine,omitempty"`
}

// Metadata 
type Metadata struct {

  // Arn of the source of the dataset. For e.g.: AppFlow Flow ARN.
  SourceArn string `json:"SourceArn,omitempty"`
}

// PathOptions Path options for dataset
type PathOptions struct {
  FilesLimit *FilesLimit `json:"FilesLimit,omitempty"`
  LastModifiedDateCondition *FilterExpression `json:"LastModifiedDateCondition,omitempty"`
  Parameters []*PathParameter `json:"Parameters,omitempty"`
}

// PathParameter A key-value pair to associate dataset parameter name with its definition.
type PathParameter struct {
  DatasetParameter *DatasetParameter `json:"DatasetParameter"`
  PathParameterName string `json:"PathParameterName"`
}

// Resource Resource schema for AWS::DataBrew::Dataset.
type Resource struct {

  // Dataset format
  Format string `json:"Format,omitempty"`

  // Format options for dataset
  FormatOptions *FormatOptions `json:"FormatOptions,omitempty"`

  // Input
  Input *Input `json:"Input"`

  // Dataset name
  Name string `json:"Name"`

  // PathOptions
  PathOptions *PathOptions `json:"PathOptions,omitempty"`
  Tags []*Tag `json:"Tags,omitempty"`
}

// S3Location Input location
type S3Location struct {
  Bucket string `json:"Bucket"`
  Key string `json:"Key,omitempty"`
}

// Tag A key-value pair to associate with a resource.
type Tag struct {
  Key string `json:"Key"`
  Value string `json:"Value"`
}

func (strct *CsvOptions) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Delimiter" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Delimiter\": ")
	if tmp, err := json.Marshal(strct.Delimiter); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "HeaderRow" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HeaderRow\": ")
	if tmp, err := json.Marshal(strct.HeaderRow); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CsvOptions) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Delimiter":
            if err := json.Unmarshal([]byte(v), &strct.Delimiter); err != nil {
                return err
             }
        case "HeaderRow":
            if err := json.Unmarshal([]byte(v), &strct.HeaderRow); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *DataCatalogInputDefinition) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CatalogId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CatalogId\": ")
	if tmp, err := json.Marshal(strct.CatalogId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DatabaseName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DatabaseName\": ")
	if tmp, err := json.Marshal(strct.DatabaseName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TableName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TableName\": ")
	if tmp, err := json.Marshal(strct.TableName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TempDirectory" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TempDirectory\": ")
	if tmp, err := json.Marshal(strct.TempDirectory); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DataCatalogInputDefinition) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CatalogId":
            if err := json.Unmarshal([]byte(v), &strct.CatalogId); err != nil {
                return err
             }
        case "DatabaseName":
            if err := json.Unmarshal([]byte(v), &strct.DatabaseName); err != nil {
                return err
             }
        case "TableName":
            if err := json.Unmarshal([]byte(v), &strct.TableName); err != nil {
                return err
             }
        case "TempDirectory":
            if err := json.Unmarshal([]byte(v), &strct.TempDirectory); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *DatabaseInputDefinition) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DatabaseTableName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DatabaseTableName\": ")
	if tmp, err := json.Marshal(strct.DatabaseTableName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "GlueConnectionName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "GlueConnectionName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"GlueConnectionName\": ")
	if tmp, err := json.Marshal(strct.GlueConnectionName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "QueryString" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"QueryString\": ")
	if tmp, err := json.Marshal(strct.QueryString); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TempDirectory" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TempDirectory\": ")
	if tmp, err := json.Marshal(strct.TempDirectory); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DatabaseInputDefinition) UnmarshalJSON(b []byte) error {
    GlueConnectionNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DatabaseTableName":
            if err := json.Unmarshal([]byte(v), &strct.DatabaseTableName); err != nil {
                return err
             }
        case "GlueConnectionName":
            if err := json.Unmarshal([]byte(v), &strct.GlueConnectionName); err != nil {
                return err
             }
            GlueConnectionNameReceived = true
        case "QueryString":
            if err := json.Unmarshal([]byte(v), &strct.QueryString); err != nil {
                return err
             }
        case "TempDirectory":
            if err := json.Unmarshal([]byte(v), &strct.TempDirectory); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if GlueConnectionName (a required property) was received
    if !GlueConnectionNameReceived {
        return errors.New("\"GlueConnectionName\" is required but was not present")
    }
    return nil
}

func (strct *DatasetParameter) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CreateColumn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CreateColumn\": ")
	if tmp, err := json.Marshal(strct.CreateColumn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DatetimeOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DatetimeOptions\": ")
	if tmp, err := json.Marshal(strct.DatetimeOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Filter" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Filter\": ")
	if tmp, err := json.Marshal(strct.Filter); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DatasetParameter) UnmarshalJSON(b []byte) error {
    NameReceived := false
    TypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CreateColumn":
            if err := json.Unmarshal([]byte(v), &strct.CreateColumn); err != nil {
                return err
             }
        case "DatetimeOptions":
            if err := json.Unmarshal([]byte(v), &strct.DatetimeOptions); err != nil {
                return err
             }
        case "Filter":
            if err := json.Unmarshal([]byte(v), &strct.Filter); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            TypeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    // check if Type (a required property) was received
    if !TypeReceived {
        return errors.New("\"Type\" is required but was not present")
    }
    return nil
}

func (strct *DatetimeOptions) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Format" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Format" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Format\": ")
	if tmp, err := json.Marshal(strct.Format); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LocaleCode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LocaleCode\": ")
	if tmp, err := json.Marshal(strct.LocaleCode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TimezoneOffset" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TimezoneOffset\": ")
	if tmp, err := json.Marshal(strct.TimezoneOffset); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DatetimeOptions) UnmarshalJSON(b []byte) error {
    FormatReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Format":
            if err := json.Unmarshal([]byte(v), &strct.Format); err != nil {
                return err
             }
            FormatReceived = true
        case "LocaleCode":
            if err := json.Unmarshal([]byte(v), &strct.LocaleCode); err != nil {
                return err
             }
        case "TimezoneOffset":
            if err := json.Unmarshal([]byte(v), &strct.TimezoneOffset); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Format (a required property) was received
    if !FormatReceived {
        return errors.New("\"Format\" is required but was not present")
    }
    return nil
}

func (strct *ExcelOptions) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "HeaderRow" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HeaderRow\": ")
	if tmp, err := json.Marshal(strct.HeaderRow); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SheetIndexes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SheetIndexes\": ")
	if tmp, err := json.Marshal(strct.SheetIndexes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SheetNames" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SheetNames\": ")
	if tmp, err := json.Marshal(strct.SheetNames); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ExcelOptions) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "HeaderRow":
            if err := json.Unmarshal([]byte(v), &strct.HeaderRow); err != nil {
                return err
             }
        case "SheetIndexes":
            if err := json.Unmarshal([]byte(v), &strct.SheetIndexes); err != nil {
                return err
             }
        case "SheetNames":
            if err := json.Unmarshal([]byte(v), &strct.SheetNames); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *FilesLimit) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "MaxFiles" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "MaxFiles" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaxFiles\": ")
	if tmp, err := json.Marshal(strct.MaxFiles); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Order" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Order\": ")
	if tmp, err := json.Marshal(strct.Order); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OrderedBy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OrderedBy\": ")
	if tmp, err := json.Marshal(strct.OrderedBy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FilesLimit) UnmarshalJSON(b []byte) error {
    MaxFilesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "MaxFiles":
            if err := json.Unmarshal([]byte(v), &strct.MaxFiles); err != nil {
                return err
             }
            MaxFilesReceived = true
        case "Order":
            if err := json.Unmarshal([]byte(v), &strct.Order); err != nil {
                return err
             }
        case "OrderedBy":
            if err := json.Unmarshal([]byte(v), &strct.OrderedBy); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if MaxFiles (a required property) was received
    if !MaxFilesReceived {
        return errors.New("\"MaxFiles\" is required but was not present")
    }
    return nil
}

func (strct *FilterExpression) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Expression" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Expression" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Expression\": ")
	if tmp, err := json.Marshal(strct.Expression); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ValuesMap" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ValuesMap" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ValuesMap\": ")
	if tmp, err := json.Marshal(strct.ValuesMap); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FilterExpression) UnmarshalJSON(b []byte) error {
    ExpressionReceived := false
    ValuesMapReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Expression":
            if err := json.Unmarshal([]byte(v), &strct.Expression); err != nil {
                return err
             }
            ExpressionReceived = true
        case "ValuesMap":
            if err := json.Unmarshal([]byte(v), &strct.ValuesMap); err != nil {
                return err
             }
            ValuesMapReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Expression (a required property) was received
    if !ExpressionReceived {
        return errors.New("\"Expression\" is required but was not present")
    }
    // check if ValuesMap (a required property) was received
    if !ValuesMapReceived {
        return errors.New("\"ValuesMap\" is required but was not present")
    }
    return nil
}

func (strct *FilterValue) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ValueReference" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ValueReference" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ValueReference\": ")
	if tmp, err := json.Marshal(strct.ValueReference); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FilterValue) UnmarshalJSON(b []byte) error {
    ValueReceived := false
    ValueReferenceReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        case "ValueReference":
            if err := json.Unmarshal([]byte(v), &strct.ValueReference); err != nil {
                return err
             }
            ValueReferenceReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    // check if ValueReference (a required property) was received
    if !ValueReferenceReceived {
        return errors.New("\"ValueReference\" is required but was not present")
    }
    return nil
}

func (strct *FormatOptions) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Csv" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Csv\": ")
	if tmp, err := json.Marshal(strct.Csv); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Excel" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Excel\": ")
	if tmp, err := json.Marshal(strct.Excel); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Json" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Json\": ")
	if tmp, err := json.Marshal(strct.Json); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FormatOptions) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Csv":
            if err := json.Unmarshal([]byte(v), &strct.Csv); err != nil {
                return err
             }
        case "Excel":
            if err := json.Unmarshal([]byte(v), &strct.Excel); err != nil {
                return err
             }
        case "Json":
            if err := json.Unmarshal([]byte(v), &strct.Json); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Input) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DataCatalogInputDefinition" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DataCatalogInputDefinition\": ")
	if tmp, err := json.Marshal(strct.DataCatalogInputDefinition); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DatabaseInputDefinition" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DatabaseInputDefinition\": ")
	if tmp, err := json.Marshal(strct.DatabaseInputDefinition); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Metadata" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Metadata\": ")
	if tmp, err := json.Marshal(strct.Metadata); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "S3InputDefinition" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3InputDefinition\": ")
	if tmp, err := json.Marshal(strct.S3InputDefinition); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Input) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DataCatalogInputDefinition":
            if err := json.Unmarshal([]byte(v), &strct.DataCatalogInputDefinition); err != nil {
                return err
             }
        case "DatabaseInputDefinition":
            if err := json.Unmarshal([]byte(v), &strct.DatabaseInputDefinition); err != nil {
                return err
             }
        case "Metadata":
            if err := json.Unmarshal([]byte(v), &strct.Metadata); err != nil {
                return err
             }
        case "S3InputDefinition":
            if err := json.Unmarshal([]byte(v), &strct.S3InputDefinition); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *JsonOptions) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "MultiLine" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MultiLine\": ")
	if tmp, err := json.Marshal(strct.MultiLine); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *JsonOptions) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "MultiLine":
            if err := json.Unmarshal([]byte(v), &strct.MultiLine); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Metadata) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "SourceArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SourceArn\": ")
	if tmp, err := json.Marshal(strct.SourceArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Metadata) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "SourceArn":
            if err := json.Unmarshal([]byte(v), &strct.SourceArn); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *PathOptions) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "FilesLimit" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FilesLimit\": ")
	if tmp, err := json.Marshal(strct.FilesLimit); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LastModifiedDateCondition" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LastModifiedDateCondition\": ")
	if tmp, err := json.Marshal(strct.LastModifiedDateCondition); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Parameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Parameters\": ")
	if tmp, err := json.Marshal(strct.Parameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PathOptions) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "FilesLimit":
            if err := json.Unmarshal([]byte(v), &strct.FilesLimit); err != nil {
                return err
             }
        case "LastModifiedDateCondition":
            if err := json.Unmarshal([]byte(v), &strct.LastModifiedDateCondition); err != nil {
                return err
             }
        case "Parameters":
            if err := json.Unmarshal([]byte(v), &strct.Parameters); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *PathParameter) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "DatasetParameter" field is required
    if strct.DatasetParameter == nil {
        return nil, errors.New("DatasetParameter is a required field")
    }
    // Marshal the "DatasetParameter" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DatasetParameter\": ")
	if tmp, err := json.Marshal(strct.DatasetParameter); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "PathParameterName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "PathParameterName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PathParameterName\": ")
	if tmp, err := json.Marshal(strct.PathParameterName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PathParameter) UnmarshalJSON(b []byte) error {
    DatasetParameterReceived := false
    PathParameterNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DatasetParameter":
            if err := json.Unmarshal([]byte(v), &strct.DatasetParameter); err != nil {
                return err
             }
            DatasetParameterReceived = true
        case "PathParameterName":
            if err := json.Unmarshal([]byte(v), &strct.PathParameterName); err != nil {
                return err
             }
            PathParameterNameReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if DatasetParameter (a required property) was received
    if !DatasetParameterReceived {
        return errors.New("\"DatasetParameter\" is required but was not present")
    }
    // check if PathParameterName (a required property) was received
    if !PathParameterNameReceived {
        return errors.New("\"PathParameterName\" is required but was not present")
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Format" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Format\": ")
	if tmp, err := json.Marshal(strct.Format); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FormatOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FormatOptions\": ")
	if tmp, err := json.Marshal(strct.FormatOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Input" field is required
    if strct.Input == nil {
        return nil, errors.New("Input is a required field")
    }
    // Marshal the "Input" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Input\": ")
	if tmp, err := json.Marshal(strct.Input); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PathOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PathOptions\": ")
	if tmp, err := json.Marshal(strct.PathOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    InputReceived := false
    NameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Format":
            if err := json.Unmarshal([]byte(v), &strct.Format); err != nil {
                return err
             }
        case "FormatOptions":
            if err := json.Unmarshal([]byte(v), &strct.FormatOptions); err != nil {
                return err
             }
        case "Input":
            if err := json.Unmarshal([]byte(v), &strct.Input); err != nil {
                return err
             }
            InputReceived = true
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        case "PathOptions":
            if err := json.Unmarshal([]byte(v), &strct.PathOptions); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Input (a required property) was received
    if !InputReceived {
        return errors.New("\"Input\" is required but was not present")
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    return nil
}

func (strct *S3Location) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Bucket" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Bucket" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Bucket\": ")
	if tmp, err := json.Marshal(strct.Bucket); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *S3Location) UnmarshalJSON(b []byte) error {
    BucketReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Bucket":
            if err := json.Unmarshal([]byte(v), &strct.Bucket); err != nil {
                return err
             }
            BucketReceived = true
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Bucket (a required property) was received
    if !BucketReceived {
        return errors.New("\"Bucket\" is required but was not present")
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}
