// Code generated by schema-generate. DO NOT EDIT.

package function

import (
    "encoding/json"
    "fmt"
    "errors"
    "bytes"
)

// Code 
type Code struct {

  // ImageUri.
  ImageUri string `json:"ImageUri,omitempty"`

  // An Amazon S3 bucket in the same AWS Region as your function. The bucket can be in a different AWS account.
  S3Bucket string `json:"S3Bucket,omitempty"`

  // The Amazon S3 key of the deployment package.
  S3Key string `json:"S3Key,omitempty"`

  // For versioned objects, the version of the deployment package object to use.
  S3ObjectVersion string `json:"S3ObjectVersion,omitempty"`

  // The source code of your Lambda function. If you include your function source inline with this parameter, AWS CloudFormation places it in a file named index and zips it to create a deployment package..
  ZipFile string `json:"ZipFile,omitempty"`
}

// DeadLetterConfig The dead-letter queue for failed asynchronous invocations.
type DeadLetterConfig struct {

  // The Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.
  TargetArn string `json:"TargetArn,omitempty"`
}

// Environment A function's environment variable settings.
type Environment struct {

  // Environment variable key-value pairs.
  Variables *Variables `json:"Variables,omitempty"`
}

// EphemeralStorage A function's ephemeral storage settings.
type EphemeralStorage struct {

  // The amount of ephemeral storage that your function has access to.
  Size int `json:"Size"`
}

// FileSystemConfig 
type FileSystemConfig struct {

  // The Amazon Resource Name (ARN) of the Amazon EFS access point that provides access to the file system.
  Arn string `json:"Arn"`

  // The path where the function can access the file system, starting with /mnt/.
  LocalMountPath string `json:"LocalMountPath"`
}

// ImageConfig 
type ImageConfig struct {

  // Command.
  Command []string `json:"Command,omitempty"`

  // EntryPoint.
  EntryPoint []string `json:"EntryPoint,omitempty"`

  // WorkingDirectory.
  WorkingDirectory string `json:"WorkingDirectory,omitempty"`
}

// Resource Resource Type definition for AWS::Lambda::Function
type Resource struct {
  Architectures []string `json:"Architectures,omitempty"`

  // Unique identifier for function resources
  Arn string `json:"Arn,omitempty"`

  // The code for the function.
  Code *Code `json:"Code"`

  // A unique Arn for CodeSigningConfig resource
  CodeSigningConfigArn string `json:"CodeSigningConfigArn,omitempty"`

  // A dead letter queue configuration that specifies the queue or topic where Lambda sends asynchronous events when they fail processing.
  DeadLetterConfig *DeadLetterConfig `json:"DeadLetterConfig,omitempty"`

  // A description of the function.
  Description string `json:"Description,omitempty"`

  // Environment variables that are accessible from function code during execution.
  Environment *Environment `json:"Environment,omitempty"`

  // A function's ephemeral storage settings.
  EphemeralStorage *EphemeralStorage `json:"EphemeralStorage,omitempty"`

  // Connection settings for an Amazon EFS file system. To connect a function to a file system, a mount target must be available in every Availability Zone that your function connects to. If your template contains an AWS::EFS::MountTarget resource, you must also specify a DependsOn attribute to ensure that the mount target is created or updated before the function.
  FileSystemConfigs []*FileSystemConfig `json:"FileSystemConfigs,omitempty"`

  // The name of the Lambda function, up to 64 characters in length. If you don't specify a name, AWS CloudFormation generates one.
  FunctionName string `json:"FunctionName,omitempty"`

  // The name of the method within your code that Lambda calls to execute your function. The format includes the file name. It can also include namespaces and other qualifiers, depending on the runtime
  Handler string `json:"Handler,omitempty"`

  // ImageConfig
  ImageConfig *ImageConfig `json:"ImageConfig,omitempty"`

  // The ARN of the AWS Key Management Service (AWS KMS) key that's used to encrypt your function's environment variables. If it's not provided, AWS Lambda uses a default service key.
  KmsKeyArn string `json:"KmsKeyArn,omitempty"`

  // A list of function layers to add to the function's execution environment. Specify each layer by its ARN, including the version.
  Layers []string `json:"Layers,omitempty"`

  // The amount of memory that your function has access to. Increasing the function's memory also increases its CPU allocation. The default value is 128 MB. The value must be a multiple of 64 MB.
  MemorySize int `json:"MemorySize,omitempty"`

  // PackageType.
  PackageType string `json:"PackageType,omitempty"`

  // The number of simultaneous executions to reserve for the function.
  ReservedConcurrentExecutions int `json:"ReservedConcurrentExecutions,omitempty"`

  // The Amazon Resource Name (ARN) of the function's execution role.
  Role string `json:"Role"`

  // The identifier of the function's runtime.
  Runtime string `json:"Runtime,omitempty"`

  // RuntimeManagementConfig
  RuntimeManagementConfig *RuntimeManagementConfig `json:"RuntimeManagementConfig,omitempty"`

  // The SnapStart setting of your function
  SnapStart *SnapStart `json:"SnapStart,omitempty"`

  // The SnapStart response of your function
  SnapStartResponse *SnapStartResponse `json:"SnapStartResponse,omitempty"`

  // A list of tags to apply to the function.
  Tags []*Tag `json:"Tags,omitempty"`

  // The amount of time that Lambda allows a function to run before stopping it. The default is 3 seconds. The maximum allowed value is 900 seconds.
  Timeout int `json:"Timeout,omitempty"`

  // Set Mode to Active to sample and trace a subset of incoming requests with AWS X-Ray.
  TracingConfig *TracingConfig `json:"TracingConfig,omitempty"`

  // For network connectivity to AWS resources in a VPC, specify a list of security groups and subnets in the VPC.
  VpcConfig *VpcConfig `json:"VpcConfig,omitempty"`
}

// RuntimeManagementConfig 
type RuntimeManagementConfig struct {

  // Unique identifier for a runtime version arn
  RuntimeVersionArn string `json:"RuntimeVersionArn,omitempty"`

  // Trigger for runtime update
  UpdateRuntimeOn string `json:"UpdateRuntimeOn"`
}

// SnapStart The function's SnapStart setting. When set to PublishedVersions, Lambda creates a snapshot of the execution environment when you publish a function version.
type SnapStart struct {

  // Applying SnapStart setting on function resource type.
  ApplyOn string `json:"ApplyOn"`
}

// SnapStartResponse The function's SnapStart Response. When set to PublishedVersions, Lambda creates a snapshot of the execution environment when you publish a function version.
type SnapStartResponse struct {

  // Applying SnapStart setting on function resource type.
  ApplyOn string `json:"ApplyOn,omitempty"`

  // Indicates whether SnapStart is activated for the specified function version.
  OptimizationStatus string `json:"OptimizationStatus,omitempty"`
}

// Tag 
type Tag struct {

  // The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
  Key string `json:"Key"`

  // The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
  Value string `json:"Value,omitempty"`
}

// TracingConfig The function's AWS X-Ray tracing configuration. To sample and record incoming requests, set Mode to Active.
type TracingConfig struct {

  // The tracing mode.
  Mode string `json:"Mode,omitempty"`
}

// Variables Environment variable key-value pairs.
type Variables struct {
}

// VpcConfig The VPC security groups and subnets that are attached to a Lambda function. When you connect a function to a VPC, Lambda creates an elastic network interface for each combination of security group and subnet in the function's VPC configuration. The function can only access resources and the internet through that VPC.
type VpcConfig struct {

  // A list of VPC security groups IDs.
  SecurityGroupIds []string `json:"SecurityGroupIds,omitempty"`

  // A list of VPC subnet IDs.
  SubnetIds []string `json:"SubnetIds,omitempty"`
}

func (strct *Code) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ImageUri" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ImageUri\": ")
	if tmp, err := json.Marshal(strct.ImageUri); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "S3Bucket" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3Bucket\": ")
	if tmp, err := json.Marshal(strct.S3Bucket); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "S3Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3Key\": ")
	if tmp, err := json.Marshal(strct.S3Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "S3ObjectVersion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3ObjectVersion\": ")
	if tmp, err := json.Marshal(strct.S3ObjectVersion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ZipFile" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ZipFile\": ")
	if tmp, err := json.Marshal(strct.ZipFile); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Code) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ImageUri":
            if err := json.Unmarshal([]byte(v), &strct.ImageUri); err != nil {
                return err
             }
        case "S3Bucket":
            if err := json.Unmarshal([]byte(v), &strct.S3Bucket); err != nil {
                return err
             }
        case "S3Key":
            if err := json.Unmarshal([]byte(v), &strct.S3Key); err != nil {
                return err
             }
        case "S3ObjectVersion":
            if err := json.Unmarshal([]byte(v), &strct.S3ObjectVersion); err != nil {
                return err
             }
        case "ZipFile":
            if err := json.Unmarshal([]byte(v), &strct.ZipFile); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *DeadLetterConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "TargetArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TargetArn\": ")
	if tmp, err := json.Marshal(strct.TargetArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DeadLetterConfig) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "TargetArn":
            if err := json.Unmarshal([]byte(v), &strct.TargetArn); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Environment) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Variables" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Variables\": ")
	if tmp, err := json.Marshal(strct.Variables); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Environment) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Variables":
            if err := json.Unmarshal([]byte(v), &strct.Variables); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *EphemeralStorage) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Size" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Size" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Size\": ")
	if tmp, err := json.Marshal(strct.Size); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *EphemeralStorage) UnmarshalJSON(b []byte) error {
    SizeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Size":
            if err := json.Unmarshal([]byte(v), &strct.Size); err != nil {
                return err
             }
            SizeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Size (a required property) was received
    if !SizeReceived {
        return errors.New("\"Size\" is required but was not present")
    }
    return nil
}

func (strct *FileSystemConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Arn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Arn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Arn\": ")
	if tmp, err := json.Marshal(strct.Arn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "LocalMountPath" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "LocalMountPath" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LocalMountPath\": ")
	if tmp, err := json.Marshal(strct.LocalMountPath); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FileSystemConfig) UnmarshalJSON(b []byte) error {
    ArnReceived := false
    LocalMountPathReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Arn":
            if err := json.Unmarshal([]byte(v), &strct.Arn); err != nil {
                return err
             }
            ArnReceived = true
        case "LocalMountPath":
            if err := json.Unmarshal([]byte(v), &strct.LocalMountPath); err != nil {
                return err
             }
            LocalMountPathReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Arn (a required property) was received
    if !ArnReceived {
        return errors.New("\"Arn\" is required but was not present")
    }
    // check if LocalMountPath (a required property) was received
    if !LocalMountPathReceived {
        return errors.New("\"LocalMountPath\" is required but was not present")
    }
    return nil
}

func (strct *ImageConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Command" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Command\": ")
	if tmp, err := json.Marshal(strct.Command); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EntryPoint" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EntryPoint\": ")
	if tmp, err := json.Marshal(strct.EntryPoint); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "WorkingDirectory" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"WorkingDirectory\": ")
	if tmp, err := json.Marshal(strct.WorkingDirectory); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ImageConfig) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Command":
            if err := json.Unmarshal([]byte(v), &strct.Command); err != nil {
                return err
             }
        case "EntryPoint":
            if err := json.Unmarshal([]byte(v), &strct.EntryPoint); err != nil {
                return err
             }
        case "WorkingDirectory":
            if err := json.Unmarshal([]byte(v), &strct.WorkingDirectory); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Architectures" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Architectures\": ")
	if tmp, err := json.Marshal(strct.Architectures); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Arn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Arn\": ")
	if tmp, err := json.Marshal(strct.Arn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Code" field is required
    if strct.Code == nil {
        return nil, errors.New("Code is a required field")
    }
    // Marshal the "Code" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Code\": ")
	if tmp, err := json.Marshal(strct.Code); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CodeSigningConfigArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CodeSigningConfigArn\": ")
	if tmp, err := json.Marshal(strct.CodeSigningConfigArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DeadLetterConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DeadLetterConfig\": ")
	if tmp, err := json.Marshal(strct.DeadLetterConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Environment" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Environment\": ")
	if tmp, err := json.Marshal(strct.Environment); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EphemeralStorage" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EphemeralStorage\": ")
	if tmp, err := json.Marshal(strct.EphemeralStorage); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FileSystemConfigs" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FileSystemConfigs\": ")
	if tmp, err := json.Marshal(strct.FileSystemConfigs); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FunctionName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FunctionName\": ")
	if tmp, err := json.Marshal(strct.FunctionName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Handler" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Handler\": ")
	if tmp, err := json.Marshal(strct.Handler); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ImageConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ImageConfig\": ")
	if tmp, err := json.Marshal(strct.ImageConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "KmsKeyArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KmsKeyArn\": ")
	if tmp, err := json.Marshal(strct.KmsKeyArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Layers" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Layers\": ")
	if tmp, err := json.Marshal(strct.Layers); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MemorySize" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MemorySize\": ")
	if tmp, err := json.Marshal(strct.MemorySize); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PackageType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PackageType\": ")
	if tmp, err := json.Marshal(strct.PackageType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ReservedConcurrentExecutions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ReservedConcurrentExecutions\": ")
	if tmp, err := json.Marshal(strct.ReservedConcurrentExecutions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Role" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Role" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Role\": ")
	if tmp, err := json.Marshal(strct.Role); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Runtime" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Runtime\": ")
	if tmp, err := json.Marshal(strct.Runtime); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RuntimeManagementConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RuntimeManagementConfig\": ")
	if tmp, err := json.Marshal(strct.RuntimeManagementConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SnapStart" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SnapStart\": ")
	if tmp, err := json.Marshal(strct.SnapStart); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SnapStartResponse" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SnapStartResponse\": ")
	if tmp, err := json.Marshal(strct.SnapStartResponse); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Timeout" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Timeout\": ")
	if tmp, err := json.Marshal(strct.Timeout); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TracingConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TracingConfig\": ")
	if tmp, err := json.Marshal(strct.TracingConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VpcConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VpcConfig\": ")
	if tmp, err := json.Marshal(strct.VpcConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    CodeReceived := false
    RoleReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Architectures":
            if err := json.Unmarshal([]byte(v), &strct.Architectures); err != nil {
                return err
             }
        case "Arn":
            if err := json.Unmarshal([]byte(v), &strct.Arn); err != nil {
                return err
             }
        case "Code":
            if err := json.Unmarshal([]byte(v), &strct.Code); err != nil {
                return err
             }
            CodeReceived = true
        case "CodeSigningConfigArn":
            if err := json.Unmarshal([]byte(v), &strct.CodeSigningConfigArn); err != nil {
                return err
             }
        case "DeadLetterConfig":
            if err := json.Unmarshal([]byte(v), &strct.DeadLetterConfig); err != nil {
                return err
             }
        case "Description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "Environment":
            if err := json.Unmarshal([]byte(v), &strct.Environment); err != nil {
                return err
             }
        case "EphemeralStorage":
            if err := json.Unmarshal([]byte(v), &strct.EphemeralStorage); err != nil {
                return err
             }
        case "FileSystemConfigs":
            if err := json.Unmarshal([]byte(v), &strct.FileSystemConfigs); err != nil {
                return err
             }
        case "FunctionName":
            if err := json.Unmarshal([]byte(v), &strct.FunctionName); err != nil {
                return err
             }
        case "Handler":
            if err := json.Unmarshal([]byte(v), &strct.Handler); err != nil {
                return err
             }
        case "ImageConfig":
            if err := json.Unmarshal([]byte(v), &strct.ImageConfig); err != nil {
                return err
             }
        case "KmsKeyArn":
            if err := json.Unmarshal([]byte(v), &strct.KmsKeyArn); err != nil {
                return err
             }
        case "Layers":
            if err := json.Unmarshal([]byte(v), &strct.Layers); err != nil {
                return err
             }
        case "MemorySize":
            if err := json.Unmarshal([]byte(v), &strct.MemorySize); err != nil {
                return err
             }
        case "PackageType":
            if err := json.Unmarshal([]byte(v), &strct.PackageType); err != nil {
                return err
             }
        case "ReservedConcurrentExecutions":
            if err := json.Unmarshal([]byte(v), &strct.ReservedConcurrentExecutions); err != nil {
                return err
             }
        case "Role":
            if err := json.Unmarshal([]byte(v), &strct.Role); err != nil {
                return err
             }
            RoleReceived = true
        case "Runtime":
            if err := json.Unmarshal([]byte(v), &strct.Runtime); err != nil {
                return err
             }
        case "RuntimeManagementConfig":
            if err := json.Unmarshal([]byte(v), &strct.RuntimeManagementConfig); err != nil {
                return err
             }
        case "SnapStart":
            if err := json.Unmarshal([]byte(v), &strct.SnapStart); err != nil {
                return err
             }
        case "SnapStartResponse":
            if err := json.Unmarshal([]byte(v), &strct.SnapStartResponse); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        case "Timeout":
            if err := json.Unmarshal([]byte(v), &strct.Timeout); err != nil {
                return err
             }
        case "TracingConfig":
            if err := json.Unmarshal([]byte(v), &strct.TracingConfig); err != nil {
                return err
             }
        case "VpcConfig":
            if err := json.Unmarshal([]byte(v), &strct.VpcConfig); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Code (a required property) was received
    if !CodeReceived {
        return errors.New("\"Code\" is required but was not present")
    }
    // check if Role (a required property) was received
    if !RoleReceived {
        return errors.New("\"Role\" is required but was not present")
    }
    return nil
}

func (strct *RuntimeManagementConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "RuntimeVersionArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RuntimeVersionArn\": ")
	if tmp, err := json.Marshal(strct.RuntimeVersionArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "UpdateRuntimeOn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "UpdateRuntimeOn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UpdateRuntimeOn\": ")
	if tmp, err := json.Marshal(strct.UpdateRuntimeOn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RuntimeManagementConfig) UnmarshalJSON(b []byte) error {
    UpdateRuntimeOnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "RuntimeVersionArn":
            if err := json.Unmarshal([]byte(v), &strct.RuntimeVersionArn); err != nil {
                return err
             }
        case "UpdateRuntimeOn":
            if err := json.Unmarshal([]byte(v), &strct.UpdateRuntimeOn); err != nil {
                return err
             }
            UpdateRuntimeOnReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if UpdateRuntimeOn (a required property) was received
    if !UpdateRuntimeOnReceived {
        return errors.New("\"UpdateRuntimeOn\" is required but was not present")
    }
    return nil
}

func (strct *SnapStart) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ApplyOn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ApplyOn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ApplyOn\": ")
	if tmp, err := json.Marshal(strct.ApplyOn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SnapStart) UnmarshalJSON(b []byte) error {
    ApplyOnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ApplyOn":
            if err := json.Unmarshal([]byte(v), &strct.ApplyOn); err != nil {
                return err
             }
            ApplyOnReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ApplyOn (a required property) was received
    if !ApplyOnReceived {
        return errors.New("\"ApplyOn\" is required but was not present")
    }
    return nil
}

func (strct *SnapStartResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ApplyOn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ApplyOn\": ")
	if tmp, err := json.Marshal(strct.ApplyOn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OptimizationStatus" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OptimizationStatus\": ")
	if tmp, err := json.Marshal(strct.OptimizationStatus); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SnapStartResponse) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ApplyOn":
            if err := json.Unmarshal([]byte(v), &strct.ApplyOn); err != nil {
                return err
             }
        case "OptimizationStatus":
            if err := json.Unmarshal([]byte(v), &strct.OptimizationStatus); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    return nil
}

func (strct *TracingConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Mode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Mode\": ")
	if tmp, err := json.Marshal(strct.Mode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TracingConfig) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Mode":
            if err := json.Unmarshal([]byte(v), &strct.Mode); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Variables) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Variables) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *VpcConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "SecurityGroupIds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SecurityGroupIds\": ")
	if tmp, err := json.Marshal(strct.SecurityGroupIds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SubnetIds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SubnetIds\": ")
	if tmp, err := json.Marshal(strct.SubnetIds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *VpcConfig) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "SecurityGroupIds":
            if err := json.Unmarshal([]byte(v), &strct.SecurityGroupIds); err != nil {
                return err
             }
        case "SubnetIds":
            if err := json.Unmarshal([]byte(v), &strct.SubnetIds); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}
