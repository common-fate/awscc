// Code generated by schema-generate. DO NOT EDIT.

package eventsourcemapping

import (
    "errors"
    "bytes"
    "encoding/json"
    "fmt"
)

// AmazonManagedKafkaEventSourceConfig Specific configuration settings for an MSK event source.
type AmazonManagedKafkaEventSourceConfig struct {

  // The identifier for the Kafka Consumer Group to join.
  ConsumerGroupId string `json:"ConsumerGroupId,omitempty"`
}

// DestinationConfig (Streams) An Amazon SQS queue or Amazon SNS topic destination for discarded records.
type DestinationConfig struct {

  // The destination configuration for failed invocations.
  OnFailure *OnFailure `json:"OnFailure,omitempty"`
}

// DocumentDBEventSourceConfig Document db event source config.
type DocumentDBEventSourceConfig struct {

  // The collection name to connect to.
  CollectionName string `json:"CollectionName,omitempty"`

  // The database name to connect to.
  DatabaseName string `json:"DatabaseName,omitempty"`

  // Include full document in change stream response. The default option will only send the changes made to documents to Lambda. If you want the complete document sent to Lambda, set this to UpdateLookup.
  FullDocument string `json:"FullDocument,omitempty"`
}

// Endpoints The endpoints used by AWS Lambda to access a self-managed event source.
type Endpoints struct {

  // A list of Kafka server endpoints.
  KafkaBootstrapServers []string `json:"KafkaBootstrapServers,omitempty"`
}

// Filter The filter object that defines parameters for ESM filtering.
type Filter struct {

  // The filter pattern that defines which events should be passed for invocations.
  Pattern string `json:"Pattern,omitempty"`
}

// FilterCriteria The filter criteria to control event filtering.
type FilterCriteria struct {

  // List of filters of this FilterCriteria
  Filters []*Filter `json:"Filters,omitempty"`
}

// OnFailure A destination for events that failed processing.
type OnFailure struct {

  // The Amazon Resource Name (ARN) of the destination resource.
  Destination string `json:"Destination,omitempty"`
}

// Resource Resource Type definition for AWS::Lambda::EventSourceMapping
type Resource struct {

  // Specific configuration settings for an MSK event source.
  AmazonManagedKafkaEventSourceConfig *AmazonManagedKafkaEventSourceConfig `json:"AmazonManagedKafkaEventSourceConfig,omitempty"`

  // The maximum number of items to retrieve in a single batch.
  BatchSize int `json:"BatchSize,omitempty"`

  // (Streams) If the function returns an error, split the batch in two and retry.
  BisectBatchOnFunctionError bool `json:"BisectBatchOnFunctionError,omitempty"`

  // (Streams) An Amazon SQS queue or Amazon SNS topic destination for discarded records.
  DestinationConfig *DestinationConfig `json:"DestinationConfig,omitempty"`

  // Document db event source config.
  DocumentDBEventSourceConfig *DocumentDBEventSourceConfig `json:"DocumentDBEventSourceConfig,omitempty"`

  // Disables the event source mapping to pause polling and invocation.
  Enabled bool `json:"Enabled,omitempty"`

  // The Amazon Resource Name (ARN) of the event source.
  EventSourceArn string `json:"EventSourceArn,omitempty"`

  // The filter criteria to control event filtering.
  FilterCriteria *FilterCriteria `json:"FilterCriteria,omitempty"`

  // The name of the Lambda function.
  FunctionName string `json:"FunctionName"`

  // (Streams) A list of response types supported by the function.
  FunctionResponseTypes []string `json:"FunctionResponseTypes,omitempty"`

  // Event Source Mapping Identifier UUID.
  Id string `json:"Id,omitempty"`

  // (Streams) The maximum amount of time to gather records before invoking the function, in seconds.
  MaximumBatchingWindowInSeconds int `json:"MaximumBatchingWindowInSeconds,omitempty"`

  // (Streams) The maximum age of a record that Lambda sends to a function for processing.
  MaximumRecordAgeInSeconds int `json:"MaximumRecordAgeInSeconds,omitempty"`

  // (Streams) The maximum number of times to retry when the function returns an error.
  MaximumRetryAttempts int `json:"MaximumRetryAttempts,omitempty"`

  // (Streams) The number of batches to process from each shard concurrently.
  ParallelizationFactor int `json:"ParallelizationFactor,omitempty"`

  // (ActiveMQ) A list of ActiveMQ queues.
  Queues []string `json:"Queues,omitempty"`

  // The scaling configuration for the event source.
  ScalingConfig *ScalingConfig `json:"ScalingConfig,omitempty"`

  // Self-managed event source endpoints.
  SelfManagedEventSource *SelfManagedEventSource `json:"SelfManagedEventSource,omitempty"`

  // Specific configuration settings for a Self-Managed Apache Kafka event source.
  SelfManagedKafkaEventSourceConfig *SelfManagedKafkaEventSourceConfig `json:"SelfManagedKafkaEventSourceConfig,omitempty"`

  // A list of SourceAccessConfiguration.
  SourceAccessConfigurations []*SourceAccessConfiguration `json:"SourceAccessConfigurations,omitempty"`

  // The position in a stream from which to start reading. Required for Amazon Kinesis and Amazon DynamoDB Streams sources.
  StartingPosition string `json:"StartingPosition,omitempty"`

  // With StartingPosition set to AT_TIMESTAMP, the time from which to start reading, in Unix time seconds.
  StartingPositionTimestamp float64 `json:"StartingPositionTimestamp,omitempty"`

  // (Kafka) A list of Kafka topics.
  Topics []string `json:"Topics,omitempty"`

  // (Streams) Tumbling window (non-overlapping time window) duration to perform aggregations.
  TumblingWindowInSeconds int `json:"TumblingWindowInSeconds,omitempty"`
}

// ScalingConfig The scaling configuration for the event source.
type ScalingConfig struct {

  // The maximum number of concurrent functions that the event source can invoke.
  MaximumConcurrency int `json:"MaximumConcurrency,omitempty"`
}

// SelfManagedEventSource The configuration used by AWS Lambda to access a self-managed event source.
type SelfManagedEventSource struct {

  // The endpoints for a self-managed event source.
  Endpoints *Endpoints `json:"Endpoints,omitempty"`
}

// SelfManagedKafkaEventSourceConfig Specific configuration settings for a Self-Managed Apache Kafka event source.
type SelfManagedKafkaEventSourceConfig struct {

  // The identifier for the Kafka Consumer Group to join.
  ConsumerGroupId string `json:"ConsumerGroupId,omitempty"`
}

// SourceAccessConfiguration The configuration used by AWS Lambda to access event source
type SourceAccessConfiguration struct {

  // The type of source access configuration.
  Type string `json:"Type,omitempty"`

  // The URI for the source access configuration resource.
  URI string `json:"URI,omitempty"`
}

func (strct *AmazonManagedKafkaEventSourceConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ConsumerGroupId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConsumerGroupId\": ")
	if tmp, err := json.Marshal(strct.ConsumerGroupId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AmazonManagedKafkaEventSourceConfig) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ConsumerGroupId":
            if err := json.Unmarshal([]byte(v), &strct.ConsumerGroupId); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *DestinationConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "OnFailure" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OnFailure\": ")
	if tmp, err := json.Marshal(strct.OnFailure); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DestinationConfig) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "OnFailure":
            if err := json.Unmarshal([]byte(v), &strct.OnFailure); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *DocumentDBEventSourceConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CollectionName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CollectionName\": ")
	if tmp, err := json.Marshal(strct.CollectionName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DatabaseName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DatabaseName\": ")
	if tmp, err := json.Marshal(strct.DatabaseName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FullDocument" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FullDocument\": ")
	if tmp, err := json.Marshal(strct.FullDocument); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DocumentDBEventSourceConfig) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CollectionName":
            if err := json.Unmarshal([]byte(v), &strct.CollectionName); err != nil {
                return err
             }
        case "DatabaseName":
            if err := json.Unmarshal([]byte(v), &strct.DatabaseName); err != nil {
                return err
             }
        case "FullDocument":
            if err := json.Unmarshal([]byte(v), &strct.FullDocument); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Endpoints) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "KafkaBootstrapServers" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KafkaBootstrapServers\": ")
	if tmp, err := json.Marshal(strct.KafkaBootstrapServers); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Endpoints) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "KafkaBootstrapServers":
            if err := json.Unmarshal([]byte(v), &strct.KafkaBootstrapServers); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Filter) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Pattern" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Pattern\": ")
	if tmp, err := json.Marshal(strct.Pattern); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Filter) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Pattern":
            if err := json.Unmarshal([]byte(v), &strct.Pattern); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *FilterCriteria) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Filters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Filters\": ")
	if tmp, err := json.Marshal(strct.Filters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FilterCriteria) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Filters":
            if err := json.Unmarshal([]byte(v), &strct.Filters); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *OnFailure) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Destination" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Destination\": ")
	if tmp, err := json.Marshal(strct.Destination); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *OnFailure) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Destination":
            if err := json.Unmarshal([]byte(v), &strct.Destination); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AmazonManagedKafkaEventSourceConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AmazonManagedKafkaEventSourceConfig\": ")
	if tmp, err := json.Marshal(strct.AmazonManagedKafkaEventSourceConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BatchSize" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BatchSize\": ")
	if tmp, err := json.Marshal(strct.BatchSize); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BisectBatchOnFunctionError" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BisectBatchOnFunctionError\": ")
	if tmp, err := json.Marshal(strct.BisectBatchOnFunctionError); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DestinationConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DestinationConfig\": ")
	if tmp, err := json.Marshal(strct.DestinationConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DocumentDBEventSourceConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DocumentDBEventSourceConfig\": ")
	if tmp, err := json.Marshal(strct.DocumentDBEventSourceConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Enabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EventSourceArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EventSourceArn\": ")
	if tmp, err := json.Marshal(strct.EventSourceArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FilterCriteria" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FilterCriteria\": ")
	if tmp, err := json.Marshal(strct.FilterCriteria); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "FunctionName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "FunctionName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FunctionName\": ")
	if tmp, err := json.Marshal(strct.FunctionName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FunctionResponseTypes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FunctionResponseTypes\": ")
	if tmp, err := json.Marshal(strct.FunctionResponseTypes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Id" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MaximumBatchingWindowInSeconds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaximumBatchingWindowInSeconds\": ")
	if tmp, err := json.Marshal(strct.MaximumBatchingWindowInSeconds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MaximumRecordAgeInSeconds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaximumRecordAgeInSeconds\": ")
	if tmp, err := json.Marshal(strct.MaximumRecordAgeInSeconds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MaximumRetryAttempts" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaximumRetryAttempts\": ")
	if tmp, err := json.Marshal(strct.MaximumRetryAttempts); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ParallelizationFactor" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ParallelizationFactor\": ")
	if tmp, err := json.Marshal(strct.ParallelizationFactor); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Queues" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Queues\": ")
	if tmp, err := json.Marshal(strct.Queues); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ScalingConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ScalingConfig\": ")
	if tmp, err := json.Marshal(strct.ScalingConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SelfManagedEventSource" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SelfManagedEventSource\": ")
	if tmp, err := json.Marshal(strct.SelfManagedEventSource); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SelfManagedKafkaEventSourceConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SelfManagedKafkaEventSourceConfig\": ")
	if tmp, err := json.Marshal(strct.SelfManagedKafkaEventSourceConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SourceAccessConfigurations" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SourceAccessConfigurations\": ")
	if tmp, err := json.Marshal(strct.SourceAccessConfigurations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StartingPosition" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StartingPosition\": ")
	if tmp, err := json.Marshal(strct.StartingPosition); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StartingPositionTimestamp" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StartingPositionTimestamp\": ")
	if tmp, err := json.Marshal(strct.StartingPositionTimestamp); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Topics" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Topics\": ")
	if tmp, err := json.Marshal(strct.Topics); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TumblingWindowInSeconds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TumblingWindowInSeconds\": ")
	if tmp, err := json.Marshal(strct.TumblingWindowInSeconds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    FunctionNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AmazonManagedKafkaEventSourceConfig":
            if err := json.Unmarshal([]byte(v), &strct.AmazonManagedKafkaEventSourceConfig); err != nil {
                return err
             }
        case "BatchSize":
            if err := json.Unmarshal([]byte(v), &strct.BatchSize); err != nil {
                return err
             }
        case "BisectBatchOnFunctionError":
            if err := json.Unmarshal([]byte(v), &strct.BisectBatchOnFunctionError); err != nil {
                return err
             }
        case "DestinationConfig":
            if err := json.Unmarshal([]byte(v), &strct.DestinationConfig); err != nil {
                return err
             }
        case "DocumentDBEventSourceConfig":
            if err := json.Unmarshal([]byte(v), &strct.DocumentDBEventSourceConfig); err != nil {
                return err
             }
        case "Enabled":
            if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
                return err
             }
        case "EventSourceArn":
            if err := json.Unmarshal([]byte(v), &strct.EventSourceArn); err != nil {
                return err
             }
        case "FilterCriteria":
            if err := json.Unmarshal([]byte(v), &strct.FilterCriteria); err != nil {
                return err
             }
        case "FunctionName":
            if err := json.Unmarshal([]byte(v), &strct.FunctionName); err != nil {
                return err
             }
            FunctionNameReceived = true
        case "FunctionResponseTypes":
            if err := json.Unmarshal([]byte(v), &strct.FunctionResponseTypes); err != nil {
                return err
             }
        case "Id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
        case "MaximumBatchingWindowInSeconds":
            if err := json.Unmarshal([]byte(v), &strct.MaximumBatchingWindowInSeconds); err != nil {
                return err
             }
        case "MaximumRecordAgeInSeconds":
            if err := json.Unmarshal([]byte(v), &strct.MaximumRecordAgeInSeconds); err != nil {
                return err
             }
        case "MaximumRetryAttempts":
            if err := json.Unmarshal([]byte(v), &strct.MaximumRetryAttempts); err != nil {
                return err
             }
        case "ParallelizationFactor":
            if err := json.Unmarshal([]byte(v), &strct.ParallelizationFactor); err != nil {
                return err
             }
        case "Queues":
            if err := json.Unmarshal([]byte(v), &strct.Queues); err != nil {
                return err
             }
        case "ScalingConfig":
            if err := json.Unmarshal([]byte(v), &strct.ScalingConfig); err != nil {
                return err
             }
        case "SelfManagedEventSource":
            if err := json.Unmarshal([]byte(v), &strct.SelfManagedEventSource); err != nil {
                return err
             }
        case "SelfManagedKafkaEventSourceConfig":
            if err := json.Unmarshal([]byte(v), &strct.SelfManagedKafkaEventSourceConfig); err != nil {
                return err
             }
        case "SourceAccessConfigurations":
            if err := json.Unmarshal([]byte(v), &strct.SourceAccessConfigurations); err != nil {
                return err
             }
        case "StartingPosition":
            if err := json.Unmarshal([]byte(v), &strct.StartingPosition); err != nil {
                return err
             }
        case "StartingPositionTimestamp":
            if err := json.Unmarshal([]byte(v), &strct.StartingPositionTimestamp); err != nil {
                return err
             }
        case "Topics":
            if err := json.Unmarshal([]byte(v), &strct.Topics); err != nil {
                return err
             }
        case "TumblingWindowInSeconds":
            if err := json.Unmarshal([]byte(v), &strct.TumblingWindowInSeconds); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if FunctionName (a required property) was received
    if !FunctionNameReceived {
        return errors.New("\"FunctionName\" is required but was not present")
    }
    return nil
}

func (strct *ScalingConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "MaximumConcurrency" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaximumConcurrency\": ")
	if tmp, err := json.Marshal(strct.MaximumConcurrency); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ScalingConfig) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "MaximumConcurrency":
            if err := json.Unmarshal([]byte(v), &strct.MaximumConcurrency); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *SelfManagedEventSource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Endpoints" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Endpoints\": ")
	if tmp, err := json.Marshal(strct.Endpoints); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SelfManagedEventSource) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Endpoints":
            if err := json.Unmarshal([]byte(v), &strct.Endpoints); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *SelfManagedKafkaEventSourceConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ConsumerGroupId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConsumerGroupId\": ")
	if tmp, err := json.Marshal(strct.ConsumerGroupId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SelfManagedKafkaEventSourceConfig) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ConsumerGroupId":
            if err := json.Unmarshal([]byte(v), &strct.ConsumerGroupId); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *SourceAccessConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "URI" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"URI\": ")
	if tmp, err := json.Marshal(strct.URI); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SourceAccessConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
        case "URI":
            if err := json.Unmarshal([]byte(v), &strct.URI); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}
