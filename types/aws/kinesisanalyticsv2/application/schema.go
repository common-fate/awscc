// Code generated by schema-generate. DO NOT EDIT.

package application

import (
    "bytes"
    "errors"
    "encoding/json"
    "fmt"
)

// ApplicationCodeConfiguration Describes code configuration for an application.
type ApplicationCodeConfiguration struct {

  // The location and type of the application code.
  CodeContent *CodeContent `json:"CodeContent"`

  // Specifies whether the code content is in text or zip format.
  CodeContentType string `json:"CodeContentType"`
}

// ApplicationConfiguration Specifies the creation parameters for a Kinesis Data Analytics application.
type ApplicationConfiguration struct {

  // The code location and type parameters for a Flink-based Kinesis Data Analytics application.
  ApplicationCodeConfiguration *ApplicationCodeConfiguration `json:"ApplicationCodeConfiguration,omitempty"`

  // Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.
  ApplicationSnapshotConfiguration *ApplicationSnapshotConfiguration `json:"ApplicationSnapshotConfiguration,omitempty"`

  // Describes execution properties for a Flink-based Kinesis Data Analytics application.
  EnvironmentProperties *EnvironmentProperties `json:"EnvironmentProperties,omitempty"`

  // The creation and update parameters for a Flink-based Kinesis Data Analytics application.
  FlinkApplicationConfiguration *FlinkApplicationConfiguration `json:"FlinkApplicationConfiguration,omitempty"`

  // The creation and update parameters for a SQL-based Kinesis Data Analytics application.
  SqlApplicationConfiguration *SqlApplicationConfiguration `json:"SqlApplicationConfiguration,omitempty"`

  // The array of descriptions of VPC configurations available to the application.
  VpcConfigurations []*VpcConfiguration `json:"VpcConfigurations,omitempty"`

  // The configuration parameters for a Kinesis Data Analytics Studio notebook.
  ZeppelinApplicationConfiguration *ZeppelinApplicationConfiguration `json:"ZeppelinApplicationConfiguration,omitempty"`
}

// ApplicationMaintenanceConfiguration Describes the maintenance configuration for the application.
type ApplicationMaintenanceConfiguration struct {

  // The start time for the maintenance window.
  ApplicationMaintenanceWindowStartTime string `json:"ApplicationMaintenanceWindowStartTime"`
}

// ApplicationRestoreConfiguration Describes the restore behavior of a restarting application.
type ApplicationRestoreConfiguration struct {

  // Specifies how the application should be restored.
  ApplicationRestoreType string `json:"ApplicationRestoreType"`

  // The identifier of an existing snapshot of application state to use to restart an application. The application uses this value if RESTORE_FROM_CUSTOM_SNAPSHOT is specified for the ApplicationRestoreType.
  SnapshotName string `json:"SnapshotName,omitempty"`
}

// ApplicationSnapshotConfiguration Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.
type ApplicationSnapshotConfiguration struct {

  // Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.
  SnapshotsEnabled bool `json:"SnapshotsEnabled"`
}

// CSVMappingParameters For a SQL-based Kinesis Data Analytics application, provides additional mapping information when the record format uses delimiters, such as CSV. For example, the following sample records use CSV format, where the records use the '\n' as the row delimiter and a comma (",") as the column delimiter:
// `"name1", "address1"`
// `"name2", "address2"`
type CSVMappingParameters struct {

  // The column delimiter. For example, in a CSV format, a comma (",") is the typical column delimiter.
  RecordColumnDelimiter string `json:"RecordColumnDelimiter"`

  // The row delimiter. For example, in a CSV format, '\n' is the typical row delimiter.
  RecordRowDelimiter string `json:"RecordRowDelimiter"`
}

// CatalogConfiguration The configuration parameters for the default Amazon Glue database. You use this database for SQL queries that you write in a Kinesis Data Analytics Studio notebook.
type CatalogConfiguration struct {

  // The configuration parameters for the default Amazon Glue database. You use this database for Apache Flink SQL queries and table API transforms that you write in a Kinesis Data Analytics Studio notebook.
  GlueDataCatalogConfiguration *GlueDataCatalogConfiguration `json:"GlueDataCatalogConfiguration,omitempty"`
}

// CheckpointConfiguration Describes an application's checkpointing configuration. Checkpointing is the process of persisting application state for fault tolerance. For more information, see Checkpoints for Fault Tolerance in the Apache Flink Documentation.
type CheckpointConfiguration struct {

  // Describes the interval in milliseconds between checkpoint operations.
  CheckpointInterval int `json:"CheckpointInterval,omitempty"`

  // Describes whether checkpointing is enabled for a Flink-based Kinesis Data Analytics application.
  CheckpointingEnabled bool `json:"CheckpointingEnabled,omitempty"`

  // Describes whether the application uses Kinesis Data Analytics' default checkpointing behavior. You must set this property to `CUSTOM` in order to set the `CheckpointingEnabled`, `CheckpointInterval`, or `MinPauseBetweenCheckpoints` parameters.
  ConfigurationType string `json:"ConfigurationType"`

  // Describes the minimum time in milliseconds after a checkpoint operation completes that a new checkpoint operation can start. If a checkpoint operation takes longer than the CheckpointInterval, the application otherwise performs continual checkpoint operations. For more information, see Tuning Checkpointing in the Apache Flink Documentation.
  MinPauseBetweenCheckpoints int `json:"MinPauseBetweenCheckpoints,omitempty"`
}

// CodeContent Specifies either the application code, or the location of the application code, for a Flink-based Kinesis Data Analytics application.
type CodeContent struct {

  // Information about the Amazon S3 bucket that contains the application code.
  S3ContentLocation *S3ContentLocation `json:"S3ContentLocation,omitempty"`

  // The text-format code for a Flink-based Kinesis Data Analytics application.
  TextContent string `json:"TextContent,omitempty"`

  // The zip-format code for a Flink-based Kinesis Data Analytics application.
  ZipFileContent string `json:"ZipFileContent,omitempty"`
}

// CustomArtifactConfiguration The configuration of connectors and user-defined functions.
type CustomArtifactConfiguration struct {

  // Set this to either `UDF` or `DEPENDENCY_JAR`. `UDF` stands for user-defined functions. This type of artifact must be in an S3 bucket. A `DEPENDENCY_JAR` can be in either Maven or an S3 bucket.
  ArtifactType string `json:"ArtifactType"`

  // The parameters required to fully specify a Maven reference.
  MavenReference *MavenReference `json:"MavenReference,omitempty"`

  // The location of the custom artifacts.
  S3ContentLocation *S3ContentLocation `json:"S3ContentLocation,omitempty"`
}

// DeployAsApplicationConfiguration The information required to deploy a Kinesis Data Analytics Studio notebook as an application with durable state.
type DeployAsApplicationConfiguration struct {

  // The description of an Amazon S3 object that contains the Amazon Data Analytics application, including the Amazon Resource Name (ARN) of the S3 bucket, the name of the Amazon S3 object that contains the data, and the version number of the Amazon S3 object that contains the data.
  S3ContentLocation *S3ContentBaseLocation `json:"S3ContentLocation"`
}

// EnvironmentProperties Describes execution properties for a Flink-based Kinesis Data Analytics application.
type EnvironmentProperties struct {

  // Describes the execution property groups.
  PropertyGroups []*PropertyGroup `json:"PropertyGroups,omitempty"`
}

// FlinkApplicationConfiguration Describes configuration parameters for a Flink-based Kinesis Data Analytics application or a Studio notebook.
type FlinkApplicationConfiguration struct {

  // Describes an application's checkpointing configuration. Checkpointing is the process of persisting application state for fault tolerance. For more information, see Checkpoints for Fault Tolerance in the Apache Flink Documentation.
  CheckpointConfiguration *CheckpointConfiguration `json:"CheckpointConfiguration,omitempty"`

  // Describes configuration parameters for Amazon CloudWatch logging for an application.
  MonitoringConfiguration *MonitoringConfiguration `json:"MonitoringConfiguration,omitempty"`

  // Describes parameters for how an application executes multiple tasks simultaneously.
  ParallelismConfiguration *ParallelismConfiguration `json:"ParallelismConfiguration,omitempty"`
}

// FlinkRunConfiguration Describes the starting parameters for a Flink-based Kinesis Data Analytics application.
type FlinkRunConfiguration struct {

  // When restoring from a snapshot, specifies whether the runtime is allowed to skip a state that cannot be mapped to the new program. Defaults to false. If you update your application without specifying this parameter, AllowNonRestoredState will be set to false, even if it was previously set to true.
  AllowNonRestoredState bool `json:"AllowNonRestoredState,omitempty"`
}

// GlueDataCatalogConfiguration The configuration of the Glue Data Catalog that you use for Apache Flink SQL queries and table API transforms that you write in an application.
type GlueDataCatalogConfiguration struct {

  // The Amazon Resource Name (ARN) of the database.
  DatabaseARN string `json:"DatabaseARN,omitempty"`
}

// Input When you configure the application input for a SQL-based Kinesis Data Analytics application, you specify the streaming source, the in-application stream name that is created, and the mapping between the two.
type Input struct {

  // Describes the number of in-application streams to create.
  InputParallelism *InputParallelism `json:"InputParallelism,omitempty"`

  // The InputProcessingConfiguration for the input. An input processor transforms records as they are received from the stream, before the application's SQL code executes. Currently, the only input processing configuration available is InputLambdaProcessor.
  InputProcessingConfiguration *InputProcessingConfiguration `json:"InputProcessingConfiguration,omitempty"`

  // Describes the format of the data in the streaming source, and how each data element maps to corresponding columns in the in-application stream that is being created.
  InputSchema *InputSchema `json:"InputSchema"`

  // If the streaming source is an Amazon Kinesis Data Firehose delivery stream, identifies the delivery stream's ARN.
  KinesisFirehoseInput *KinesisFirehoseInput `json:"KinesisFirehoseInput,omitempty"`

  // If the streaming source is an Amazon Kinesis data stream, identifies the stream's Amazon Resource Name (ARN).
  KinesisStreamsInput *KinesisStreamsInput `json:"KinesisStreamsInput,omitempty"`

  // The name prefix to use when creating an in-application stream. Suppose that you specify a prefix `"MyInApplicationStream"`. Kinesis Data Analytics then creates one or more (as per the InputParallelism count you specified) in-application streams with the names `"MyInApplicationStream_001"`, `"MyInApplicationStream_002"`, and so on.
  NamePrefix string `json:"NamePrefix"`
}

// InputLambdaProcessor An object that contains the Amazon Resource Name (ARN) of the Amazon Lambda function that is used to preprocess records in the stream in a SQL-based Kinesis Data Analytics application.
type InputLambdaProcessor struct {

  // The ARN of the Amazon Lambda function that operates on records in the stream.
  ResourceARN string `json:"ResourceARN"`
}

// InputParallelism For a SQL-based Kinesis Data Analytics application, describes the number of in-application streams to create for a given streaming source.
type InputParallelism struct {

  // The number of in-application streams to create.
  Count int `json:"Count,omitempty"`
}

// InputProcessingConfiguration For an SQL-based Amazon Kinesis Data Analytics application, describes a processor that is used to preprocess the records in the stream before being processed by your application code. Currently, the only input processor available is Amazon Lambda.
type InputProcessingConfiguration struct {

  // The InputLambdaProcessor that is used to preprocess the records in the stream before being processed by your application code.
  InputLambdaProcessor *InputLambdaProcessor `json:"InputLambdaProcessor,omitempty"`
}

// InputSchema For a SQL-based Kinesis Data Analytics application, describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.
type InputSchema struct {

  // A list of `RecordColumn` objects.
  RecordColumns []*RecordColumn `json:"RecordColumns"`

  // Specifies the encoding of the records in the streaming source. For example, UTF-8.
  RecordEncoding string `json:"RecordEncoding,omitempty"`

  // Specifies the format of the records on the streaming source.
  RecordFormat *RecordFormat `json:"RecordFormat"`
}

// JSONMappingParameters For a SQL-based Kinesis Data Analytics application, provides additional mapping information when JSON is the record format on the streaming source.
type JSONMappingParameters struct {

  // The path to the top-level parent that contains the records.
  RecordRowPath string `json:"RecordRowPath"`
}

// KinesisFirehoseInput For a SQL-based Kinesis Data Analytics application, identifies a Kinesis Data Firehose delivery stream as the streaming source. You provide the delivery stream's Amazon Resource Name (ARN).
type KinesisFirehoseInput struct {

  // The Amazon Resource Name (ARN) of the delivery stream.
  ResourceARN string `json:"ResourceARN"`
}

// KinesisStreamsInput Identifies a Kinesis data stream as the streaming source. You provide the stream's Amazon Resource Name (ARN).
type KinesisStreamsInput struct {

  // The ARN of the input Kinesis data stream to read.
  ResourceARN string `json:"ResourceARN"`
}

// MappingParameters When you configure a SQL-based Kinesis Data Analytics application's input at the time of creating or updating an application, provides additional mapping information specific to the record format (such as JSON, CSV, or record fields delimited by some delimiter) on the streaming source.
type MappingParameters struct {

  // Provides additional mapping information when the record format uses delimiters (for example, CSV).
  CSVMappingParameters *CSVMappingParameters `json:"CSVMappingParameters,omitempty"`

  // Provides additional mapping information when JSON is the record format on the streaming source.
  JSONMappingParameters *JSONMappingParameters `json:"JSONMappingParameters,omitempty"`
}

// MavenReference The information required to specify a Maven reference. You can use Maven references to specify dependency JAR files.
type MavenReference struct {

  // The artifact ID of the Maven reference.
  ArtifactId string `json:"ArtifactId"`

  // The group ID of the Maven reference.
  GroupId string `json:"GroupId"`

  // The version of the Maven reference.
  Version string `json:"Version"`
}

// MonitoringConfiguration Describes configuration parameters for Amazon CloudWatch logging for a Java-based Kinesis Data Analytics application. For more information about CloudWatch logging, see Monitoring.
type MonitoringConfiguration struct {

  // Describes whether to use the default CloudWatch logging configuration for an application. You must set this property to CUSTOM in order to set the LogLevel or MetricsLevel parameters.
  ConfigurationType string `json:"ConfigurationType"`

  // Describes the verbosity of the CloudWatch Logs for an application.
  LogLevel string `json:"LogLevel,omitempty"`

  // Describes the granularity of the CloudWatch Logs for an application. The Parallelism level is not recommended for applications with a Parallelism over 64 due to excessive costs.
  MetricsLevel string `json:"MetricsLevel,omitempty"`
}

// ParallelismConfiguration Describes parameters for how a Flink-based Kinesis Data Analytics application executes multiple tasks simultaneously. For more information about parallelism, see Parallel Execution in the Apache Flink Documentation
type ParallelismConfiguration struct {

  // Describes whether the Kinesis Data Analytics service can increase the parallelism of the application in response to increased throughput.
  AutoScalingEnabled bool `json:"AutoScalingEnabled,omitempty"`

  // Describes whether the application uses the default parallelism for the Kinesis Data Analytics service. You must set this property to `CUSTOM` in order to change your application's `AutoScalingEnabled`, `Parallelism`, or `ParallelismPerKPU` properties.
  ConfigurationType string `json:"ConfigurationType"`

  // Describes the initial number of parallel tasks that a Java-based Kinesis Data Analytics application can perform. The Kinesis Data Analytics service can increase this number automatically if ParallelismConfiguration:AutoScalingEnabled is set to true.
  Parallelism int `json:"Parallelism,omitempty"`

  // Describes the number of parallel tasks that a Java-based Kinesis Data Analytics application can perform per Kinesis Processing Unit (KPU) used by the application. For more information about KPUs, see Amazon Kinesis Data Analytics Pricing.
  ParallelismPerKPU int `json:"ParallelismPerKPU,omitempty"`
}

// PropertyGroup Property key-value pairs passed into an application.
type PropertyGroup struct {

  // Describes the key of an application execution property key-value pair.
  PropertyGroupId string `json:"PropertyGroupId,omitempty"`

  // Describes the value of an application execution property key-value pair.
  PropertyMap *PropertyMap `json:"PropertyMap,omitempty"`
}

// PropertyMap Describes the value of an application execution property key-value pair.
type PropertyMap struct {
}

// RecordColumn For a SQL-based Kinesis Data Analytics application, describes the mapping of each data element in the streaming source to the corresponding column in the in-application stream.
// Also used to describe the format of the reference data source.
type RecordColumn struct {

  // A reference to the data element in the streaming input or the reference data source.
  Mapping string `json:"Mapping,omitempty"`

  // The name of the column that is created in the in-application input stream or reference table.
  Name string `json:"Name"`

  // The type of column created in the in-application input stream or reference table.
  SqlType string `json:"SqlType"`
}

// RecordFormat For a SQL-based Kinesis Data Analytics application, describes the record format and relevant mapping information that should be applied to schematize the records on the stream.
type RecordFormat struct {

  // When you configure application input at the time of creating or updating an application, provides additional mapping information specific to the record format (such as JSON, CSV, or record fields delimited by some delimiter) on the streaming source.
  MappingParameters *MappingParameters `json:"MappingParameters,omitempty"`

  // The type of record format.
  RecordFormatType string `json:"RecordFormatType"`
}

// Resource Creates an Amazon Kinesis Data Analytics application. For information about creating a Kinesis Data Analytics application, see [Creating an Application](https://docs.aws.amazon.com/kinesisanalytics/latest/java/getting-started.html).
type Resource struct {

  // Use this parameter to configure the application.
  ApplicationConfiguration *ApplicationConfiguration `json:"ApplicationConfiguration,omitempty"`

  // The description of the application.
  ApplicationDescription string `json:"ApplicationDescription,omitempty"`

  // Used to configure start of maintenance window.
  ApplicationMaintenanceConfiguration *ApplicationMaintenanceConfiguration `json:"ApplicationMaintenanceConfiguration,omitempty"`

  // To create a Kinesis Data Analytics Studio notebook, you must set the mode to `INTERACTIVE`. However, for a Kinesis Data Analytics for Apache Flink application, the mode is optional.
  ApplicationMode string `json:"ApplicationMode,omitempty"`

  // The name of the application.
  ApplicationName string `json:"ApplicationName,omitempty"`

  // Specifies run configuration (start parameters) of a Kinesis Data Analytics application. Evaluated on update for RUNNING applications an only.
  RunConfiguration *RunConfiguration `json:"RunConfiguration,omitempty"`

  // The runtime environment for the application.
  RuntimeEnvironment string `json:"RuntimeEnvironment"`

  // Specifies the IAM role that the application uses to access external resources.
  ServiceExecutionRole string `json:"ServiceExecutionRole"`

  // A list of one or more tags to assign to the application. A tag is a key-value pair that identifies an application. Note that the maximum number of application tags includes system tags. The maximum number of user-defined application tags is 50.
  Tags []*Tag `json:"Tags,omitempty"`
}

// RunConfiguration Identifies the run configuration (start parameters) of a Kinesis Data Analytics application. This section is evaluated only on stack updates for applications in running RUNNING state and has no effect during manual application start.
type RunConfiguration struct {

  // Describes the restore behavior of a restarting application.
  ApplicationRestoreConfiguration *ApplicationRestoreConfiguration `json:"ApplicationRestoreConfiguration,omitempty"`

  // Describes the starting parameters for a Flink-based Kinesis Data Analytics application.
  FlinkRunConfiguration *FlinkRunConfiguration `json:"FlinkRunConfiguration,omitempty"`
}

// S3ContentBaseLocation The base location of the Amazon Data Analytics application.
type S3ContentBaseLocation struct {

  // The base path for the S3 bucket.
  BasePath string `json:"BasePath,omitempty"`

  // The Amazon Resource Name (ARN) of the S3 bucket.
  BucketARN string `json:"BucketARN"`
}

// S3ContentLocation The location of an application or a custom artifact.
type S3ContentLocation struct {

  // The Amazon Resource Name (ARN) for the S3 bucket containing the application code.
  BucketARN string `json:"BucketARN"`

  // The file key for the object containing the application code.
  FileKey string `json:"FileKey"`

  // The version of the object containing the application code.
  ObjectVersion string `json:"ObjectVersion,omitempty"`
}

// SqlApplicationConfiguration Describes the inputs, outputs, and reference data sources for a SQL-based Kinesis Data Analytics application.
type SqlApplicationConfiguration struct {

  // The array of Input objects describing the input streams used by the application.
  Inputs []*Input `json:"Inputs,omitempty"`
}

// Tag A key-value pair that identifies an application.
type Tag struct {

  // The key name of the tag. You can specify a value that's 1 to 128 Unicode characters in length and can't be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
  Key string `json:"Key"`

  // The value for the tag. You can specify a value that's 0 to 256 characters in length.
  Value string `json:"Value"`
}

// VpcConfiguration Describes the parameters of a VPC used by the application.
type VpcConfiguration struct {

  // The array of SecurityGroup IDs used by the VPC configuration.
  SecurityGroupIds []string `json:"SecurityGroupIds"`

  // The array of Subnet IDs used by the VPC configuration.
  SubnetIds []string `json:"SubnetIds"`
}

// ZeppelinApplicationConfiguration The configuration of a Kinesis Data Analytics Studio notebook.
type ZeppelinApplicationConfiguration struct {

  // The Amazon Glue Data Catalog that you use in queries in a Kinesis Data Analytics Studio notebook.
  CatalogConfiguration *CatalogConfiguration `json:"CatalogConfiguration,omitempty"`

  // A list of CustomArtifactConfiguration objects.
  CustomArtifactsConfiguration []*CustomArtifactConfiguration `json:"CustomArtifactsConfiguration,omitempty"`

  // The information required to deploy a Kinesis Data Analytics Studio notebook as an application with durable state.
  DeployAsApplicationConfiguration *DeployAsApplicationConfiguration `json:"DeployAsApplicationConfiguration,omitempty"`

  // The monitoring configuration of a Kinesis Data Analytics Studio notebook.
  MonitoringConfiguration *ZeppelinMonitoringConfiguration `json:"MonitoringConfiguration,omitempty"`
}

// ZeppelinMonitoringConfiguration Describes configuration parameters for Amazon CloudWatch logging for a Kinesis Data Analytics Studio notebook. For more information about CloudWatch logging, see Monitoring.
type ZeppelinMonitoringConfiguration struct {

  // The verbosity of the CloudWatch Logs for an application. You can set it to `INFO`, `WARN`, `ERROR`, or `DEBUG`.
  LogLevel string `json:"LogLevel,omitempty"`
}

func (strct *ApplicationCodeConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "CodeContent" field is required
    if strct.CodeContent == nil {
        return nil, errors.New("CodeContent is a required field")
    }
    // Marshal the "CodeContent" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CodeContent\": ")
	if tmp, err := json.Marshal(strct.CodeContent); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "CodeContentType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "CodeContentType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CodeContentType\": ")
	if tmp, err := json.Marshal(strct.CodeContentType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ApplicationCodeConfiguration) UnmarshalJSON(b []byte) error {
    CodeContentReceived := false
    CodeContentTypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CodeContent":
            if err := json.Unmarshal([]byte(v), &strct.CodeContent); err != nil {
                return err
             }
            CodeContentReceived = true
        case "CodeContentType":
            if err := json.Unmarshal([]byte(v), &strct.CodeContentType); err != nil {
                return err
             }
            CodeContentTypeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if CodeContent (a required property) was received
    if !CodeContentReceived {
        return errors.New("\"CodeContent\" is required but was not present")
    }
    // check if CodeContentType (a required property) was received
    if !CodeContentTypeReceived {
        return errors.New("\"CodeContentType\" is required but was not present")
    }
    return nil
}

func (strct *ApplicationConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ApplicationCodeConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ApplicationCodeConfiguration\": ")
	if tmp, err := json.Marshal(strct.ApplicationCodeConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ApplicationSnapshotConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ApplicationSnapshotConfiguration\": ")
	if tmp, err := json.Marshal(strct.ApplicationSnapshotConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EnvironmentProperties" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EnvironmentProperties\": ")
	if tmp, err := json.Marshal(strct.EnvironmentProperties); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FlinkApplicationConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FlinkApplicationConfiguration\": ")
	if tmp, err := json.Marshal(strct.FlinkApplicationConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SqlApplicationConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SqlApplicationConfiguration\": ")
	if tmp, err := json.Marshal(strct.SqlApplicationConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VpcConfigurations" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VpcConfigurations\": ")
	if tmp, err := json.Marshal(strct.VpcConfigurations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ZeppelinApplicationConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ZeppelinApplicationConfiguration\": ")
	if tmp, err := json.Marshal(strct.ZeppelinApplicationConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ApplicationConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ApplicationCodeConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.ApplicationCodeConfiguration); err != nil {
                return err
             }
        case "ApplicationSnapshotConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.ApplicationSnapshotConfiguration); err != nil {
                return err
             }
        case "EnvironmentProperties":
            if err := json.Unmarshal([]byte(v), &strct.EnvironmentProperties); err != nil {
                return err
             }
        case "FlinkApplicationConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.FlinkApplicationConfiguration); err != nil {
                return err
             }
        case "SqlApplicationConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.SqlApplicationConfiguration); err != nil {
                return err
             }
        case "VpcConfigurations":
            if err := json.Unmarshal([]byte(v), &strct.VpcConfigurations); err != nil {
                return err
             }
        case "ZeppelinApplicationConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.ZeppelinApplicationConfiguration); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ApplicationMaintenanceConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ApplicationMaintenanceWindowStartTime" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ApplicationMaintenanceWindowStartTime" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ApplicationMaintenanceWindowStartTime\": ")
	if tmp, err := json.Marshal(strct.ApplicationMaintenanceWindowStartTime); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ApplicationMaintenanceConfiguration) UnmarshalJSON(b []byte) error {
    ApplicationMaintenanceWindowStartTimeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ApplicationMaintenanceWindowStartTime":
            if err := json.Unmarshal([]byte(v), &strct.ApplicationMaintenanceWindowStartTime); err != nil {
                return err
             }
            ApplicationMaintenanceWindowStartTimeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ApplicationMaintenanceWindowStartTime (a required property) was received
    if !ApplicationMaintenanceWindowStartTimeReceived {
        return errors.New("\"ApplicationMaintenanceWindowStartTime\" is required but was not present")
    }
    return nil
}

func (strct *ApplicationRestoreConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ApplicationRestoreType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ApplicationRestoreType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ApplicationRestoreType\": ")
	if tmp, err := json.Marshal(strct.ApplicationRestoreType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SnapshotName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SnapshotName\": ")
	if tmp, err := json.Marshal(strct.SnapshotName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ApplicationRestoreConfiguration) UnmarshalJSON(b []byte) error {
    ApplicationRestoreTypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ApplicationRestoreType":
            if err := json.Unmarshal([]byte(v), &strct.ApplicationRestoreType); err != nil {
                return err
             }
            ApplicationRestoreTypeReceived = true
        case "SnapshotName":
            if err := json.Unmarshal([]byte(v), &strct.SnapshotName); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ApplicationRestoreType (a required property) was received
    if !ApplicationRestoreTypeReceived {
        return errors.New("\"ApplicationRestoreType\" is required but was not present")
    }
    return nil
}

func (strct *ApplicationSnapshotConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "SnapshotsEnabled" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "SnapshotsEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SnapshotsEnabled\": ")
	if tmp, err := json.Marshal(strct.SnapshotsEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ApplicationSnapshotConfiguration) UnmarshalJSON(b []byte) error {
    SnapshotsEnabledReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "SnapshotsEnabled":
            if err := json.Unmarshal([]byte(v), &strct.SnapshotsEnabled); err != nil {
                return err
             }
            SnapshotsEnabledReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if SnapshotsEnabled (a required property) was received
    if !SnapshotsEnabledReceived {
        return errors.New("\"SnapshotsEnabled\" is required but was not present")
    }
    return nil
}

func (strct *CSVMappingParameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "RecordColumnDelimiter" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RecordColumnDelimiter" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RecordColumnDelimiter\": ")
	if tmp, err := json.Marshal(strct.RecordColumnDelimiter); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RecordRowDelimiter" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RecordRowDelimiter" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RecordRowDelimiter\": ")
	if tmp, err := json.Marshal(strct.RecordRowDelimiter); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CSVMappingParameters) UnmarshalJSON(b []byte) error {
    RecordColumnDelimiterReceived := false
    RecordRowDelimiterReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "RecordColumnDelimiter":
            if err := json.Unmarshal([]byte(v), &strct.RecordColumnDelimiter); err != nil {
                return err
             }
            RecordColumnDelimiterReceived = true
        case "RecordRowDelimiter":
            if err := json.Unmarshal([]byte(v), &strct.RecordRowDelimiter); err != nil {
                return err
             }
            RecordRowDelimiterReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if RecordColumnDelimiter (a required property) was received
    if !RecordColumnDelimiterReceived {
        return errors.New("\"RecordColumnDelimiter\" is required but was not present")
    }
    // check if RecordRowDelimiter (a required property) was received
    if !RecordRowDelimiterReceived {
        return errors.New("\"RecordRowDelimiter\" is required but was not present")
    }
    return nil
}

func (strct *CatalogConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "GlueDataCatalogConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"GlueDataCatalogConfiguration\": ")
	if tmp, err := json.Marshal(strct.GlueDataCatalogConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CatalogConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "GlueDataCatalogConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.GlueDataCatalogConfiguration); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *CheckpointConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CheckpointInterval" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CheckpointInterval\": ")
	if tmp, err := json.Marshal(strct.CheckpointInterval); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CheckpointingEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CheckpointingEnabled\": ")
	if tmp, err := json.Marshal(strct.CheckpointingEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ConfigurationType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ConfigurationType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConfigurationType\": ")
	if tmp, err := json.Marshal(strct.ConfigurationType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MinPauseBetweenCheckpoints" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MinPauseBetweenCheckpoints\": ")
	if tmp, err := json.Marshal(strct.MinPauseBetweenCheckpoints); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CheckpointConfiguration) UnmarshalJSON(b []byte) error {
    ConfigurationTypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CheckpointInterval":
            if err := json.Unmarshal([]byte(v), &strct.CheckpointInterval); err != nil {
                return err
             }
        case "CheckpointingEnabled":
            if err := json.Unmarshal([]byte(v), &strct.CheckpointingEnabled); err != nil {
                return err
             }
        case "ConfigurationType":
            if err := json.Unmarshal([]byte(v), &strct.ConfigurationType); err != nil {
                return err
             }
            ConfigurationTypeReceived = true
        case "MinPauseBetweenCheckpoints":
            if err := json.Unmarshal([]byte(v), &strct.MinPauseBetweenCheckpoints); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ConfigurationType (a required property) was received
    if !ConfigurationTypeReceived {
        return errors.New("\"ConfigurationType\" is required but was not present")
    }
    return nil
}

func (strct *CodeContent) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "S3ContentLocation" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3ContentLocation\": ")
	if tmp, err := json.Marshal(strct.S3ContentLocation); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TextContent" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TextContent\": ")
	if tmp, err := json.Marshal(strct.TextContent); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ZipFileContent" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ZipFileContent\": ")
	if tmp, err := json.Marshal(strct.ZipFileContent); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CodeContent) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "S3ContentLocation":
            if err := json.Unmarshal([]byte(v), &strct.S3ContentLocation); err != nil {
                return err
             }
        case "TextContent":
            if err := json.Unmarshal([]byte(v), &strct.TextContent); err != nil {
                return err
             }
        case "ZipFileContent":
            if err := json.Unmarshal([]byte(v), &strct.ZipFileContent); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *CustomArtifactConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ArtifactType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ArtifactType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ArtifactType\": ")
	if tmp, err := json.Marshal(strct.ArtifactType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MavenReference" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MavenReference\": ")
	if tmp, err := json.Marshal(strct.MavenReference); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "S3ContentLocation" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3ContentLocation\": ")
	if tmp, err := json.Marshal(strct.S3ContentLocation); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CustomArtifactConfiguration) UnmarshalJSON(b []byte) error {
    ArtifactTypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ArtifactType":
            if err := json.Unmarshal([]byte(v), &strct.ArtifactType); err != nil {
                return err
             }
            ArtifactTypeReceived = true
        case "MavenReference":
            if err := json.Unmarshal([]byte(v), &strct.MavenReference); err != nil {
                return err
             }
        case "S3ContentLocation":
            if err := json.Unmarshal([]byte(v), &strct.S3ContentLocation); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ArtifactType (a required property) was received
    if !ArtifactTypeReceived {
        return errors.New("\"ArtifactType\" is required but was not present")
    }
    return nil
}

func (strct *DeployAsApplicationConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "S3ContentLocation" field is required
    if strct.S3ContentLocation == nil {
        return nil, errors.New("S3ContentLocation is a required field")
    }
    // Marshal the "S3ContentLocation" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3ContentLocation\": ")
	if tmp, err := json.Marshal(strct.S3ContentLocation); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DeployAsApplicationConfiguration) UnmarshalJSON(b []byte) error {
    S3ContentLocationReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "S3ContentLocation":
            if err := json.Unmarshal([]byte(v), &strct.S3ContentLocation); err != nil {
                return err
             }
            S3ContentLocationReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if S3ContentLocation (a required property) was received
    if !S3ContentLocationReceived {
        return errors.New("\"S3ContentLocation\" is required but was not present")
    }
    return nil
}

func (strct *EnvironmentProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "PropertyGroups" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PropertyGroups\": ")
	if tmp, err := json.Marshal(strct.PropertyGroups); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *EnvironmentProperties) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "PropertyGroups":
            if err := json.Unmarshal([]byte(v), &strct.PropertyGroups); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *FlinkApplicationConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CheckpointConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CheckpointConfiguration\": ")
	if tmp, err := json.Marshal(strct.CheckpointConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MonitoringConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MonitoringConfiguration\": ")
	if tmp, err := json.Marshal(strct.MonitoringConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ParallelismConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ParallelismConfiguration\": ")
	if tmp, err := json.Marshal(strct.ParallelismConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FlinkApplicationConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CheckpointConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.CheckpointConfiguration); err != nil {
                return err
             }
        case "MonitoringConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.MonitoringConfiguration); err != nil {
                return err
             }
        case "ParallelismConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.ParallelismConfiguration); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *FlinkRunConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AllowNonRestoredState" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AllowNonRestoredState\": ")
	if tmp, err := json.Marshal(strct.AllowNonRestoredState); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FlinkRunConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AllowNonRestoredState":
            if err := json.Unmarshal([]byte(v), &strct.AllowNonRestoredState); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *GlueDataCatalogConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DatabaseARN" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DatabaseARN\": ")
	if tmp, err := json.Marshal(strct.DatabaseARN); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *GlueDataCatalogConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DatabaseARN":
            if err := json.Unmarshal([]byte(v), &strct.DatabaseARN); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Input) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "InputParallelism" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InputParallelism\": ")
	if tmp, err := json.Marshal(strct.InputParallelism); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "InputProcessingConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InputProcessingConfiguration\": ")
	if tmp, err := json.Marshal(strct.InputProcessingConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "InputSchema" field is required
    if strct.InputSchema == nil {
        return nil, errors.New("InputSchema is a required field")
    }
    // Marshal the "InputSchema" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InputSchema\": ")
	if tmp, err := json.Marshal(strct.InputSchema); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "KinesisFirehoseInput" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KinesisFirehoseInput\": ")
	if tmp, err := json.Marshal(strct.KinesisFirehoseInput); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "KinesisStreamsInput" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KinesisStreamsInput\": ")
	if tmp, err := json.Marshal(strct.KinesisStreamsInput); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "NamePrefix" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "NamePrefix" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NamePrefix\": ")
	if tmp, err := json.Marshal(strct.NamePrefix); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Input) UnmarshalJSON(b []byte) error {
    InputSchemaReceived := false
    NamePrefixReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "InputParallelism":
            if err := json.Unmarshal([]byte(v), &strct.InputParallelism); err != nil {
                return err
             }
        case "InputProcessingConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.InputProcessingConfiguration); err != nil {
                return err
             }
        case "InputSchema":
            if err := json.Unmarshal([]byte(v), &strct.InputSchema); err != nil {
                return err
             }
            InputSchemaReceived = true
        case "KinesisFirehoseInput":
            if err := json.Unmarshal([]byte(v), &strct.KinesisFirehoseInput); err != nil {
                return err
             }
        case "KinesisStreamsInput":
            if err := json.Unmarshal([]byte(v), &strct.KinesisStreamsInput); err != nil {
                return err
             }
        case "NamePrefix":
            if err := json.Unmarshal([]byte(v), &strct.NamePrefix); err != nil {
                return err
             }
            NamePrefixReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if InputSchema (a required property) was received
    if !InputSchemaReceived {
        return errors.New("\"InputSchema\" is required but was not present")
    }
    // check if NamePrefix (a required property) was received
    if !NamePrefixReceived {
        return errors.New("\"NamePrefix\" is required but was not present")
    }
    return nil
}

func (strct *InputLambdaProcessor) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ResourceARN" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ResourceARN" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ResourceARN\": ")
	if tmp, err := json.Marshal(strct.ResourceARN); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *InputLambdaProcessor) UnmarshalJSON(b []byte) error {
    ResourceARNReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ResourceARN":
            if err := json.Unmarshal([]byte(v), &strct.ResourceARN); err != nil {
                return err
             }
            ResourceARNReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ResourceARN (a required property) was received
    if !ResourceARNReceived {
        return errors.New("\"ResourceARN\" is required but was not present")
    }
    return nil
}

func (strct *InputParallelism) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Count" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Count\": ")
	if tmp, err := json.Marshal(strct.Count); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *InputParallelism) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Count":
            if err := json.Unmarshal([]byte(v), &strct.Count); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *InputProcessingConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "InputLambdaProcessor" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InputLambdaProcessor\": ")
	if tmp, err := json.Marshal(strct.InputLambdaProcessor); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *InputProcessingConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "InputLambdaProcessor":
            if err := json.Unmarshal([]byte(v), &strct.InputLambdaProcessor); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *InputSchema) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "RecordColumns" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RecordColumns" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RecordColumns\": ")
	if tmp, err := json.Marshal(strct.RecordColumns); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RecordEncoding" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RecordEncoding\": ")
	if tmp, err := json.Marshal(strct.RecordEncoding); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RecordFormat" field is required
    if strct.RecordFormat == nil {
        return nil, errors.New("RecordFormat is a required field")
    }
    // Marshal the "RecordFormat" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RecordFormat\": ")
	if tmp, err := json.Marshal(strct.RecordFormat); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *InputSchema) UnmarshalJSON(b []byte) error {
    RecordColumnsReceived := false
    RecordFormatReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "RecordColumns":
            if err := json.Unmarshal([]byte(v), &strct.RecordColumns); err != nil {
                return err
             }
            RecordColumnsReceived = true
        case "RecordEncoding":
            if err := json.Unmarshal([]byte(v), &strct.RecordEncoding); err != nil {
                return err
             }
        case "RecordFormat":
            if err := json.Unmarshal([]byte(v), &strct.RecordFormat); err != nil {
                return err
             }
            RecordFormatReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if RecordColumns (a required property) was received
    if !RecordColumnsReceived {
        return errors.New("\"RecordColumns\" is required but was not present")
    }
    // check if RecordFormat (a required property) was received
    if !RecordFormatReceived {
        return errors.New("\"RecordFormat\" is required but was not present")
    }
    return nil
}

func (strct *JSONMappingParameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "RecordRowPath" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RecordRowPath" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RecordRowPath\": ")
	if tmp, err := json.Marshal(strct.RecordRowPath); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *JSONMappingParameters) UnmarshalJSON(b []byte) error {
    RecordRowPathReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "RecordRowPath":
            if err := json.Unmarshal([]byte(v), &strct.RecordRowPath); err != nil {
                return err
             }
            RecordRowPathReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if RecordRowPath (a required property) was received
    if !RecordRowPathReceived {
        return errors.New("\"RecordRowPath\" is required but was not present")
    }
    return nil
}

func (strct *KinesisFirehoseInput) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ResourceARN" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ResourceARN" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ResourceARN\": ")
	if tmp, err := json.Marshal(strct.ResourceARN); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *KinesisFirehoseInput) UnmarshalJSON(b []byte) error {
    ResourceARNReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ResourceARN":
            if err := json.Unmarshal([]byte(v), &strct.ResourceARN); err != nil {
                return err
             }
            ResourceARNReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ResourceARN (a required property) was received
    if !ResourceARNReceived {
        return errors.New("\"ResourceARN\" is required but was not present")
    }
    return nil
}

func (strct *KinesisStreamsInput) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ResourceARN" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ResourceARN" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ResourceARN\": ")
	if tmp, err := json.Marshal(strct.ResourceARN); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *KinesisStreamsInput) UnmarshalJSON(b []byte) error {
    ResourceARNReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ResourceARN":
            if err := json.Unmarshal([]byte(v), &strct.ResourceARN); err != nil {
                return err
             }
            ResourceARNReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ResourceARN (a required property) was received
    if !ResourceARNReceived {
        return errors.New("\"ResourceARN\" is required but was not present")
    }
    return nil
}

func (strct *MappingParameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CSVMappingParameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CSVMappingParameters\": ")
	if tmp, err := json.Marshal(strct.CSVMappingParameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "JSONMappingParameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"JSONMappingParameters\": ")
	if tmp, err := json.Marshal(strct.JSONMappingParameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MappingParameters) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CSVMappingParameters":
            if err := json.Unmarshal([]byte(v), &strct.CSVMappingParameters); err != nil {
                return err
             }
        case "JSONMappingParameters":
            if err := json.Unmarshal([]byte(v), &strct.JSONMappingParameters); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *MavenReference) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ArtifactId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ArtifactId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ArtifactId\": ")
	if tmp, err := json.Marshal(strct.ArtifactId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "GroupId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "GroupId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"GroupId\": ")
	if tmp, err := json.Marshal(strct.GroupId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Version" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Version" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Version\": ")
	if tmp, err := json.Marshal(strct.Version); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MavenReference) UnmarshalJSON(b []byte) error {
    ArtifactIdReceived := false
    GroupIdReceived := false
    VersionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ArtifactId":
            if err := json.Unmarshal([]byte(v), &strct.ArtifactId); err != nil {
                return err
             }
            ArtifactIdReceived = true
        case "GroupId":
            if err := json.Unmarshal([]byte(v), &strct.GroupId); err != nil {
                return err
             }
            GroupIdReceived = true
        case "Version":
            if err := json.Unmarshal([]byte(v), &strct.Version); err != nil {
                return err
             }
            VersionReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ArtifactId (a required property) was received
    if !ArtifactIdReceived {
        return errors.New("\"ArtifactId\" is required but was not present")
    }
    // check if GroupId (a required property) was received
    if !GroupIdReceived {
        return errors.New("\"GroupId\" is required but was not present")
    }
    // check if Version (a required property) was received
    if !VersionReceived {
        return errors.New("\"Version\" is required but was not present")
    }
    return nil
}

func (strct *MonitoringConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ConfigurationType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ConfigurationType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConfigurationType\": ")
	if tmp, err := json.Marshal(strct.ConfigurationType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LogLevel" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LogLevel\": ")
	if tmp, err := json.Marshal(strct.LogLevel); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MetricsLevel" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MetricsLevel\": ")
	if tmp, err := json.Marshal(strct.MetricsLevel); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MonitoringConfiguration) UnmarshalJSON(b []byte) error {
    ConfigurationTypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ConfigurationType":
            if err := json.Unmarshal([]byte(v), &strct.ConfigurationType); err != nil {
                return err
             }
            ConfigurationTypeReceived = true
        case "LogLevel":
            if err := json.Unmarshal([]byte(v), &strct.LogLevel); err != nil {
                return err
             }
        case "MetricsLevel":
            if err := json.Unmarshal([]byte(v), &strct.MetricsLevel); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ConfigurationType (a required property) was received
    if !ConfigurationTypeReceived {
        return errors.New("\"ConfigurationType\" is required but was not present")
    }
    return nil
}

func (strct *ParallelismConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AutoScalingEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AutoScalingEnabled\": ")
	if tmp, err := json.Marshal(strct.AutoScalingEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ConfigurationType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ConfigurationType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConfigurationType\": ")
	if tmp, err := json.Marshal(strct.ConfigurationType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Parallelism" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Parallelism\": ")
	if tmp, err := json.Marshal(strct.Parallelism); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ParallelismPerKPU" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ParallelismPerKPU\": ")
	if tmp, err := json.Marshal(strct.ParallelismPerKPU); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ParallelismConfiguration) UnmarshalJSON(b []byte) error {
    ConfigurationTypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AutoScalingEnabled":
            if err := json.Unmarshal([]byte(v), &strct.AutoScalingEnabled); err != nil {
                return err
             }
        case "ConfigurationType":
            if err := json.Unmarshal([]byte(v), &strct.ConfigurationType); err != nil {
                return err
             }
            ConfigurationTypeReceived = true
        case "Parallelism":
            if err := json.Unmarshal([]byte(v), &strct.Parallelism); err != nil {
                return err
             }
        case "ParallelismPerKPU":
            if err := json.Unmarshal([]byte(v), &strct.ParallelismPerKPU); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ConfigurationType (a required property) was received
    if !ConfigurationTypeReceived {
        return errors.New("\"ConfigurationType\" is required but was not present")
    }
    return nil
}

func (strct *PropertyGroup) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "PropertyGroupId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PropertyGroupId\": ")
	if tmp, err := json.Marshal(strct.PropertyGroupId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PropertyMap" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PropertyMap\": ")
	if tmp, err := json.Marshal(strct.PropertyMap); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PropertyGroup) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "PropertyGroupId":
            if err := json.Unmarshal([]byte(v), &strct.PropertyGroupId); err != nil {
                return err
             }
        case "PropertyMap":
            if err := json.Unmarshal([]byte(v), &strct.PropertyMap); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *PropertyMap) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PropertyMap) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *RecordColumn) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Mapping" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Mapping\": ")
	if tmp, err := json.Marshal(strct.Mapping); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "SqlType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "SqlType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SqlType\": ")
	if tmp, err := json.Marshal(strct.SqlType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RecordColumn) UnmarshalJSON(b []byte) error {
    NameReceived := false
    SqlTypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Mapping":
            if err := json.Unmarshal([]byte(v), &strct.Mapping); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        case "SqlType":
            if err := json.Unmarshal([]byte(v), &strct.SqlType); err != nil {
                return err
             }
            SqlTypeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    // check if SqlType (a required property) was received
    if !SqlTypeReceived {
        return errors.New("\"SqlType\" is required but was not present")
    }
    return nil
}

func (strct *RecordFormat) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "MappingParameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MappingParameters\": ")
	if tmp, err := json.Marshal(strct.MappingParameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RecordFormatType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RecordFormatType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RecordFormatType\": ")
	if tmp, err := json.Marshal(strct.RecordFormatType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RecordFormat) UnmarshalJSON(b []byte) error {
    RecordFormatTypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "MappingParameters":
            if err := json.Unmarshal([]byte(v), &strct.MappingParameters); err != nil {
                return err
             }
        case "RecordFormatType":
            if err := json.Unmarshal([]byte(v), &strct.RecordFormatType); err != nil {
                return err
             }
            RecordFormatTypeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if RecordFormatType (a required property) was received
    if !RecordFormatTypeReceived {
        return errors.New("\"RecordFormatType\" is required but was not present")
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ApplicationConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ApplicationConfiguration\": ")
	if tmp, err := json.Marshal(strct.ApplicationConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ApplicationDescription" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ApplicationDescription\": ")
	if tmp, err := json.Marshal(strct.ApplicationDescription); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ApplicationMaintenanceConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ApplicationMaintenanceConfiguration\": ")
	if tmp, err := json.Marshal(strct.ApplicationMaintenanceConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ApplicationMode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ApplicationMode\": ")
	if tmp, err := json.Marshal(strct.ApplicationMode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ApplicationName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ApplicationName\": ")
	if tmp, err := json.Marshal(strct.ApplicationName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RunConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RunConfiguration\": ")
	if tmp, err := json.Marshal(strct.RunConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RuntimeEnvironment" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RuntimeEnvironment" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RuntimeEnvironment\": ")
	if tmp, err := json.Marshal(strct.RuntimeEnvironment); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ServiceExecutionRole" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ServiceExecutionRole" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ServiceExecutionRole\": ")
	if tmp, err := json.Marshal(strct.ServiceExecutionRole); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    RuntimeEnvironmentReceived := false
    ServiceExecutionRoleReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ApplicationConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.ApplicationConfiguration); err != nil {
                return err
             }
        case "ApplicationDescription":
            if err := json.Unmarshal([]byte(v), &strct.ApplicationDescription); err != nil {
                return err
             }
        case "ApplicationMaintenanceConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.ApplicationMaintenanceConfiguration); err != nil {
                return err
             }
        case "ApplicationMode":
            if err := json.Unmarshal([]byte(v), &strct.ApplicationMode); err != nil {
                return err
             }
        case "ApplicationName":
            if err := json.Unmarshal([]byte(v), &strct.ApplicationName); err != nil {
                return err
             }
        case "RunConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.RunConfiguration); err != nil {
                return err
             }
        case "RuntimeEnvironment":
            if err := json.Unmarshal([]byte(v), &strct.RuntimeEnvironment); err != nil {
                return err
             }
            RuntimeEnvironmentReceived = true
        case "ServiceExecutionRole":
            if err := json.Unmarshal([]byte(v), &strct.ServiceExecutionRole); err != nil {
                return err
             }
            ServiceExecutionRoleReceived = true
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if RuntimeEnvironment (a required property) was received
    if !RuntimeEnvironmentReceived {
        return errors.New("\"RuntimeEnvironment\" is required but was not present")
    }
    // check if ServiceExecutionRole (a required property) was received
    if !ServiceExecutionRoleReceived {
        return errors.New("\"ServiceExecutionRole\" is required but was not present")
    }
    return nil
}

func (strct *RunConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ApplicationRestoreConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ApplicationRestoreConfiguration\": ")
	if tmp, err := json.Marshal(strct.ApplicationRestoreConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FlinkRunConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FlinkRunConfiguration\": ")
	if tmp, err := json.Marshal(strct.FlinkRunConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RunConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ApplicationRestoreConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.ApplicationRestoreConfiguration); err != nil {
                return err
             }
        case "FlinkRunConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.FlinkRunConfiguration); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *S3ContentBaseLocation) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "BasePath" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BasePath\": ")
	if tmp, err := json.Marshal(strct.BasePath); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "BucketARN" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "BucketARN" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BucketARN\": ")
	if tmp, err := json.Marshal(strct.BucketARN); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *S3ContentBaseLocation) UnmarshalJSON(b []byte) error {
    BucketARNReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BasePath":
            if err := json.Unmarshal([]byte(v), &strct.BasePath); err != nil {
                return err
             }
        case "BucketARN":
            if err := json.Unmarshal([]byte(v), &strct.BucketARN); err != nil {
                return err
             }
            BucketARNReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if BucketARN (a required property) was received
    if !BucketARNReceived {
        return errors.New("\"BucketARN\" is required but was not present")
    }
    return nil
}

func (strct *S3ContentLocation) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "BucketARN" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "BucketARN" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BucketARN\": ")
	if tmp, err := json.Marshal(strct.BucketARN); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "FileKey" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "FileKey" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FileKey\": ")
	if tmp, err := json.Marshal(strct.FileKey); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ObjectVersion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ObjectVersion\": ")
	if tmp, err := json.Marshal(strct.ObjectVersion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *S3ContentLocation) UnmarshalJSON(b []byte) error {
    BucketARNReceived := false
    FileKeyReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BucketARN":
            if err := json.Unmarshal([]byte(v), &strct.BucketARN); err != nil {
                return err
             }
            BucketARNReceived = true
        case "FileKey":
            if err := json.Unmarshal([]byte(v), &strct.FileKey); err != nil {
                return err
             }
            FileKeyReceived = true
        case "ObjectVersion":
            if err := json.Unmarshal([]byte(v), &strct.ObjectVersion); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if BucketARN (a required property) was received
    if !BucketARNReceived {
        return errors.New("\"BucketARN\" is required but was not present")
    }
    // check if FileKey (a required property) was received
    if !FileKeyReceived {
        return errors.New("\"FileKey\" is required but was not present")
    }
    return nil
}

func (strct *SqlApplicationConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Inputs" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Inputs\": ")
	if tmp, err := json.Marshal(strct.Inputs); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SqlApplicationConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Inputs":
            if err := json.Unmarshal([]byte(v), &strct.Inputs); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *VpcConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "SecurityGroupIds" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "SecurityGroupIds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SecurityGroupIds\": ")
	if tmp, err := json.Marshal(strct.SecurityGroupIds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "SubnetIds" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "SubnetIds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SubnetIds\": ")
	if tmp, err := json.Marshal(strct.SubnetIds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *VpcConfiguration) UnmarshalJSON(b []byte) error {
    SecurityGroupIdsReceived := false
    SubnetIdsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "SecurityGroupIds":
            if err := json.Unmarshal([]byte(v), &strct.SecurityGroupIds); err != nil {
                return err
             }
            SecurityGroupIdsReceived = true
        case "SubnetIds":
            if err := json.Unmarshal([]byte(v), &strct.SubnetIds); err != nil {
                return err
             }
            SubnetIdsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if SecurityGroupIds (a required property) was received
    if !SecurityGroupIdsReceived {
        return errors.New("\"SecurityGroupIds\" is required but was not present")
    }
    // check if SubnetIds (a required property) was received
    if !SubnetIdsReceived {
        return errors.New("\"SubnetIds\" is required but was not present")
    }
    return nil
}

func (strct *ZeppelinApplicationConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CatalogConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CatalogConfiguration\": ")
	if tmp, err := json.Marshal(strct.CatalogConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CustomArtifactsConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CustomArtifactsConfiguration\": ")
	if tmp, err := json.Marshal(strct.CustomArtifactsConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DeployAsApplicationConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DeployAsApplicationConfiguration\": ")
	if tmp, err := json.Marshal(strct.DeployAsApplicationConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MonitoringConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MonitoringConfiguration\": ")
	if tmp, err := json.Marshal(strct.MonitoringConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ZeppelinApplicationConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CatalogConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.CatalogConfiguration); err != nil {
                return err
             }
        case "CustomArtifactsConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.CustomArtifactsConfiguration); err != nil {
                return err
             }
        case "DeployAsApplicationConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.DeployAsApplicationConfiguration); err != nil {
                return err
             }
        case "MonitoringConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.MonitoringConfiguration); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ZeppelinMonitoringConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "LogLevel" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LogLevel\": ")
	if tmp, err := json.Marshal(strct.LogLevel); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ZeppelinMonitoringConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "LogLevel":
            if err := json.Unmarshal([]byte(v), &strct.LogLevel); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}
