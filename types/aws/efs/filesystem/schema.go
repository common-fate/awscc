// Code generated by schema-generate. DO NOT EDIT.

package filesystem

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// BackupPolicy 
type BackupPolicy struct {
  Status string `json:"Status"`
}

// ElasticFileSystemTag 
type ElasticFileSystemTag struct {
  Key string `json:"Key"`
  Value string `json:"Value"`
}

// FileSystemPolicy 
type FileSystemPolicy struct {
}

// LifecyclePolicy 
type LifecyclePolicy struct {
  TransitionToIA string `json:"TransitionToIA,omitempty"`
  TransitionToPrimaryStorageClass string `json:"TransitionToPrimaryStorageClass,omitempty"`
}

// Resource Resource Type definition for AWS::EFS::FileSystem
type Resource struct {
  Arn string `json:"Arn,omitempty"`
  AvailabilityZoneName string `json:"AvailabilityZoneName,omitempty"`
  BackupPolicy *BackupPolicy `json:"BackupPolicy,omitempty"`

  // Whether to bypass the FileSystemPolicy lockout safety check. The policy lockout safety check determines whether the policy in the request will prevent the principal making the request to be locked out from making future PutFileSystemPolicy requests on the file system. Set BypassPolicyLockoutSafetyCheck to True only when you intend to prevent the principal that is making the request from making a subsequent PutFileSystemPolicy request on the file system. Defaults to false
  BypassPolicyLockoutSafetyCheck bool `json:"BypassPolicyLockoutSafetyCheck,omitempty"`
  Encrypted bool `json:"Encrypted,omitempty"`
  FileSystemId string `json:"FileSystemId,omitempty"`
  FileSystemPolicy *FileSystemPolicy `json:"FileSystemPolicy,omitempty"`
  FileSystemTags []*ElasticFileSystemTag `json:"FileSystemTags,omitempty"`
  KmsKeyId string `json:"KmsKeyId,omitempty"`
  LifecyclePolicies []*LifecyclePolicy `json:"LifecyclePolicies,omitempty"`
  PerformanceMode string `json:"PerformanceMode,omitempty"`
  ProvisionedThroughputInMibps float64 `json:"ProvisionedThroughputInMibps,omitempty"`
  ThroughputMode string `json:"ThroughputMode,omitempty"`
}

func (strct *BackupPolicy) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Status" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Status" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Status\": ")
	if tmp, err := json.Marshal(strct.Status); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BackupPolicy) UnmarshalJSON(b []byte) error {
    StatusReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Status":
            if err := json.Unmarshal([]byte(v), &strct.Status); err != nil {
                return err
             }
            StatusReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Status (a required property) was received
    if !StatusReceived {
        return errors.New("\"Status\" is required but was not present")
    }
    return nil
}

func (strct *ElasticFileSystemTag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ElasticFileSystemTag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *LifecyclePolicy) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "TransitionToIA" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TransitionToIA\": ")
	if tmp, err := json.Marshal(strct.TransitionToIA); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TransitionToPrimaryStorageClass" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TransitionToPrimaryStorageClass\": ")
	if tmp, err := json.Marshal(strct.TransitionToPrimaryStorageClass); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LifecyclePolicy) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "TransitionToIA":
            if err := json.Unmarshal([]byte(v), &strct.TransitionToIA); err != nil {
                return err
             }
        case "TransitionToPrimaryStorageClass":
            if err := json.Unmarshal([]byte(v), &strct.TransitionToPrimaryStorageClass); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Arn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Arn\": ")
	if tmp, err := json.Marshal(strct.Arn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AvailabilityZoneName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AvailabilityZoneName\": ")
	if tmp, err := json.Marshal(strct.AvailabilityZoneName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BackupPolicy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BackupPolicy\": ")
	if tmp, err := json.Marshal(strct.BackupPolicy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BypassPolicyLockoutSafetyCheck" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BypassPolicyLockoutSafetyCheck\": ")
	if tmp, err := json.Marshal(strct.BypassPolicyLockoutSafetyCheck); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Encrypted" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Encrypted\": ")
	if tmp, err := json.Marshal(strct.Encrypted); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FileSystemId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FileSystemId\": ")
	if tmp, err := json.Marshal(strct.FileSystemId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FileSystemPolicy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FileSystemPolicy\": ")
	if tmp, err := json.Marshal(strct.FileSystemPolicy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FileSystemTags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FileSystemTags\": ")
	if tmp, err := json.Marshal(strct.FileSystemTags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "KmsKeyId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KmsKeyId\": ")
	if tmp, err := json.Marshal(strct.KmsKeyId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LifecyclePolicies" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LifecyclePolicies\": ")
	if tmp, err := json.Marshal(strct.LifecyclePolicies); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PerformanceMode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PerformanceMode\": ")
	if tmp, err := json.Marshal(strct.PerformanceMode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ProvisionedThroughputInMibps" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ProvisionedThroughputInMibps\": ")
	if tmp, err := json.Marshal(strct.ProvisionedThroughputInMibps); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ThroughputMode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ThroughputMode\": ")
	if tmp, err := json.Marshal(strct.ThroughputMode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Arn":
            if err := json.Unmarshal([]byte(v), &strct.Arn); err != nil {
                return err
             }
        case "AvailabilityZoneName":
            if err := json.Unmarshal([]byte(v), &strct.AvailabilityZoneName); err != nil {
                return err
             }
        case "BackupPolicy":
            if err := json.Unmarshal([]byte(v), &strct.BackupPolicy); err != nil {
                return err
             }
        case "BypassPolicyLockoutSafetyCheck":
            if err := json.Unmarshal([]byte(v), &strct.BypassPolicyLockoutSafetyCheck); err != nil {
                return err
             }
        case "Encrypted":
            if err := json.Unmarshal([]byte(v), &strct.Encrypted); err != nil {
                return err
             }
        case "FileSystemId":
            if err := json.Unmarshal([]byte(v), &strct.FileSystemId); err != nil {
                return err
             }
        case "FileSystemPolicy":
            if err := json.Unmarshal([]byte(v), &strct.FileSystemPolicy); err != nil {
                return err
             }
        case "FileSystemTags":
            if err := json.Unmarshal([]byte(v), &strct.FileSystemTags); err != nil {
                return err
             }
        case "KmsKeyId":
            if err := json.Unmarshal([]byte(v), &strct.KmsKeyId); err != nil {
                return err
             }
        case "LifecyclePolicies":
            if err := json.Unmarshal([]byte(v), &strct.LifecyclePolicies); err != nil {
                return err
             }
        case "PerformanceMode":
            if err := json.Unmarshal([]byte(v), &strct.PerformanceMode); err != nil {
                return err
             }
        case "ProvisionedThroughputInMibps":
            if err := json.Unmarshal([]byte(v), &strct.ProvisionedThroughputInMibps); err != nil {
                return err
             }
        case "ThroughputMode":
            if err := json.Unmarshal([]byte(v), &strct.ThroughputMode); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}
