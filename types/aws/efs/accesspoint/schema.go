// Code generated by schema-generate. DO NOT EDIT.

package accesspoint

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// AccessPointTag 
type AccessPointTag struct {
  Key string `json:"Key,omitempty"`
  Value string `json:"Value,omitempty"`
}

// CreationInfo 
type CreationInfo struct {

  // Specifies the POSIX group ID to apply to the RootDirectory. Accepts values from 0 to 2^32 (4294967295).
  OwnerGid string `json:"OwnerGid"`

  // Specifies the POSIX user ID to apply to the RootDirectory. Accepts values from 0 to 2^32 (4294967295).
  OwnerUid string `json:"OwnerUid"`

  // Specifies the POSIX permissions to apply to the RootDirectory, in the format of an octal number representing the file's mode bits.
  Permissions string `json:"Permissions"`
}

// PosixUser 
type PosixUser struct {

  // The POSIX group ID used for all file system operations using this access point.
  Gid string `json:"Gid"`

  // Secondary POSIX group IDs used for all file system operations using this access point.
  SecondaryGids []string `json:"SecondaryGids,omitempty"`

  // The POSIX user ID used for all file system operations using this access point.
  Uid string `json:"Uid"`
}

// Resource Resource Type definition for AWS::EFS::AccessPoint
type Resource struct {
  AccessPointId string `json:"AccessPointId,omitempty"`
  AccessPointTags []*AccessPointTag `json:"AccessPointTags,omitempty"`
  Arn string `json:"Arn,omitempty"`

  // (optional) A string of up to 64 ASCII characters that Amazon EFS uses to ensure idempotent creation.
  ClientToken string `json:"ClientToken,omitempty"`

  // The ID of the EFS file system that the access point provides access to.
  FileSystemId string `json:"FileSystemId"`

  // The operating system user and group applied to all file system requests made using the access point.
  PosixUser *PosixUser `json:"PosixUser,omitempty"`

  // Specifies the directory on the Amazon EFS file system that the access point exposes as the root directory of your file system to NFS clients using the access point. The clients using the access point can only access the root directory and below. If the RootDirectory>Path specified does not exist, EFS creates it and applies the CreationInfo settings when a client connects to an access point. When specifying a RootDirectory, you need to provide the Path, and the CreationInfo is optional.
  RootDirectory *RootDirectory `json:"RootDirectory,omitempty"`
}

// RootDirectory 
type RootDirectory struct {

  // (Optional) Specifies the POSIX IDs and permissions to apply to the access point's RootDirectory. If the RootDirectory>Path specified does not exist, EFS creates the root directory using the CreationInfo settings when a client connects to an access point. When specifying the CreationInfo, you must provide values for all properties.   If you do not provide CreationInfo and the specified RootDirectory>Path does not exist, attempts to mount the file system using the access point will fail. 
  CreationInfo *CreationInfo `json:"CreationInfo,omitempty"`

  // Specifies the path on the EFS file system to expose as the root directory to NFS clients using the access point to access the EFS file system. A path can have up to four subdirectories. If the specified path does not exist, you are required to provide the CreationInfo.
  Path string `json:"Path,omitempty"`
}

func (strct *AccessPointTag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AccessPointTag) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *CreationInfo) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "OwnerGid" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "OwnerGid" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OwnerGid\": ")
	if tmp, err := json.Marshal(strct.OwnerGid); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "OwnerUid" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "OwnerUid" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OwnerUid\": ")
	if tmp, err := json.Marshal(strct.OwnerUid); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Permissions" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Permissions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Permissions\": ")
	if tmp, err := json.Marshal(strct.Permissions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CreationInfo) UnmarshalJSON(b []byte) error {
    OwnerGidReceived := false
    OwnerUidReceived := false
    PermissionsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "OwnerGid":
            if err := json.Unmarshal([]byte(v), &strct.OwnerGid); err != nil {
                return err
             }
            OwnerGidReceived = true
        case "OwnerUid":
            if err := json.Unmarshal([]byte(v), &strct.OwnerUid); err != nil {
                return err
             }
            OwnerUidReceived = true
        case "Permissions":
            if err := json.Unmarshal([]byte(v), &strct.Permissions); err != nil {
                return err
             }
            PermissionsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if OwnerGid (a required property) was received
    if !OwnerGidReceived {
        return errors.New("\"OwnerGid\" is required but was not present")
    }
    // check if OwnerUid (a required property) was received
    if !OwnerUidReceived {
        return errors.New("\"OwnerUid\" is required but was not present")
    }
    // check if Permissions (a required property) was received
    if !PermissionsReceived {
        return errors.New("\"Permissions\" is required but was not present")
    }
    return nil
}

func (strct *PosixUser) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Gid" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Gid" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Gid\": ")
	if tmp, err := json.Marshal(strct.Gid); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SecondaryGids" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SecondaryGids\": ")
	if tmp, err := json.Marshal(strct.SecondaryGids); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Uid" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Uid" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Uid\": ")
	if tmp, err := json.Marshal(strct.Uid); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PosixUser) UnmarshalJSON(b []byte) error {
    GidReceived := false
    UidReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Gid":
            if err := json.Unmarshal([]byte(v), &strct.Gid); err != nil {
                return err
             }
            GidReceived = true
        case "SecondaryGids":
            if err := json.Unmarshal([]byte(v), &strct.SecondaryGids); err != nil {
                return err
             }
        case "Uid":
            if err := json.Unmarshal([]byte(v), &strct.Uid); err != nil {
                return err
             }
            UidReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Gid (a required property) was received
    if !GidReceived {
        return errors.New("\"Gid\" is required but was not present")
    }
    // check if Uid (a required property) was received
    if !UidReceived {
        return errors.New("\"Uid\" is required but was not present")
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AccessPointId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AccessPointId\": ")
	if tmp, err := json.Marshal(strct.AccessPointId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AccessPointTags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AccessPointTags\": ")
	if tmp, err := json.Marshal(strct.AccessPointTags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Arn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Arn\": ")
	if tmp, err := json.Marshal(strct.Arn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ClientToken" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ClientToken\": ")
	if tmp, err := json.Marshal(strct.ClientToken); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "FileSystemId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "FileSystemId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FileSystemId\": ")
	if tmp, err := json.Marshal(strct.FileSystemId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PosixUser" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PosixUser\": ")
	if tmp, err := json.Marshal(strct.PosixUser); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RootDirectory" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RootDirectory\": ")
	if tmp, err := json.Marshal(strct.RootDirectory); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    FileSystemIdReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AccessPointId":
            if err := json.Unmarshal([]byte(v), &strct.AccessPointId); err != nil {
                return err
             }
        case "AccessPointTags":
            if err := json.Unmarshal([]byte(v), &strct.AccessPointTags); err != nil {
                return err
             }
        case "Arn":
            if err := json.Unmarshal([]byte(v), &strct.Arn); err != nil {
                return err
             }
        case "ClientToken":
            if err := json.Unmarshal([]byte(v), &strct.ClientToken); err != nil {
                return err
             }
        case "FileSystemId":
            if err := json.Unmarshal([]byte(v), &strct.FileSystemId); err != nil {
                return err
             }
            FileSystemIdReceived = true
        case "PosixUser":
            if err := json.Unmarshal([]byte(v), &strct.PosixUser); err != nil {
                return err
             }
        case "RootDirectory":
            if err := json.Unmarshal([]byte(v), &strct.RootDirectory); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if FileSystemId (a required property) was received
    if !FileSystemIdReceived {
        return errors.New("\"FileSystemId\" is required but was not present")
    }
    return nil
}

func (strct *RootDirectory) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CreationInfo" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CreationInfo\": ")
	if tmp, err := json.Marshal(strct.CreationInfo); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Path" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Path\": ")
	if tmp, err := json.Marshal(strct.Path); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RootDirectory) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CreationInfo":
            if err := json.Unmarshal([]byte(v), &strct.CreationInfo); err != nil {
                return err
             }
        case "Path":
            if err := json.Unmarshal([]byte(v), &strct.Path); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}
