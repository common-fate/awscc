// Code generated by schema-generate. DO NOT EDIT.

package route

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// DefaultRouteInput 
type DefaultRouteInput struct {
  ActivationState string `json:"ActivationState"`
}

// Resource Definition of AWS::RefactorSpaces::Route Resource Type
type Resource struct {
  ApplicationIdentifier string `json:"ApplicationIdentifier"`
  Arn string `json:"Arn,omitempty"`
  DefaultRoute *DefaultRouteInput `json:"DefaultRoute,omitempty"`
  EnvironmentIdentifier string `json:"EnvironmentIdentifier"`
  PathResourceToId string `json:"PathResourceToId,omitempty"`
  RouteIdentifier string `json:"RouteIdentifier,omitempty"`
  RouteType string `json:"RouteType,omitempty"`
  ServiceIdentifier string `json:"ServiceIdentifier"`

  // Metadata that you can assign to help organize the frameworks that you create. Each tag is a key-value pair.
  Tags []*Tag `json:"Tags,omitempty"`
  UriPathRoute *UriPathRouteInput `json:"UriPathRoute,omitempty"`
}

// Tag A label for tagging Environment resource
type Tag struct {

  // A string used to identify this tag
  Key string `json:"Key"`

  // A string containing the value for the tag
  Value string `json:"Value"`
}

// UriPathRouteInput 
type UriPathRouteInput struct {
  ActivationState string `json:"ActivationState"`
  IncludeChildPaths bool `json:"IncludeChildPaths,omitempty"`
  Methods []string `json:"Methods,omitempty"`
  SourcePath string `json:"SourcePath,omitempty"`
}

func (strct *DefaultRouteInput) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ActivationState" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ActivationState" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ActivationState\": ")
	if tmp, err := json.Marshal(strct.ActivationState); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DefaultRouteInput) UnmarshalJSON(b []byte) error {
    ActivationStateReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ActivationState":
            if err := json.Unmarshal([]byte(v), &strct.ActivationState); err != nil {
                return err
             }
            ActivationStateReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ActivationState (a required property) was received
    if !ActivationStateReceived {
        return errors.New("\"ActivationState\" is required but was not present")
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ApplicationIdentifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ApplicationIdentifier" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ApplicationIdentifier\": ")
	if tmp, err := json.Marshal(strct.ApplicationIdentifier); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Arn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Arn\": ")
	if tmp, err := json.Marshal(strct.Arn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DefaultRoute" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DefaultRoute\": ")
	if tmp, err := json.Marshal(strct.DefaultRoute); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "EnvironmentIdentifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "EnvironmentIdentifier" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EnvironmentIdentifier\": ")
	if tmp, err := json.Marshal(strct.EnvironmentIdentifier); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PathResourceToId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PathResourceToId\": ")
	if tmp, err := json.Marshal(strct.PathResourceToId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RouteIdentifier" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RouteIdentifier\": ")
	if tmp, err := json.Marshal(strct.RouteIdentifier); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RouteType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RouteType\": ")
	if tmp, err := json.Marshal(strct.RouteType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ServiceIdentifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ServiceIdentifier" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ServiceIdentifier\": ")
	if tmp, err := json.Marshal(strct.ServiceIdentifier); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "UriPathRoute" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UriPathRoute\": ")
	if tmp, err := json.Marshal(strct.UriPathRoute); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    ApplicationIdentifierReceived := false
    EnvironmentIdentifierReceived := false
    ServiceIdentifierReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ApplicationIdentifier":
            if err := json.Unmarshal([]byte(v), &strct.ApplicationIdentifier); err != nil {
                return err
             }
            ApplicationIdentifierReceived = true
        case "Arn":
            if err := json.Unmarshal([]byte(v), &strct.Arn); err != nil {
                return err
             }
        case "DefaultRoute":
            if err := json.Unmarshal([]byte(v), &strct.DefaultRoute); err != nil {
                return err
             }
        case "EnvironmentIdentifier":
            if err := json.Unmarshal([]byte(v), &strct.EnvironmentIdentifier); err != nil {
                return err
             }
            EnvironmentIdentifierReceived = true
        case "PathResourceToId":
            if err := json.Unmarshal([]byte(v), &strct.PathResourceToId); err != nil {
                return err
             }
        case "RouteIdentifier":
            if err := json.Unmarshal([]byte(v), &strct.RouteIdentifier); err != nil {
                return err
             }
        case "RouteType":
            if err := json.Unmarshal([]byte(v), &strct.RouteType); err != nil {
                return err
             }
        case "ServiceIdentifier":
            if err := json.Unmarshal([]byte(v), &strct.ServiceIdentifier); err != nil {
                return err
             }
            ServiceIdentifierReceived = true
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        case "UriPathRoute":
            if err := json.Unmarshal([]byte(v), &strct.UriPathRoute); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ApplicationIdentifier (a required property) was received
    if !ApplicationIdentifierReceived {
        return errors.New("\"ApplicationIdentifier\" is required but was not present")
    }
    // check if EnvironmentIdentifier (a required property) was received
    if !EnvironmentIdentifierReceived {
        return errors.New("\"EnvironmentIdentifier\" is required but was not present")
    }
    // check if ServiceIdentifier (a required property) was received
    if !ServiceIdentifierReceived {
        return errors.New("\"ServiceIdentifier\" is required but was not present")
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *UriPathRouteInput) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ActivationState" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ActivationState" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ActivationState\": ")
	if tmp, err := json.Marshal(strct.ActivationState); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IncludeChildPaths" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IncludeChildPaths\": ")
	if tmp, err := json.Marshal(strct.IncludeChildPaths); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Methods" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Methods\": ")
	if tmp, err := json.Marshal(strct.Methods); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SourcePath" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SourcePath\": ")
	if tmp, err := json.Marshal(strct.SourcePath); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *UriPathRouteInput) UnmarshalJSON(b []byte) error {
    ActivationStateReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ActivationState":
            if err := json.Unmarshal([]byte(v), &strct.ActivationState); err != nil {
                return err
             }
            ActivationStateReceived = true
        case "IncludeChildPaths":
            if err := json.Unmarshal([]byte(v), &strct.IncludeChildPaths); err != nil {
                return err
             }
        case "Methods":
            if err := json.Unmarshal([]byte(v), &strct.Methods); err != nil {
                return err
             }
        case "SourcePath":
            if err := json.Unmarshal([]byte(v), &strct.SourcePath); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ActivationState (a required property) was received
    if !ActivationStateReceived {
        return errors.New("\"ActivationState\" is required but was not present")
    }
    return nil
}
