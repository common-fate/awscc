// Code generated by schema-generate. DO NOT EDIT.

package compositealarm

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// Resource The AWS::CloudWatch::CompositeAlarm type specifies an alarm which aggregates the states of other Alarms (Metric or Composite Alarms) as defined by the AlarmRule expression
type Resource struct {

  // Indicates whether actions should be executed during any changes to the alarm state. The default is TRUE.
  ActionsEnabled bool `json:"ActionsEnabled,omitempty"`

  // Actions will be suppressed if the suppressor alarm is in the ALARM state. ActionsSuppressor can be an AlarmName or an Amazon Resource Name (ARN) from an existing alarm. 
  ActionsSuppressor string `json:"ActionsSuppressor,omitempty"`

  // Actions will be suppressed if WaitPeriod is active. The length of time that actions are suppressed is in seconds.
  ActionsSuppressorExtensionPeriod int `json:"ActionsSuppressorExtensionPeriod,omitempty"`

  // Actions will be suppressed if ExtensionPeriod is active. The length of time that actions are suppressed is in seconds.
  ActionsSuppressorWaitPeriod int `json:"ActionsSuppressorWaitPeriod,omitempty"`

  // The list of actions to execute when this alarm transitions into an ALARM state from any other state. Specify each action as an Amazon Resource Name (ARN).
  AlarmActions []string `json:"AlarmActions,omitempty"`

  // The description of the alarm
  AlarmDescription string `json:"AlarmDescription,omitempty"`

  // The name of the Composite Alarm
  AlarmName string `json:"AlarmName,omitempty"`

  // Expression which aggregates the state of other Alarms (Metric or Composite Alarms)
  AlarmRule string `json:"AlarmRule"`

  // Amazon Resource Name (ARN) of the alarm
  Arn string `json:"Arn,omitempty"`

  // The actions to execute when this alarm transitions to the INSUFFICIENT_DATA state from any other state. Each action is specified as an Amazon Resource Name (ARN).
  InsufficientDataActions []string `json:"InsufficientDataActions,omitempty"`

  // The actions to execute when this alarm transitions to the OK state from any other state. Each action is specified as an Amazon Resource Name (ARN).
  OKActions []string `json:"OKActions,omitempty"`
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ActionsEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ActionsEnabled\": ")
	if tmp, err := json.Marshal(strct.ActionsEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ActionsSuppressor" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ActionsSuppressor\": ")
	if tmp, err := json.Marshal(strct.ActionsSuppressor); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ActionsSuppressorExtensionPeriod" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ActionsSuppressorExtensionPeriod\": ")
	if tmp, err := json.Marshal(strct.ActionsSuppressorExtensionPeriod); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ActionsSuppressorWaitPeriod" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ActionsSuppressorWaitPeriod\": ")
	if tmp, err := json.Marshal(strct.ActionsSuppressorWaitPeriod); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AlarmActions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AlarmActions\": ")
	if tmp, err := json.Marshal(strct.AlarmActions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AlarmDescription" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AlarmDescription\": ")
	if tmp, err := json.Marshal(strct.AlarmDescription); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AlarmName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AlarmName\": ")
	if tmp, err := json.Marshal(strct.AlarmName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "AlarmRule" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AlarmRule" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AlarmRule\": ")
	if tmp, err := json.Marshal(strct.AlarmRule); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Arn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Arn\": ")
	if tmp, err := json.Marshal(strct.Arn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "InsufficientDataActions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InsufficientDataActions\": ")
	if tmp, err := json.Marshal(strct.InsufficientDataActions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OKActions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OKActions\": ")
	if tmp, err := json.Marshal(strct.OKActions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    AlarmRuleReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ActionsEnabled":
            if err := json.Unmarshal([]byte(v), &strct.ActionsEnabled); err != nil {
                return err
             }
        case "ActionsSuppressor":
            if err := json.Unmarshal([]byte(v), &strct.ActionsSuppressor); err != nil {
                return err
             }
        case "ActionsSuppressorExtensionPeriod":
            if err := json.Unmarshal([]byte(v), &strct.ActionsSuppressorExtensionPeriod); err != nil {
                return err
             }
        case "ActionsSuppressorWaitPeriod":
            if err := json.Unmarshal([]byte(v), &strct.ActionsSuppressorWaitPeriod); err != nil {
                return err
             }
        case "AlarmActions":
            if err := json.Unmarshal([]byte(v), &strct.AlarmActions); err != nil {
                return err
             }
        case "AlarmDescription":
            if err := json.Unmarshal([]byte(v), &strct.AlarmDescription); err != nil {
                return err
             }
        case "AlarmName":
            if err := json.Unmarshal([]byte(v), &strct.AlarmName); err != nil {
                return err
             }
        case "AlarmRule":
            if err := json.Unmarshal([]byte(v), &strct.AlarmRule); err != nil {
                return err
             }
            AlarmRuleReceived = true
        case "Arn":
            if err := json.Unmarshal([]byte(v), &strct.Arn); err != nil {
                return err
             }
        case "InsufficientDataActions":
            if err := json.Unmarshal([]byte(v), &strct.InsufficientDataActions); err != nil {
                return err
             }
        case "OKActions":
            if err := json.Unmarshal([]byte(v), &strct.OKActions); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if AlarmRule (a required property) was received
    if !AlarmRuleReceived {
        return errors.New("\"AlarmRule\" is required but was not present")
    }
    return nil
}
