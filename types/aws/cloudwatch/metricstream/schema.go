// Code generated by schema-generate. DO NOT EDIT.

package metricstream

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// MetricStreamFilter This structure defines the metrics that will be streamed.
type MetricStreamFilter struct {

  // Only metrics with Namespace matching this value will be streamed.
  Namespace string `json:"Namespace"`
}

// MetricStreamStatisticsConfiguration This structure specifies a list of additional statistics to stream, and the metrics to stream those additional statistics for. All metrics that match the combination of metric name and namespace will be streamed with the extended statistics, no matter their dimensions.
type MetricStreamStatisticsConfiguration struct {

  // The additional statistics to stream for the metrics listed in IncludeMetrics.
  AdditionalStatistics []string `json:"AdditionalStatistics"`

  // An array that defines the metrics that are to have additional statistics streamed.
  IncludeMetrics []*MetricStreamStatisticsMetric `json:"IncludeMetrics"`
}

// MetricStreamStatisticsMetric A structure that specifies the metric name and namespace for one metric that is going to have additional statistics included in the stream.
type MetricStreamStatisticsMetric struct {

  // The name of the metric.
  MetricName string `json:"MetricName"`

  // The namespace of the metric.
  Namespace string `json:"Namespace"`
}

// Resource Resource Type definition for Metric Stream
type Resource struct {

  // Amazon Resource Name of the metric stream.
  Arn string `json:"Arn,omitempty"`

  // The date of creation of the metric stream.
  CreationDate string `json:"CreationDate,omitempty"`

  // Define which metrics will be not streamed. Metrics matched by multiple instances of MetricStreamFilter are joined with an OR operation by default. If both IncludeFilters and ExcludeFilters are omitted, all metrics in the account will be streamed. IncludeFilters and ExcludeFilters are mutually exclusive. Default to null.
  ExcludeFilters []*MetricStreamFilter `json:"ExcludeFilters,omitempty"`

  // The ARN of the Kinesis Firehose where to stream the data.
  FirehoseArn string `json:"FirehoseArn"`

  // Define which metrics will be streamed. Metrics matched by multiple instances of MetricStreamFilter are joined with an OR operation by default. If both IncludeFilters and ExcludeFilters are omitted, all metrics in the account will be streamed. IncludeFilters and ExcludeFilters are mutually exclusive. Default to null.
  IncludeFilters []*MetricStreamFilter `json:"IncludeFilters,omitempty"`

  // If you are creating a metric stream in a monitoring account, specify true to include metrics from source accounts that are linked to this monitoring account, in the metric stream. The default is false.
  IncludeLinkedAccountsMetrics bool `json:"IncludeLinkedAccountsMetrics,omitempty"`

  // The date of the last update of the metric stream.
  LastUpdateDate string `json:"LastUpdateDate,omitempty"`

  // Name of the metric stream.
  Name string `json:"Name,omitempty"`

  // The output format of the data streamed to the Kinesis Firehose.
  OutputFormat string `json:"OutputFormat"`

  // The ARN of the role that provides access to the Kinesis Firehose.
  RoleArn string `json:"RoleArn"`

  // Displays the state of the Metric Stream.
  State string `json:"State,omitempty"`

  // By default, a metric stream always sends the MAX, MIN, SUM, and SAMPLECOUNT statistics for each metric that is streamed. You can use this parameter to have the metric stream also send additional statistics in the stream. This array can have up to 100 members.
  StatisticsConfigurations []*MetricStreamStatisticsConfiguration `json:"StatisticsConfigurations,omitempty"`

  // A set of tags to assign to the delivery stream.
  Tags []*Tag `json:"Tags,omitempty"`
}

// Tag Metadata that you can assign to a Metric Stream, consisting of a key-value pair.
type Tag struct {

  // A unique identifier for the tag.
  Key string `json:"Key"`

  // An optional string, which you can use to describe or define the tag.
  Value string `json:"Value,omitempty"`
}

func (strct *MetricStreamFilter) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Namespace" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Namespace" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Namespace\": ")
	if tmp, err := json.Marshal(strct.Namespace); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MetricStreamFilter) UnmarshalJSON(b []byte) error {
    NamespaceReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Namespace":
            if err := json.Unmarshal([]byte(v), &strct.Namespace); err != nil {
                return err
             }
            NamespaceReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Namespace (a required property) was received
    if !NamespaceReceived {
        return errors.New("\"Namespace\" is required but was not present")
    }
    return nil
}

func (strct *MetricStreamStatisticsConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AdditionalStatistics" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AdditionalStatistics" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AdditionalStatistics\": ")
	if tmp, err := json.Marshal(strct.AdditionalStatistics); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "IncludeMetrics" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "IncludeMetrics" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IncludeMetrics\": ")
	if tmp, err := json.Marshal(strct.IncludeMetrics); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MetricStreamStatisticsConfiguration) UnmarshalJSON(b []byte) error {
    AdditionalStatisticsReceived := false
    IncludeMetricsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AdditionalStatistics":
            if err := json.Unmarshal([]byte(v), &strct.AdditionalStatistics); err != nil {
                return err
             }
            AdditionalStatisticsReceived = true
        case "IncludeMetrics":
            if err := json.Unmarshal([]byte(v), &strct.IncludeMetrics); err != nil {
                return err
             }
            IncludeMetricsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if AdditionalStatistics (a required property) was received
    if !AdditionalStatisticsReceived {
        return errors.New("\"AdditionalStatistics\" is required but was not present")
    }
    // check if IncludeMetrics (a required property) was received
    if !IncludeMetricsReceived {
        return errors.New("\"IncludeMetrics\" is required but was not present")
    }
    return nil
}

func (strct *MetricStreamStatisticsMetric) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "MetricName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "MetricName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MetricName\": ")
	if tmp, err := json.Marshal(strct.MetricName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Namespace" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Namespace" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Namespace\": ")
	if tmp, err := json.Marshal(strct.Namespace); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MetricStreamStatisticsMetric) UnmarshalJSON(b []byte) error {
    MetricNameReceived := false
    NamespaceReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "MetricName":
            if err := json.Unmarshal([]byte(v), &strct.MetricName); err != nil {
                return err
             }
            MetricNameReceived = true
        case "Namespace":
            if err := json.Unmarshal([]byte(v), &strct.Namespace); err != nil {
                return err
             }
            NamespaceReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if MetricName (a required property) was received
    if !MetricNameReceived {
        return errors.New("\"MetricName\" is required but was not present")
    }
    // check if Namespace (a required property) was received
    if !NamespaceReceived {
        return errors.New("\"Namespace\" is required but was not present")
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Arn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Arn\": ")
	if tmp, err := json.Marshal(strct.Arn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CreationDate" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CreationDate\": ")
	if tmp, err := json.Marshal(strct.CreationDate); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ExcludeFilters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ExcludeFilters\": ")
	if tmp, err := json.Marshal(strct.ExcludeFilters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "FirehoseArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "FirehoseArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FirehoseArn\": ")
	if tmp, err := json.Marshal(strct.FirehoseArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IncludeFilters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IncludeFilters\": ")
	if tmp, err := json.Marshal(strct.IncludeFilters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IncludeLinkedAccountsMetrics" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IncludeLinkedAccountsMetrics\": ")
	if tmp, err := json.Marshal(strct.IncludeLinkedAccountsMetrics); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LastUpdateDate" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LastUpdateDate\": ")
	if tmp, err := json.Marshal(strct.LastUpdateDate); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "OutputFormat" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "OutputFormat" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OutputFormat\": ")
	if tmp, err := json.Marshal(strct.OutputFormat); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RoleArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoleArn\": ")
	if tmp, err := json.Marshal(strct.RoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "State" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"State\": ")
	if tmp, err := json.Marshal(strct.State); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StatisticsConfigurations" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StatisticsConfigurations\": ")
	if tmp, err := json.Marshal(strct.StatisticsConfigurations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    FirehoseArnReceived := false
    OutputFormatReceived := false
    RoleArnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Arn":
            if err := json.Unmarshal([]byte(v), &strct.Arn); err != nil {
                return err
             }
        case "CreationDate":
            if err := json.Unmarshal([]byte(v), &strct.CreationDate); err != nil {
                return err
             }
        case "ExcludeFilters":
            if err := json.Unmarshal([]byte(v), &strct.ExcludeFilters); err != nil {
                return err
             }
        case "FirehoseArn":
            if err := json.Unmarshal([]byte(v), &strct.FirehoseArn); err != nil {
                return err
             }
            FirehoseArnReceived = true
        case "IncludeFilters":
            if err := json.Unmarshal([]byte(v), &strct.IncludeFilters); err != nil {
                return err
             }
        case "IncludeLinkedAccountsMetrics":
            if err := json.Unmarshal([]byte(v), &strct.IncludeLinkedAccountsMetrics); err != nil {
                return err
             }
        case "LastUpdateDate":
            if err := json.Unmarshal([]byte(v), &strct.LastUpdateDate); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "OutputFormat":
            if err := json.Unmarshal([]byte(v), &strct.OutputFormat); err != nil {
                return err
             }
            OutputFormatReceived = true
        case "RoleArn":
            if err := json.Unmarshal([]byte(v), &strct.RoleArn); err != nil {
                return err
             }
            RoleArnReceived = true
        case "State":
            if err := json.Unmarshal([]byte(v), &strct.State); err != nil {
                return err
             }
        case "StatisticsConfigurations":
            if err := json.Unmarshal([]byte(v), &strct.StatisticsConfigurations); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if FirehoseArn (a required property) was received
    if !FirehoseArnReceived {
        return errors.New("\"FirehoseArn\" is required but was not present")
    }
    // check if OutputFormat (a required property) was received
    if !OutputFormatReceived {
        return errors.New("\"OutputFormat\" is required but was not present")
    }
    // check if RoleArn (a required property) was received
    if !RoleArnReceived {
        return errors.New("\"RoleArn\" is required but was not present")
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    return nil
}
