// Code generated by schema-generate. DO NOT EDIT.

package endpointaccess

import (
    "errors"
    "bytes"
    "encoding/json"
    "fmt"
)

// NetworkInterface Describes a network interface.
type NetworkInterface struct {

  // The Availability Zone.
  AvailabilityZone string `json:"AvailabilityZone,omitempty"`

  // The network interface identifier.
  NetworkInterfaceId string `json:"NetworkInterfaceId,omitempty"`

  // The IPv4 address of the network interface within the subnet.
  PrivateIpAddress string `json:"PrivateIpAddress,omitempty"`

  // The subnet identifier.
  SubnetId string `json:"SubnetId,omitempty"`
}

// Resource Resource schema for a Redshift-managed VPC endpoint.
type Resource struct {

  // The DNS address of the endpoint.
  Address string `json:"Address,omitempty"`

  // A unique identifier for the cluster. You use this identifier to refer to the cluster for any subsequent cluster operations such as deleting or modifying. All alphabetical characters must be lower case, no hypens at the end, no two consecutive hyphens. Cluster name should be unique for all clusters within an AWS account
  ClusterIdentifier string `json:"ClusterIdentifier"`

  // The time (UTC) that the endpoint was created.
  EndpointCreateTime string `json:"EndpointCreateTime,omitempty"`

  // The name of the endpoint.
  EndpointName string `json:"EndpointName"`

  // The status of the endpoint.
  EndpointStatus string `json:"EndpointStatus,omitempty"`

  // The port number on which the cluster accepts incoming connections.
  Port int `json:"Port,omitempty"`

  // The AWS account ID of the owner of the cluster.
  ResourceOwner string `json:"ResourceOwner,omitempty"`

  // The subnet group name where Amazon Redshift chooses to deploy the endpoint.
  SubnetGroupName string `json:"SubnetGroupName"`

  // The connection endpoint for connecting to an Amazon Redshift cluster through the proxy.
  VpcEndpoint *VpcEndpoint `json:"VpcEndpoint,omitempty"`

  // A list of vpc security group ids to apply to the created endpoint access.
  VpcSecurityGroupIds []string `json:"VpcSecurityGroupIds"`

  // A list of Virtual Private Cloud (VPC) security groups to be associated with the endpoint.
  VpcSecurityGroups []*VpcSecurityGroup `json:"VpcSecurityGroups,omitempty"`
}

// VpcEndpoint The connection endpoint for connecting to an Amazon Redshift cluster through the proxy.
type VpcEndpoint struct {

  // One or more network interfaces of the endpoint. Also known as an interface endpoint.
  NetworkInterfaces []*NetworkInterface `json:"NetworkInterfaces,omitempty"`

  // The connection endpoint ID for connecting an Amazon Redshift cluster through the proxy.
  VpcEndpointId string `json:"VpcEndpointId,omitempty"`

  // The VPC identifier that the endpoint is associated.
  VpcId string `json:"VpcId,omitempty"`
}

// VpcSecurityGroup Describes the members of a VPC security group.
type VpcSecurityGroup struct {

  // The status of the VPC security group.
  Status string `json:"Status,omitempty"`

  // The identifier of the VPC security group.
  VpcSecurityGroupId string `json:"VpcSecurityGroupId,omitempty"`
}

func (strct *NetworkInterface) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AvailabilityZone" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AvailabilityZone\": ")
	if tmp, err := json.Marshal(strct.AvailabilityZone); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "NetworkInterfaceId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NetworkInterfaceId\": ")
	if tmp, err := json.Marshal(strct.NetworkInterfaceId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PrivateIpAddress" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PrivateIpAddress\": ")
	if tmp, err := json.Marshal(strct.PrivateIpAddress); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SubnetId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SubnetId\": ")
	if tmp, err := json.Marshal(strct.SubnetId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *NetworkInterface) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AvailabilityZone":
            if err := json.Unmarshal([]byte(v), &strct.AvailabilityZone); err != nil {
                return err
             }
        case "NetworkInterfaceId":
            if err := json.Unmarshal([]byte(v), &strct.NetworkInterfaceId); err != nil {
                return err
             }
        case "PrivateIpAddress":
            if err := json.Unmarshal([]byte(v), &strct.PrivateIpAddress); err != nil {
                return err
             }
        case "SubnetId":
            if err := json.Unmarshal([]byte(v), &strct.SubnetId); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Address" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Address\": ")
	if tmp, err := json.Marshal(strct.Address); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ClusterIdentifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ClusterIdentifier" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ClusterIdentifier\": ")
	if tmp, err := json.Marshal(strct.ClusterIdentifier); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EndpointCreateTime" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EndpointCreateTime\": ")
	if tmp, err := json.Marshal(strct.EndpointCreateTime); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "EndpointName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "EndpointName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EndpointName\": ")
	if tmp, err := json.Marshal(strct.EndpointName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EndpointStatus" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EndpointStatus\": ")
	if tmp, err := json.Marshal(strct.EndpointStatus); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Port" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Port\": ")
	if tmp, err := json.Marshal(strct.Port); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ResourceOwner" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ResourceOwner\": ")
	if tmp, err := json.Marshal(strct.ResourceOwner); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "SubnetGroupName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "SubnetGroupName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SubnetGroupName\": ")
	if tmp, err := json.Marshal(strct.SubnetGroupName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VpcEndpoint" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VpcEndpoint\": ")
	if tmp, err := json.Marshal(strct.VpcEndpoint); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "VpcSecurityGroupIds" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "VpcSecurityGroupIds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VpcSecurityGroupIds\": ")
	if tmp, err := json.Marshal(strct.VpcSecurityGroupIds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VpcSecurityGroups" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VpcSecurityGroups\": ")
	if tmp, err := json.Marshal(strct.VpcSecurityGroups); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    ClusterIdentifierReceived := false
    EndpointNameReceived := false
    SubnetGroupNameReceived := false
    VpcSecurityGroupIdsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Address":
            if err := json.Unmarshal([]byte(v), &strct.Address); err != nil {
                return err
             }
        case "ClusterIdentifier":
            if err := json.Unmarshal([]byte(v), &strct.ClusterIdentifier); err != nil {
                return err
             }
            ClusterIdentifierReceived = true
        case "EndpointCreateTime":
            if err := json.Unmarshal([]byte(v), &strct.EndpointCreateTime); err != nil {
                return err
             }
        case "EndpointName":
            if err := json.Unmarshal([]byte(v), &strct.EndpointName); err != nil {
                return err
             }
            EndpointNameReceived = true
        case "EndpointStatus":
            if err := json.Unmarshal([]byte(v), &strct.EndpointStatus); err != nil {
                return err
             }
        case "Port":
            if err := json.Unmarshal([]byte(v), &strct.Port); err != nil {
                return err
             }
        case "ResourceOwner":
            if err := json.Unmarshal([]byte(v), &strct.ResourceOwner); err != nil {
                return err
             }
        case "SubnetGroupName":
            if err := json.Unmarshal([]byte(v), &strct.SubnetGroupName); err != nil {
                return err
             }
            SubnetGroupNameReceived = true
        case "VpcEndpoint":
            if err := json.Unmarshal([]byte(v), &strct.VpcEndpoint); err != nil {
                return err
             }
        case "VpcSecurityGroupIds":
            if err := json.Unmarshal([]byte(v), &strct.VpcSecurityGroupIds); err != nil {
                return err
             }
            VpcSecurityGroupIdsReceived = true
        case "VpcSecurityGroups":
            if err := json.Unmarshal([]byte(v), &strct.VpcSecurityGroups); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ClusterIdentifier (a required property) was received
    if !ClusterIdentifierReceived {
        return errors.New("\"ClusterIdentifier\" is required but was not present")
    }
    // check if EndpointName (a required property) was received
    if !EndpointNameReceived {
        return errors.New("\"EndpointName\" is required but was not present")
    }
    // check if SubnetGroupName (a required property) was received
    if !SubnetGroupNameReceived {
        return errors.New("\"SubnetGroupName\" is required but was not present")
    }
    // check if VpcSecurityGroupIds (a required property) was received
    if !VpcSecurityGroupIdsReceived {
        return errors.New("\"VpcSecurityGroupIds\" is required but was not present")
    }
    return nil
}

func (strct *VpcEndpoint) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "NetworkInterfaces" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NetworkInterfaces\": ")
	if tmp, err := json.Marshal(strct.NetworkInterfaces); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VpcEndpointId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VpcEndpointId\": ")
	if tmp, err := json.Marshal(strct.VpcEndpointId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VpcId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VpcId\": ")
	if tmp, err := json.Marshal(strct.VpcId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *VpcEndpoint) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "NetworkInterfaces":
            if err := json.Unmarshal([]byte(v), &strct.NetworkInterfaces); err != nil {
                return err
             }
        case "VpcEndpointId":
            if err := json.Unmarshal([]byte(v), &strct.VpcEndpointId); err != nil {
                return err
             }
        case "VpcId":
            if err := json.Unmarshal([]byte(v), &strct.VpcId); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *VpcSecurityGroup) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Status" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Status\": ")
	if tmp, err := json.Marshal(strct.Status); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VpcSecurityGroupId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VpcSecurityGroupId\": ")
	if tmp, err := json.Marshal(strct.VpcSecurityGroupId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *VpcSecurityGroup) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Status":
            if err := json.Unmarshal([]byte(v), &strct.Status); err != nil {
                return err
             }
        case "VpcSecurityGroupId":
            if err := json.Unmarshal([]byte(v), &strct.VpcSecurityGroupId); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}
