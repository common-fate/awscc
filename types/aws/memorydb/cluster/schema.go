// Code generated by schema-generate. DO NOT EDIT.

package cluster

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// DataTiering Enables data tiering. Data tiering is only supported for clusters using the r6gd node type. This parameter must be set when using r6gd nodes.
type DataTiering struct {
}

// Endpoint 
type Endpoint struct {

  // The DNS address of the primary read-write node.
  Address string `json:"Address,omitempty"`

  // The port number that the engine is listening on. 
  Port int `json:"Port,omitempty"`
}

// Resource The AWS::MemoryDB::Cluster resource creates an Amazon MemoryDB Cluster.
type Resource struct {

  // The name of the Access Control List to associate with the cluster.
  ACLName string `json:"ACLName"`

  // The Amazon Resource Name (ARN) of the cluster.
  ARN string `json:"ARN,omitempty"`

  // A flag that enables automatic minor version upgrade when set to true.
  // 
  // You cannot modify the value of AutoMinorVersionUpgrade after the cluster is created. To enable AutoMinorVersionUpgrade on a cluster you must set AutoMinorVersionUpgrade to true when you create a cluster.
  AutoMinorVersionUpgrade bool `json:"AutoMinorVersionUpgrade,omitempty"`

  // The cluster endpoint.
  ClusterEndpoint *Endpoint `json:"ClusterEndpoint,omitempty"`

  // The name of the cluster. This value must be unique as it also serves as the cluster identifier.
  ClusterName string `json:"ClusterName"`

  // Enables data tiering. Data tiering is only supported for clusters using the r6gd node type. This parameter must be set when using r6gd nodes.
  DataTiering *DataTiering `json:"DataTiering,omitempty"`

  // An optional description of the cluster.
  Description string `json:"Description,omitempty"`

  // The Redis engine version used by the cluster.
  EngineVersion string `json:"EngineVersion,omitempty"`

  // The user-supplied name of a final cluster snapshot. This is the unique name that identifies the snapshot. MemoryDB creates the snapshot, and then deletes the cluster immediately afterward.
  FinalSnapshotName string `json:"FinalSnapshotName,omitempty"`

  // The ID of the KMS key used to encrypt the cluster.
  KmsKeyId string `json:"KmsKeyId,omitempty"`

  // Specifies the weekly time range during which maintenance on the cluster is performed. It is specified as a range in the format ddd:hh24:mi-ddd:hh24:mi (24H Clock UTC). The minimum maintenance window is a 60 minute period.
  MaintenanceWindow string `json:"MaintenanceWindow,omitempty"`

  // The compute and memory capacity of the nodes in the cluster.
  NodeType string `json:"NodeType"`

  // The number of replicas to apply to each shard. The limit is 5.
  NumReplicasPerShard int `json:"NumReplicasPerShard,omitempty"`

  // The number of shards the cluster will contain.
  NumShards int `json:"NumShards,omitempty"`

  // The name of the parameter group associated with the cluster.
  ParameterGroupName string `json:"ParameterGroupName,omitempty"`

  // The status of the parameter group used by the cluster.
  ParameterGroupStatus string `json:"ParameterGroupStatus,omitempty"`

  // The port number on which each member of the cluster accepts connections.
  Port int `json:"Port,omitempty"`

  // One or more Amazon VPC security groups associated with this cluster.
  SecurityGroupIds []string `json:"SecurityGroupIds,omitempty"`

  // A list of Amazon Resource Names (ARN) that uniquely identify the RDB snapshot files stored in Amazon S3. The snapshot files are used to populate the new cluster. The Amazon S3 object name in the ARN cannot contain any commas.
  SnapshotArns []string `json:"SnapshotArns,omitempty"`

  // The name of a snapshot from which to restore data into the new cluster. The snapshot status changes to restoring while the new cluster is being created.
  SnapshotName string `json:"SnapshotName,omitempty"`

  // The number of days for which MemoryDB retains automatic snapshots before deleting them. For example, if you set SnapshotRetentionLimit to 5, a snapshot that was taken today is retained for 5 days before being deleted.
  SnapshotRetentionLimit int `json:"SnapshotRetentionLimit,omitempty"`

  // The daily time range (in UTC) during which MemoryDB begins taking a daily snapshot of your cluster.
  SnapshotWindow string `json:"SnapshotWindow,omitempty"`

  // The Amazon Resource Name (ARN) of the Amazon Simple Notification Service (SNS) topic to which notifications are sent.
  SnsTopicArn string `json:"SnsTopicArn,omitempty"`

  // The status of the Amazon SNS notification topic. Notifications are sent only if the status is enabled.
  SnsTopicStatus string `json:"SnsTopicStatus,omitempty"`

  // The status of the cluster. For example, Available, Updating, Creating.
  Status string `json:"Status,omitempty"`

  // The name of the subnet group to be used for the cluster.
  SubnetGroupName string `json:"SubnetGroupName,omitempty"`

  // A flag that enables in-transit encryption when set to true.
  // 
  // You cannot modify the value of TransitEncryptionEnabled after the cluster is created. To enable in-transit encryption on a cluster you must set TransitEncryptionEnabled to true when you create a cluster.
  TLSEnabled bool `json:"TLSEnabled,omitempty"`

  // An array of key-value pairs to apply to this cluster.
  Tags []*Tag `json:"Tags,omitempty"`
}

// Tag A key-value pair to associate with a resource.
type Tag struct {

  // The key for the tag. May not be null.
  Key string `json:"Key"`

  // The tag's value. May be null.
  Value string `json:"Value"`
}

func (strct *Endpoint) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Address" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Address\": ")
	if tmp, err := json.Marshal(strct.Address); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Port" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Port\": ")
	if tmp, err := json.Marshal(strct.Port); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Endpoint) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Address":
            if err := json.Unmarshal([]byte(v), &strct.Address); err != nil {
                return err
             }
        case "Port":
            if err := json.Unmarshal([]byte(v), &strct.Port); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ACLName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ACLName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ACLName\": ")
	if tmp, err := json.Marshal(strct.ACLName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ARN" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ARN\": ")
	if tmp, err := json.Marshal(strct.ARN); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AutoMinorVersionUpgrade" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AutoMinorVersionUpgrade\": ")
	if tmp, err := json.Marshal(strct.AutoMinorVersionUpgrade); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ClusterEndpoint" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ClusterEndpoint\": ")
	if tmp, err := json.Marshal(strct.ClusterEndpoint); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ClusterName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ClusterName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ClusterName\": ")
	if tmp, err := json.Marshal(strct.ClusterName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DataTiering" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DataTiering\": ")
	if tmp, err := json.Marshal(strct.DataTiering); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EngineVersion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EngineVersion\": ")
	if tmp, err := json.Marshal(strct.EngineVersion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FinalSnapshotName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FinalSnapshotName\": ")
	if tmp, err := json.Marshal(strct.FinalSnapshotName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "KmsKeyId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KmsKeyId\": ")
	if tmp, err := json.Marshal(strct.KmsKeyId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MaintenanceWindow" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaintenanceWindow\": ")
	if tmp, err := json.Marshal(strct.MaintenanceWindow); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "NodeType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "NodeType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NodeType\": ")
	if tmp, err := json.Marshal(strct.NodeType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "NumReplicasPerShard" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NumReplicasPerShard\": ")
	if tmp, err := json.Marshal(strct.NumReplicasPerShard); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "NumShards" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NumShards\": ")
	if tmp, err := json.Marshal(strct.NumShards); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ParameterGroupName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ParameterGroupName\": ")
	if tmp, err := json.Marshal(strct.ParameterGroupName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ParameterGroupStatus" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ParameterGroupStatus\": ")
	if tmp, err := json.Marshal(strct.ParameterGroupStatus); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Port" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Port\": ")
	if tmp, err := json.Marshal(strct.Port); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SecurityGroupIds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SecurityGroupIds\": ")
	if tmp, err := json.Marshal(strct.SecurityGroupIds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SnapshotArns" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SnapshotArns\": ")
	if tmp, err := json.Marshal(strct.SnapshotArns); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SnapshotName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SnapshotName\": ")
	if tmp, err := json.Marshal(strct.SnapshotName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SnapshotRetentionLimit" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SnapshotRetentionLimit\": ")
	if tmp, err := json.Marshal(strct.SnapshotRetentionLimit); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SnapshotWindow" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SnapshotWindow\": ")
	if tmp, err := json.Marshal(strct.SnapshotWindow); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SnsTopicArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SnsTopicArn\": ")
	if tmp, err := json.Marshal(strct.SnsTopicArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SnsTopicStatus" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SnsTopicStatus\": ")
	if tmp, err := json.Marshal(strct.SnsTopicStatus); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Status" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Status\": ")
	if tmp, err := json.Marshal(strct.Status); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SubnetGroupName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SubnetGroupName\": ")
	if tmp, err := json.Marshal(strct.SubnetGroupName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TLSEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TLSEnabled\": ")
	if tmp, err := json.Marshal(strct.TLSEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    ACLNameReceived := false
    ClusterNameReceived := false
    NodeTypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ACLName":
            if err := json.Unmarshal([]byte(v), &strct.ACLName); err != nil {
                return err
             }
            ACLNameReceived = true
        case "ARN":
            if err := json.Unmarshal([]byte(v), &strct.ARN); err != nil {
                return err
             }
        case "AutoMinorVersionUpgrade":
            if err := json.Unmarshal([]byte(v), &strct.AutoMinorVersionUpgrade); err != nil {
                return err
             }
        case "ClusterEndpoint":
            if err := json.Unmarshal([]byte(v), &strct.ClusterEndpoint); err != nil {
                return err
             }
        case "ClusterName":
            if err := json.Unmarshal([]byte(v), &strct.ClusterName); err != nil {
                return err
             }
            ClusterNameReceived = true
        case "DataTiering":
            if err := json.Unmarshal([]byte(v), &strct.DataTiering); err != nil {
                return err
             }
        case "Description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "EngineVersion":
            if err := json.Unmarshal([]byte(v), &strct.EngineVersion); err != nil {
                return err
             }
        case "FinalSnapshotName":
            if err := json.Unmarshal([]byte(v), &strct.FinalSnapshotName); err != nil {
                return err
             }
        case "KmsKeyId":
            if err := json.Unmarshal([]byte(v), &strct.KmsKeyId); err != nil {
                return err
             }
        case "MaintenanceWindow":
            if err := json.Unmarshal([]byte(v), &strct.MaintenanceWindow); err != nil {
                return err
             }
        case "NodeType":
            if err := json.Unmarshal([]byte(v), &strct.NodeType); err != nil {
                return err
             }
            NodeTypeReceived = true
        case "NumReplicasPerShard":
            if err := json.Unmarshal([]byte(v), &strct.NumReplicasPerShard); err != nil {
                return err
             }
        case "NumShards":
            if err := json.Unmarshal([]byte(v), &strct.NumShards); err != nil {
                return err
             }
        case "ParameterGroupName":
            if err := json.Unmarshal([]byte(v), &strct.ParameterGroupName); err != nil {
                return err
             }
        case "ParameterGroupStatus":
            if err := json.Unmarshal([]byte(v), &strct.ParameterGroupStatus); err != nil {
                return err
             }
        case "Port":
            if err := json.Unmarshal([]byte(v), &strct.Port); err != nil {
                return err
             }
        case "SecurityGroupIds":
            if err := json.Unmarshal([]byte(v), &strct.SecurityGroupIds); err != nil {
                return err
             }
        case "SnapshotArns":
            if err := json.Unmarshal([]byte(v), &strct.SnapshotArns); err != nil {
                return err
             }
        case "SnapshotName":
            if err := json.Unmarshal([]byte(v), &strct.SnapshotName); err != nil {
                return err
             }
        case "SnapshotRetentionLimit":
            if err := json.Unmarshal([]byte(v), &strct.SnapshotRetentionLimit); err != nil {
                return err
             }
        case "SnapshotWindow":
            if err := json.Unmarshal([]byte(v), &strct.SnapshotWindow); err != nil {
                return err
             }
        case "SnsTopicArn":
            if err := json.Unmarshal([]byte(v), &strct.SnsTopicArn); err != nil {
                return err
             }
        case "SnsTopicStatus":
            if err := json.Unmarshal([]byte(v), &strct.SnsTopicStatus); err != nil {
                return err
             }
        case "Status":
            if err := json.Unmarshal([]byte(v), &strct.Status); err != nil {
                return err
             }
        case "SubnetGroupName":
            if err := json.Unmarshal([]byte(v), &strct.SubnetGroupName); err != nil {
                return err
             }
        case "TLSEnabled":
            if err := json.Unmarshal([]byte(v), &strct.TLSEnabled); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ACLName (a required property) was received
    if !ACLNameReceived {
        return errors.New("\"ACLName\" is required but was not present")
    }
    // check if ClusterName (a required property) was received
    if !ClusterNameReceived {
        return errors.New("\"ClusterName\" is required but was not present")
    }
    // check if NodeType (a required property) was received
    if !NodeTypeReceived {
        return errors.New("\"NodeType\" is required but was not present")
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}
