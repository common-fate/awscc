// Code generated by schema-generate. DO NOT EDIT.

package tag

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// Resource A resource schema representing a Lake Formation Tag.
type Resource struct {

  // The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
  CatalogId string `json:"CatalogId,omitempty"`

  // The key-name for the LF-tag.
  TagKey string `json:"TagKey"`

  // A list of possible values an attribute can take.
  TagValues []string `json:"TagValues"`
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CatalogId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CatalogId\": ")
	if tmp, err := json.Marshal(strct.CatalogId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TagKey" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TagKey" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TagKey\": ")
	if tmp, err := json.Marshal(strct.TagKey); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TagValues" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TagValues" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TagValues\": ")
	if tmp, err := json.Marshal(strct.TagValues); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    TagKeyReceived := false
    TagValuesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CatalogId":
            if err := json.Unmarshal([]byte(v), &strct.CatalogId); err != nil {
                return err
             }
        case "TagKey":
            if err := json.Unmarshal([]byte(v), &strct.TagKey); err != nil {
                return err
             }
            TagKeyReceived = true
        case "TagValues":
            if err := json.Unmarshal([]byte(v), &strct.TagValues); err != nil {
                return err
             }
            TagValuesReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if TagKey (a required property) was received
    if !TagKeyReceived {
        return errors.New("\"TagKey\" is required but was not present")
    }
    // check if TagValues (a required property) was received
    if !TagValuesReceived {
        return errors.New("\"TagValues\" is required but was not present")
    }
    return nil
}
