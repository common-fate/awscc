// Code generated by schema-generate. DO NOT EDIT.

package instance

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// Attributes 
type Attributes struct {
  AutoResolveBestVoices bool `json:"AutoResolveBestVoices,omitempty"`
  ContactLens bool `json:"ContactLens,omitempty"`
  ContactflowLogs bool `json:"ContactflowLogs,omitempty"`
  EarlyMedia bool `json:"EarlyMedia,omitempty"`
  InboundCalls bool `json:"InboundCalls"`
  OutboundCalls bool `json:"OutboundCalls"`
  UseCustomTTSVoices bool `json:"UseCustomTTSVoices,omitempty"`
}

// Resource Resource Type definition for AWS::Connect::Instance
type Resource struct {

  // An instanceArn is automatically generated on creation based on instanceId.
  Arn string `json:"Arn,omitempty"`

  // The attributes for the instance.
  Attributes *Attributes `json:"Attributes"`

  // Timestamp of instance creation logged as part of instance creation.
  CreatedTime string `json:"CreatedTime,omitempty"`

  // Existing directoryId user wants to map to the new Connect instance.
  DirectoryId string `json:"DirectoryId,omitempty"`

  // An instanceId is automatically generated on creation and assigned as the unique identifier.
  Id string `json:"Id,omitempty"`

  // Specifies the type of directory integration for new instance.
  IdentityManagementType string `json:"IdentityManagementType"`

  // Alias of the new directory created as part of new instance creation.
  InstanceAlias string `json:"InstanceAlias,omitempty"`

  // Specifies the creation status of new instance.
  InstanceStatus string `json:"InstanceStatus,omitempty"`

  // Service linked role created as part of instance creation.
  ServiceRole string `json:"ServiceRole,omitempty"`
}

func (strct *Attributes) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AutoResolveBestVoices" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AutoResolveBestVoices\": ")
	if tmp, err := json.Marshal(strct.AutoResolveBestVoices); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ContactLens" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ContactLens\": ")
	if tmp, err := json.Marshal(strct.ContactLens); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ContactflowLogs" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ContactflowLogs\": ")
	if tmp, err := json.Marshal(strct.ContactflowLogs); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EarlyMedia" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EarlyMedia\": ")
	if tmp, err := json.Marshal(strct.EarlyMedia); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "InboundCalls" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "InboundCalls" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InboundCalls\": ")
	if tmp, err := json.Marshal(strct.InboundCalls); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "OutboundCalls" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "OutboundCalls" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OutboundCalls\": ")
	if tmp, err := json.Marshal(strct.OutboundCalls); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "UseCustomTTSVoices" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UseCustomTTSVoices\": ")
	if tmp, err := json.Marshal(strct.UseCustomTTSVoices); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Attributes) UnmarshalJSON(b []byte) error {
    InboundCallsReceived := false
    OutboundCallsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AutoResolveBestVoices":
            if err := json.Unmarshal([]byte(v), &strct.AutoResolveBestVoices); err != nil {
                return err
             }
        case "ContactLens":
            if err := json.Unmarshal([]byte(v), &strct.ContactLens); err != nil {
                return err
             }
        case "ContactflowLogs":
            if err := json.Unmarshal([]byte(v), &strct.ContactflowLogs); err != nil {
                return err
             }
        case "EarlyMedia":
            if err := json.Unmarshal([]byte(v), &strct.EarlyMedia); err != nil {
                return err
             }
        case "InboundCalls":
            if err := json.Unmarshal([]byte(v), &strct.InboundCalls); err != nil {
                return err
             }
            InboundCallsReceived = true
        case "OutboundCalls":
            if err := json.Unmarshal([]byte(v), &strct.OutboundCalls); err != nil {
                return err
             }
            OutboundCallsReceived = true
        case "UseCustomTTSVoices":
            if err := json.Unmarshal([]byte(v), &strct.UseCustomTTSVoices); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if InboundCalls (a required property) was received
    if !InboundCallsReceived {
        return errors.New("\"InboundCalls\" is required but was not present")
    }
    // check if OutboundCalls (a required property) was received
    if !OutboundCallsReceived {
        return errors.New("\"OutboundCalls\" is required but was not present")
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Arn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Arn\": ")
	if tmp, err := json.Marshal(strct.Arn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Attributes" field is required
    if strct.Attributes == nil {
        return nil, errors.New("Attributes is a required field")
    }
    // Marshal the "Attributes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Attributes\": ")
	if tmp, err := json.Marshal(strct.Attributes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CreatedTime" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CreatedTime\": ")
	if tmp, err := json.Marshal(strct.CreatedTime); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DirectoryId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DirectoryId\": ")
	if tmp, err := json.Marshal(strct.DirectoryId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Id" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "IdentityManagementType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "IdentityManagementType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IdentityManagementType\": ")
	if tmp, err := json.Marshal(strct.IdentityManagementType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "InstanceAlias" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InstanceAlias\": ")
	if tmp, err := json.Marshal(strct.InstanceAlias); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "InstanceStatus" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InstanceStatus\": ")
	if tmp, err := json.Marshal(strct.InstanceStatus); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ServiceRole" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ServiceRole\": ")
	if tmp, err := json.Marshal(strct.ServiceRole); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    AttributesReceived := false
    IdentityManagementTypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Arn":
            if err := json.Unmarshal([]byte(v), &strct.Arn); err != nil {
                return err
             }
        case "Attributes":
            if err := json.Unmarshal([]byte(v), &strct.Attributes); err != nil {
                return err
             }
            AttributesReceived = true
        case "CreatedTime":
            if err := json.Unmarshal([]byte(v), &strct.CreatedTime); err != nil {
                return err
             }
        case "DirectoryId":
            if err := json.Unmarshal([]byte(v), &strct.DirectoryId); err != nil {
                return err
             }
        case "Id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
        case "IdentityManagementType":
            if err := json.Unmarshal([]byte(v), &strct.IdentityManagementType); err != nil {
                return err
             }
            IdentityManagementTypeReceived = true
        case "InstanceAlias":
            if err := json.Unmarshal([]byte(v), &strct.InstanceAlias); err != nil {
                return err
             }
        case "InstanceStatus":
            if err := json.Unmarshal([]byte(v), &strct.InstanceStatus); err != nil {
                return err
             }
        case "ServiceRole":
            if err := json.Unmarshal([]byte(v), &strct.ServiceRole); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Attributes (a required property) was received
    if !AttributesReceived {
        return errors.New("\"Attributes\" is required but was not present")
    }
    // check if IdentityManagementType (a required property) was received
    if !IdentityManagementTypeReceived {
        return errors.New("\"IdentityManagementType\" is required but was not present")
    }
    return nil
}
