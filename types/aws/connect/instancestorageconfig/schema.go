// Code generated by schema-generate. DO NOT EDIT.

package instancestorageconfig

import (
    "encoding/json"
    "fmt"
    "errors"
    "bytes"
)

// EncryptionConfig 
type EncryptionConfig struct {
  EncryptionType string `json:"EncryptionType"`
  KeyId string `json:"KeyId"`
}

// KinesisFirehoseConfig 
type KinesisFirehoseConfig struct {
  FirehoseArn string `json:"FirehoseArn"`
}

// KinesisStreamConfig 
type KinesisStreamConfig struct {
  StreamArn string `json:"StreamArn"`
}

// KinesisVideoStreamConfig 
type KinesisVideoStreamConfig struct {
  EncryptionConfig *EncryptionConfig `json:"EncryptionConfig,omitempty"`
  Prefix string `json:"Prefix"`
  RetentionPeriodHours float64 `json:"RetentionPeriodHours"`
}

// Resource Resource Type definition for AWS::Connect::InstanceStorageConfig
type Resource struct {
  AssociationId string `json:"AssociationId,omitempty"`

  // Connect Instance ID with which the storage config will be associated
  InstanceArn string `json:"InstanceArn"`
  KinesisFirehoseConfig *KinesisFirehoseConfig `json:"KinesisFirehoseConfig,omitempty"`
  KinesisStreamConfig *KinesisStreamConfig `json:"KinesisStreamConfig,omitempty"`
  KinesisVideoStreamConfig *KinesisVideoStreamConfig `json:"KinesisVideoStreamConfig,omitempty"`
  ResourceType string `json:"ResourceType"`
  S3Config *S3Config `json:"S3Config,omitempty"`
  StorageType string `json:"StorageType"`
}

// S3Config 
type S3Config struct {
  BucketName string `json:"BucketName"`
  BucketPrefix string `json:"BucketPrefix"`
  EncryptionConfig *EncryptionConfig `json:"EncryptionConfig,omitempty"`
}

func (strct *EncryptionConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "EncryptionType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "EncryptionType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EncryptionType\": ")
	if tmp, err := json.Marshal(strct.EncryptionType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "KeyId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "KeyId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KeyId\": ")
	if tmp, err := json.Marshal(strct.KeyId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *EncryptionConfig) UnmarshalJSON(b []byte) error {
    EncryptionTypeReceived := false
    KeyIdReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "EncryptionType":
            if err := json.Unmarshal([]byte(v), &strct.EncryptionType); err != nil {
                return err
             }
            EncryptionTypeReceived = true
        case "KeyId":
            if err := json.Unmarshal([]byte(v), &strct.KeyId); err != nil {
                return err
             }
            KeyIdReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if EncryptionType (a required property) was received
    if !EncryptionTypeReceived {
        return errors.New("\"EncryptionType\" is required but was not present")
    }
    // check if KeyId (a required property) was received
    if !KeyIdReceived {
        return errors.New("\"KeyId\" is required but was not present")
    }
    return nil
}

func (strct *KinesisFirehoseConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "FirehoseArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "FirehoseArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FirehoseArn\": ")
	if tmp, err := json.Marshal(strct.FirehoseArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *KinesisFirehoseConfig) UnmarshalJSON(b []byte) error {
    FirehoseArnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "FirehoseArn":
            if err := json.Unmarshal([]byte(v), &strct.FirehoseArn); err != nil {
                return err
             }
            FirehoseArnReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if FirehoseArn (a required property) was received
    if !FirehoseArnReceived {
        return errors.New("\"FirehoseArn\" is required but was not present")
    }
    return nil
}

func (strct *KinesisStreamConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "StreamArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "StreamArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StreamArn\": ")
	if tmp, err := json.Marshal(strct.StreamArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *KinesisStreamConfig) UnmarshalJSON(b []byte) error {
    StreamArnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "StreamArn":
            if err := json.Unmarshal([]byte(v), &strct.StreamArn); err != nil {
                return err
             }
            StreamArnReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if StreamArn (a required property) was received
    if !StreamArnReceived {
        return errors.New("\"StreamArn\" is required but was not present")
    }
    return nil
}

func (strct *KinesisVideoStreamConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "EncryptionConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EncryptionConfig\": ")
	if tmp, err := json.Marshal(strct.EncryptionConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Prefix" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Prefix" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Prefix\": ")
	if tmp, err := json.Marshal(strct.Prefix); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RetentionPeriodHours" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RetentionPeriodHours" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RetentionPeriodHours\": ")
	if tmp, err := json.Marshal(strct.RetentionPeriodHours); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *KinesisVideoStreamConfig) UnmarshalJSON(b []byte) error {
    PrefixReceived := false
    RetentionPeriodHoursReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "EncryptionConfig":
            if err := json.Unmarshal([]byte(v), &strct.EncryptionConfig); err != nil {
                return err
             }
        case "Prefix":
            if err := json.Unmarshal([]byte(v), &strct.Prefix); err != nil {
                return err
             }
            PrefixReceived = true
        case "RetentionPeriodHours":
            if err := json.Unmarshal([]byte(v), &strct.RetentionPeriodHours); err != nil {
                return err
             }
            RetentionPeriodHoursReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Prefix (a required property) was received
    if !PrefixReceived {
        return errors.New("\"Prefix\" is required but was not present")
    }
    // check if RetentionPeriodHours (a required property) was received
    if !RetentionPeriodHoursReceived {
        return errors.New("\"RetentionPeriodHours\" is required but was not present")
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AssociationId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AssociationId\": ")
	if tmp, err := json.Marshal(strct.AssociationId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "InstanceArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "InstanceArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InstanceArn\": ")
	if tmp, err := json.Marshal(strct.InstanceArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "KinesisFirehoseConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KinesisFirehoseConfig\": ")
	if tmp, err := json.Marshal(strct.KinesisFirehoseConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "KinesisStreamConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KinesisStreamConfig\": ")
	if tmp, err := json.Marshal(strct.KinesisStreamConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "KinesisVideoStreamConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KinesisVideoStreamConfig\": ")
	if tmp, err := json.Marshal(strct.KinesisVideoStreamConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ResourceType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ResourceType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ResourceType\": ")
	if tmp, err := json.Marshal(strct.ResourceType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "S3Config" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3Config\": ")
	if tmp, err := json.Marshal(strct.S3Config); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "StorageType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "StorageType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StorageType\": ")
	if tmp, err := json.Marshal(strct.StorageType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    InstanceArnReceived := false
    ResourceTypeReceived := false
    StorageTypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AssociationId":
            if err := json.Unmarshal([]byte(v), &strct.AssociationId); err != nil {
                return err
             }
        case "InstanceArn":
            if err := json.Unmarshal([]byte(v), &strct.InstanceArn); err != nil {
                return err
             }
            InstanceArnReceived = true
        case "KinesisFirehoseConfig":
            if err := json.Unmarshal([]byte(v), &strct.KinesisFirehoseConfig); err != nil {
                return err
             }
        case "KinesisStreamConfig":
            if err := json.Unmarshal([]byte(v), &strct.KinesisStreamConfig); err != nil {
                return err
             }
        case "KinesisVideoStreamConfig":
            if err := json.Unmarshal([]byte(v), &strct.KinesisVideoStreamConfig); err != nil {
                return err
             }
        case "ResourceType":
            if err := json.Unmarshal([]byte(v), &strct.ResourceType); err != nil {
                return err
             }
            ResourceTypeReceived = true
        case "S3Config":
            if err := json.Unmarshal([]byte(v), &strct.S3Config); err != nil {
                return err
             }
        case "StorageType":
            if err := json.Unmarshal([]byte(v), &strct.StorageType); err != nil {
                return err
             }
            StorageTypeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if InstanceArn (a required property) was received
    if !InstanceArnReceived {
        return errors.New("\"InstanceArn\" is required but was not present")
    }
    // check if ResourceType (a required property) was received
    if !ResourceTypeReceived {
        return errors.New("\"ResourceType\" is required but was not present")
    }
    // check if StorageType (a required property) was received
    if !StorageTypeReceived {
        return errors.New("\"StorageType\" is required but was not present")
    }
    return nil
}

func (strct *S3Config) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "BucketName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "BucketName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BucketName\": ")
	if tmp, err := json.Marshal(strct.BucketName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "BucketPrefix" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "BucketPrefix" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BucketPrefix\": ")
	if tmp, err := json.Marshal(strct.BucketPrefix); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EncryptionConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EncryptionConfig\": ")
	if tmp, err := json.Marshal(strct.EncryptionConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *S3Config) UnmarshalJSON(b []byte) error {
    BucketNameReceived := false
    BucketPrefixReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BucketName":
            if err := json.Unmarshal([]byte(v), &strct.BucketName); err != nil {
                return err
             }
            BucketNameReceived = true
        case "BucketPrefix":
            if err := json.Unmarshal([]byte(v), &strct.BucketPrefix); err != nil {
                return err
             }
            BucketPrefixReceived = true
        case "EncryptionConfig":
            if err := json.Unmarshal([]byte(v), &strct.EncryptionConfig); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if BucketName (a required property) was received
    if !BucketNameReceived {
        return errors.New("\"BucketName\" is required but was not present")
    }
    // check if BucketPrefix (a required property) was received
    if !BucketPrefixReceived {
        return errors.New("\"BucketPrefix\" is required but was not present")
    }
    return nil
}
