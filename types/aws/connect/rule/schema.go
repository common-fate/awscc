// Code generated by schema-generate. DO NOT EDIT.

package rule

import (
    "fmt"
    "errors"
    "bytes"
    "encoding/json"
)

// Actions The list of actions that will be executed when a rule is triggered.
type Actions struct {
  AssignContactCategoryActions []*AssignContactCategoryAction `json:"AssignContactCategoryActions,omitempty"`
  EventBridgeActions []*EventBridgeAction `json:"EventBridgeActions,omitempty"`
  SendNotificationActions []*SendNotificationAction `json:"SendNotificationActions,omitempty"`
  TaskActions []*TaskAction `json:"TaskActions,omitempty"`
}

// AssignContactCategoryAction The definition for assigning contact category action.
type AssignContactCategoryAction struct {
}

// EventBridgeAction The definition for event bridge action.
type EventBridgeAction struct {

  // The name of the event bridge action.
  Name string `json:"Name"`
}

// NotificationRecipientType The type of notification recipient.
type NotificationRecipientType struct {

  // The list of recipients by user arns.
  UserArns []string `json:"UserArns,omitempty"`

  // The collection of recipients who are identified by user tags
  UserTags interface{} `json:"UserTags,omitempty"`
}

// Reference A contact reference.
type Reference struct {
  Type string `json:"Type"`
  Value string `json:"Value"`
}

// Resource Resource Type definition for AWS:Connect::Rule
type Resource struct {

  // The list of actions that will be executed when a rule is triggered.
  Actions *Actions `json:"Actions"`

  // The conditions of a rule.
  Function string `json:"Function"`

  // The Amazon Resource Name (ARN) of the instance.
  InstanceArn string `json:"InstanceArn"`

  // The name of the rule.
  Name string `json:"Name"`

  // The publish status of a rule, either draft or published.
  PublishStatus string `json:"PublishStatus"`

  // The Amazon Resource Name (ARN) of the rule.
  RuleArn string `json:"RuleArn,omitempty"`

  // One or more tags.
  Tags []*Tag `json:"Tags,omitempty"`

  // The event source that triggers the rule.
  TriggerEventSource *RuleTriggerEventSource `json:"TriggerEventSource"`
}

// RuleTriggerEventSource The event source that will trigger the rule.
type RuleTriggerEventSource struct {

  // The name of event source.
  EventSourceName string `json:"EventSourceName"`

  // The Amazon Resource Name (ARN) for the AppIntegration association.
  IntegrationAssociationArn string `json:"IntegrationAssociationArn,omitempty"`
}

// SendNotificationAction The definition for sending notification action.
type SendNotificationAction struct {

  // The content of notification.
  Content string `json:"Content"`

  // The type of content.
  ContentType string `json:"ContentType"`

  // The means of delivery.
  DeliveryMethod string `json:"DeliveryMethod"`
  Recipient *NotificationRecipientType `json:"Recipient"`

  // The subject of notification.
  Subject string `json:"Subject,omitempty"`
}

// Tag A key-value pair to associate with a resource.
type Tag struct {

  // The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
  Key string `json:"Key"`

  // The value for the tag. You can specify a value that's 1 to 256 characters in length.
  Value string `json:"Value"`
}

// TaskAction The definition of task action.
type TaskAction struct {

  // The Amazon Resource Name (ARN) of the contact flow.
  ContactFlowArn string `json:"ContactFlowArn"`

  // The description which appears in the agent's Contact Control Panel (CCP).
  Description string `json:"Description,omitempty"`

  // The name which appears in the agent's Contact Control Panel (CCP).
  Name string `json:"Name"`

  // A formatted URL that is shown to an agent in the Contact Control Panel (CCP).
  References interface{} `json:"References,omitempty"`
}

func (strct *Actions) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AssignContactCategoryActions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AssignContactCategoryActions\": ")
	if tmp, err := json.Marshal(strct.AssignContactCategoryActions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EventBridgeActions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EventBridgeActions\": ")
	if tmp, err := json.Marshal(strct.EventBridgeActions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SendNotificationActions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SendNotificationActions\": ")
	if tmp, err := json.Marshal(strct.SendNotificationActions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TaskActions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TaskActions\": ")
	if tmp, err := json.Marshal(strct.TaskActions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Actions) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AssignContactCategoryActions":
            if err := json.Unmarshal([]byte(v), &strct.AssignContactCategoryActions); err != nil {
                return err
             }
        case "EventBridgeActions":
            if err := json.Unmarshal([]byte(v), &strct.EventBridgeActions); err != nil {
                return err
             }
        case "SendNotificationActions":
            if err := json.Unmarshal([]byte(v), &strct.SendNotificationActions); err != nil {
                return err
             }
        case "TaskActions":
            if err := json.Unmarshal([]byte(v), &strct.TaskActions); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *EventBridgeAction) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *EventBridgeAction) UnmarshalJSON(b []byte) error {
    NameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    return nil
}

func (strct *NotificationRecipientType) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "UserArns" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UserArns\": ")
	if tmp, err := json.Marshal(strct.UserArns); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "UserTags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UserTags\": ")
	if tmp, err := json.Marshal(strct.UserTags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *NotificationRecipientType) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "UserArns":
            if err := json.Unmarshal([]byte(v), &strct.UserArns); err != nil {
                return err
             }
        case "UserTags":
            if err := json.Unmarshal([]byte(v), &strct.UserTags); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Reference) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Reference) UnmarshalJSON(b []byte) error {
    TypeReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            TypeReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Type (a required property) was received
    if !TypeReceived {
        return errors.New("\"Type\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Actions" field is required
    if strct.Actions == nil {
        return nil, errors.New("Actions is a required field")
    }
    // Marshal the "Actions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Actions\": ")
	if tmp, err := json.Marshal(strct.Actions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Function" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Function" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Function\": ")
	if tmp, err := json.Marshal(strct.Function); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "InstanceArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "InstanceArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InstanceArn\": ")
	if tmp, err := json.Marshal(strct.InstanceArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "PublishStatus" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "PublishStatus" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PublishStatus\": ")
	if tmp, err := json.Marshal(strct.PublishStatus); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RuleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RuleArn\": ")
	if tmp, err := json.Marshal(strct.RuleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TriggerEventSource" field is required
    if strct.TriggerEventSource == nil {
        return nil, errors.New("TriggerEventSource is a required field")
    }
    // Marshal the "TriggerEventSource" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TriggerEventSource\": ")
	if tmp, err := json.Marshal(strct.TriggerEventSource); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    ActionsReceived := false
    FunctionReceived := false
    InstanceArnReceived := false
    NameReceived := false
    PublishStatusReceived := false
    TriggerEventSourceReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Actions":
            if err := json.Unmarshal([]byte(v), &strct.Actions); err != nil {
                return err
             }
            ActionsReceived = true
        case "Function":
            if err := json.Unmarshal([]byte(v), &strct.Function); err != nil {
                return err
             }
            FunctionReceived = true
        case "InstanceArn":
            if err := json.Unmarshal([]byte(v), &strct.InstanceArn); err != nil {
                return err
             }
            InstanceArnReceived = true
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        case "PublishStatus":
            if err := json.Unmarshal([]byte(v), &strct.PublishStatus); err != nil {
                return err
             }
            PublishStatusReceived = true
        case "RuleArn":
            if err := json.Unmarshal([]byte(v), &strct.RuleArn); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        case "TriggerEventSource":
            if err := json.Unmarshal([]byte(v), &strct.TriggerEventSource); err != nil {
                return err
             }
            TriggerEventSourceReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Actions (a required property) was received
    if !ActionsReceived {
        return errors.New("\"Actions\" is required but was not present")
    }
    // check if Function (a required property) was received
    if !FunctionReceived {
        return errors.New("\"Function\" is required but was not present")
    }
    // check if InstanceArn (a required property) was received
    if !InstanceArnReceived {
        return errors.New("\"InstanceArn\" is required but was not present")
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    // check if PublishStatus (a required property) was received
    if !PublishStatusReceived {
        return errors.New("\"PublishStatus\" is required but was not present")
    }
    // check if TriggerEventSource (a required property) was received
    if !TriggerEventSourceReceived {
        return errors.New("\"TriggerEventSource\" is required but was not present")
    }
    return nil
}

func (strct *RuleTriggerEventSource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "EventSourceName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "EventSourceName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EventSourceName\": ")
	if tmp, err := json.Marshal(strct.EventSourceName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IntegrationAssociationArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IntegrationAssociationArn\": ")
	if tmp, err := json.Marshal(strct.IntegrationAssociationArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RuleTriggerEventSource) UnmarshalJSON(b []byte) error {
    EventSourceNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "EventSourceName":
            if err := json.Unmarshal([]byte(v), &strct.EventSourceName); err != nil {
                return err
             }
            EventSourceNameReceived = true
        case "IntegrationAssociationArn":
            if err := json.Unmarshal([]byte(v), &strct.IntegrationAssociationArn); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if EventSourceName (a required property) was received
    if !EventSourceNameReceived {
        return errors.New("\"EventSourceName\" is required but was not present")
    }
    return nil
}

func (strct *SendNotificationAction) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Content" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Content" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Content\": ")
	if tmp, err := json.Marshal(strct.Content); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ContentType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ContentType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ContentType\": ")
	if tmp, err := json.Marshal(strct.ContentType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "DeliveryMethod" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "DeliveryMethod" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DeliveryMethod\": ")
	if tmp, err := json.Marshal(strct.DeliveryMethod); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Recipient" field is required
    if strct.Recipient == nil {
        return nil, errors.New("Recipient is a required field")
    }
    // Marshal the "Recipient" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Recipient\": ")
	if tmp, err := json.Marshal(strct.Recipient); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Subject" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Subject\": ")
	if tmp, err := json.Marshal(strct.Subject); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SendNotificationAction) UnmarshalJSON(b []byte) error {
    ContentReceived := false
    ContentTypeReceived := false
    DeliveryMethodReceived := false
    RecipientReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Content":
            if err := json.Unmarshal([]byte(v), &strct.Content); err != nil {
                return err
             }
            ContentReceived = true
        case "ContentType":
            if err := json.Unmarshal([]byte(v), &strct.ContentType); err != nil {
                return err
             }
            ContentTypeReceived = true
        case "DeliveryMethod":
            if err := json.Unmarshal([]byte(v), &strct.DeliveryMethod); err != nil {
                return err
             }
            DeliveryMethodReceived = true
        case "Recipient":
            if err := json.Unmarshal([]byte(v), &strct.Recipient); err != nil {
                return err
             }
            RecipientReceived = true
        case "Subject":
            if err := json.Unmarshal([]byte(v), &strct.Subject); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Content (a required property) was received
    if !ContentReceived {
        return errors.New("\"Content\" is required but was not present")
    }
    // check if ContentType (a required property) was received
    if !ContentTypeReceived {
        return errors.New("\"ContentType\" is required but was not present")
    }
    // check if DeliveryMethod (a required property) was received
    if !DeliveryMethodReceived {
        return errors.New("\"DeliveryMethod\" is required but was not present")
    }
    // check if Recipient (a required property) was received
    if !RecipientReceived {
        return errors.New("\"Recipient\" is required but was not present")
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *TaskAction) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ContactFlowArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ContactFlowArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ContactFlowArn\": ")
	if tmp, err := json.Marshal(strct.ContactFlowArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "References" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"References\": ")
	if tmp, err := json.Marshal(strct.References); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TaskAction) UnmarshalJSON(b []byte) error {
    ContactFlowArnReceived := false
    NameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ContactFlowArn":
            if err := json.Unmarshal([]byte(v), &strct.ContactFlowArn); err != nil {
                return err
             }
            ContactFlowArnReceived = true
        case "Description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        case "References":
            if err := json.Unmarshal([]byte(v), &strct.References); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ContactFlowArn (a required property) was received
    if !ContactFlowArnReceived {
        return errors.New("\"ContactFlowArn\" is required but was not present")
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    return nil
}
