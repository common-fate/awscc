// Code generated by schema-generate. DO NOT EDIT.

package flowoutput

import (
    "errors"
    "bytes"
    "encoding/json"
    "fmt"
)

// Encryption Information about the encryption of the flow.
type Encryption struct {

  // The type of algorithm that is used for the encryption (such as aes128, aes192, or aes256).
  Algorithm string `json:"Algorithm,omitempty"`

  // The type of key that is used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
  KeyType string `json:"KeyType,omitempty"`

  // The ARN of the role that you created during setup (when you set up AWS Elemental MediaConnect as a trusted entity).
  RoleArn string `json:"RoleArn"`

  //  The ARN of the secret that you created in AWS Secrets Manager to store the encryption key. This parameter is required for static key encryption and is not valid for SPEKE encryption.
  SecretArn string `json:"SecretArn"`
}

// Resource Resource schema for AWS::MediaConnect::FlowOutput
type Resource struct {

  // The range of IP addresses that should be allowed to initiate output requests to this flow. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
  CidrAllowList []string `json:"CidrAllowList,omitempty"`

  // A description of the output.
  Description string `json:"Description,omitempty"`

  // The address where you want to send the output.
  Destination string `json:"Destination,omitempty"`

  // The type of key used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
  Encryption *Encryption `json:"Encryption,omitempty"`

  // The Amazon Resource Name (ARN), a unique identifier for any AWS resource, of the flow.
  FlowArn string `json:"FlowArn"`

  // The maximum latency in milliseconds. This parameter applies only to RIST-based and Zixi-based streams.
  MaxLatency int `json:"MaxLatency,omitempty"`

  // The minimum latency in milliseconds.
  MinLatency int `json:"MinLatency,omitempty"`

  // The name of the output. This value must be unique within the current flow.
  Name string `json:"Name,omitempty"`

  // The ARN of the output.
  OutputArn string `json:"OutputArn,omitempty"`

  // The port to use when content is distributed to this output.
  Port int `json:"Port,omitempty"`

  // The protocol that is used by the source or output.
  Protocol string `json:"Protocol"`

  // The remote ID for the Zixi-pull stream.
  RemoteId string `json:"RemoteId,omitempty"`

  // The smoothing latency in milliseconds for RIST, RTP, and RTP-FEC streams.
  SmoothingLatency int `json:"SmoothingLatency,omitempty"`

  // The stream ID that you want to use for this transport. This parameter applies only to Zixi-based streams.
  StreamId string `json:"StreamId,omitempty"`

  // The name of the VPC interface attachment to use for this output.
  VpcInterfaceAttachment *VpcInterfaceAttachment `json:"VpcInterfaceAttachment,omitempty"`
}

// VpcInterfaceAttachment The settings for attaching a VPC interface to an output.
type VpcInterfaceAttachment struct {

  // The name of the VPC interface to use for this output.
  VpcInterfaceName string `json:"VpcInterfaceName,omitempty"`
}

func (strct *Encryption) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Algorithm" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Algorithm\": ")
	if tmp, err := json.Marshal(strct.Algorithm); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "KeyType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KeyType\": ")
	if tmp, err := json.Marshal(strct.KeyType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RoleArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoleArn\": ")
	if tmp, err := json.Marshal(strct.RoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "SecretArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "SecretArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SecretArn\": ")
	if tmp, err := json.Marshal(strct.SecretArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Encryption) UnmarshalJSON(b []byte) error {
    RoleArnReceived := false
    SecretArnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Algorithm":
            if err := json.Unmarshal([]byte(v), &strct.Algorithm); err != nil {
                return err
             }
        case "KeyType":
            if err := json.Unmarshal([]byte(v), &strct.KeyType); err != nil {
                return err
             }
        case "RoleArn":
            if err := json.Unmarshal([]byte(v), &strct.RoleArn); err != nil {
                return err
             }
            RoleArnReceived = true
        case "SecretArn":
            if err := json.Unmarshal([]byte(v), &strct.SecretArn); err != nil {
                return err
             }
            SecretArnReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if RoleArn (a required property) was received
    if !RoleArnReceived {
        return errors.New("\"RoleArn\" is required but was not present")
    }
    // check if SecretArn (a required property) was received
    if !SecretArnReceived {
        return errors.New("\"SecretArn\" is required but was not present")
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CidrAllowList" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CidrAllowList\": ")
	if tmp, err := json.Marshal(strct.CidrAllowList); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Destination" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Destination\": ")
	if tmp, err := json.Marshal(strct.Destination); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Encryption" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Encryption\": ")
	if tmp, err := json.Marshal(strct.Encryption); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "FlowArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "FlowArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FlowArn\": ")
	if tmp, err := json.Marshal(strct.FlowArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MaxLatency" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaxLatency\": ")
	if tmp, err := json.Marshal(strct.MaxLatency); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MinLatency" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MinLatency\": ")
	if tmp, err := json.Marshal(strct.MinLatency); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OutputArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OutputArn\": ")
	if tmp, err := json.Marshal(strct.OutputArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Port" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Port\": ")
	if tmp, err := json.Marshal(strct.Port); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Protocol" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Protocol" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Protocol\": ")
	if tmp, err := json.Marshal(strct.Protocol); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RemoteId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RemoteId\": ")
	if tmp, err := json.Marshal(strct.RemoteId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SmoothingLatency" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SmoothingLatency\": ")
	if tmp, err := json.Marshal(strct.SmoothingLatency); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StreamId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StreamId\": ")
	if tmp, err := json.Marshal(strct.StreamId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VpcInterfaceAttachment" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VpcInterfaceAttachment\": ")
	if tmp, err := json.Marshal(strct.VpcInterfaceAttachment); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    FlowArnReceived := false
    ProtocolReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CidrAllowList":
            if err := json.Unmarshal([]byte(v), &strct.CidrAllowList); err != nil {
                return err
             }
        case "Description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "Destination":
            if err := json.Unmarshal([]byte(v), &strct.Destination); err != nil {
                return err
             }
        case "Encryption":
            if err := json.Unmarshal([]byte(v), &strct.Encryption); err != nil {
                return err
             }
        case "FlowArn":
            if err := json.Unmarshal([]byte(v), &strct.FlowArn); err != nil {
                return err
             }
            FlowArnReceived = true
        case "MaxLatency":
            if err := json.Unmarshal([]byte(v), &strct.MaxLatency); err != nil {
                return err
             }
        case "MinLatency":
            if err := json.Unmarshal([]byte(v), &strct.MinLatency); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "OutputArn":
            if err := json.Unmarshal([]byte(v), &strct.OutputArn); err != nil {
                return err
             }
        case "Port":
            if err := json.Unmarshal([]byte(v), &strct.Port); err != nil {
                return err
             }
        case "Protocol":
            if err := json.Unmarshal([]byte(v), &strct.Protocol); err != nil {
                return err
             }
            ProtocolReceived = true
        case "RemoteId":
            if err := json.Unmarshal([]byte(v), &strct.RemoteId); err != nil {
                return err
             }
        case "SmoothingLatency":
            if err := json.Unmarshal([]byte(v), &strct.SmoothingLatency); err != nil {
                return err
             }
        case "StreamId":
            if err := json.Unmarshal([]byte(v), &strct.StreamId); err != nil {
                return err
             }
        case "VpcInterfaceAttachment":
            if err := json.Unmarshal([]byte(v), &strct.VpcInterfaceAttachment); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if FlowArn (a required property) was received
    if !FlowArnReceived {
        return errors.New("\"FlowArn\" is required but was not present")
    }
    // check if Protocol (a required property) was received
    if !ProtocolReceived {
        return errors.New("\"Protocol\" is required but was not present")
    }
    return nil
}

func (strct *VpcInterfaceAttachment) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "VpcInterfaceName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VpcInterfaceName\": ")
	if tmp, err := json.Marshal(strct.VpcInterfaceName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *VpcInterfaceAttachment) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "VpcInterfaceName":
            if err := json.Unmarshal([]byte(v), &strct.VpcInterfaceName); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}
