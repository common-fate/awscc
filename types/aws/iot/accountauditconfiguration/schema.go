// Code generated by schema-generate. DO NOT EDIT.

package accountauditconfiguration

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// AuditCheckConfiguration The configuration for a specific audit check.
type AuditCheckConfiguration struct {

  // True if the check is enabled.
  Enabled bool `json:"Enabled,omitempty"`
}

// AuditCheckConfigurations Specifies which audit checks are enabled and disabled for this account.
type AuditCheckConfigurations struct {
  AuthenticatedCognitoRoleOverlyPermissiveCheck *AuditCheckConfiguration `json:"AuthenticatedCognitoRoleOverlyPermissiveCheck,omitempty"`
  CaCertificateExpiringCheck *AuditCheckConfiguration `json:"CaCertificateExpiringCheck,omitempty"`
  CaCertificateKeyQualityCheck *AuditCheckConfiguration `json:"CaCertificateKeyQualityCheck,omitempty"`
  ConflictingClientIdsCheck *AuditCheckConfiguration `json:"ConflictingClientIdsCheck,omitempty"`
  DeviceCertificateExpiringCheck *AuditCheckConfiguration `json:"DeviceCertificateExpiringCheck,omitempty"`
  DeviceCertificateKeyQualityCheck *AuditCheckConfiguration `json:"DeviceCertificateKeyQualityCheck,omitempty"`
  DeviceCertificateSharedCheck *AuditCheckConfiguration `json:"DeviceCertificateSharedCheck,omitempty"`
  IntermediateCaRevokedForActiveDeviceCertificatesCheck *AuditCheckConfiguration `json:"IntermediateCaRevokedForActiveDeviceCertificatesCheck,omitempty"`
  IoTPolicyPotentialMisConfigurationCheck *AuditCheckConfiguration `json:"IoTPolicyPotentialMisConfigurationCheck,omitempty"`
  IotPolicyOverlyPermissiveCheck *AuditCheckConfiguration `json:"IotPolicyOverlyPermissiveCheck,omitempty"`
  IotRoleAliasAllowsAccessToUnusedServicesCheck *AuditCheckConfiguration `json:"IotRoleAliasAllowsAccessToUnusedServicesCheck,omitempty"`
  IotRoleAliasOverlyPermissiveCheck *AuditCheckConfiguration `json:"IotRoleAliasOverlyPermissiveCheck,omitempty"`
  LoggingDisabledCheck *AuditCheckConfiguration `json:"LoggingDisabledCheck,omitempty"`
  RevokedCaCertificateStillActiveCheck *AuditCheckConfiguration `json:"RevokedCaCertificateStillActiveCheck,omitempty"`
  RevokedDeviceCertificateStillActiveCheck *AuditCheckConfiguration `json:"RevokedDeviceCertificateStillActiveCheck,omitempty"`
  UnauthenticatedCognitoRoleOverlyPermissiveCheck *AuditCheckConfiguration `json:"UnauthenticatedCognitoRoleOverlyPermissiveCheck,omitempty"`
}

// AuditNotificationTarget 
type AuditNotificationTarget struct {

  // True if notifications to the target are enabled.
  Enabled bool `json:"Enabled,omitempty"`

  // The ARN of the role that grants permission to send notifications to the target.
  RoleArn string `json:"RoleArn,omitempty"`

  // The ARN of the target (SNS topic) to which audit notifications are sent.
  TargetArn string `json:"TargetArn,omitempty"`
}

// AuditNotificationTargetConfigurations Information about the targets to which audit notifications are sent.
type AuditNotificationTargetConfigurations struct {
  Sns *AuditNotificationTarget `json:"Sns,omitempty"`
}

// Resource Configures the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.
type Resource struct {

  // Your 12-digit account ID (used as the primary identifier for the CloudFormation resource).
  AccountId string `json:"AccountId"`
  AuditCheckConfigurations *AuditCheckConfigurations `json:"AuditCheckConfigurations"`
  AuditNotificationTargetConfigurations *AuditNotificationTargetConfigurations `json:"AuditNotificationTargetConfigurations,omitempty"`

  // The ARN of the role that grants permission to AWS IoT to access information about your devices, policies, certificates and other items as required when performing an audit.
  RoleArn string `json:"RoleArn"`
}

func (strct *AuditCheckConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Enabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AuditCheckConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Enabled":
            if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *AuditCheckConfigurations) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AuthenticatedCognitoRoleOverlyPermissiveCheck" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AuthenticatedCognitoRoleOverlyPermissiveCheck\": ")
	if tmp, err := json.Marshal(strct.AuthenticatedCognitoRoleOverlyPermissiveCheck); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CaCertificateExpiringCheck" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CaCertificateExpiringCheck\": ")
	if tmp, err := json.Marshal(strct.CaCertificateExpiringCheck); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CaCertificateKeyQualityCheck" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CaCertificateKeyQualityCheck\": ")
	if tmp, err := json.Marshal(strct.CaCertificateKeyQualityCheck); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ConflictingClientIdsCheck" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConflictingClientIdsCheck\": ")
	if tmp, err := json.Marshal(strct.ConflictingClientIdsCheck); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DeviceCertificateExpiringCheck" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DeviceCertificateExpiringCheck\": ")
	if tmp, err := json.Marshal(strct.DeviceCertificateExpiringCheck); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DeviceCertificateKeyQualityCheck" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DeviceCertificateKeyQualityCheck\": ")
	if tmp, err := json.Marshal(strct.DeviceCertificateKeyQualityCheck); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DeviceCertificateSharedCheck" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DeviceCertificateSharedCheck\": ")
	if tmp, err := json.Marshal(strct.DeviceCertificateSharedCheck); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IntermediateCaRevokedForActiveDeviceCertificatesCheck" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IntermediateCaRevokedForActiveDeviceCertificatesCheck\": ")
	if tmp, err := json.Marshal(strct.IntermediateCaRevokedForActiveDeviceCertificatesCheck); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IoTPolicyPotentialMisConfigurationCheck" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IoTPolicyPotentialMisConfigurationCheck\": ")
	if tmp, err := json.Marshal(strct.IoTPolicyPotentialMisConfigurationCheck); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IotPolicyOverlyPermissiveCheck" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IotPolicyOverlyPermissiveCheck\": ")
	if tmp, err := json.Marshal(strct.IotPolicyOverlyPermissiveCheck); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IotRoleAliasAllowsAccessToUnusedServicesCheck" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IotRoleAliasAllowsAccessToUnusedServicesCheck\": ")
	if tmp, err := json.Marshal(strct.IotRoleAliasAllowsAccessToUnusedServicesCheck); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IotRoleAliasOverlyPermissiveCheck" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IotRoleAliasOverlyPermissiveCheck\": ")
	if tmp, err := json.Marshal(strct.IotRoleAliasOverlyPermissiveCheck); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LoggingDisabledCheck" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LoggingDisabledCheck\": ")
	if tmp, err := json.Marshal(strct.LoggingDisabledCheck); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RevokedCaCertificateStillActiveCheck" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RevokedCaCertificateStillActiveCheck\": ")
	if tmp, err := json.Marshal(strct.RevokedCaCertificateStillActiveCheck); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RevokedDeviceCertificateStillActiveCheck" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RevokedDeviceCertificateStillActiveCheck\": ")
	if tmp, err := json.Marshal(strct.RevokedDeviceCertificateStillActiveCheck); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "UnauthenticatedCognitoRoleOverlyPermissiveCheck" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UnauthenticatedCognitoRoleOverlyPermissiveCheck\": ")
	if tmp, err := json.Marshal(strct.UnauthenticatedCognitoRoleOverlyPermissiveCheck); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AuditCheckConfigurations) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AuthenticatedCognitoRoleOverlyPermissiveCheck":
            if err := json.Unmarshal([]byte(v), &strct.AuthenticatedCognitoRoleOverlyPermissiveCheck); err != nil {
                return err
             }
        case "CaCertificateExpiringCheck":
            if err := json.Unmarshal([]byte(v), &strct.CaCertificateExpiringCheck); err != nil {
                return err
             }
        case "CaCertificateKeyQualityCheck":
            if err := json.Unmarshal([]byte(v), &strct.CaCertificateKeyQualityCheck); err != nil {
                return err
             }
        case "ConflictingClientIdsCheck":
            if err := json.Unmarshal([]byte(v), &strct.ConflictingClientIdsCheck); err != nil {
                return err
             }
        case "DeviceCertificateExpiringCheck":
            if err := json.Unmarshal([]byte(v), &strct.DeviceCertificateExpiringCheck); err != nil {
                return err
             }
        case "DeviceCertificateKeyQualityCheck":
            if err := json.Unmarshal([]byte(v), &strct.DeviceCertificateKeyQualityCheck); err != nil {
                return err
             }
        case "DeviceCertificateSharedCheck":
            if err := json.Unmarshal([]byte(v), &strct.DeviceCertificateSharedCheck); err != nil {
                return err
             }
        case "IntermediateCaRevokedForActiveDeviceCertificatesCheck":
            if err := json.Unmarshal([]byte(v), &strct.IntermediateCaRevokedForActiveDeviceCertificatesCheck); err != nil {
                return err
             }
        case "IoTPolicyPotentialMisConfigurationCheck":
            if err := json.Unmarshal([]byte(v), &strct.IoTPolicyPotentialMisConfigurationCheck); err != nil {
                return err
             }
        case "IotPolicyOverlyPermissiveCheck":
            if err := json.Unmarshal([]byte(v), &strct.IotPolicyOverlyPermissiveCheck); err != nil {
                return err
             }
        case "IotRoleAliasAllowsAccessToUnusedServicesCheck":
            if err := json.Unmarshal([]byte(v), &strct.IotRoleAliasAllowsAccessToUnusedServicesCheck); err != nil {
                return err
             }
        case "IotRoleAliasOverlyPermissiveCheck":
            if err := json.Unmarshal([]byte(v), &strct.IotRoleAliasOverlyPermissiveCheck); err != nil {
                return err
             }
        case "LoggingDisabledCheck":
            if err := json.Unmarshal([]byte(v), &strct.LoggingDisabledCheck); err != nil {
                return err
             }
        case "RevokedCaCertificateStillActiveCheck":
            if err := json.Unmarshal([]byte(v), &strct.RevokedCaCertificateStillActiveCheck); err != nil {
                return err
             }
        case "RevokedDeviceCertificateStillActiveCheck":
            if err := json.Unmarshal([]byte(v), &strct.RevokedDeviceCertificateStillActiveCheck); err != nil {
                return err
             }
        case "UnauthenticatedCognitoRoleOverlyPermissiveCheck":
            if err := json.Unmarshal([]byte(v), &strct.UnauthenticatedCognitoRoleOverlyPermissiveCheck); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *AuditNotificationTarget) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Enabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoleArn\": ")
	if tmp, err := json.Marshal(strct.RoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TargetArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TargetArn\": ")
	if tmp, err := json.Marshal(strct.TargetArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AuditNotificationTarget) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Enabled":
            if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
                return err
             }
        case "RoleArn":
            if err := json.Unmarshal([]byte(v), &strct.RoleArn); err != nil {
                return err
             }
        case "TargetArn":
            if err := json.Unmarshal([]byte(v), &strct.TargetArn); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *AuditNotificationTargetConfigurations) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Sns" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Sns\": ")
	if tmp, err := json.Marshal(strct.Sns); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AuditNotificationTargetConfigurations) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Sns":
            if err := json.Unmarshal([]byte(v), &strct.Sns); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AccountId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AccountId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AccountId\": ")
	if tmp, err := json.Marshal(strct.AccountId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "AuditCheckConfigurations" field is required
    if strct.AuditCheckConfigurations == nil {
        return nil, errors.New("AuditCheckConfigurations is a required field")
    }
    // Marshal the "AuditCheckConfigurations" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AuditCheckConfigurations\": ")
	if tmp, err := json.Marshal(strct.AuditCheckConfigurations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AuditNotificationTargetConfigurations" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AuditNotificationTargetConfigurations\": ")
	if tmp, err := json.Marshal(strct.AuditNotificationTargetConfigurations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RoleArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoleArn\": ")
	if tmp, err := json.Marshal(strct.RoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    AccountIdReceived := false
    AuditCheckConfigurationsReceived := false
    RoleArnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AccountId":
            if err := json.Unmarshal([]byte(v), &strct.AccountId); err != nil {
                return err
             }
            AccountIdReceived = true
        case "AuditCheckConfigurations":
            if err := json.Unmarshal([]byte(v), &strct.AuditCheckConfigurations); err != nil {
                return err
             }
            AuditCheckConfigurationsReceived = true
        case "AuditNotificationTargetConfigurations":
            if err := json.Unmarshal([]byte(v), &strct.AuditNotificationTargetConfigurations); err != nil {
                return err
             }
        case "RoleArn":
            if err := json.Unmarshal([]byte(v), &strct.RoleArn); err != nil {
                return err
             }
            RoleArnReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if AccountId (a required property) was received
    if !AccountIdReceived {
        return errors.New("\"AccountId\" is required but was not present")
    }
    // check if AuditCheckConfigurations (a required property) was received
    if !AuditCheckConfigurationsReceived {
        return errors.New("\"AuditCheckConfigurations\" is required but was not present")
    }
    // check if RoleArn (a required property) was received
    if !RoleArnReceived {
        return errors.New("\"RoleArn\" is required but was not present")
    }
    return nil
}
