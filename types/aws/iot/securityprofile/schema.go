// Code generated by schema-generate. DO NOT EDIT.

package securityprofile

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// AlertTarget A structure containing the alert target ARN and the role ARN.
type AlertTarget struct {

  // The ARN of the notification target to which alerts are sent.
  AlertTargetArn string `json:"AlertTargetArn"`

  // The ARN of the role that grants permission to send alerts to the notification target.
  RoleArn string `json:"RoleArn"`
}

// AlertTargets Specifies the destinations to which alerts are sent.
type AlertTargets struct {
}

// Behavior A security profile behavior.
type Behavior struct {
  Criteria *BehaviorCriteria `json:"Criteria,omitempty"`

  // What is measured by the behavior.
  Metric string `json:"Metric,omitempty"`
  MetricDimension *MetricDimension `json:"MetricDimension,omitempty"`

  // The name for the behavior.
  Name string `json:"Name"`

  // Manage Detect alarm SNS notifications by setting behavior notification to on or suppressed. Detect will continue to performing device behavior evaluations. However, suppressed alarms wouldn't be forwarded for SNS notification.
  SuppressAlerts bool `json:"SuppressAlerts,omitempty"`
}

// BehaviorCriteria The criteria by which the behavior is determined to be normal.
type BehaviorCriteria struct {

  // The operator that relates the thing measured (metric) to the criteria (containing a value or statisticalThreshold).
  ComparisonOperator string `json:"ComparisonOperator,omitempty"`

  // If a device is in violation of the behavior for the specified number of consecutive datapoints, an alarm occurs. If not specified, the default is 1.
  ConsecutiveDatapointsToAlarm int `json:"ConsecutiveDatapointsToAlarm,omitempty"`

  // If an alarm has occurred and the offending device is no longer in violation of the behavior for the specified number of consecutive datapoints, the alarm is cleared. If not specified, the default is 1.
  ConsecutiveDatapointsToClear int `json:"ConsecutiveDatapointsToClear,omitempty"`

  // Use this to specify the time duration over which the behavior is evaluated.
  DurationSeconds int `json:"DurationSeconds,omitempty"`
  MlDetectionConfig *MachineLearningDetectionConfig `json:"MlDetectionConfig,omitempty"`
  StatisticalThreshold *StatisticalThreshold `json:"StatisticalThreshold,omitempty"`
  Value *MetricValue `json:"Value,omitempty"`
}

// MachineLearningDetectionConfig The configuration of an ML Detect Security Profile.
type MachineLearningDetectionConfig struct {

  // The sensitivity of anomalous behavior evaluation. Can be Low, Medium, or High.
  ConfidenceLevel string `json:"ConfidenceLevel,omitempty"`
}

// MetricDimension The dimension of a metric.
type MetricDimension struct {

  // A unique identifier for the dimension.
  DimensionName string `json:"DimensionName"`

  // Defines how the dimensionValues of a dimension are interpreted.
  Operator string `json:"Operator,omitempty"`
}

// MetricToRetain The metric you want to retain. Dimensions are optional.
type MetricToRetain struct {

  // What is measured by the behavior.
  Metric string `json:"Metric"`
  MetricDimension *MetricDimension `json:"MetricDimension,omitempty"`
}

// MetricValue The value to be compared with the metric.
type MetricValue struct {

  // If the ComparisonOperator calls for a set of CIDRs, use this to specify that set to be compared with the metric.
  Cidrs []string `json:"Cidrs,omitempty"`

  // If the ComparisonOperator calls for a numeric value, use this to specify that (integer) numeric value to be compared with the metric.
  Count string `json:"Count,omitempty"`

  // The numeral value of a metric.
  Number float64 `json:"Number,omitempty"`

  // The numeral values of a metric.
  Numbers []float64 `json:"Numbers,omitempty"`

  // If the ComparisonOperator calls for a set of ports, use this to specify that set to be compared with the metric.
  Ports []int `json:"Ports,omitempty"`

  // The string values of a metric.
  Strings []string `json:"Strings,omitempty"`
}

// Resource A security profile defines a set of expected behaviors for devices in your account.
type Resource struct {

  // A list of metrics whose data is retained (stored). By default, data is retained for any metric used in the profile's behaviors, but it is also retained for any metric specified here.
  AdditionalMetricsToRetainV2 []*MetricToRetain `json:"AdditionalMetricsToRetainV2,omitempty"`

  // Specifies the destinations to which alerts are sent.
  AlertTargets *AlertTargets `json:"AlertTargets,omitempty"`

  // Specifies the behaviors that, when violated by a device (thing), cause an alert.
  Behaviors []*Behavior `json:"Behaviors,omitempty"`

  // The ARN (Amazon resource name) of the created security profile.
  SecurityProfileArn string `json:"SecurityProfileArn,omitempty"`

  // A description of the security profile.
  SecurityProfileDescription string `json:"SecurityProfileDescription,omitempty"`

  // A unique identifier for the security profile.
  SecurityProfileName string `json:"SecurityProfileName,omitempty"`

  // Metadata that can be used to manage the security profile.
  Tags []*Tag `json:"Tags,omitempty"`

  // A set of target ARNs that the security profile is attached to.
  TargetArns []string `json:"TargetArns,omitempty"`
}

// StatisticalThreshold A statistical ranking (percentile) which indicates a threshold value by which a behavior is determined to be in compliance or in violation of the behavior.
type StatisticalThreshold struct {

  // The percentile which resolves to a threshold value by which compliance with a behavior is determined
  Statistic string `json:"Statistic,omitempty"`
}

// Tag A key-value pair to associate with a resource.
type Tag struct {

  // The tag's key.
  Key string `json:"Key"`

  // The tag's value.
  Value string `json:"Value"`
}

func (strct *AlertTarget) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AlertTargetArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AlertTargetArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AlertTargetArn\": ")
	if tmp, err := json.Marshal(strct.AlertTargetArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RoleArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoleArn\": ")
	if tmp, err := json.Marshal(strct.RoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AlertTarget) UnmarshalJSON(b []byte) error {
    AlertTargetArnReceived := false
    RoleArnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AlertTargetArn":
            if err := json.Unmarshal([]byte(v), &strct.AlertTargetArn); err != nil {
                return err
             }
            AlertTargetArnReceived = true
        case "RoleArn":
            if err := json.Unmarshal([]byte(v), &strct.RoleArn); err != nil {
                return err
             }
            RoleArnReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if AlertTargetArn (a required property) was received
    if !AlertTargetArnReceived {
        return errors.New("\"AlertTargetArn\" is required but was not present")
    }
    // check if RoleArn (a required property) was received
    if !RoleArnReceived {
        return errors.New("\"RoleArn\" is required but was not present")
    }
    return nil
}

func (strct *AlertTargets) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AlertTargets) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Behavior) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Criteria" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Criteria\": ")
	if tmp, err := json.Marshal(strct.Criteria); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Metric" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Metric\": ")
	if tmp, err := json.Marshal(strct.Metric); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MetricDimension" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MetricDimension\": ")
	if tmp, err := json.Marshal(strct.MetricDimension); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SuppressAlerts" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SuppressAlerts\": ")
	if tmp, err := json.Marshal(strct.SuppressAlerts); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Behavior) UnmarshalJSON(b []byte) error {
    NameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Criteria":
            if err := json.Unmarshal([]byte(v), &strct.Criteria); err != nil {
                return err
             }
        case "Metric":
            if err := json.Unmarshal([]byte(v), &strct.Metric); err != nil {
                return err
             }
        case "MetricDimension":
            if err := json.Unmarshal([]byte(v), &strct.MetricDimension); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        case "SuppressAlerts":
            if err := json.Unmarshal([]byte(v), &strct.SuppressAlerts); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    return nil
}

func (strct *BehaviorCriteria) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ComparisonOperator" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ComparisonOperator\": ")
	if tmp, err := json.Marshal(strct.ComparisonOperator); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ConsecutiveDatapointsToAlarm" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConsecutiveDatapointsToAlarm\": ")
	if tmp, err := json.Marshal(strct.ConsecutiveDatapointsToAlarm); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ConsecutiveDatapointsToClear" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConsecutiveDatapointsToClear\": ")
	if tmp, err := json.Marshal(strct.ConsecutiveDatapointsToClear); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DurationSeconds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DurationSeconds\": ")
	if tmp, err := json.Marshal(strct.DurationSeconds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MlDetectionConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MlDetectionConfig\": ")
	if tmp, err := json.Marshal(strct.MlDetectionConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StatisticalThreshold" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StatisticalThreshold\": ")
	if tmp, err := json.Marshal(strct.StatisticalThreshold); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BehaviorCriteria) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ComparisonOperator":
            if err := json.Unmarshal([]byte(v), &strct.ComparisonOperator); err != nil {
                return err
             }
        case "ConsecutiveDatapointsToAlarm":
            if err := json.Unmarshal([]byte(v), &strct.ConsecutiveDatapointsToAlarm); err != nil {
                return err
             }
        case "ConsecutiveDatapointsToClear":
            if err := json.Unmarshal([]byte(v), &strct.ConsecutiveDatapointsToClear); err != nil {
                return err
             }
        case "DurationSeconds":
            if err := json.Unmarshal([]byte(v), &strct.DurationSeconds); err != nil {
                return err
             }
        case "MlDetectionConfig":
            if err := json.Unmarshal([]byte(v), &strct.MlDetectionConfig); err != nil {
                return err
             }
        case "StatisticalThreshold":
            if err := json.Unmarshal([]byte(v), &strct.StatisticalThreshold); err != nil {
                return err
             }
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *MachineLearningDetectionConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ConfidenceLevel" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConfidenceLevel\": ")
	if tmp, err := json.Marshal(strct.ConfidenceLevel); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MachineLearningDetectionConfig) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ConfidenceLevel":
            if err := json.Unmarshal([]byte(v), &strct.ConfidenceLevel); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *MetricDimension) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "DimensionName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "DimensionName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DimensionName\": ")
	if tmp, err := json.Marshal(strct.DimensionName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Operator" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Operator\": ")
	if tmp, err := json.Marshal(strct.Operator); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MetricDimension) UnmarshalJSON(b []byte) error {
    DimensionNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DimensionName":
            if err := json.Unmarshal([]byte(v), &strct.DimensionName); err != nil {
                return err
             }
            DimensionNameReceived = true
        case "Operator":
            if err := json.Unmarshal([]byte(v), &strct.Operator); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if DimensionName (a required property) was received
    if !DimensionNameReceived {
        return errors.New("\"DimensionName\" is required but was not present")
    }
    return nil
}

func (strct *MetricToRetain) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Metric" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Metric" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Metric\": ")
	if tmp, err := json.Marshal(strct.Metric); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MetricDimension" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MetricDimension\": ")
	if tmp, err := json.Marshal(strct.MetricDimension); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MetricToRetain) UnmarshalJSON(b []byte) error {
    MetricReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Metric":
            if err := json.Unmarshal([]byte(v), &strct.Metric); err != nil {
                return err
             }
            MetricReceived = true
        case "MetricDimension":
            if err := json.Unmarshal([]byte(v), &strct.MetricDimension); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Metric (a required property) was received
    if !MetricReceived {
        return errors.New("\"Metric\" is required but was not present")
    }
    return nil
}

func (strct *MetricValue) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Cidrs" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Cidrs\": ")
	if tmp, err := json.Marshal(strct.Cidrs); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Count" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Count\": ")
	if tmp, err := json.Marshal(strct.Count); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Number" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Number\": ")
	if tmp, err := json.Marshal(strct.Number); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Numbers" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Numbers\": ")
	if tmp, err := json.Marshal(strct.Numbers); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Ports" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Ports\": ")
	if tmp, err := json.Marshal(strct.Ports); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Strings" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Strings\": ")
	if tmp, err := json.Marshal(strct.Strings); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MetricValue) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Cidrs":
            if err := json.Unmarshal([]byte(v), &strct.Cidrs); err != nil {
                return err
             }
        case "Count":
            if err := json.Unmarshal([]byte(v), &strct.Count); err != nil {
                return err
             }
        case "Number":
            if err := json.Unmarshal([]byte(v), &strct.Number); err != nil {
                return err
             }
        case "Numbers":
            if err := json.Unmarshal([]byte(v), &strct.Numbers); err != nil {
                return err
             }
        case "Ports":
            if err := json.Unmarshal([]byte(v), &strct.Ports); err != nil {
                return err
             }
        case "Strings":
            if err := json.Unmarshal([]byte(v), &strct.Strings); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AdditionalMetricsToRetainV2" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AdditionalMetricsToRetainV2\": ")
	if tmp, err := json.Marshal(strct.AdditionalMetricsToRetainV2); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AlertTargets" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AlertTargets\": ")
	if tmp, err := json.Marshal(strct.AlertTargets); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Behaviors" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Behaviors\": ")
	if tmp, err := json.Marshal(strct.Behaviors); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SecurityProfileArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SecurityProfileArn\": ")
	if tmp, err := json.Marshal(strct.SecurityProfileArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SecurityProfileDescription" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SecurityProfileDescription\": ")
	if tmp, err := json.Marshal(strct.SecurityProfileDescription); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SecurityProfileName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SecurityProfileName\": ")
	if tmp, err := json.Marshal(strct.SecurityProfileName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TargetArns" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TargetArns\": ")
	if tmp, err := json.Marshal(strct.TargetArns); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AdditionalMetricsToRetainV2":
            if err := json.Unmarshal([]byte(v), &strct.AdditionalMetricsToRetainV2); err != nil {
                return err
             }
        case "AlertTargets":
            if err := json.Unmarshal([]byte(v), &strct.AlertTargets); err != nil {
                return err
             }
        case "Behaviors":
            if err := json.Unmarshal([]byte(v), &strct.Behaviors); err != nil {
                return err
             }
        case "SecurityProfileArn":
            if err := json.Unmarshal([]byte(v), &strct.SecurityProfileArn); err != nil {
                return err
             }
        case "SecurityProfileDescription":
            if err := json.Unmarshal([]byte(v), &strct.SecurityProfileDescription); err != nil {
                return err
             }
        case "SecurityProfileName":
            if err := json.Unmarshal([]byte(v), &strct.SecurityProfileName); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        case "TargetArns":
            if err := json.Unmarshal([]byte(v), &strct.TargetArns); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *StatisticalThreshold) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Statistic" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Statistic\": ")
	if tmp, err := json.Marshal(strct.Statistic); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *StatisticalThreshold) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Statistic":
            if err := json.Unmarshal([]byte(v), &strct.Statistic); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}
