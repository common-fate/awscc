// Code generated by schema-generate. DO NOT EDIT.

package topicrule

import (
    "fmt"
    "errors"
    "bytes"
    "encoding/json"
)

// Action 
type Action struct {
  CloudwatchAlarm *CloudwatchAlarmAction `json:"CloudwatchAlarm,omitempty"`
  CloudwatchLogs *CloudwatchLogsAction `json:"CloudwatchLogs,omitempty"`
  CloudwatchMetric *CloudwatchMetricAction `json:"CloudwatchMetric,omitempty"`
  DynamoDB *DynamoDBAction `json:"DynamoDB,omitempty"`
  DynamoDBv2 *DynamoDBv2Action `json:"DynamoDBv2,omitempty"`
  Elasticsearch *ElasticsearchAction `json:"Elasticsearch,omitempty"`
  Firehose *FirehoseAction `json:"Firehose,omitempty"`
  Http *HttpAction `json:"Http,omitempty"`
  IotAnalytics *IotAnalyticsAction `json:"IotAnalytics,omitempty"`
  IotEvents *IotEventsAction `json:"IotEvents,omitempty"`
  IotSiteWise *IotSiteWiseAction `json:"IotSiteWise,omitempty"`
  Kafka *KafkaAction `json:"Kafka,omitempty"`
  Kinesis *KinesisAction `json:"Kinesis,omitempty"`
  Lambda *LambdaAction `json:"Lambda,omitempty"`
  Location *LocationAction `json:"Location,omitempty"`
  OpenSearch *OpenSearchAction `json:"OpenSearch,omitempty"`
  Republish *RepublishAction `json:"Republish,omitempty"`
  S3 *S3Action `json:"S3,omitempty"`
  Sns *SnsAction `json:"Sns,omitempty"`
  Sqs *SqsAction `json:"Sqs,omitempty"`
  StepFunctions *StepFunctionsAction `json:"StepFunctions,omitempty"`
  Timestream *TimestreamAction `json:"Timestream,omitempty"`
}

// AssetPropertyTimestamp 
type AssetPropertyTimestamp struct {
  OffsetInNanos string `json:"OffsetInNanos,omitempty"`
  TimeInSeconds string `json:"TimeInSeconds"`
}

// AssetPropertyValue 
type AssetPropertyValue struct {
  Quality string `json:"Quality,omitempty"`
  Timestamp *AssetPropertyTimestamp `json:"Timestamp"`
  Value *AssetPropertyVariant `json:"Value"`
}

// AssetPropertyVariant 
type AssetPropertyVariant struct {
  BooleanValue string `json:"BooleanValue,omitempty"`
  DoubleValue string `json:"DoubleValue,omitempty"`
  IntegerValue string `json:"IntegerValue,omitempty"`
  StringValue string `json:"StringValue,omitempty"`
}

// ClientProperties 
type ClientProperties struct {
}

// CloudwatchAlarmAction 
type CloudwatchAlarmAction struct {
  AlarmName string `json:"AlarmName"`
  RoleArn string `json:"RoleArn"`
  StateReason string `json:"StateReason"`
  StateValue string `json:"StateValue"`
}

// CloudwatchLogsAction 
type CloudwatchLogsAction struct {
  LogGroupName string `json:"LogGroupName"`
  RoleArn string `json:"RoleArn"`
}

// CloudwatchMetricAction 
type CloudwatchMetricAction struct {
  MetricName string `json:"MetricName"`
  MetricNamespace string `json:"MetricNamespace"`
  MetricTimestamp string `json:"MetricTimestamp,omitempty"`
  MetricUnit string `json:"MetricUnit"`
  MetricValue string `json:"MetricValue"`
  RoleArn string `json:"RoleArn"`
}

// DynamoDBAction 
type DynamoDBAction struct {
  HashKeyField string `json:"HashKeyField"`
  HashKeyType string `json:"HashKeyType,omitempty"`
  HashKeyValue string `json:"HashKeyValue"`
  PayloadField string `json:"PayloadField,omitempty"`
  RangeKeyField string `json:"RangeKeyField,omitempty"`
  RangeKeyType string `json:"RangeKeyType,omitempty"`
  RangeKeyValue string `json:"RangeKeyValue,omitempty"`
  RoleArn string `json:"RoleArn"`
  TableName string `json:"TableName"`
}

// DynamoDBv2Action 
type DynamoDBv2Action struct {
  PutItem *PutItemInput `json:"PutItem,omitempty"`
  RoleArn string `json:"RoleArn,omitempty"`
}

// ElasticsearchAction 
type ElasticsearchAction struct {
  Endpoint string `json:"Endpoint"`
  Id string `json:"Id"`
  Index string `json:"Index"`
  RoleArn string `json:"RoleArn"`
  Type string `json:"Type"`
}

// FirehoseAction 
type FirehoseAction struct {
  BatchMode bool `json:"BatchMode,omitempty"`
  DeliveryStreamName string `json:"DeliveryStreamName"`
  RoleArn string `json:"RoleArn"`
  Separator string `json:"Separator,omitempty"`
}

// HttpAction 
type HttpAction struct {
  Auth *HttpAuthorization `json:"Auth,omitempty"`
  ConfirmationUrl string `json:"ConfirmationUrl,omitempty"`
  Headers []*HttpActionHeader `json:"Headers,omitempty"`
  Url string `json:"Url"`
}

// HttpActionHeader 
type HttpActionHeader struct {
  Key string `json:"Key"`
  Value string `json:"Value"`
}

// HttpAuthorization 
type HttpAuthorization struct {
  Sigv4 *SigV4Authorization `json:"Sigv4,omitempty"`
}

// IotAnalyticsAction 
type IotAnalyticsAction struct {
  BatchMode bool `json:"BatchMode,omitempty"`
  ChannelName string `json:"ChannelName"`
  RoleArn string `json:"RoleArn"`
}

// IotEventsAction 
type IotEventsAction struct {
  BatchMode bool `json:"BatchMode,omitempty"`
  InputName string `json:"InputName"`
  MessageId string `json:"MessageId,omitempty"`
  RoleArn string `json:"RoleArn"`
}

// IotSiteWiseAction 
type IotSiteWiseAction struct {
  PutAssetPropertyValueEntries []*PutAssetPropertyValueEntry `json:"PutAssetPropertyValueEntries"`
  RoleArn string `json:"RoleArn"`
}

// KafkaAction 
type KafkaAction struct {
  ClientProperties *ClientProperties `json:"ClientProperties"`
  DestinationArn string `json:"DestinationArn"`
  Key string `json:"Key,omitempty"`
  Partition string `json:"Partition,omitempty"`
  Topic string `json:"Topic"`
}

// KinesisAction 
type KinesisAction struct {
  PartitionKey string `json:"PartitionKey,omitempty"`
  RoleArn string `json:"RoleArn"`
  StreamName string `json:"StreamName"`
}

// LambdaAction 
type LambdaAction struct {
  FunctionArn string `json:"FunctionArn,omitempty"`
}

// LocationAction 
type LocationAction struct {
  DeviceId string `json:"DeviceId"`
  Latitude string `json:"Latitude"`
  Longitude string `json:"Longitude"`
  RoleArn string `json:"RoleArn"`
  Timestamp *Timestamp `json:"Timestamp,omitempty"`
  TrackerName string `json:"TrackerName"`
}

// OpenSearchAction 
type OpenSearchAction struct {
  Endpoint string `json:"Endpoint"`
  Id string `json:"Id"`
  Index string `json:"Index"`
  RoleArn string `json:"RoleArn"`
  Type string `json:"Type"`
}

// PutAssetPropertyValueEntry 
type PutAssetPropertyValueEntry struct {
  AssetId string `json:"AssetId,omitempty"`
  EntryId string `json:"EntryId,omitempty"`
  PropertyAlias string `json:"PropertyAlias,omitempty"`
  PropertyId string `json:"PropertyId,omitempty"`
  PropertyValues []*AssetPropertyValue `json:"PropertyValues"`
}

// PutItemInput 
type PutItemInput struct {
  TableName string `json:"TableName"`
}

// RepublishAction 
type RepublishAction struct {
  Headers *RepublishActionHeaders `json:"Headers,omitempty"`
  Qos int `json:"Qos,omitempty"`
  RoleArn string `json:"RoleArn"`
  Topic string `json:"Topic"`
}

// RepublishActionHeaders 
type RepublishActionHeaders struct {
  ContentType string `json:"ContentType,omitempty"`
  CorrelationData string `json:"CorrelationData,omitempty"`
  MessageExpiry string `json:"MessageExpiry,omitempty"`
  PayloadFormatIndicator string `json:"PayloadFormatIndicator,omitempty"`
  ResponseTopic string `json:"ResponseTopic,omitempty"`
  UserProperties []*UserProperty `json:"UserProperties,omitempty"`
}

// Resource Resource Type definition for AWS::IoT::TopicRule
type Resource struct {
  Arn string `json:"Arn,omitempty"`
  RuleName string `json:"RuleName,omitempty"`
  Tags []*Tag `json:"Tags,omitempty"`
  TopicRulePayload *TopicRulePayload `json:"TopicRulePayload"`
}

// S3Action 
type S3Action struct {
  BucketName string `json:"BucketName"`
  CannedAcl string `json:"CannedAcl,omitempty"`
  Key string `json:"Key"`
  RoleArn string `json:"RoleArn"`
}

// SigV4Authorization 
type SigV4Authorization struct {
  RoleArn string `json:"RoleArn"`
  ServiceName string `json:"ServiceName"`
  SigningRegion string `json:"SigningRegion"`
}

// SnsAction 
type SnsAction struct {
  MessageFormat string `json:"MessageFormat,omitempty"`
  RoleArn string `json:"RoleArn"`
  TargetArn string `json:"TargetArn"`
}

// SqsAction 
type SqsAction struct {
  QueueUrl string `json:"QueueUrl"`
  RoleArn string `json:"RoleArn"`
  UseBase64 bool `json:"UseBase64,omitempty"`
}

// StepFunctionsAction 
type StepFunctionsAction struct {
  ExecutionNamePrefix string `json:"ExecutionNamePrefix,omitempty"`
  RoleArn string `json:"RoleArn"`
  StateMachineName string `json:"StateMachineName"`
}

// Tag 
type Tag struct {
  Key string `json:"Key"`
  Value string `json:"Value"`
}

// Timestamp 
type Timestamp struct {
  Unit string `json:"Unit,omitempty"`
  Value string `json:"Value"`
}

// TimestreamAction 
type TimestreamAction struct {
  DatabaseName string `json:"DatabaseName"`
  Dimensions []*TimestreamDimension `json:"Dimensions"`
  RoleArn string `json:"RoleArn"`
  TableName string `json:"TableName"`
  Timestamp *TimestreamTimestamp `json:"Timestamp,omitempty"`
}

// TimestreamDimension 
type TimestreamDimension struct {
  Name string `json:"Name"`
  Value string `json:"Value"`
}

// TimestreamTimestamp 
type TimestreamTimestamp struct {
  Unit string `json:"Unit"`
  Value string `json:"Value"`
}

// TopicRulePayload 
type TopicRulePayload struct {
  Actions []*Action `json:"Actions"`
  AwsIotSqlVersion string `json:"AwsIotSqlVersion,omitempty"`
  Description string `json:"Description,omitempty"`
  ErrorAction *Action `json:"ErrorAction,omitempty"`
  RuleDisabled bool `json:"RuleDisabled,omitempty"`
  Sql string `json:"Sql"`
}

// UserProperty 
type UserProperty struct {
  Key string `json:"Key"`
  Value string `json:"Value"`
}

func (strct *Action) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CloudwatchAlarm" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CloudwatchAlarm\": ")
	if tmp, err := json.Marshal(strct.CloudwatchAlarm); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CloudwatchLogs" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CloudwatchLogs\": ")
	if tmp, err := json.Marshal(strct.CloudwatchLogs); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CloudwatchMetric" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CloudwatchMetric\": ")
	if tmp, err := json.Marshal(strct.CloudwatchMetric); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DynamoDB" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DynamoDB\": ")
	if tmp, err := json.Marshal(strct.DynamoDB); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DynamoDBv2" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DynamoDBv2\": ")
	if tmp, err := json.Marshal(strct.DynamoDBv2); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Elasticsearch" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Elasticsearch\": ")
	if tmp, err := json.Marshal(strct.Elasticsearch); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Firehose" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Firehose\": ")
	if tmp, err := json.Marshal(strct.Firehose); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Http" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Http\": ")
	if tmp, err := json.Marshal(strct.Http); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IotAnalytics" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IotAnalytics\": ")
	if tmp, err := json.Marshal(strct.IotAnalytics); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IotEvents" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IotEvents\": ")
	if tmp, err := json.Marshal(strct.IotEvents); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IotSiteWise" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IotSiteWise\": ")
	if tmp, err := json.Marshal(strct.IotSiteWise); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Kafka" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Kafka\": ")
	if tmp, err := json.Marshal(strct.Kafka); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Kinesis" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Kinesis\": ")
	if tmp, err := json.Marshal(strct.Kinesis); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Lambda" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Lambda\": ")
	if tmp, err := json.Marshal(strct.Lambda); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Location" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Location\": ")
	if tmp, err := json.Marshal(strct.Location); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OpenSearch" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OpenSearch\": ")
	if tmp, err := json.Marshal(strct.OpenSearch); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Republish" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Republish\": ")
	if tmp, err := json.Marshal(strct.Republish); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "S3" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3\": ")
	if tmp, err := json.Marshal(strct.S3); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Sns" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Sns\": ")
	if tmp, err := json.Marshal(strct.Sns); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Sqs" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Sqs\": ")
	if tmp, err := json.Marshal(strct.Sqs); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StepFunctions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StepFunctions\": ")
	if tmp, err := json.Marshal(strct.StepFunctions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Timestream" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Timestream\": ")
	if tmp, err := json.Marshal(strct.Timestream); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Action) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CloudwatchAlarm":
            if err := json.Unmarshal([]byte(v), &strct.CloudwatchAlarm); err != nil {
                return err
             }
        case "CloudwatchLogs":
            if err := json.Unmarshal([]byte(v), &strct.CloudwatchLogs); err != nil {
                return err
             }
        case "CloudwatchMetric":
            if err := json.Unmarshal([]byte(v), &strct.CloudwatchMetric); err != nil {
                return err
             }
        case "DynamoDB":
            if err := json.Unmarshal([]byte(v), &strct.DynamoDB); err != nil {
                return err
             }
        case "DynamoDBv2":
            if err := json.Unmarshal([]byte(v), &strct.DynamoDBv2); err != nil {
                return err
             }
        case "Elasticsearch":
            if err := json.Unmarshal([]byte(v), &strct.Elasticsearch); err != nil {
                return err
             }
        case "Firehose":
            if err := json.Unmarshal([]byte(v), &strct.Firehose); err != nil {
                return err
             }
        case "Http":
            if err := json.Unmarshal([]byte(v), &strct.Http); err != nil {
                return err
             }
        case "IotAnalytics":
            if err := json.Unmarshal([]byte(v), &strct.IotAnalytics); err != nil {
                return err
             }
        case "IotEvents":
            if err := json.Unmarshal([]byte(v), &strct.IotEvents); err != nil {
                return err
             }
        case "IotSiteWise":
            if err := json.Unmarshal([]byte(v), &strct.IotSiteWise); err != nil {
                return err
             }
        case "Kafka":
            if err := json.Unmarshal([]byte(v), &strct.Kafka); err != nil {
                return err
             }
        case "Kinesis":
            if err := json.Unmarshal([]byte(v), &strct.Kinesis); err != nil {
                return err
             }
        case "Lambda":
            if err := json.Unmarshal([]byte(v), &strct.Lambda); err != nil {
                return err
             }
        case "Location":
            if err := json.Unmarshal([]byte(v), &strct.Location); err != nil {
                return err
             }
        case "OpenSearch":
            if err := json.Unmarshal([]byte(v), &strct.OpenSearch); err != nil {
                return err
             }
        case "Republish":
            if err := json.Unmarshal([]byte(v), &strct.Republish); err != nil {
                return err
             }
        case "S3":
            if err := json.Unmarshal([]byte(v), &strct.S3); err != nil {
                return err
             }
        case "Sns":
            if err := json.Unmarshal([]byte(v), &strct.Sns); err != nil {
                return err
             }
        case "Sqs":
            if err := json.Unmarshal([]byte(v), &strct.Sqs); err != nil {
                return err
             }
        case "StepFunctions":
            if err := json.Unmarshal([]byte(v), &strct.StepFunctions); err != nil {
                return err
             }
        case "Timestream":
            if err := json.Unmarshal([]byte(v), &strct.Timestream); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *AssetPropertyTimestamp) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "OffsetInNanos" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OffsetInNanos\": ")
	if tmp, err := json.Marshal(strct.OffsetInNanos); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TimeInSeconds" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TimeInSeconds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TimeInSeconds\": ")
	if tmp, err := json.Marshal(strct.TimeInSeconds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AssetPropertyTimestamp) UnmarshalJSON(b []byte) error {
    TimeInSecondsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "OffsetInNanos":
            if err := json.Unmarshal([]byte(v), &strct.OffsetInNanos); err != nil {
                return err
             }
        case "TimeInSeconds":
            if err := json.Unmarshal([]byte(v), &strct.TimeInSeconds); err != nil {
                return err
             }
            TimeInSecondsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if TimeInSeconds (a required property) was received
    if !TimeInSecondsReceived {
        return errors.New("\"TimeInSeconds\" is required but was not present")
    }
    return nil
}

func (strct *AssetPropertyValue) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Quality" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Quality\": ")
	if tmp, err := json.Marshal(strct.Quality); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Timestamp" field is required
    if strct.Timestamp == nil {
        return nil, errors.New("Timestamp is a required field")
    }
    // Marshal the "Timestamp" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Timestamp\": ")
	if tmp, err := json.Marshal(strct.Timestamp); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    if strct.Value == nil {
        return nil, errors.New("Value is a required field")
    }
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AssetPropertyValue) UnmarshalJSON(b []byte) error {
    TimestampReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Quality":
            if err := json.Unmarshal([]byte(v), &strct.Quality); err != nil {
                return err
             }
        case "Timestamp":
            if err := json.Unmarshal([]byte(v), &strct.Timestamp); err != nil {
                return err
             }
            TimestampReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Timestamp (a required property) was received
    if !TimestampReceived {
        return errors.New("\"Timestamp\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *AssetPropertyVariant) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "BooleanValue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BooleanValue\": ")
	if tmp, err := json.Marshal(strct.BooleanValue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DoubleValue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DoubleValue\": ")
	if tmp, err := json.Marshal(strct.DoubleValue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IntegerValue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IntegerValue\": ")
	if tmp, err := json.Marshal(strct.IntegerValue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StringValue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StringValue\": ")
	if tmp, err := json.Marshal(strct.StringValue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AssetPropertyVariant) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BooleanValue":
            if err := json.Unmarshal([]byte(v), &strct.BooleanValue); err != nil {
                return err
             }
        case "DoubleValue":
            if err := json.Unmarshal([]byte(v), &strct.DoubleValue); err != nil {
                return err
             }
        case "IntegerValue":
            if err := json.Unmarshal([]byte(v), &strct.IntegerValue); err != nil {
                return err
             }
        case "StringValue":
            if err := json.Unmarshal([]byte(v), &strct.StringValue); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ClientProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ClientProperties) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *CloudwatchAlarmAction) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AlarmName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AlarmName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AlarmName\": ")
	if tmp, err := json.Marshal(strct.AlarmName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RoleArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoleArn\": ")
	if tmp, err := json.Marshal(strct.RoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "StateReason" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "StateReason" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StateReason\": ")
	if tmp, err := json.Marshal(strct.StateReason); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "StateValue" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "StateValue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StateValue\": ")
	if tmp, err := json.Marshal(strct.StateValue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CloudwatchAlarmAction) UnmarshalJSON(b []byte) error {
    AlarmNameReceived := false
    RoleArnReceived := false
    StateReasonReceived := false
    StateValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AlarmName":
            if err := json.Unmarshal([]byte(v), &strct.AlarmName); err != nil {
                return err
             }
            AlarmNameReceived = true
        case "RoleArn":
            if err := json.Unmarshal([]byte(v), &strct.RoleArn); err != nil {
                return err
             }
            RoleArnReceived = true
        case "StateReason":
            if err := json.Unmarshal([]byte(v), &strct.StateReason); err != nil {
                return err
             }
            StateReasonReceived = true
        case "StateValue":
            if err := json.Unmarshal([]byte(v), &strct.StateValue); err != nil {
                return err
             }
            StateValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if AlarmName (a required property) was received
    if !AlarmNameReceived {
        return errors.New("\"AlarmName\" is required but was not present")
    }
    // check if RoleArn (a required property) was received
    if !RoleArnReceived {
        return errors.New("\"RoleArn\" is required but was not present")
    }
    // check if StateReason (a required property) was received
    if !StateReasonReceived {
        return errors.New("\"StateReason\" is required but was not present")
    }
    // check if StateValue (a required property) was received
    if !StateValueReceived {
        return errors.New("\"StateValue\" is required but was not present")
    }
    return nil
}

func (strct *CloudwatchLogsAction) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "LogGroupName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "LogGroupName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LogGroupName\": ")
	if tmp, err := json.Marshal(strct.LogGroupName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RoleArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoleArn\": ")
	if tmp, err := json.Marshal(strct.RoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CloudwatchLogsAction) UnmarshalJSON(b []byte) error {
    LogGroupNameReceived := false
    RoleArnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "LogGroupName":
            if err := json.Unmarshal([]byte(v), &strct.LogGroupName); err != nil {
                return err
             }
            LogGroupNameReceived = true
        case "RoleArn":
            if err := json.Unmarshal([]byte(v), &strct.RoleArn); err != nil {
                return err
             }
            RoleArnReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if LogGroupName (a required property) was received
    if !LogGroupNameReceived {
        return errors.New("\"LogGroupName\" is required but was not present")
    }
    // check if RoleArn (a required property) was received
    if !RoleArnReceived {
        return errors.New("\"RoleArn\" is required but was not present")
    }
    return nil
}

func (strct *CloudwatchMetricAction) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "MetricName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "MetricName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MetricName\": ")
	if tmp, err := json.Marshal(strct.MetricName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "MetricNamespace" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "MetricNamespace" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MetricNamespace\": ")
	if tmp, err := json.Marshal(strct.MetricNamespace); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MetricTimestamp" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MetricTimestamp\": ")
	if tmp, err := json.Marshal(strct.MetricTimestamp); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "MetricUnit" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "MetricUnit" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MetricUnit\": ")
	if tmp, err := json.Marshal(strct.MetricUnit); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "MetricValue" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "MetricValue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MetricValue\": ")
	if tmp, err := json.Marshal(strct.MetricValue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RoleArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoleArn\": ")
	if tmp, err := json.Marshal(strct.RoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CloudwatchMetricAction) UnmarshalJSON(b []byte) error {
    MetricNameReceived := false
    MetricNamespaceReceived := false
    MetricUnitReceived := false
    MetricValueReceived := false
    RoleArnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "MetricName":
            if err := json.Unmarshal([]byte(v), &strct.MetricName); err != nil {
                return err
             }
            MetricNameReceived = true
        case "MetricNamespace":
            if err := json.Unmarshal([]byte(v), &strct.MetricNamespace); err != nil {
                return err
             }
            MetricNamespaceReceived = true
        case "MetricTimestamp":
            if err := json.Unmarshal([]byte(v), &strct.MetricTimestamp); err != nil {
                return err
             }
        case "MetricUnit":
            if err := json.Unmarshal([]byte(v), &strct.MetricUnit); err != nil {
                return err
             }
            MetricUnitReceived = true
        case "MetricValue":
            if err := json.Unmarshal([]byte(v), &strct.MetricValue); err != nil {
                return err
             }
            MetricValueReceived = true
        case "RoleArn":
            if err := json.Unmarshal([]byte(v), &strct.RoleArn); err != nil {
                return err
             }
            RoleArnReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if MetricName (a required property) was received
    if !MetricNameReceived {
        return errors.New("\"MetricName\" is required but was not present")
    }
    // check if MetricNamespace (a required property) was received
    if !MetricNamespaceReceived {
        return errors.New("\"MetricNamespace\" is required but was not present")
    }
    // check if MetricUnit (a required property) was received
    if !MetricUnitReceived {
        return errors.New("\"MetricUnit\" is required but was not present")
    }
    // check if MetricValue (a required property) was received
    if !MetricValueReceived {
        return errors.New("\"MetricValue\" is required but was not present")
    }
    // check if RoleArn (a required property) was received
    if !RoleArnReceived {
        return errors.New("\"RoleArn\" is required but was not present")
    }
    return nil
}

func (strct *DynamoDBAction) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "HashKeyField" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "HashKeyField" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HashKeyField\": ")
	if tmp, err := json.Marshal(strct.HashKeyField); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "HashKeyType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HashKeyType\": ")
	if tmp, err := json.Marshal(strct.HashKeyType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "HashKeyValue" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "HashKeyValue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HashKeyValue\": ")
	if tmp, err := json.Marshal(strct.HashKeyValue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PayloadField" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PayloadField\": ")
	if tmp, err := json.Marshal(strct.PayloadField); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RangeKeyField" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RangeKeyField\": ")
	if tmp, err := json.Marshal(strct.RangeKeyField); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RangeKeyType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RangeKeyType\": ")
	if tmp, err := json.Marshal(strct.RangeKeyType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RangeKeyValue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RangeKeyValue\": ")
	if tmp, err := json.Marshal(strct.RangeKeyValue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RoleArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoleArn\": ")
	if tmp, err := json.Marshal(strct.RoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TableName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TableName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TableName\": ")
	if tmp, err := json.Marshal(strct.TableName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DynamoDBAction) UnmarshalJSON(b []byte) error {
    HashKeyFieldReceived := false
    HashKeyValueReceived := false
    RoleArnReceived := false
    TableNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "HashKeyField":
            if err := json.Unmarshal([]byte(v), &strct.HashKeyField); err != nil {
                return err
             }
            HashKeyFieldReceived = true
        case "HashKeyType":
            if err := json.Unmarshal([]byte(v), &strct.HashKeyType); err != nil {
                return err
             }
        case "HashKeyValue":
            if err := json.Unmarshal([]byte(v), &strct.HashKeyValue); err != nil {
                return err
             }
            HashKeyValueReceived = true
        case "PayloadField":
            if err := json.Unmarshal([]byte(v), &strct.PayloadField); err != nil {
                return err
             }
        case "RangeKeyField":
            if err := json.Unmarshal([]byte(v), &strct.RangeKeyField); err != nil {
                return err
             }
        case "RangeKeyType":
            if err := json.Unmarshal([]byte(v), &strct.RangeKeyType); err != nil {
                return err
             }
        case "RangeKeyValue":
            if err := json.Unmarshal([]byte(v), &strct.RangeKeyValue); err != nil {
                return err
             }
        case "RoleArn":
            if err := json.Unmarshal([]byte(v), &strct.RoleArn); err != nil {
                return err
             }
            RoleArnReceived = true
        case "TableName":
            if err := json.Unmarshal([]byte(v), &strct.TableName); err != nil {
                return err
             }
            TableNameReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if HashKeyField (a required property) was received
    if !HashKeyFieldReceived {
        return errors.New("\"HashKeyField\" is required but was not present")
    }
    // check if HashKeyValue (a required property) was received
    if !HashKeyValueReceived {
        return errors.New("\"HashKeyValue\" is required but was not present")
    }
    // check if RoleArn (a required property) was received
    if !RoleArnReceived {
        return errors.New("\"RoleArn\" is required but was not present")
    }
    // check if TableName (a required property) was received
    if !TableNameReceived {
        return errors.New("\"TableName\" is required but was not present")
    }
    return nil
}

func (strct *DynamoDBv2Action) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "PutItem" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PutItem\": ")
	if tmp, err := json.Marshal(strct.PutItem); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoleArn\": ")
	if tmp, err := json.Marshal(strct.RoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DynamoDBv2Action) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "PutItem":
            if err := json.Unmarshal([]byte(v), &strct.PutItem); err != nil {
                return err
             }
        case "RoleArn":
            if err := json.Unmarshal([]byte(v), &strct.RoleArn); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ElasticsearchAction) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Endpoint" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Endpoint" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Endpoint\": ")
	if tmp, err := json.Marshal(strct.Endpoint); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Id" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Id" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Index" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Index" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Index\": ")
	if tmp, err := json.Marshal(strct.Index); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RoleArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoleArn\": ")
	if tmp, err := json.Marshal(strct.RoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ElasticsearchAction) UnmarshalJSON(b []byte) error {
    EndpointReceived := false
    IdReceived := false
    IndexReceived := false
    RoleArnReceived := false
    TypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Endpoint":
            if err := json.Unmarshal([]byte(v), &strct.Endpoint); err != nil {
                return err
             }
            EndpointReceived = true
        case "Id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
            IdReceived = true
        case "Index":
            if err := json.Unmarshal([]byte(v), &strct.Index); err != nil {
                return err
             }
            IndexReceived = true
        case "RoleArn":
            if err := json.Unmarshal([]byte(v), &strct.RoleArn); err != nil {
                return err
             }
            RoleArnReceived = true
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            TypeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Endpoint (a required property) was received
    if !EndpointReceived {
        return errors.New("\"Endpoint\" is required but was not present")
    }
    // check if Id (a required property) was received
    if !IdReceived {
        return errors.New("\"Id\" is required but was not present")
    }
    // check if Index (a required property) was received
    if !IndexReceived {
        return errors.New("\"Index\" is required but was not present")
    }
    // check if RoleArn (a required property) was received
    if !RoleArnReceived {
        return errors.New("\"RoleArn\" is required but was not present")
    }
    // check if Type (a required property) was received
    if !TypeReceived {
        return errors.New("\"Type\" is required but was not present")
    }
    return nil
}

func (strct *FirehoseAction) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "BatchMode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BatchMode\": ")
	if tmp, err := json.Marshal(strct.BatchMode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "DeliveryStreamName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "DeliveryStreamName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DeliveryStreamName\": ")
	if tmp, err := json.Marshal(strct.DeliveryStreamName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RoleArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoleArn\": ")
	if tmp, err := json.Marshal(strct.RoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Separator" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Separator\": ")
	if tmp, err := json.Marshal(strct.Separator); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FirehoseAction) UnmarshalJSON(b []byte) error {
    DeliveryStreamNameReceived := false
    RoleArnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BatchMode":
            if err := json.Unmarshal([]byte(v), &strct.BatchMode); err != nil {
                return err
             }
        case "DeliveryStreamName":
            if err := json.Unmarshal([]byte(v), &strct.DeliveryStreamName); err != nil {
                return err
             }
            DeliveryStreamNameReceived = true
        case "RoleArn":
            if err := json.Unmarshal([]byte(v), &strct.RoleArn); err != nil {
                return err
             }
            RoleArnReceived = true
        case "Separator":
            if err := json.Unmarshal([]byte(v), &strct.Separator); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if DeliveryStreamName (a required property) was received
    if !DeliveryStreamNameReceived {
        return errors.New("\"DeliveryStreamName\" is required but was not present")
    }
    // check if RoleArn (a required property) was received
    if !RoleArnReceived {
        return errors.New("\"RoleArn\" is required but was not present")
    }
    return nil
}

func (strct *HttpAction) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Auth" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Auth\": ")
	if tmp, err := json.Marshal(strct.Auth); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ConfirmationUrl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConfirmationUrl\": ")
	if tmp, err := json.Marshal(strct.ConfirmationUrl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Headers" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Headers\": ")
	if tmp, err := json.Marshal(strct.Headers); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Url" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Url" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Url\": ")
	if tmp, err := json.Marshal(strct.Url); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *HttpAction) UnmarshalJSON(b []byte) error {
    UrlReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Auth":
            if err := json.Unmarshal([]byte(v), &strct.Auth); err != nil {
                return err
             }
        case "ConfirmationUrl":
            if err := json.Unmarshal([]byte(v), &strct.ConfirmationUrl); err != nil {
                return err
             }
        case "Headers":
            if err := json.Unmarshal([]byte(v), &strct.Headers); err != nil {
                return err
             }
        case "Url":
            if err := json.Unmarshal([]byte(v), &strct.Url); err != nil {
                return err
             }
            UrlReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Url (a required property) was received
    if !UrlReceived {
        return errors.New("\"Url\" is required but was not present")
    }
    return nil
}

func (strct *HttpActionHeader) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *HttpActionHeader) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *HttpAuthorization) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Sigv4" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Sigv4\": ")
	if tmp, err := json.Marshal(strct.Sigv4); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *HttpAuthorization) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Sigv4":
            if err := json.Unmarshal([]byte(v), &strct.Sigv4); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *IotAnalyticsAction) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "BatchMode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BatchMode\": ")
	if tmp, err := json.Marshal(strct.BatchMode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ChannelName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ChannelName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ChannelName\": ")
	if tmp, err := json.Marshal(strct.ChannelName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RoleArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoleArn\": ")
	if tmp, err := json.Marshal(strct.RoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *IotAnalyticsAction) UnmarshalJSON(b []byte) error {
    ChannelNameReceived := false
    RoleArnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BatchMode":
            if err := json.Unmarshal([]byte(v), &strct.BatchMode); err != nil {
                return err
             }
        case "ChannelName":
            if err := json.Unmarshal([]byte(v), &strct.ChannelName); err != nil {
                return err
             }
            ChannelNameReceived = true
        case "RoleArn":
            if err := json.Unmarshal([]byte(v), &strct.RoleArn); err != nil {
                return err
             }
            RoleArnReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ChannelName (a required property) was received
    if !ChannelNameReceived {
        return errors.New("\"ChannelName\" is required but was not present")
    }
    // check if RoleArn (a required property) was received
    if !RoleArnReceived {
        return errors.New("\"RoleArn\" is required but was not present")
    }
    return nil
}

func (strct *IotEventsAction) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "BatchMode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BatchMode\": ")
	if tmp, err := json.Marshal(strct.BatchMode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "InputName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "InputName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InputName\": ")
	if tmp, err := json.Marshal(strct.InputName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MessageId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MessageId\": ")
	if tmp, err := json.Marshal(strct.MessageId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RoleArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoleArn\": ")
	if tmp, err := json.Marshal(strct.RoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *IotEventsAction) UnmarshalJSON(b []byte) error {
    InputNameReceived := false
    RoleArnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BatchMode":
            if err := json.Unmarshal([]byte(v), &strct.BatchMode); err != nil {
                return err
             }
        case "InputName":
            if err := json.Unmarshal([]byte(v), &strct.InputName); err != nil {
                return err
             }
            InputNameReceived = true
        case "MessageId":
            if err := json.Unmarshal([]byte(v), &strct.MessageId); err != nil {
                return err
             }
        case "RoleArn":
            if err := json.Unmarshal([]byte(v), &strct.RoleArn); err != nil {
                return err
             }
            RoleArnReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if InputName (a required property) was received
    if !InputNameReceived {
        return errors.New("\"InputName\" is required but was not present")
    }
    // check if RoleArn (a required property) was received
    if !RoleArnReceived {
        return errors.New("\"RoleArn\" is required but was not present")
    }
    return nil
}

func (strct *IotSiteWiseAction) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "PutAssetPropertyValueEntries" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "PutAssetPropertyValueEntries" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PutAssetPropertyValueEntries\": ")
	if tmp, err := json.Marshal(strct.PutAssetPropertyValueEntries); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RoleArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoleArn\": ")
	if tmp, err := json.Marshal(strct.RoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *IotSiteWiseAction) UnmarshalJSON(b []byte) error {
    PutAssetPropertyValueEntriesReceived := false
    RoleArnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "PutAssetPropertyValueEntries":
            if err := json.Unmarshal([]byte(v), &strct.PutAssetPropertyValueEntries); err != nil {
                return err
             }
            PutAssetPropertyValueEntriesReceived = true
        case "RoleArn":
            if err := json.Unmarshal([]byte(v), &strct.RoleArn); err != nil {
                return err
             }
            RoleArnReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if PutAssetPropertyValueEntries (a required property) was received
    if !PutAssetPropertyValueEntriesReceived {
        return errors.New("\"PutAssetPropertyValueEntries\" is required but was not present")
    }
    // check if RoleArn (a required property) was received
    if !RoleArnReceived {
        return errors.New("\"RoleArn\" is required but was not present")
    }
    return nil
}

func (strct *KafkaAction) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ClientProperties" field is required
    if strct.ClientProperties == nil {
        return nil, errors.New("ClientProperties is a required field")
    }
    // Marshal the "ClientProperties" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ClientProperties\": ")
	if tmp, err := json.Marshal(strct.ClientProperties); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "DestinationArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "DestinationArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DestinationArn\": ")
	if tmp, err := json.Marshal(strct.DestinationArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Partition" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Partition\": ")
	if tmp, err := json.Marshal(strct.Partition); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Topic" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Topic" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Topic\": ")
	if tmp, err := json.Marshal(strct.Topic); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *KafkaAction) UnmarshalJSON(b []byte) error {
    ClientPropertiesReceived := false
    DestinationArnReceived := false
    TopicReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ClientProperties":
            if err := json.Unmarshal([]byte(v), &strct.ClientProperties); err != nil {
                return err
             }
            ClientPropertiesReceived = true
        case "DestinationArn":
            if err := json.Unmarshal([]byte(v), &strct.DestinationArn); err != nil {
                return err
             }
            DestinationArnReceived = true
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
        case "Partition":
            if err := json.Unmarshal([]byte(v), &strct.Partition); err != nil {
                return err
             }
        case "Topic":
            if err := json.Unmarshal([]byte(v), &strct.Topic); err != nil {
                return err
             }
            TopicReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ClientProperties (a required property) was received
    if !ClientPropertiesReceived {
        return errors.New("\"ClientProperties\" is required but was not present")
    }
    // check if DestinationArn (a required property) was received
    if !DestinationArnReceived {
        return errors.New("\"DestinationArn\" is required but was not present")
    }
    // check if Topic (a required property) was received
    if !TopicReceived {
        return errors.New("\"Topic\" is required but was not present")
    }
    return nil
}

func (strct *KinesisAction) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "PartitionKey" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PartitionKey\": ")
	if tmp, err := json.Marshal(strct.PartitionKey); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RoleArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoleArn\": ")
	if tmp, err := json.Marshal(strct.RoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "StreamName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "StreamName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StreamName\": ")
	if tmp, err := json.Marshal(strct.StreamName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *KinesisAction) UnmarshalJSON(b []byte) error {
    RoleArnReceived := false
    StreamNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "PartitionKey":
            if err := json.Unmarshal([]byte(v), &strct.PartitionKey); err != nil {
                return err
             }
        case "RoleArn":
            if err := json.Unmarshal([]byte(v), &strct.RoleArn); err != nil {
                return err
             }
            RoleArnReceived = true
        case "StreamName":
            if err := json.Unmarshal([]byte(v), &strct.StreamName); err != nil {
                return err
             }
            StreamNameReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if RoleArn (a required property) was received
    if !RoleArnReceived {
        return errors.New("\"RoleArn\" is required but was not present")
    }
    // check if StreamName (a required property) was received
    if !StreamNameReceived {
        return errors.New("\"StreamName\" is required but was not present")
    }
    return nil
}

func (strct *LambdaAction) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "FunctionArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FunctionArn\": ")
	if tmp, err := json.Marshal(strct.FunctionArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LambdaAction) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "FunctionArn":
            if err := json.Unmarshal([]byte(v), &strct.FunctionArn); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *LocationAction) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "DeviceId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "DeviceId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DeviceId\": ")
	if tmp, err := json.Marshal(strct.DeviceId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Latitude" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Latitude" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Latitude\": ")
	if tmp, err := json.Marshal(strct.Latitude); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Longitude" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Longitude" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Longitude\": ")
	if tmp, err := json.Marshal(strct.Longitude); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RoleArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoleArn\": ")
	if tmp, err := json.Marshal(strct.RoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Timestamp" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Timestamp\": ")
	if tmp, err := json.Marshal(strct.Timestamp); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TrackerName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TrackerName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TrackerName\": ")
	if tmp, err := json.Marshal(strct.TrackerName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LocationAction) UnmarshalJSON(b []byte) error {
    DeviceIdReceived := false
    LatitudeReceived := false
    LongitudeReceived := false
    RoleArnReceived := false
    TrackerNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DeviceId":
            if err := json.Unmarshal([]byte(v), &strct.DeviceId); err != nil {
                return err
             }
            DeviceIdReceived = true
        case "Latitude":
            if err := json.Unmarshal([]byte(v), &strct.Latitude); err != nil {
                return err
             }
            LatitudeReceived = true
        case "Longitude":
            if err := json.Unmarshal([]byte(v), &strct.Longitude); err != nil {
                return err
             }
            LongitudeReceived = true
        case "RoleArn":
            if err := json.Unmarshal([]byte(v), &strct.RoleArn); err != nil {
                return err
             }
            RoleArnReceived = true
        case "Timestamp":
            if err := json.Unmarshal([]byte(v), &strct.Timestamp); err != nil {
                return err
             }
        case "TrackerName":
            if err := json.Unmarshal([]byte(v), &strct.TrackerName); err != nil {
                return err
             }
            TrackerNameReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if DeviceId (a required property) was received
    if !DeviceIdReceived {
        return errors.New("\"DeviceId\" is required but was not present")
    }
    // check if Latitude (a required property) was received
    if !LatitudeReceived {
        return errors.New("\"Latitude\" is required but was not present")
    }
    // check if Longitude (a required property) was received
    if !LongitudeReceived {
        return errors.New("\"Longitude\" is required but was not present")
    }
    // check if RoleArn (a required property) was received
    if !RoleArnReceived {
        return errors.New("\"RoleArn\" is required but was not present")
    }
    // check if TrackerName (a required property) was received
    if !TrackerNameReceived {
        return errors.New("\"TrackerName\" is required but was not present")
    }
    return nil
}

func (strct *OpenSearchAction) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Endpoint" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Endpoint" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Endpoint\": ")
	if tmp, err := json.Marshal(strct.Endpoint); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Id" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Id" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Index" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Index" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Index\": ")
	if tmp, err := json.Marshal(strct.Index); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RoleArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoleArn\": ")
	if tmp, err := json.Marshal(strct.RoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *OpenSearchAction) UnmarshalJSON(b []byte) error {
    EndpointReceived := false
    IdReceived := false
    IndexReceived := false
    RoleArnReceived := false
    TypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Endpoint":
            if err := json.Unmarshal([]byte(v), &strct.Endpoint); err != nil {
                return err
             }
            EndpointReceived = true
        case "Id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
            IdReceived = true
        case "Index":
            if err := json.Unmarshal([]byte(v), &strct.Index); err != nil {
                return err
             }
            IndexReceived = true
        case "RoleArn":
            if err := json.Unmarshal([]byte(v), &strct.RoleArn); err != nil {
                return err
             }
            RoleArnReceived = true
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            TypeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Endpoint (a required property) was received
    if !EndpointReceived {
        return errors.New("\"Endpoint\" is required but was not present")
    }
    // check if Id (a required property) was received
    if !IdReceived {
        return errors.New("\"Id\" is required but was not present")
    }
    // check if Index (a required property) was received
    if !IndexReceived {
        return errors.New("\"Index\" is required but was not present")
    }
    // check if RoleArn (a required property) was received
    if !RoleArnReceived {
        return errors.New("\"RoleArn\" is required but was not present")
    }
    // check if Type (a required property) was received
    if !TypeReceived {
        return errors.New("\"Type\" is required but was not present")
    }
    return nil
}

func (strct *PutAssetPropertyValueEntry) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AssetId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AssetId\": ")
	if tmp, err := json.Marshal(strct.AssetId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EntryId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EntryId\": ")
	if tmp, err := json.Marshal(strct.EntryId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PropertyAlias" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PropertyAlias\": ")
	if tmp, err := json.Marshal(strct.PropertyAlias); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PropertyId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PropertyId\": ")
	if tmp, err := json.Marshal(strct.PropertyId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "PropertyValues" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "PropertyValues" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PropertyValues\": ")
	if tmp, err := json.Marshal(strct.PropertyValues); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PutAssetPropertyValueEntry) UnmarshalJSON(b []byte) error {
    PropertyValuesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AssetId":
            if err := json.Unmarshal([]byte(v), &strct.AssetId); err != nil {
                return err
             }
        case "EntryId":
            if err := json.Unmarshal([]byte(v), &strct.EntryId); err != nil {
                return err
             }
        case "PropertyAlias":
            if err := json.Unmarshal([]byte(v), &strct.PropertyAlias); err != nil {
                return err
             }
        case "PropertyId":
            if err := json.Unmarshal([]byte(v), &strct.PropertyId); err != nil {
                return err
             }
        case "PropertyValues":
            if err := json.Unmarshal([]byte(v), &strct.PropertyValues); err != nil {
                return err
             }
            PropertyValuesReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if PropertyValues (a required property) was received
    if !PropertyValuesReceived {
        return errors.New("\"PropertyValues\" is required but was not present")
    }
    return nil
}

func (strct *PutItemInput) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "TableName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TableName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TableName\": ")
	if tmp, err := json.Marshal(strct.TableName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PutItemInput) UnmarshalJSON(b []byte) error {
    TableNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "TableName":
            if err := json.Unmarshal([]byte(v), &strct.TableName); err != nil {
                return err
             }
            TableNameReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if TableName (a required property) was received
    if !TableNameReceived {
        return errors.New("\"TableName\" is required but was not present")
    }
    return nil
}

func (strct *RepublishAction) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Headers" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Headers\": ")
	if tmp, err := json.Marshal(strct.Headers); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Qos" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Qos\": ")
	if tmp, err := json.Marshal(strct.Qos); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RoleArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoleArn\": ")
	if tmp, err := json.Marshal(strct.RoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Topic" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Topic" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Topic\": ")
	if tmp, err := json.Marshal(strct.Topic); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RepublishAction) UnmarshalJSON(b []byte) error {
    RoleArnReceived := false
    TopicReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Headers":
            if err := json.Unmarshal([]byte(v), &strct.Headers); err != nil {
                return err
             }
        case "Qos":
            if err := json.Unmarshal([]byte(v), &strct.Qos); err != nil {
                return err
             }
        case "RoleArn":
            if err := json.Unmarshal([]byte(v), &strct.RoleArn); err != nil {
                return err
             }
            RoleArnReceived = true
        case "Topic":
            if err := json.Unmarshal([]byte(v), &strct.Topic); err != nil {
                return err
             }
            TopicReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if RoleArn (a required property) was received
    if !RoleArnReceived {
        return errors.New("\"RoleArn\" is required but was not present")
    }
    // check if Topic (a required property) was received
    if !TopicReceived {
        return errors.New("\"Topic\" is required but was not present")
    }
    return nil
}

func (strct *RepublishActionHeaders) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ContentType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ContentType\": ")
	if tmp, err := json.Marshal(strct.ContentType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CorrelationData" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CorrelationData\": ")
	if tmp, err := json.Marshal(strct.CorrelationData); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MessageExpiry" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MessageExpiry\": ")
	if tmp, err := json.Marshal(strct.MessageExpiry); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PayloadFormatIndicator" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PayloadFormatIndicator\": ")
	if tmp, err := json.Marshal(strct.PayloadFormatIndicator); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ResponseTopic" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ResponseTopic\": ")
	if tmp, err := json.Marshal(strct.ResponseTopic); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "UserProperties" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UserProperties\": ")
	if tmp, err := json.Marshal(strct.UserProperties); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RepublishActionHeaders) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ContentType":
            if err := json.Unmarshal([]byte(v), &strct.ContentType); err != nil {
                return err
             }
        case "CorrelationData":
            if err := json.Unmarshal([]byte(v), &strct.CorrelationData); err != nil {
                return err
             }
        case "MessageExpiry":
            if err := json.Unmarshal([]byte(v), &strct.MessageExpiry); err != nil {
                return err
             }
        case "PayloadFormatIndicator":
            if err := json.Unmarshal([]byte(v), &strct.PayloadFormatIndicator); err != nil {
                return err
             }
        case "ResponseTopic":
            if err := json.Unmarshal([]byte(v), &strct.ResponseTopic); err != nil {
                return err
             }
        case "UserProperties":
            if err := json.Unmarshal([]byte(v), &strct.UserProperties); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Arn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Arn\": ")
	if tmp, err := json.Marshal(strct.Arn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RuleName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RuleName\": ")
	if tmp, err := json.Marshal(strct.RuleName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TopicRulePayload" field is required
    if strct.TopicRulePayload == nil {
        return nil, errors.New("TopicRulePayload is a required field")
    }
    // Marshal the "TopicRulePayload" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TopicRulePayload\": ")
	if tmp, err := json.Marshal(strct.TopicRulePayload); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    TopicRulePayloadReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Arn":
            if err := json.Unmarshal([]byte(v), &strct.Arn); err != nil {
                return err
             }
        case "RuleName":
            if err := json.Unmarshal([]byte(v), &strct.RuleName); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        case "TopicRulePayload":
            if err := json.Unmarshal([]byte(v), &strct.TopicRulePayload); err != nil {
                return err
             }
            TopicRulePayloadReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if TopicRulePayload (a required property) was received
    if !TopicRulePayloadReceived {
        return errors.New("\"TopicRulePayload\" is required but was not present")
    }
    return nil
}

func (strct *S3Action) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "BucketName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "BucketName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BucketName\": ")
	if tmp, err := json.Marshal(strct.BucketName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CannedAcl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CannedAcl\": ")
	if tmp, err := json.Marshal(strct.CannedAcl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RoleArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoleArn\": ")
	if tmp, err := json.Marshal(strct.RoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *S3Action) UnmarshalJSON(b []byte) error {
    BucketNameReceived := false
    KeyReceived := false
    RoleArnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BucketName":
            if err := json.Unmarshal([]byte(v), &strct.BucketName); err != nil {
                return err
             }
            BucketNameReceived = true
        case "CannedAcl":
            if err := json.Unmarshal([]byte(v), &strct.CannedAcl); err != nil {
                return err
             }
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "RoleArn":
            if err := json.Unmarshal([]byte(v), &strct.RoleArn); err != nil {
                return err
             }
            RoleArnReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if BucketName (a required property) was received
    if !BucketNameReceived {
        return errors.New("\"BucketName\" is required but was not present")
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if RoleArn (a required property) was received
    if !RoleArnReceived {
        return errors.New("\"RoleArn\" is required but was not present")
    }
    return nil
}

func (strct *SigV4Authorization) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "RoleArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoleArn\": ")
	if tmp, err := json.Marshal(strct.RoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ServiceName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ServiceName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ServiceName\": ")
	if tmp, err := json.Marshal(strct.ServiceName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "SigningRegion" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "SigningRegion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SigningRegion\": ")
	if tmp, err := json.Marshal(strct.SigningRegion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SigV4Authorization) UnmarshalJSON(b []byte) error {
    RoleArnReceived := false
    ServiceNameReceived := false
    SigningRegionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "RoleArn":
            if err := json.Unmarshal([]byte(v), &strct.RoleArn); err != nil {
                return err
             }
            RoleArnReceived = true
        case "ServiceName":
            if err := json.Unmarshal([]byte(v), &strct.ServiceName); err != nil {
                return err
             }
            ServiceNameReceived = true
        case "SigningRegion":
            if err := json.Unmarshal([]byte(v), &strct.SigningRegion); err != nil {
                return err
             }
            SigningRegionReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if RoleArn (a required property) was received
    if !RoleArnReceived {
        return errors.New("\"RoleArn\" is required but was not present")
    }
    // check if ServiceName (a required property) was received
    if !ServiceNameReceived {
        return errors.New("\"ServiceName\" is required but was not present")
    }
    // check if SigningRegion (a required property) was received
    if !SigningRegionReceived {
        return errors.New("\"SigningRegion\" is required but was not present")
    }
    return nil
}

func (strct *SnsAction) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "MessageFormat" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MessageFormat\": ")
	if tmp, err := json.Marshal(strct.MessageFormat); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RoleArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoleArn\": ")
	if tmp, err := json.Marshal(strct.RoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TargetArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TargetArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TargetArn\": ")
	if tmp, err := json.Marshal(strct.TargetArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SnsAction) UnmarshalJSON(b []byte) error {
    RoleArnReceived := false
    TargetArnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "MessageFormat":
            if err := json.Unmarshal([]byte(v), &strct.MessageFormat); err != nil {
                return err
             }
        case "RoleArn":
            if err := json.Unmarshal([]byte(v), &strct.RoleArn); err != nil {
                return err
             }
            RoleArnReceived = true
        case "TargetArn":
            if err := json.Unmarshal([]byte(v), &strct.TargetArn); err != nil {
                return err
             }
            TargetArnReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if RoleArn (a required property) was received
    if !RoleArnReceived {
        return errors.New("\"RoleArn\" is required but was not present")
    }
    // check if TargetArn (a required property) was received
    if !TargetArnReceived {
        return errors.New("\"TargetArn\" is required but was not present")
    }
    return nil
}

func (strct *SqsAction) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "QueueUrl" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "QueueUrl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"QueueUrl\": ")
	if tmp, err := json.Marshal(strct.QueueUrl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RoleArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoleArn\": ")
	if tmp, err := json.Marshal(strct.RoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "UseBase64" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UseBase64\": ")
	if tmp, err := json.Marshal(strct.UseBase64); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SqsAction) UnmarshalJSON(b []byte) error {
    QueueUrlReceived := false
    RoleArnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "QueueUrl":
            if err := json.Unmarshal([]byte(v), &strct.QueueUrl); err != nil {
                return err
             }
            QueueUrlReceived = true
        case "RoleArn":
            if err := json.Unmarshal([]byte(v), &strct.RoleArn); err != nil {
                return err
             }
            RoleArnReceived = true
        case "UseBase64":
            if err := json.Unmarshal([]byte(v), &strct.UseBase64); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if QueueUrl (a required property) was received
    if !QueueUrlReceived {
        return errors.New("\"QueueUrl\" is required but was not present")
    }
    // check if RoleArn (a required property) was received
    if !RoleArnReceived {
        return errors.New("\"RoleArn\" is required but was not present")
    }
    return nil
}

func (strct *StepFunctionsAction) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ExecutionNamePrefix" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ExecutionNamePrefix\": ")
	if tmp, err := json.Marshal(strct.ExecutionNamePrefix); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RoleArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoleArn\": ")
	if tmp, err := json.Marshal(strct.RoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "StateMachineName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "StateMachineName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StateMachineName\": ")
	if tmp, err := json.Marshal(strct.StateMachineName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *StepFunctionsAction) UnmarshalJSON(b []byte) error {
    RoleArnReceived := false
    StateMachineNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ExecutionNamePrefix":
            if err := json.Unmarshal([]byte(v), &strct.ExecutionNamePrefix); err != nil {
                return err
             }
        case "RoleArn":
            if err := json.Unmarshal([]byte(v), &strct.RoleArn); err != nil {
                return err
             }
            RoleArnReceived = true
        case "StateMachineName":
            if err := json.Unmarshal([]byte(v), &strct.StateMachineName); err != nil {
                return err
             }
            StateMachineNameReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if RoleArn (a required property) was received
    if !RoleArnReceived {
        return errors.New("\"RoleArn\" is required but was not present")
    }
    // check if StateMachineName (a required property) was received
    if !StateMachineNameReceived {
        return errors.New("\"StateMachineName\" is required but was not present")
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *Timestamp) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Unit" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Unit\": ")
	if tmp, err := json.Marshal(strct.Unit); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Timestamp) UnmarshalJSON(b []byte) error {
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Unit":
            if err := json.Unmarshal([]byte(v), &strct.Unit); err != nil {
                return err
             }
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *TimestreamAction) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "DatabaseName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "DatabaseName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DatabaseName\": ")
	if tmp, err := json.Marshal(strct.DatabaseName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Dimensions" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Dimensions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Dimensions\": ")
	if tmp, err := json.Marshal(strct.Dimensions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RoleArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoleArn\": ")
	if tmp, err := json.Marshal(strct.RoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TableName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TableName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TableName\": ")
	if tmp, err := json.Marshal(strct.TableName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Timestamp" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Timestamp\": ")
	if tmp, err := json.Marshal(strct.Timestamp); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TimestreamAction) UnmarshalJSON(b []byte) error {
    DatabaseNameReceived := false
    DimensionsReceived := false
    RoleArnReceived := false
    TableNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DatabaseName":
            if err := json.Unmarshal([]byte(v), &strct.DatabaseName); err != nil {
                return err
             }
            DatabaseNameReceived = true
        case "Dimensions":
            if err := json.Unmarshal([]byte(v), &strct.Dimensions); err != nil {
                return err
             }
            DimensionsReceived = true
        case "RoleArn":
            if err := json.Unmarshal([]byte(v), &strct.RoleArn); err != nil {
                return err
             }
            RoleArnReceived = true
        case "TableName":
            if err := json.Unmarshal([]byte(v), &strct.TableName); err != nil {
                return err
             }
            TableNameReceived = true
        case "Timestamp":
            if err := json.Unmarshal([]byte(v), &strct.Timestamp); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if DatabaseName (a required property) was received
    if !DatabaseNameReceived {
        return errors.New("\"DatabaseName\" is required but was not present")
    }
    // check if Dimensions (a required property) was received
    if !DimensionsReceived {
        return errors.New("\"Dimensions\" is required but was not present")
    }
    // check if RoleArn (a required property) was received
    if !RoleArnReceived {
        return errors.New("\"RoleArn\" is required but was not present")
    }
    // check if TableName (a required property) was received
    if !TableNameReceived {
        return errors.New("\"TableName\" is required but was not present")
    }
    return nil
}

func (strct *TimestreamDimension) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TimestreamDimension) UnmarshalJSON(b []byte) error {
    NameReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *TimestreamTimestamp) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Unit" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Unit" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Unit\": ")
	if tmp, err := json.Marshal(strct.Unit); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TimestreamTimestamp) UnmarshalJSON(b []byte) error {
    UnitReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Unit":
            if err := json.Unmarshal([]byte(v), &strct.Unit); err != nil {
                return err
             }
            UnitReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Unit (a required property) was received
    if !UnitReceived {
        return errors.New("\"Unit\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *TopicRulePayload) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Actions" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Actions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Actions\": ")
	if tmp, err := json.Marshal(strct.Actions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AwsIotSqlVersion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AwsIotSqlVersion\": ")
	if tmp, err := json.Marshal(strct.AwsIotSqlVersion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ErrorAction" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ErrorAction\": ")
	if tmp, err := json.Marshal(strct.ErrorAction); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RuleDisabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RuleDisabled\": ")
	if tmp, err := json.Marshal(strct.RuleDisabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Sql" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Sql" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Sql\": ")
	if tmp, err := json.Marshal(strct.Sql); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TopicRulePayload) UnmarshalJSON(b []byte) error {
    ActionsReceived := false
    SqlReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Actions":
            if err := json.Unmarshal([]byte(v), &strct.Actions); err != nil {
                return err
             }
            ActionsReceived = true
        case "AwsIotSqlVersion":
            if err := json.Unmarshal([]byte(v), &strct.AwsIotSqlVersion); err != nil {
                return err
             }
        case "Description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "ErrorAction":
            if err := json.Unmarshal([]byte(v), &strct.ErrorAction); err != nil {
                return err
             }
        case "RuleDisabled":
            if err := json.Unmarshal([]byte(v), &strct.RuleDisabled); err != nil {
                return err
             }
        case "Sql":
            if err := json.Unmarshal([]byte(v), &strct.Sql); err != nil {
                return err
             }
            SqlReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Actions (a required property) was received
    if !ActionsReceived {
        return errors.New("\"Actions\" is required but was not present")
    }
    // check if Sql (a required property) was received
    if !SqlReceived {
        return errors.New("\"Sql\" is required but was not present")
    }
    return nil
}

func (strct *UserProperty) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *UserProperty) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}
