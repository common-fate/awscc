// Code generated by schema-generate. DO NOT EDIT.

package mitigationaction

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// ActionParams The set of parameters for this mitigation action. You can specify only one type of parameter (in other words, you can apply only one action for each defined mitigation action).
type ActionParams struct {
  AddThingsToThingGroupParams *AddThingsToThingGroupParams `json:"AddThingsToThingGroupParams,omitempty"`
  EnableIoTLoggingParams *EnableIoTLoggingParams `json:"EnableIoTLoggingParams,omitempty"`
  PublishFindingToSnsParams *PublishFindingToSnsParams `json:"PublishFindingToSnsParams,omitempty"`
  ReplaceDefaultPolicyVersionParams *ReplaceDefaultPolicyVersionParams `json:"ReplaceDefaultPolicyVersionParams,omitempty"`
  UpdateCACertificateParams *UpdateCACertificateParams `json:"UpdateCACertificateParams,omitempty"`
  UpdateDeviceCertificateParams *UpdateDeviceCertificateParams `json:"UpdateDeviceCertificateParams,omitempty"`
}

// AddThingsToThingGroupParams Parameters to define a mitigation action that moves devices associated with a certificate to one or more specified thing groups, typically for quarantine.
type AddThingsToThingGroupParams struct {

  // Specifies if this mitigation action can move the things that triggered the mitigation action out of one or more dynamic thing groups.
  OverrideDynamicGroups bool `json:"OverrideDynamicGroups,omitempty"`

  // The list of groups to which you want to add the things that triggered the mitigation action.
  ThingGroupNames []string `json:"ThingGroupNames"`
}

// EnableIoTLoggingParams Parameters to define a mitigation action that enables AWS IoT logging at a specified level of detail.
type EnableIoTLoggingParams struct {

  //  Specifies which types of information are logged.
  LogLevel string `json:"LogLevel"`

  //  The ARN of the IAM role used for logging.
  RoleArnForLogging string `json:"RoleArnForLogging"`
}

// PublishFindingToSnsParams Parameters, to define a mitigation action that publishes findings to Amazon SNS. You can implement your own custom actions in response to the Amazon SNS messages.
type PublishFindingToSnsParams struct {

  // The ARN of the topic to which you want to publish the findings.
  TopicArn string `json:"TopicArn"`
}

// ReplaceDefaultPolicyVersionParams Parameters to define a mitigation action that adds a blank policy to restrict permissions.
type ReplaceDefaultPolicyVersionParams struct {
  TemplateName string `json:"TemplateName"`
}

// Resource Mitigation actions can be used to take actions to mitigate issues that were found in an Audit finding or Detect violation.
type Resource struct {

  // A unique identifier for the mitigation action.
  ActionName string `json:"ActionName,omitempty"`
  ActionParams *ActionParams `json:"ActionParams"`
  MitigationActionArn string `json:"MitigationActionArn,omitempty"`
  MitigationActionId string `json:"MitigationActionId,omitempty"`
  RoleArn string `json:"RoleArn"`

  // An array of key-value pairs to apply to this resource.
  Tags []*Tag `json:"Tags,omitempty"`
}

// Tag A key-value pair to associate with a resource.
type Tag struct {

  // The tag's key.
  Key string `json:"Key"`

  // The tag's value.
  Value string `json:"Value"`
}

// UpdateCACertificateParams Parameters to define a mitigation action that changes the state of the CA certificate to inactive.
type UpdateCACertificateParams struct {
  Action string `json:"Action"`
}

// UpdateDeviceCertificateParams Parameters to define a mitigation action that changes the state of the device certificate to inactive.
type UpdateDeviceCertificateParams struct {
  Action string `json:"Action"`
}

func (strct *ActionParams) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AddThingsToThingGroupParams" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AddThingsToThingGroupParams\": ")
	if tmp, err := json.Marshal(strct.AddThingsToThingGroupParams); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EnableIoTLoggingParams" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EnableIoTLoggingParams\": ")
	if tmp, err := json.Marshal(strct.EnableIoTLoggingParams); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PublishFindingToSnsParams" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PublishFindingToSnsParams\": ")
	if tmp, err := json.Marshal(strct.PublishFindingToSnsParams); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ReplaceDefaultPolicyVersionParams" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ReplaceDefaultPolicyVersionParams\": ")
	if tmp, err := json.Marshal(strct.ReplaceDefaultPolicyVersionParams); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "UpdateCACertificateParams" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UpdateCACertificateParams\": ")
	if tmp, err := json.Marshal(strct.UpdateCACertificateParams); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "UpdateDeviceCertificateParams" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UpdateDeviceCertificateParams\": ")
	if tmp, err := json.Marshal(strct.UpdateDeviceCertificateParams); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ActionParams) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AddThingsToThingGroupParams":
            if err := json.Unmarshal([]byte(v), &strct.AddThingsToThingGroupParams); err != nil {
                return err
             }
        case "EnableIoTLoggingParams":
            if err := json.Unmarshal([]byte(v), &strct.EnableIoTLoggingParams); err != nil {
                return err
             }
        case "PublishFindingToSnsParams":
            if err := json.Unmarshal([]byte(v), &strct.PublishFindingToSnsParams); err != nil {
                return err
             }
        case "ReplaceDefaultPolicyVersionParams":
            if err := json.Unmarshal([]byte(v), &strct.ReplaceDefaultPolicyVersionParams); err != nil {
                return err
             }
        case "UpdateCACertificateParams":
            if err := json.Unmarshal([]byte(v), &strct.UpdateCACertificateParams); err != nil {
                return err
             }
        case "UpdateDeviceCertificateParams":
            if err := json.Unmarshal([]byte(v), &strct.UpdateDeviceCertificateParams); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *AddThingsToThingGroupParams) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "OverrideDynamicGroups" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OverrideDynamicGroups\": ")
	if tmp, err := json.Marshal(strct.OverrideDynamicGroups); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ThingGroupNames" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ThingGroupNames" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ThingGroupNames\": ")
	if tmp, err := json.Marshal(strct.ThingGroupNames); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AddThingsToThingGroupParams) UnmarshalJSON(b []byte) error {
    ThingGroupNamesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "OverrideDynamicGroups":
            if err := json.Unmarshal([]byte(v), &strct.OverrideDynamicGroups); err != nil {
                return err
             }
        case "ThingGroupNames":
            if err := json.Unmarshal([]byte(v), &strct.ThingGroupNames); err != nil {
                return err
             }
            ThingGroupNamesReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ThingGroupNames (a required property) was received
    if !ThingGroupNamesReceived {
        return errors.New("\"ThingGroupNames\" is required but was not present")
    }
    return nil
}

func (strct *EnableIoTLoggingParams) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "LogLevel" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "LogLevel" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LogLevel\": ")
	if tmp, err := json.Marshal(strct.LogLevel); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RoleArnForLogging" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RoleArnForLogging" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoleArnForLogging\": ")
	if tmp, err := json.Marshal(strct.RoleArnForLogging); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *EnableIoTLoggingParams) UnmarshalJSON(b []byte) error {
    LogLevelReceived := false
    RoleArnForLoggingReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "LogLevel":
            if err := json.Unmarshal([]byte(v), &strct.LogLevel); err != nil {
                return err
             }
            LogLevelReceived = true
        case "RoleArnForLogging":
            if err := json.Unmarshal([]byte(v), &strct.RoleArnForLogging); err != nil {
                return err
             }
            RoleArnForLoggingReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if LogLevel (a required property) was received
    if !LogLevelReceived {
        return errors.New("\"LogLevel\" is required but was not present")
    }
    // check if RoleArnForLogging (a required property) was received
    if !RoleArnForLoggingReceived {
        return errors.New("\"RoleArnForLogging\" is required but was not present")
    }
    return nil
}

func (strct *PublishFindingToSnsParams) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "TopicArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TopicArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TopicArn\": ")
	if tmp, err := json.Marshal(strct.TopicArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PublishFindingToSnsParams) UnmarshalJSON(b []byte) error {
    TopicArnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "TopicArn":
            if err := json.Unmarshal([]byte(v), &strct.TopicArn); err != nil {
                return err
             }
            TopicArnReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if TopicArn (a required property) was received
    if !TopicArnReceived {
        return errors.New("\"TopicArn\" is required but was not present")
    }
    return nil
}

func (strct *ReplaceDefaultPolicyVersionParams) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "TemplateName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TemplateName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TemplateName\": ")
	if tmp, err := json.Marshal(strct.TemplateName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ReplaceDefaultPolicyVersionParams) UnmarshalJSON(b []byte) error {
    TemplateNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "TemplateName":
            if err := json.Unmarshal([]byte(v), &strct.TemplateName); err != nil {
                return err
             }
            TemplateNameReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if TemplateName (a required property) was received
    if !TemplateNameReceived {
        return errors.New("\"TemplateName\" is required but was not present")
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ActionName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ActionName\": ")
	if tmp, err := json.Marshal(strct.ActionName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ActionParams" field is required
    if strct.ActionParams == nil {
        return nil, errors.New("ActionParams is a required field")
    }
    // Marshal the "ActionParams" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ActionParams\": ")
	if tmp, err := json.Marshal(strct.ActionParams); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MitigationActionArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MitigationActionArn\": ")
	if tmp, err := json.Marshal(strct.MitigationActionArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MitigationActionId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MitigationActionId\": ")
	if tmp, err := json.Marshal(strct.MitigationActionId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RoleArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoleArn\": ")
	if tmp, err := json.Marshal(strct.RoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    ActionParamsReceived := false
    RoleArnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ActionName":
            if err := json.Unmarshal([]byte(v), &strct.ActionName); err != nil {
                return err
             }
        case "ActionParams":
            if err := json.Unmarshal([]byte(v), &strct.ActionParams); err != nil {
                return err
             }
            ActionParamsReceived = true
        case "MitigationActionArn":
            if err := json.Unmarshal([]byte(v), &strct.MitigationActionArn); err != nil {
                return err
             }
        case "MitigationActionId":
            if err := json.Unmarshal([]byte(v), &strct.MitigationActionId); err != nil {
                return err
             }
        case "RoleArn":
            if err := json.Unmarshal([]byte(v), &strct.RoleArn); err != nil {
                return err
             }
            RoleArnReceived = true
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ActionParams (a required property) was received
    if !ActionParamsReceived {
        return errors.New("\"ActionParams\" is required but was not present")
    }
    // check if RoleArn (a required property) was received
    if !RoleArnReceived {
        return errors.New("\"RoleArn\" is required but was not present")
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *UpdateCACertificateParams) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Action" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Action" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Action\": ")
	if tmp, err := json.Marshal(strct.Action); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *UpdateCACertificateParams) UnmarshalJSON(b []byte) error {
    ActionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Action":
            if err := json.Unmarshal([]byte(v), &strct.Action); err != nil {
                return err
             }
            ActionReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Action (a required property) was received
    if !ActionReceived {
        return errors.New("\"Action\" is required but was not present")
    }
    return nil
}

func (strct *UpdateDeviceCertificateParams) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Action" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Action" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Action\": ")
	if tmp, err := json.Marshal(strct.Action); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *UpdateDeviceCertificateParams) UnmarshalJSON(b []byte) error {
    ActionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Action":
            if err := json.Unmarshal([]byte(v), &strct.Action); err != nil {
                return err
             }
            ActionReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Action (a required property) was received
    if !ActionReceived {
        return errors.New("\"Action\" is required but was not present")
    }
    return nil
}
