// Code generated by schema-generate. DO NOT EDIT.

package scheduledaudit

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// Resource Scheduled audits can be used to specify the checks you want to perform during an audit and how often the audit should be run.
type Resource struct {

  // The day of the month on which the scheduled audit takes place. Can be 1 through 31 or LAST. This field is required if the frequency parameter is set to MONTHLY.
  DayOfMonth string `json:"DayOfMonth,omitempty"`

  // The day of the week on which the scheduled audit takes place. Can be one of SUN, MON, TUE,WED, THU, FRI, or SAT. This field is required if the frequency parameter is set to WEEKLY or BIWEEKLY.
  DayOfWeek string `json:"DayOfWeek,omitempty"`

  // How often the scheduled audit takes place. Can be one of DAILY, WEEKLY, BIWEEKLY, or MONTHLY.
  Frequency string `json:"Frequency"`

  // The ARN (Amazon resource name) of the scheduled audit.
  ScheduledAuditArn string `json:"ScheduledAuditArn,omitempty"`

  // The name you want to give to the scheduled audit.
  ScheduledAuditName string `json:"ScheduledAuditName,omitempty"`

  // An array of key-value pairs to apply to this resource.
  Tags []*Tag `json:"Tags,omitempty"`

  // Which checks are performed during the scheduled audit. Checks must be enabled for your account.
  TargetCheckNames []string `json:"TargetCheckNames"`
}

// Tag A key-value pair to associate with a resource.
type Tag struct {

  // The tag's key.
  Key string `json:"Key"`

  // The tag's value.
  Value string `json:"Value"`
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DayOfMonth" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DayOfMonth\": ")
	if tmp, err := json.Marshal(strct.DayOfMonth); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DayOfWeek" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DayOfWeek\": ")
	if tmp, err := json.Marshal(strct.DayOfWeek); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Frequency" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Frequency" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Frequency\": ")
	if tmp, err := json.Marshal(strct.Frequency); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ScheduledAuditArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ScheduledAuditArn\": ")
	if tmp, err := json.Marshal(strct.ScheduledAuditArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ScheduledAuditName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ScheduledAuditName\": ")
	if tmp, err := json.Marshal(strct.ScheduledAuditName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TargetCheckNames" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TargetCheckNames" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TargetCheckNames\": ")
	if tmp, err := json.Marshal(strct.TargetCheckNames); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    FrequencyReceived := false
    TargetCheckNamesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DayOfMonth":
            if err := json.Unmarshal([]byte(v), &strct.DayOfMonth); err != nil {
                return err
             }
        case "DayOfWeek":
            if err := json.Unmarshal([]byte(v), &strct.DayOfWeek); err != nil {
                return err
             }
        case "Frequency":
            if err := json.Unmarshal([]byte(v), &strct.Frequency); err != nil {
                return err
             }
            FrequencyReceived = true
        case "ScheduledAuditArn":
            if err := json.Unmarshal([]byte(v), &strct.ScheduledAuditArn); err != nil {
                return err
             }
        case "ScheduledAuditName":
            if err := json.Unmarshal([]byte(v), &strct.ScheduledAuditName); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        case "TargetCheckNames":
            if err := json.Unmarshal([]byte(v), &strct.TargetCheckNames); err != nil {
                return err
             }
            TargetCheckNamesReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Frequency (a required property) was received
    if !FrequencyReceived {
        return errors.New("\"Frequency\" is required but was not present")
    }
    // check if TargetCheckNames (a required property) was received
    if !TargetCheckNamesReceived {
        return errors.New("\"TargetCheckNames\" is required but was not present")
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}
