// Code generated by schema-generate. DO NOT EDIT.

package application

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// Resource Resource schema for AWS::IoTFleetHub::Application
type Resource struct {

  // The ARN of the application.
  ApplicationArn string `json:"ApplicationArn,omitempty"`

  // When the Application was created
  ApplicationCreationDate int `json:"ApplicationCreationDate,omitempty"`

  // Application Description, should be between 1 and 2048 characters.
  ApplicationDescription string `json:"ApplicationDescription,omitempty"`

  // The ID of the application.
  ApplicationId string `json:"ApplicationId,omitempty"`

  // When the Application was last updated
  ApplicationLastUpdateDate int `json:"ApplicationLastUpdateDate,omitempty"`

  // Application Name, should be between 1 and 256 characters.
  ApplicationName string `json:"ApplicationName"`

  // The current state of the application.
  ApplicationState string `json:"ApplicationState,omitempty"`

  // The URL of the application.
  ApplicationUrl string `json:"ApplicationUrl,omitempty"`

  // A message indicating why Create or Delete Application failed.
  ErrorMessage string `json:"ErrorMessage,omitempty"`

  // The ARN of the role that the web application assumes when it interacts with AWS IoT Core. For more info on configuring this attribute, see https://docs.aws.amazon.com/iot/latest/apireference/API_iotfleethub_CreateApplication.html#API_iotfleethub_CreateApplication_RequestSyntax
  RoleArn string `json:"RoleArn"`

  // The AWS SSO application generated client ID (used with AWS SSO APIs).
  SsoClientId string `json:"SsoClientId,omitempty"`

  // A list of key-value pairs that contain metadata for the application.
  Tags []*Tag `json:"Tags,omitempty"`
}

// Tag To add or update tag, provide both key and value. To delete tag, provide only tag key to be deleted.
type Tag struct {

  // The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
  Key string `json:"Key"`

  // The value for the tag. You can specify a value that is 1 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
  Value string `json:"Value"`
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ApplicationArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ApplicationArn\": ")
	if tmp, err := json.Marshal(strct.ApplicationArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ApplicationCreationDate" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ApplicationCreationDate\": ")
	if tmp, err := json.Marshal(strct.ApplicationCreationDate); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ApplicationDescription" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ApplicationDescription\": ")
	if tmp, err := json.Marshal(strct.ApplicationDescription); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ApplicationId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ApplicationId\": ")
	if tmp, err := json.Marshal(strct.ApplicationId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ApplicationLastUpdateDate" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ApplicationLastUpdateDate\": ")
	if tmp, err := json.Marshal(strct.ApplicationLastUpdateDate); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ApplicationName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ApplicationName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ApplicationName\": ")
	if tmp, err := json.Marshal(strct.ApplicationName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ApplicationState" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ApplicationState\": ")
	if tmp, err := json.Marshal(strct.ApplicationState); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ApplicationUrl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ApplicationUrl\": ")
	if tmp, err := json.Marshal(strct.ApplicationUrl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ErrorMessage" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ErrorMessage\": ")
	if tmp, err := json.Marshal(strct.ErrorMessage); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RoleArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoleArn\": ")
	if tmp, err := json.Marshal(strct.RoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SsoClientId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SsoClientId\": ")
	if tmp, err := json.Marshal(strct.SsoClientId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    ApplicationNameReceived := false
    RoleArnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ApplicationArn":
            if err := json.Unmarshal([]byte(v), &strct.ApplicationArn); err != nil {
                return err
             }
        case "ApplicationCreationDate":
            if err := json.Unmarshal([]byte(v), &strct.ApplicationCreationDate); err != nil {
                return err
             }
        case "ApplicationDescription":
            if err := json.Unmarshal([]byte(v), &strct.ApplicationDescription); err != nil {
                return err
             }
        case "ApplicationId":
            if err := json.Unmarshal([]byte(v), &strct.ApplicationId); err != nil {
                return err
             }
        case "ApplicationLastUpdateDate":
            if err := json.Unmarshal([]byte(v), &strct.ApplicationLastUpdateDate); err != nil {
                return err
             }
        case "ApplicationName":
            if err := json.Unmarshal([]byte(v), &strct.ApplicationName); err != nil {
                return err
             }
            ApplicationNameReceived = true
        case "ApplicationState":
            if err := json.Unmarshal([]byte(v), &strct.ApplicationState); err != nil {
                return err
             }
        case "ApplicationUrl":
            if err := json.Unmarshal([]byte(v), &strct.ApplicationUrl); err != nil {
                return err
             }
        case "ErrorMessage":
            if err := json.Unmarshal([]byte(v), &strct.ErrorMessage); err != nil {
                return err
             }
        case "RoleArn":
            if err := json.Unmarshal([]byte(v), &strct.RoleArn); err != nil {
                return err
             }
            RoleArnReceived = true
        case "SsoClientId":
            if err := json.Unmarshal([]byte(v), &strct.SsoClientId); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ApplicationName (a required property) was received
    if !ApplicationNameReceived {
        return errors.New("\"ApplicationName\" is required but was not present")
    }
    // check if RoleArn (a required property) was received
    if !RoleArnReceived {
        return errors.New("\"RoleArn\" is required but was not present")
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}
