// Code generated by schema-generate. DO NOT EDIT.

package componentversion

import (
    "bytes"
    "encoding/json"
    "fmt"
)

// Attributes 
type Attributes struct {
}

// ComponentDependencies 
type ComponentDependencies struct {
}

// ComponentDependencyRequirement 
type ComponentDependencyRequirement struct {
  DependencyType string `json:"DependencyType,omitempty"`
  VersionRequirement string `json:"VersionRequirement,omitempty"`
}

// ComponentPlatform 
type ComponentPlatform struct {
  Attributes *Attributes `json:"Attributes,omitempty"`
  Name string `json:"Name,omitempty"`
}

// EnvironmentVariables 
type EnvironmentVariables struct {
}

// LambdaContainerParams 
type LambdaContainerParams struct {
  Devices []*LambdaDeviceMount `json:"Devices,omitempty"`
  MemorySizeInKB int `json:"MemorySizeInKB,omitempty"`
  MountROSysfs bool `json:"MountROSysfs,omitempty"`
  Volumes []*LambdaVolumeMount `json:"Volumes,omitempty"`
}

// LambdaDeviceMount 
type LambdaDeviceMount struct {
  AddGroupOwner bool `json:"AddGroupOwner,omitempty"`
  Path string `json:"Path,omitempty"`
  Permission string `json:"Permission,omitempty"`
}

// LambdaEventSource 
type LambdaEventSource struct {
  Topic string `json:"Topic,omitempty"`
  Type string `json:"Type,omitempty"`
}

// LambdaExecutionParameters 
type LambdaExecutionParameters struct {
  EnvironmentVariables *EnvironmentVariables `json:"EnvironmentVariables,omitempty"`
  EventSources []*LambdaEventSource `json:"EventSources,omitempty"`
  ExecArgs []string `json:"ExecArgs,omitempty"`
  InputPayloadEncodingType string `json:"InputPayloadEncodingType,omitempty"`
  LinuxProcessParams *LambdaLinuxProcessParams `json:"LinuxProcessParams,omitempty"`
  MaxIdleTimeInSeconds int `json:"MaxIdleTimeInSeconds,omitempty"`
  MaxInstancesCount int `json:"MaxInstancesCount,omitempty"`
  MaxQueueSize int `json:"MaxQueueSize,omitempty"`
  Pinned bool `json:"Pinned,omitempty"`
  StatusTimeoutInSeconds int `json:"StatusTimeoutInSeconds,omitempty"`
  TimeoutInSeconds int `json:"TimeoutInSeconds,omitempty"`
}

// LambdaFunctionRecipeSource 
type LambdaFunctionRecipeSource struct {
  ComponentDependencies *ComponentDependencies `json:"ComponentDependencies,omitempty"`
  ComponentLambdaParameters *LambdaExecutionParameters `json:"ComponentLambdaParameters,omitempty"`
  ComponentName string `json:"ComponentName,omitempty"`
  ComponentPlatforms []*ComponentPlatform `json:"ComponentPlatforms,omitempty"`
  ComponentVersion string `json:"ComponentVersion,omitempty"`
  LambdaArn string `json:"LambdaArn,omitempty"`
}

// LambdaLinuxProcessParams 
type LambdaLinuxProcessParams struct {
  ContainerParams *LambdaContainerParams `json:"ContainerParams,omitempty"`
  IsolationMode string `json:"IsolationMode,omitempty"`
}

// LambdaVolumeMount 
type LambdaVolumeMount struct {
  AddGroupOwner bool `json:"AddGroupOwner,omitempty"`
  DestinationPath string `json:"DestinationPath,omitempty"`
  Permission string `json:"Permission,omitempty"`
  SourcePath string `json:"SourcePath,omitempty"`
}

// Resource Resource for Greengrass component version.
type Resource struct {
  Arn string `json:"Arn,omitempty"`
  ComponentName string `json:"ComponentName,omitempty"`
  ComponentVersion string `json:"ComponentVersion,omitempty"`
  InlineRecipe string `json:"InlineRecipe,omitempty"`
  LambdaFunction *LambdaFunctionRecipeSource `json:"LambdaFunction,omitempty"`
  Tags *Tags `json:"Tags,omitempty"`
}

// Tags 
type Tags struct {
}

func (strct *Attributes) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Attributes) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ComponentDependencies) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ComponentDependencies) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ComponentDependencyRequirement) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DependencyType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DependencyType\": ")
	if tmp, err := json.Marshal(strct.DependencyType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VersionRequirement" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VersionRequirement\": ")
	if tmp, err := json.Marshal(strct.VersionRequirement); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ComponentDependencyRequirement) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DependencyType":
            if err := json.Unmarshal([]byte(v), &strct.DependencyType); err != nil {
                return err
             }
        case "VersionRequirement":
            if err := json.Unmarshal([]byte(v), &strct.VersionRequirement); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ComponentPlatform) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Attributes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Attributes\": ")
	if tmp, err := json.Marshal(strct.Attributes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ComponentPlatform) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Attributes":
            if err := json.Unmarshal([]byte(v), &strct.Attributes); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *EnvironmentVariables) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *EnvironmentVariables) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *LambdaContainerParams) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Devices" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Devices\": ")
	if tmp, err := json.Marshal(strct.Devices); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MemorySizeInKB" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MemorySizeInKB\": ")
	if tmp, err := json.Marshal(strct.MemorySizeInKB); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MountROSysfs" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MountROSysfs\": ")
	if tmp, err := json.Marshal(strct.MountROSysfs); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Volumes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Volumes\": ")
	if tmp, err := json.Marshal(strct.Volumes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LambdaContainerParams) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Devices":
            if err := json.Unmarshal([]byte(v), &strct.Devices); err != nil {
                return err
             }
        case "MemorySizeInKB":
            if err := json.Unmarshal([]byte(v), &strct.MemorySizeInKB); err != nil {
                return err
             }
        case "MountROSysfs":
            if err := json.Unmarshal([]byte(v), &strct.MountROSysfs); err != nil {
                return err
             }
        case "Volumes":
            if err := json.Unmarshal([]byte(v), &strct.Volumes); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *LambdaDeviceMount) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AddGroupOwner" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AddGroupOwner\": ")
	if tmp, err := json.Marshal(strct.AddGroupOwner); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Path" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Path\": ")
	if tmp, err := json.Marshal(strct.Path); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Permission" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Permission\": ")
	if tmp, err := json.Marshal(strct.Permission); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LambdaDeviceMount) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AddGroupOwner":
            if err := json.Unmarshal([]byte(v), &strct.AddGroupOwner); err != nil {
                return err
             }
        case "Path":
            if err := json.Unmarshal([]byte(v), &strct.Path); err != nil {
                return err
             }
        case "Permission":
            if err := json.Unmarshal([]byte(v), &strct.Permission); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *LambdaEventSource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Topic" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Topic\": ")
	if tmp, err := json.Marshal(strct.Topic); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LambdaEventSource) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Topic":
            if err := json.Unmarshal([]byte(v), &strct.Topic); err != nil {
                return err
             }
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *LambdaExecutionParameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "EnvironmentVariables" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EnvironmentVariables\": ")
	if tmp, err := json.Marshal(strct.EnvironmentVariables); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EventSources" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EventSources\": ")
	if tmp, err := json.Marshal(strct.EventSources); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ExecArgs" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ExecArgs\": ")
	if tmp, err := json.Marshal(strct.ExecArgs); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "InputPayloadEncodingType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InputPayloadEncodingType\": ")
	if tmp, err := json.Marshal(strct.InputPayloadEncodingType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LinuxProcessParams" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LinuxProcessParams\": ")
	if tmp, err := json.Marshal(strct.LinuxProcessParams); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MaxIdleTimeInSeconds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaxIdleTimeInSeconds\": ")
	if tmp, err := json.Marshal(strct.MaxIdleTimeInSeconds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MaxInstancesCount" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaxInstancesCount\": ")
	if tmp, err := json.Marshal(strct.MaxInstancesCount); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MaxQueueSize" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaxQueueSize\": ")
	if tmp, err := json.Marshal(strct.MaxQueueSize); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Pinned" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Pinned\": ")
	if tmp, err := json.Marshal(strct.Pinned); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StatusTimeoutInSeconds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StatusTimeoutInSeconds\": ")
	if tmp, err := json.Marshal(strct.StatusTimeoutInSeconds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TimeoutInSeconds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TimeoutInSeconds\": ")
	if tmp, err := json.Marshal(strct.TimeoutInSeconds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LambdaExecutionParameters) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "EnvironmentVariables":
            if err := json.Unmarshal([]byte(v), &strct.EnvironmentVariables); err != nil {
                return err
             }
        case "EventSources":
            if err := json.Unmarshal([]byte(v), &strct.EventSources); err != nil {
                return err
             }
        case "ExecArgs":
            if err := json.Unmarshal([]byte(v), &strct.ExecArgs); err != nil {
                return err
             }
        case "InputPayloadEncodingType":
            if err := json.Unmarshal([]byte(v), &strct.InputPayloadEncodingType); err != nil {
                return err
             }
        case "LinuxProcessParams":
            if err := json.Unmarshal([]byte(v), &strct.LinuxProcessParams); err != nil {
                return err
             }
        case "MaxIdleTimeInSeconds":
            if err := json.Unmarshal([]byte(v), &strct.MaxIdleTimeInSeconds); err != nil {
                return err
             }
        case "MaxInstancesCount":
            if err := json.Unmarshal([]byte(v), &strct.MaxInstancesCount); err != nil {
                return err
             }
        case "MaxQueueSize":
            if err := json.Unmarshal([]byte(v), &strct.MaxQueueSize); err != nil {
                return err
             }
        case "Pinned":
            if err := json.Unmarshal([]byte(v), &strct.Pinned); err != nil {
                return err
             }
        case "StatusTimeoutInSeconds":
            if err := json.Unmarshal([]byte(v), &strct.StatusTimeoutInSeconds); err != nil {
                return err
             }
        case "TimeoutInSeconds":
            if err := json.Unmarshal([]byte(v), &strct.TimeoutInSeconds); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *LambdaFunctionRecipeSource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ComponentDependencies" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ComponentDependencies\": ")
	if tmp, err := json.Marshal(strct.ComponentDependencies); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ComponentLambdaParameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ComponentLambdaParameters\": ")
	if tmp, err := json.Marshal(strct.ComponentLambdaParameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ComponentName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ComponentName\": ")
	if tmp, err := json.Marshal(strct.ComponentName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ComponentPlatforms" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ComponentPlatforms\": ")
	if tmp, err := json.Marshal(strct.ComponentPlatforms); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ComponentVersion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ComponentVersion\": ")
	if tmp, err := json.Marshal(strct.ComponentVersion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LambdaArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LambdaArn\": ")
	if tmp, err := json.Marshal(strct.LambdaArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LambdaFunctionRecipeSource) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ComponentDependencies":
            if err := json.Unmarshal([]byte(v), &strct.ComponentDependencies); err != nil {
                return err
             }
        case "ComponentLambdaParameters":
            if err := json.Unmarshal([]byte(v), &strct.ComponentLambdaParameters); err != nil {
                return err
             }
        case "ComponentName":
            if err := json.Unmarshal([]byte(v), &strct.ComponentName); err != nil {
                return err
             }
        case "ComponentPlatforms":
            if err := json.Unmarshal([]byte(v), &strct.ComponentPlatforms); err != nil {
                return err
             }
        case "ComponentVersion":
            if err := json.Unmarshal([]byte(v), &strct.ComponentVersion); err != nil {
                return err
             }
        case "LambdaArn":
            if err := json.Unmarshal([]byte(v), &strct.LambdaArn); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *LambdaLinuxProcessParams) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ContainerParams" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ContainerParams\": ")
	if tmp, err := json.Marshal(strct.ContainerParams); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IsolationMode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IsolationMode\": ")
	if tmp, err := json.Marshal(strct.IsolationMode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LambdaLinuxProcessParams) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ContainerParams":
            if err := json.Unmarshal([]byte(v), &strct.ContainerParams); err != nil {
                return err
             }
        case "IsolationMode":
            if err := json.Unmarshal([]byte(v), &strct.IsolationMode); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *LambdaVolumeMount) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AddGroupOwner" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AddGroupOwner\": ")
	if tmp, err := json.Marshal(strct.AddGroupOwner); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DestinationPath" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DestinationPath\": ")
	if tmp, err := json.Marshal(strct.DestinationPath); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Permission" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Permission\": ")
	if tmp, err := json.Marshal(strct.Permission); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SourcePath" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SourcePath\": ")
	if tmp, err := json.Marshal(strct.SourcePath); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LambdaVolumeMount) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AddGroupOwner":
            if err := json.Unmarshal([]byte(v), &strct.AddGroupOwner); err != nil {
                return err
             }
        case "DestinationPath":
            if err := json.Unmarshal([]byte(v), &strct.DestinationPath); err != nil {
                return err
             }
        case "Permission":
            if err := json.Unmarshal([]byte(v), &strct.Permission); err != nil {
                return err
             }
        case "SourcePath":
            if err := json.Unmarshal([]byte(v), &strct.SourcePath); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Arn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Arn\": ")
	if tmp, err := json.Marshal(strct.Arn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ComponentName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ComponentName\": ")
	if tmp, err := json.Marshal(strct.ComponentName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ComponentVersion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ComponentVersion\": ")
	if tmp, err := json.Marshal(strct.ComponentVersion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "InlineRecipe" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InlineRecipe\": ")
	if tmp, err := json.Marshal(strct.InlineRecipe); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LambdaFunction" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LambdaFunction\": ")
	if tmp, err := json.Marshal(strct.LambdaFunction); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Arn":
            if err := json.Unmarshal([]byte(v), &strct.Arn); err != nil {
                return err
             }
        case "ComponentName":
            if err := json.Unmarshal([]byte(v), &strct.ComponentName); err != nil {
                return err
             }
        case "ComponentVersion":
            if err := json.Unmarshal([]byte(v), &strct.ComponentVersion); err != nil {
                return err
             }
        case "InlineRecipe":
            if err := json.Unmarshal([]byte(v), &strct.InlineRecipe); err != nil {
                return err
             }
        case "LambdaFunction":
            if err := json.Unmarshal([]byte(v), &strct.LambdaFunction); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Tags) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tags) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}
