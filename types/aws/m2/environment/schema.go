// Code generated by schema-generate. DO NOT EDIT.

package environment

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// EfsStorageConfiguration Defines the storage configuration for an Amazon EFS file system.
type EfsStorageConfiguration struct {

  // The file system identifier.
  FileSystemId string `json:"FileSystemId"`

  // The mount point for the file system.
  MountPoint string `json:"MountPoint"`
}

// FsxStorageConfiguration Defines the storage configuration for an Amazon FSx file system.
type FsxStorageConfiguration struct {

  // The file system identifier.
  FileSystemId string `json:"FileSystemId"`

  // The mount point for the file system.
  MountPoint string `json:"MountPoint"`
}

// HighAvailabilityConfig Defines the details of a high availability configuration.
type HighAvailabilityConfig struct {
  DesiredCapacity int `json:"DesiredCapacity"`
}

// Resource Represents a runtime environment that can run migrated mainframe applications.
type Resource struct {

  // The description of the environment.
  Description string `json:"Description,omitempty"`
  EngineType string `json:"EngineType"`

  // The version of the runtime engine for the environment.
  EngineVersion string `json:"EngineVersion,omitempty"`

  // The Amazon Resource Name (ARN) of the runtime environment.
  EnvironmentArn string `json:"EnvironmentArn,omitempty"`

  // The unique identifier of the environment.
  EnvironmentId string `json:"EnvironmentId,omitempty"`
  HighAvailabilityConfig *HighAvailabilityConfig `json:"HighAvailabilityConfig,omitempty"`

  // The type of instance underlying the environment.
  InstanceType string `json:"InstanceType"`

  // The ID or the Amazon Resource Name (ARN) of the customer managed KMS Key used for encrypting environment-related resources.
  KmsKeyId string `json:"KmsKeyId,omitempty"`

  // The name of the environment.
  Name string `json:"Name"`

  // Configures a desired maintenance window for the environment. If you do not provide a value, a random system-generated value will be assigned.
  PreferredMaintenanceWindow string `json:"PreferredMaintenanceWindow,omitempty"`

  // Specifies whether the environment is publicly accessible.
  PubliclyAccessible bool `json:"PubliclyAccessible,omitempty"`

  // The list of security groups for the VPC associated with this environment.
  SecurityGroupIds []string `json:"SecurityGroupIds,omitempty"`

  // The storage configurations defined for the runtime environment.
  StorageConfigurations []*StorageConfiguration `json:"StorageConfigurations,omitempty"`

  // The unique identifiers of the subnets assigned to this runtime environment.
  SubnetIds []string `json:"SubnetIds,omitempty"`

  // Tags associated to this environment.
  Tags *TagMap `json:"Tags,omitempty"`
}

// StorageConfiguration Defines the storage configuration for an environment.
type StorageConfiguration struct {
}

// TagMap Defines tags associated to an environment.
type TagMap struct {
}

func (strct *EfsStorageConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "FileSystemId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "FileSystemId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FileSystemId\": ")
	if tmp, err := json.Marshal(strct.FileSystemId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "MountPoint" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "MountPoint" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MountPoint\": ")
	if tmp, err := json.Marshal(strct.MountPoint); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *EfsStorageConfiguration) UnmarshalJSON(b []byte) error {
    FileSystemIdReceived := false
    MountPointReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "FileSystemId":
            if err := json.Unmarshal([]byte(v), &strct.FileSystemId); err != nil {
                return err
             }
            FileSystemIdReceived = true
        case "MountPoint":
            if err := json.Unmarshal([]byte(v), &strct.MountPoint); err != nil {
                return err
             }
            MountPointReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if FileSystemId (a required property) was received
    if !FileSystemIdReceived {
        return errors.New("\"FileSystemId\" is required but was not present")
    }
    // check if MountPoint (a required property) was received
    if !MountPointReceived {
        return errors.New("\"MountPoint\" is required but was not present")
    }
    return nil
}

func (strct *FsxStorageConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "FileSystemId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "FileSystemId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FileSystemId\": ")
	if tmp, err := json.Marshal(strct.FileSystemId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "MountPoint" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "MountPoint" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MountPoint\": ")
	if tmp, err := json.Marshal(strct.MountPoint); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FsxStorageConfiguration) UnmarshalJSON(b []byte) error {
    FileSystemIdReceived := false
    MountPointReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "FileSystemId":
            if err := json.Unmarshal([]byte(v), &strct.FileSystemId); err != nil {
                return err
             }
            FileSystemIdReceived = true
        case "MountPoint":
            if err := json.Unmarshal([]byte(v), &strct.MountPoint); err != nil {
                return err
             }
            MountPointReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if FileSystemId (a required property) was received
    if !FileSystemIdReceived {
        return errors.New("\"FileSystemId\" is required but was not present")
    }
    // check if MountPoint (a required property) was received
    if !MountPointReceived {
        return errors.New("\"MountPoint\" is required but was not present")
    }
    return nil
}

func (strct *HighAvailabilityConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "DesiredCapacity" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "DesiredCapacity" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DesiredCapacity\": ")
	if tmp, err := json.Marshal(strct.DesiredCapacity); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *HighAvailabilityConfig) UnmarshalJSON(b []byte) error {
    DesiredCapacityReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DesiredCapacity":
            if err := json.Unmarshal([]byte(v), &strct.DesiredCapacity); err != nil {
                return err
             }
            DesiredCapacityReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if DesiredCapacity (a required property) was received
    if !DesiredCapacityReceived {
        return errors.New("\"DesiredCapacity\" is required but was not present")
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "EngineType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "EngineType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EngineType\": ")
	if tmp, err := json.Marshal(strct.EngineType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EngineVersion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EngineVersion\": ")
	if tmp, err := json.Marshal(strct.EngineVersion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EnvironmentArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EnvironmentArn\": ")
	if tmp, err := json.Marshal(strct.EnvironmentArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EnvironmentId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EnvironmentId\": ")
	if tmp, err := json.Marshal(strct.EnvironmentId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "HighAvailabilityConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HighAvailabilityConfig\": ")
	if tmp, err := json.Marshal(strct.HighAvailabilityConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "InstanceType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "InstanceType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InstanceType\": ")
	if tmp, err := json.Marshal(strct.InstanceType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "KmsKeyId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KmsKeyId\": ")
	if tmp, err := json.Marshal(strct.KmsKeyId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PreferredMaintenanceWindow" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PreferredMaintenanceWindow\": ")
	if tmp, err := json.Marshal(strct.PreferredMaintenanceWindow); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PubliclyAccessible" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PubliclyAccessible\": ")
	if tmp, err := json.Marshal(strct.PubliclyAccessible); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SecurityGroupIds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SecurityGroupIds\": ")
	if tmp, err := json.Marshal(strct.SecurityGroupIds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StorageConfigurations" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StorageConfigurations\": ")
	if tmp, err := json.Marshal(strct.StorageConfigurations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SubnetIds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SubnetIds\": ")
	if tmp, err := json.Marshal(strct.SubnetIds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    EngineTypeReceived := false
    InstanceTypeReceived := false
    NameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "EngineType":
            if err := json.Unmarshal([]byte(v), &strct.EngineType); err != nil {
                return err
             }
            EngineTypeReceived = true
        case "EngineVersion":
            if err := json.Unmarshal([]byte(v), &strct.EngineVersion); err != nil {
                return err
             }
        case "EnvironmentArn":
            if err := json.Unmarshal([]byte(v), &strct.EnvironmentArn); err != nil {
                return err
             }
        case "EnvironmentId":
            if err := json.Unmarshal([]byte(v), &strct.EnvironmentId); err != nil {
                return err
             }
        case "HighAvailabilityConfig":
            if err := json.Unmarshal([]byte(v), &strct.HighAvailabilityConfig); err != nil {
                return err
             }
        case "InstanceType":
            if err := json.Unmarshal([]byte(v), &strct.InstanceType); err != nil {
                return err
             }
            InstanceTypeReceived = true
        case "KmsKeyId":
            if err := json.Unmarshal([]byte(v), &strct.KmsKeyId); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        case "PreferredMaintenanceWindow":
            if err := json.Unmarshal([]byte(v), &strct.PreferredMaintenanceWindow); err != nil {
                return err
             }
        case "PubliclyAccessible":
            if err := json.Unmarshal([]byte(v), &strct.PubliclyAccessible); err != nil {
                return err
             }
        case "SecurityGroupIds":
            if err := json.Unmarshal([]byte(v), &strct.SecurityGroupIds); err != nil {
                return err
             }
        case "StorageConfigurations":
            if err := json.Unmarshal([]byte(v), &strct.StorageConfigurations); err != nil {
                return err
             }
        case "SubnetIds":
            if err := json.Unmarshal([]byte(v), &strct.SubnetIds); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if EngineType (a required property) was received
    if !EngineTypeReceived {
        return errors.New("\"EngineType\" is required but was not present")
    }
    // check if InstanceType (a required property) was received
    if !InstanceTypeReceived {
        return errors.New("\"InstanceType\" is required but was not present")
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    return nil
}

func (strct *TagMap) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TagMap) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}
