// Code generated by schema-generate. DO NOT EDIT.

package dataset

import (
    "encoding/json"
    "errors"
    "fmt"
    "bytes"
)

// CalculatedColumn <p>A calculated column for a dataset.</p>
type CalculatedColumn struct {

  // <p>A unique ID to identify a calculated column. During a dataset update, if the column ID
  //             of a calculated column matches that of an existing calculated column, Amazon QuickSight
  //             preserves the existing calculated column.</p>
  ColumnId string `json:"ColumnId"`

  // <p>Column name.</p>
  ColumnName string `json:"ColumnName"`

  // <p>An expression that defines the calculated column.</p>
  Expression string `json:"Expression"`
}

// CastColumnTypeOperation <p>A transform operation that casts a column to a different type.</p>
type CastColumnTypeOperation struct {

  // <p>Column name.</p>
  ColumnName string `json:"ColumnName"`

  // <p>When casting a column from string to datetime type, you can supply a string in a
  //             format supported by Amazon QuickSight to denote the source data format.</p>
  Format string `json:"Format,omitempty"`
  NewColumnType string `json:"NewColumnType"`
}

// ColumnDescription <p>Metadata that contains a description for a column.</p>
type ColumnDescription struct {

  // <p>The text of a description for a column.</p>
  Text string `json:"Text,omitempty"`
}

// ColumnGroup <p>Groupings of columns that work together in certain Amazon QuickSight features. This is
//             a variant type structure. For this structure to be valid, only one of the attributes can
//             be non-null.</p>
type ColumnGroup struct {
  GeoSpatialColumnGroup *GeoSpatialColumnGroup `json:"GeoSpatialColumnGroup,omitempty"`
}

// ColumnLevelPermissionRule 
type ColumnLevelPermissionRule struct {
  ColumnNames []string `json:"ColumnNames,omitempty"`
  Principals []string `json:"Principals,omitempty"`
}

// ColumnTag <p>A tag for a column in a <a>TagColumnOperation</a> structure. This is a
//             variant type structure. For this structure to be valid, only one of the attributes can
//             be non-null.</p>
type ColumnTag struct {
  ColumnDescription *ColumnDescription `json:"ColumnDescription,omitempty"`
  ColumnGeographicRole string `json:"ColumnGeographicRole,omitempty"`
}

// CreateColumnsOperation <p>A transform operation that creates calculated columns. Columns created in one such
//             operation form a lexical closure.</p>
type CreateColumnsOperation struct {

  // <p>Calculated columns to create.</p>
  Columns []*CalculatedColumn `json:"Columns"`
}

// CustomSql <p>A physical table type built from the results of the custom SQL query.</p>
type CustomSql struct {

  // <p>The column schema from the SQL query result set.</p>
  Columns []*InputColumn `json:"Columns"`

  // <p>The Amazon Resource Name (ARN) of the data source.</p>
  DataSourceArn string `json:"DataSourceArn"`

  // <p>A display name for the SQL query result.</p>
  Name string `json:"Name"`

  // <p>The SQL query.</p>
  SqlQuery string `json:"SqlQuery"`
}

// DataSetUsageConfiguration <p>The dataset usage configuration for the dataset.</p>
type DataSetUsageConfiguration struct {
  DisableUseAsDirectQuerySource bool `json:"DisableUseAsDirectQuerySource,omitempty"`
  DisableUseAsImportedSource bool `json:"DisableUseAsImportedSource,omitempty"`
}

// FieldFolder 
type FieldFolder struct {
  Columns []string `json:"Columns,omitempty"`
  Description string `json:"Description,omitempty"`
}

// FieldFolderMap 
type FieldFolderMap struct {
}

// FilterOperation <p>A transform operation that filters rows based on a condition.</p>
type FilterOperation struct {

  // <p>An expression that must evaluate to a Boolean value. Rows for which the expression
  //             evaluates to true are kept in the dataset.</p>
  ConditionExpression string `json:"ConditionExpression"`
}

// GeoSpatialColumnGroup <p>Geospatial column group that denotes a hierarchy.</p>
type GeoSpatialColumnGroup struct {

  // <p>Columns in this hierarchy.</p>
  Columns []string `json:"Columns"`
  CountryCode string `json:"CountryCode,omitempty"`

  // <p>A display name for the hierarchy.</p>
  Name string `json:"Name"`
}

// IngestionWaitPolicy <p>Wait policy to use when creating/updating dataset. Default is to wait for SPICE ingestion to finish with timeout of 36 hours.</p>
type IngestionWaitPolicy struct {

  // <p>The maximum time (in hours) to wait for Ingestion to complete. Default timeout is 36 hours.
  //  Applicable only when DataSetImportMode mode is set to SPICE and WaitForSpiceIngestion is set to true.</p>
  IngestionWaitTimeInHours float64 `json:"IngestionWaitTimeInHours,omitempty"`

  // <p>Wait for SPICE ingestion to finish to mark dataset creation/update successful. Default (true).
  //   Applicable only when DataSetImportMode mode is set to SPICE.</p>
  WaitForSpiceIngestion bool `json:"WaitForSpiceIngestion,omitempty"`
}

// InputColumn <p>Metadata for a column that is used as the input of a transform operation.</p>
type InputColumn struct {

  // <p>The name of this column in the underlying data source.</p>
  Name string `json:"Name"`
  Type string `json:"Type"`
}

// JoinInstruction <p>Join instruction.</p>
type JoinInstruction struct {
  LeftJoinKeyProperties *JoinKeyProperties `json:"LeftJoinKeyProperties,omitempty"`

  // <p>Left operand.</p>
  LeftOperand string `json:"LeftOperand"`

  // <p>On Clause.</p>
  OnClause string `json:"OnClause"`
  RightJoinKeyProperties *JoinKeyProperties `json:"RightJoinKeyProperties,omitempty"`

  // <p>Right operand.</p>
  RightOperand string `json:"RightOperand"`
  Type string `json:"Type"`
}

// JoinKeyProperties 
type JoinKeyProperties struct {
  UniqueKey bool `json:"UniqueKey,omitempty"`
}

// LogicalTable <p>A <i>logical table</i> is a unit that joins and that data
//             transformations operate on. A logical table has a source, which can be either a physical
//             table or result of a join. When a logical table points to a physical table, the logical
//             table acts as a mutable copy of that physical table through transform operations.</p>
type LogicalTable struct {

  // <p>A display name for the logical table.</p>
  Alias string `json:"Alias"`

  // <p>Transform operations that act on this logical table.</p>
  DataTransforms []*TransformOperation `json:"DataTransforms,omitempty"`
  Source *LogicalTableSource `json:"Source"`
}

// LogicalTableMap 
type LogicalTableMap struct {
}

// LogicalTableSource <p>Information about the source of a logical table. This is a variant type structure. For
//             this structure to be valid, only one of the attributes can be non-null.</p>
type LogicalTableSource struct {

  // <p>The Amazon Resource Name (ARN) for the dataset.</p>
  DataSetArn string `json:"DataSetArn,omitempty"`
  JoinInstruction *JoinInstruction `json:"JoinInstruction,omitempty"`

  // <p>Physical table ID.</p>
  PhysicalTableId string `json:"PhysicalTableId,omitempty"`
}

// OutputColumn <p>Output column.</p>
type OutputColumn struct {

  // <p>A description for a column.</p>
  Description string `json:"Description,omitempty"`

  // <p>A display name for the dataset.</p>
  Name string `json:"Name,omitempty"`
  Type string `json:"Type,omitempty"`
}

// PhysicalTable <p>A view of a data source that contains information about the shape of the data in the
//             underlying source. This is a variant type structure. For this structure to be valid,
//             only one of the attributes can be non-null.</p>
type PhysicalTable struct {
  CustomSql *CustomSql `json:"CustomSql,omitempty"`
  RelationalTable *RelationalTable `json:"RelationalTable,omitempty"`
  S3Source *S3Source `json:"S3Source,omitempty"`
}

// PhysicalTableMap 
type PhysicalTableMap struct {
}

// ProjectOperation <p>A transform operation that projects columns. Operations that come after a projection
//             can only refer to projected columns.</p>
type ProjectOperation struct {

  // <p>Projected columns.</p>
  ProjectedColumns []string `json:"ProjectedColumns"`
}

// RelationalTable <p>A physical table type for relational data sources.</p>
type RelationalTable struct {

  // <p>The catalog associated with a table.</p>
  Catalog string `json:"Catalog,omitempty"`

  // <p>The Amazon Resource Name (ARN) for the data source.</p>
  DataSourceArn string `json:"DataSourceArn"`

  // <p>The column schema of the table.</p>
  InputColumns []*InputColumn `json:"InputColumns"`

  // <p>The name of the relational table.</p>
  Name string `json:"Name"`

  // <p>The schema name. This name applies to certain relational database engines.</p>
  Schema string `json:"Schema,omitempty"`
}

// RenameColumnOperation <p>A transform operation that renames a column.</p>
type RenameColumnOperation struct {

  // <p>The name of the column to be renamed.</p>
  ColumnName string `json:"ColumnName"`

  // <p>The new name for the column.</p>
  NewColumnName string `json:"NewColumnName"`
}

// Resource Definition of the AWS::QuickSight::DataSet Resource Type.
type Resource struct {

  // <p>The Amazon Resource Name (ARN) of the resource.</p>
  Arn string `json:"Arn,omitempty"`
  AwsAccountId string `json:"AwsAccountId,omitempty"`

  // <p>Groupings of columns that work together in certain QuickSight features. Currently, only geospatial hierarchy is supported.</p>
  ColumnGroups []*ColumnGroup `json:"ColumnGroups,omitempty"`
  ColumnLevelPermissionRules []*ColumnLevelPermissionRule `json:"ColumnLevelPermissionRules,omitempty"`

  // <p>The amount of SPICE capacity used by this dataset. This is 0 if the dataset isn't
  //             imported into SPICE.</p>
  ConsumedSpiceCapacityInBytes float64 `json:"ConsumedSpiceCapacityInBytes,omitempty"`

  // <p>The time that this dataset was created.</p>
  CreatedTime string `json:"CreatedTime,omitempty"`
  DataSetId string `json:"DataSetId,omitempty"`
  DataSetUsageConfiguration *DataSetUsageConfiguration `json:"DataSetUsageConfiguration,omitempty"`
  FieldFolders *FieldFolderMap `json:"FieldFolders,omitempty"`
  ImportMode string `json:"ImportMode,omitempty"`
  IngestionWaitPolicy *IngestionWaitPolicy `json:"IngestionWaitPolicy,omitempty"`

  // <p>The last time that this dataset was updated.</p>
  LastUpdatedTime string `json:"LastUpdatedTime,omitempty"`
  LogicalTableMap *LogicalTableMap `json:"LogicalTableMap,omitempty"`

  // <p>The display name for the dataset.</p>
  Name string `json:"Name,omitempty"`

  // <p>The list of columns after all transforms. These columns are available in templates,
  //             analyses, and dashboards.</p>
  OutputColumns []*OutputColumn `json:"OutputColumns,omitempty"`

  // <p>A list of resource permissions on the dataset.</p>
  Permissions []*ResourcePermission `json:"Permissions,omitempty"`
  PhysicalTableMap *PhysicalTableMap `json:"PhysicalTableMap,omitempty"`
  RowLevelPermissionDataSet *RowLevelPermissionDataSet `json:"RowLevelPermissionDataSet,omitempty"`

  // <p>Contains a map of the key-value pairs for the resource tag or tags assigned to the dataset.</p>
  Tags []*Tag `json:"Tags,omitempty"`
}

// ResourcePermission <p>Permission for the resource.</p>
type ResourcePermission struct {

  // <p>The IAM action to grant or revoke permissions on.</p>
  Actions []string `json:"Actions"`

  // <p>The Amazon Resource Name (ARN) of the principal. This can be one of the
  //             following:</p>
  //         <ul>
  //             <li>
  //                 <p>The ARN of an Amazon QuickSight user or group associated with a data source or dataset. (This is common.)</p>
  //             </li>
  //             <li>
  //                 <p>The ARN of an Amazon QuickSight user, group, or namespace associated with an analysis, dashboard, template, or theme. (This is common.)</p>
  //             </li>
  //             <li>
  //                 <p>The ARN of an AWS account root: This is an IAM ARN rather than a QuickSight
  //                     ARN. Use this option only to share resources (templates) across AWS accounts.
  //                     (This is less common.) </p>
  //             </li>
  //          </ul>
  Principal string `json:"Principal"`
}

// RowLevelPermissionDataSet <p>The row-level security configuration for the dataset.</p>
type RowLevelPermissionDataSet struct {

  // <p>The Amazon Resource Name (ARN) of the permission dataset.</p>
  Arn string `json:"Arn"`
  FormatVersion string `json:"FormatVersion,omitempty"`

  // <p>The namespace associated with the row-level permissions dataset.</p>
  Namespace string `json:"Namespace,omitempty"`
  PermissionPolicy string `json:"PermissionPolicy"`
}

// S3Source <p>A physical table type for as S3 data source.</p>
type S3Source struct {

  // <p>The amazon Resource Name (ARN) for the data source.</p>
  DataSourceArn string `json:"DataSourceArn"`

  // <p>A physical table type for as S3 data source.</p>
  InputColumns []*InputColumn `json:"InputColumns"`
  UploadSettings *UploadSettings `json:"UploadSettings,omitempty"`
}

// Tag <p>The key or keys of the key-value pairs for the resource tag or tags assigned to the
//             resource.</p>
type Tag struct {

  // <p>Tag key.</p>
  Key string `json:"Key"`

  // <p>Tag value.</p>
  Value string `json:"Value"`
}

// TagColumnOperation <p>A transform operation that tags a column with additional information.</p>
type TagColumnOperation struct {

  // <p>The column that this operation acts on.</p>
  ColumnName string `json:"ColumnName"`

  // <p>The dataset column tag, currently only used for geospatial type tagging. .</p>
  //         <note>
  //             <p>This is not tags for the AWS tagging feature. .</p>
  //         </note>
  Tags []*ColumnTag `json:"Tags"`
}

// TransformOperation <p>A data transformation on a logical table. This is a variant type structure. For this
//             structure to be valid, only one of the attributes can be non-null.</p>
type TransformOperation struct {
  CastColumnTypeOperation *CastColumnTypeOperation `json:"CastColumnTypeOperation,omitempty"`
  CreateColumnsOperation *CreateColumnsOperation `json:"CreateColumnsOperation,omitempty"`
  FilterOperation *FilterOperation `json:"FilterOperation,omitempty"`
  ProjectOperation *ProjectOperation `json:"ProjectOperation,omitempty"`
  RenameColumnOperation *RenameColumnOperation `json:"RenameColumnOperation,omitempty"`
  TagColumnOperation *TagColumnOperation `json:"TagColumnOperation,omitempty"`
}

// UploadSettings <p>Information about the format for a source file or files.</p>
type UploadSettings struct {

  // <p>Whether the file has a header row, or the files each have a header row.</p>
  ContainsHeader bool `json:"ContainsHeader,omitempty"`

  // <p>The delimiter between values in the file.</p>
  Delimiter string `json:"Delimiter,omitempty"`
  Format string `json:"Format,omitempty"`

  // <p>A row number to start reading data from.</p>
  StartFromRow float64 `json:"StartFromRow,omitempty"`
  TextQualifier string `json:"TextQualifier,omitempty"`
}

func (strct *CalculatedColumn) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ColumnId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ColumnId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ColumnId\": ")
	if tmp, err := json.Marshal(strct.ColumnId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ColumnName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ColumnName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ColumnName\": ")
	if tmp, err := json.Marshal(strct.ColumnName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Expression" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Expression" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Expression\": ")
	if tmp, err := json.Marshal(strct.Expression); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CalculatedColumn) UnmarshalJSON(b []byte) error {
    ColumnIdReceived := false
    ColumnNameReceived := false
    ExpressionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ColumnId":
            if err := json.Unmarshal([]byte(v), &strct.ColumnId); err != nil {
                return err
             }
            ColumnIdReceived = true
        case "ColumnName":
            if err := json.Unmarshal([]byte(v), &strct.ColumnName); err != nil {
                return err
             }
            ColumnNameReceived = true
        case "Expression":
            if err := json.Unmarshal([]byte(v), &strct.Expression); err != nil {
                return err
             }
            ExpressionReceived = true
        }
    }
    // check if ColumnId (a required property) was received
    if !ColumnIdReceived {
        return errors.New("\"ColumnId\" is required but was not present")
    }
    // check if ColumnName (a required property) was received
    if !ColumnNameReceived {
        return errors.New("\"ColumnName\" is required but was not present")
    }
    // check if Expression (a required property) was received
    if !ExpressionReceived {
        return errors.New("\"Expression\" is required but was not present")
    }
    return nil
}

func (strct *CastColumnTypeOperation) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ColumnName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ColumnName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ColumnName\": ")
	if tmp, err := json.Marshal(strct.ColumnName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Format" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Format\": ")
	if tmp, err := json.Marshal(strct.Format); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "NewColumnType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "NewColumnType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NewColumnType\": ")
	if tmp, err := json.Marshal(strct.NewColumnType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CastColumnTypeOperation) UnmarshalJSON(b []byte) error {
    ColumnNameReceived := false
    NewColumnTypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ColumnName":
            if err := json.Unmarshal([]byte(v), &strct.ColumnName); err != nil {
                return err
             }
            ColumnNameReceived = true
        case "Format":
            if err := json.Unmarshal([]byte(v), &strct.Format); err != nil {
                return err
             }
        case "NewColumnType":
            if err := json.Unmarshal([]byte(v), &strct.NewColumnType); err != nil {
                return err
             }
            NewColumnTypeReceived = true
        }
    }
    // check if ColumnName (a required property) was received
    if !ColumnNameReceived {
        return errors.New("\"ColumnName\" is required but was not present")
    }
    // check if NewColumnType (a required property) was received
    if !NewColumnTypeReceived {
        return errors.New("\"NewColumnType\" is required but was not present")
    }
    return nil
}

func (strct *CreateColumnsOperation) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Columns" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Columns" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Columns\": ")
	if tmp, err := json.Marshal(strct.Columns); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CreateColumnsOperation) UnmarshalJSON(b []byte) error {
    ColumnsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Columns":
            if err := json.Unmarshal([]byte(v), &strct.Columns); err != nil {
                return err
             }
            ColumnsReceived = true
        }
    }
    // check if Columns (a required property) was received
    if !ColumnsReceived {
        return errors.New("\"Columns\" is required but was not present")
    }
    return nil
}

func (strct *CustomSql) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Columns" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Columns" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Columns\": ")
	if tmp, err := json.Marshal(strct.Columns); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "DataSourceArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "DataSourceArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DataSourceArn\": ")
	if tmp, err := json.Marshal(strct.DataSourceArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "SqlQuery" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "SqlQuery" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SqlQuery\": ")
	if tmp, err := json.Marshal(strct.SqlQuery); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CustomSql) UnmarshalJSON(b []byte) error {
    ColumnsReceived := false
    DataSourceArnReceived := false
    NameReceived := false
    SqlQueryReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Columns":
            if err := json.Unmarshal([]byte(v), &strct.Columns); err != nil {
                return err
             }
            ColumnsReceived = true
        case "DataSourceArn":
            if err := json.Unmarshal([]byte(v), &strct.DataSourceArn); err != nil {
                return err
             }
            DataSourceArnReceived = true
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        case "SqlQuery":
            if err := json.Unmarshal([]byte(v), &strct.SqlQuery); err != nil {
                return err
             }
            SqlQueryReceived = true
        }
    }
    // check if Columns (a required property) was received
    if !ColumnsReceived {
        return errors.New("\"Columns\" is required but was not present")
    }
    // check if DataSourceArn (a required property) was received
    if !DataSourceArnReceived {
        return errors.New("\"DataSourceArn\" is required but was not present")
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    // check if SqlQuery (a required property) was received
    if !SqlQueryReceived {
        return errors.New("\"SqlQuery\" is required but was not present")
    }
    return nil
}

func (strct *FilterOperation) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ConditionExpression" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ConditionExpression" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConditionExpression\": ")
	if tmp, err := json.Marshal(strct.ConditionExpression); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FilterOperation) UnmarshalJSON(b []byte) error {
    ConditionExpressionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ConditionExpression":
            if err := json.Unmarshal([]byte(v), &strct.ConditionExpression); err != nil {
                return err
             }
            ConditionExpressionReceived = true
        }
    }
    // check if ConditionExpression (a required property) was received
    if !ConditionExpressionReceived {
        return errors.New("\"ConditionExpression\" is required but was not present")
    }
    return nil
}

func (strct *GeoSpatialColumnGroup) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Columns" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Columns" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Columns\": ")
	if tmp, err := json.Marshal(strct.Columns); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CountryCode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CountryCode\": ")
	if tmp, err := json.Marshal(strct.CountryCode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *GeoSpatialColumnGroup) UnmarshalJSON(b []byte) error {
    ColumnsReceived := false
    NameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Columns":
            if err := json.Unmarshal([]byte(v), &strct.Columns); err != nil {
                return err
             }
            ColumnsReceived = true
        case "CountryCode":
            if err := json.Unmarshal([]byte(v), &strct.CountryCode); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        }
    }
    // check if Columns (a required property) was received
    if !ColumnsReceived {
        return errors.New("\"Columns\" is required but was not present")
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    return nil
}

func (strct *InputColumn) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *InputColumn) UnmarshalJSON(b []byte) error {
    NameReceived := false
    TypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            TypeReceived = true
        }
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    // check if Type (a required property) was received
    if !TypeReceived {
        return errors.New("\"Type\" is required but was not present")
    }
    return nil
}

func (strct *JoinInstruction) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "LeftJoinKeyProperties" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LeftJoinKeyProperties\": ")
	if tmp, err := json.Marshal(strct.LeftJoinKeyProperties); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "LeftOperand" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "LeftOperand" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LeftOperand\": ")
	if tmp, err := json.Marshal(strct.LeftOperand); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "OnClause" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "OnClause" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OnClause\": ")
	if tmp, err := json.Marshal(strct.OnClause); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RightJoinKeyProperties" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RightJoinKeyProperties\": ")
	if tmp, err := json.Marshal(strct.RightJoinKeyProperties); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RightOperand" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RightOperand" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RightOperand\": ")
	if tmp, err := json.Marshal(strct.RightOperand); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *JoinInstruction) UnmarshalJSON(b []byte) error {
    LeftOperandReceived := false
    OnClauseReceived := false
    RightOperandReceived := false
    TypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "LeftJoinKeyProperties":
            if err := json.Unmarshal([]byte(v), &strct.LeftJoinKeyProperties); err != nil {
                return err
             }
        case "LeftOperand":
            if err := json.Unmarshal([]byte(v), &strct.LeftOperand); err != nil {
                return err
             }
            LeftOperandReceived = true
        case "OnClause":
            if err := json.Unmarshal([]byte(v), &strct.OnClause); err != nil {
                return err
             }
            OnClauseReceived = true
        case "RightJoinKeyProperties":
            if err := json.Unmarshal([]byte(v), &strct.RightJoinKeyProperties); err != nil {
                return err
             }
        case "RightOperand":
            if err := json.Unmarshal([]byte(v), &strct.RightOperand); err != nil {
                return err
             }
            RightOperandReceived = true
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            TypeReceived = true
        }
    }
    // check if LeftOperand (a required property) was received
    if !LeftOperandReceived {
        return errors.New("\"LeftOperand\" is required but was not present")
    }
    // check if OnClause (a required property) was received
    if !OnClauseReceived {
        return errors.New("\"OnClause\" is required but was not present")
    }
    // check if RightOperand (a required property) was received
    if !RightOperandReceived {
        return errors.New("\"RightOperand\" is required but was not present")
    }
    // check if Type (a required property) was received
    if !TypeReceived {
        return errors.New("\"Type\" is required but was not present")
    }
    return nil
}

func (strct *LogicalTable) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Alias" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Alias" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Alias\": ")
	if tmp, err := json.Marshal(strct.Alias); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DataTransforms" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DataTransforms\": ")
	if tmp, err := json.Marshal(strct.DataTransforms); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Source" field is required
    if strct.Source == nil {
        return nil, errors.New("Source is a required field")
    }
    // Marshal the "Source" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Source\": ")
	if tmp, err := json.Marshal(strct.Source); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LogicalTable) UnmarshalJSON(b []byte) error {
    AliasReceived := false
    SourceReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Alias":
            if err := json.Unmarshal([]byte(v), &strct.Alias); err != nil {
                return err
             }
            AliasReceived = true
        case "DataTransforms":
            if err := json.Unmarshal([]byte(v), &strct.DataTransforms); err != nil {
                return err
             }
        case "Source":
            if err := json.Unmarshal([]byte(v), &strct.Source); err != nil {
                return err
             }
            SourceReceived = true
        }
    }
    // check if Alias (a required property) was received
    if !AliasReceived {
        return errors.New("\"Alias\" is required but was not present")
    }
    // check if Source (a required property) was received
    if !SourceReceived {
        return errors.New("\"Source\" is required but was not present")
    }
    return nil
}

func (strct *ProjectOperation) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ProjectedColumns" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ProjectedColumns" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ProjectedColumns\": ")
	if tmp, err := json.Marshal(strct.ProjectedColumns); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ProjectOperation) UnmarshalJSON(b []byte) error {
    ProjectedColumnsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ProjectedColumns":
            if err := json.Unmarshal([]byte(v), &strct.ProjectedColumns); err != nil {
                return err
             }
            ProjectedColumnsReceived = true
        }
    }
    // check if ProjectedColumns (a required property) was received
    if !ProjectedColumnsReceived {
        return errors.New("\"ProjectedColumns\" is required but was not present")
    }
    return nil
}

func (strct *RelationalTable) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Catalog" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Catalog\": ")
	if tmp, err := json.Marshal(strct.Catalog); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "DataSourceArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "DataSourceArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DataSourceArn\": ")
	if tmp, err := json.Marshal(strct.DataSourceArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "InputColumns" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "InputColumns" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InputColumns\": ")
	if tmp, err := json.Marshal(strct.InputColumns); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Schema" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Schema\": ")
	if tmp, err := json.Marshal(strct.Schema); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RelationalTable) UnmarshalJSON(b []byte) error {
    DataSourceArnReceived := false
    InputColumnsReceived := false
    NameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Catalog":
            if err := json.Unmarshal([]byte(v), &strct.Catalog); err != nil {
                return err
             }
        case "DataSourceArn":
            if err := json.Unmarshal([]byte(v), &strct.DataSourceArn); err != nil {
                return err
             }
            DataSourceArnReceived = true
        case "InputColumns":
            if err := json.Unmarshal([]byte(v), &strct.InputColumns); err != nil {
                return err
             }
            InputColumnsReceived = true
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        case "Schema":
            if err := json.Unmarshal([]byte(v), &strct.Schema); err != nil {
                return err
             }
        }
    }
    // check if DataSourceArn (a required property) was received
    if !DataSourceArnReceived {
        return errors.New("\"DataSourceArn\" is required but was not present")
    }
    // check if InputColumns (a required property) was received
    if !InputColumnsReceived {
        return errors.New("\"InputColumns\" is required but was not present")
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    return nil
}

func (strct *RenameColumnOperation) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ColumnName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ColumnName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ColumnName\": ")
	if tmp, err := json.Marshal(strct.ColumnName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "NewColumnName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "NewColumnName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NewColumnName\": ")
	if tmp, err := json.Marshal(strct.NewColumnName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RenameColumnOperation) UnmarshalJSON(b []byte) error {
    ColumnNameReceived := false
    NewColumnNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ColumnName":
            if err := json.Unmarshal([]byte(v), &strct.ColumnName); err != nil {
                return err
             }
            ColumnNameReceived = true
        case "NewColumnName":
            if err := json.Unmarshal([]byte(v), &strct.NewColumnName); err != nil {
                return err
             }
            NewColumnNameReceived = true
        }
    }
    // check if ColumnName (a required property) was received
    if !ColumnNameReceived {
        return errors.New("\"ColumnName\" is required but was not present")
    }
    // check if NewColumnName (a required property) was received
    if !NewColumnNameReceived {
        return errors.New("\"NewColumnName\" is required but was not present")
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Arn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Arn\": ")
	if tmp, err := json.Marshal(strct.Arn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AwsAccountId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AwsAccountId\": ")
	if tmp, err := json.Marshal(strct.AwsAccountId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ColumnGroups" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ColumnGroups\": ")
	if tmp, err := json.Marshal(strct.ColumnGroups); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ColumnLevelPermissionRules" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ColumnLevelPermissionRules\": ")
	if tmp, err := json.Marshal(strct.ColumnLevelPermissionRules); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ConsumedSpiceCapacityInBytes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConsumedSpiceCapacityInBytes\": ")
	if tmp, err := json.Marshal(strct.ConsumedSpiceCapacityInBytes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CreatedTime" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CreatedTime\": ")
	if tmp, err := json.Marshal(strct.CreatedTime); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DataSetId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DataSetId\": ")
	if tmp, err := json.Marshal(strct.DataSetId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DataSetUsageConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DataSetUsageConfiguration\": ")
	if tmp, err := json.Marshal(strct.DataSetUsageConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FieldFolders" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FieldFolders\": ")
	if tmp, err := json.Marshal(strct.FieldFolders); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ImportMode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ImportMode\": ")
	if tmp, err := json.Marshal(strct.ImportMode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IngestionWaitPolicy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IngestionWaitPolicy\": ")
	if tmp, err := json.Marshal(strct.IngestionWaitPolicy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LastUpdatedTime" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LastUpdatedTime\": ")
	if tmp, err := json.Marshal(strct.LastUpdatedTime); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LogicalTableMap" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LogicalTableMap\": ")
	if tmp, err := json.Marshal(strct.LogicalTableMap); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OutputColumns" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OutputColumns\": ")
	if tmp, err := json.Marshal(strct.OutputColumns); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Permissions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Permissions\": ")
	if tmp, err := json.Marshal(strct.Permissions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PhysicalTableMap" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PhysicalTableMap\": ")
	if tmp, err := json.Marshal(strct.PhysicalTableMap); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RowLevelPermissionDataSet" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RowLevelPermissionDataSet\": ")
	if tmp, err := json.Marshal(strct.RowLevelPermissionDataSet); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Arn":
            if err := json.Unmarshal([]byte(v), &strct.Arn); err != nil {
                return err
             }
        case "AwsAccountId":
            if err := json.Unmarshal([]byte(v), &strct.AwsAccountId); err != nil {
                return err
             }
        case "ColumnGroups":
            if err := json.Unmarshal([]byte(v), &strct.ColumnGroups); err != nil {
                return err
             }
        case "ColumnLevelPermissionRules":
            if err := json.Unmarshal([]byte(v), &strct.ColumnLevelPermissionRules); err != nil {
                return err
             }
        case "ConsumedSpiceCapacityInBytes":
            if err := json.Unmarshal([]byte(v), &strct.ConsumedSpiceCapacityInBytes); err != nil {
                return err
             }
        case "CreatedTime":
            if err := json.Unmarshal([]byte(v), &strct.CreatedTime); err != nil {
                return err
             }
        case "DataSetId":
            if err := json.Unmarshal([]byte(v), &strct.DataSetId); err != nil {
                return err
             }
        case "DataSetUsageConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.DataSetUsageConfiguration); err != nil {
                return err
             }
        case "FieldFolders":
            if err := json.Unmarshal([]byte(v), &strct.FieldFolders); err != nil {
                return err
             }
        case "ImportMode":
            if err := json.Unmarshal([]byte(v), &strct.ImportMode); err != nil {
                return err
             }
        case "IngestionWaitPolicy":
            if err := json.Unmarshal([]byte(v), &strct.IngestionWaitPolicy); err != nil {
                return err
             }
        case "LastUpdatedTime":
            if err := json.Unmarshal([]byte(v), &strct.LastUpdatedTime); err != nil {
                return err
             }
        case "LogicalTableMap":
            if err := json.Unmarshal([]byte(v), &strct.LogicalTableMap); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "OutputColumns":
            if err := json.Unmarshal([]byte(v), &strct.OutputColumns); err != nil {
                return err
             }
        case "Permissions":
            if err := json.Unmarshal([]byte(v), &strct.Permissions); err != nil {
                return err
             }
        case "PhysicalTableMap":
            if err := json.Unmarshal([]byte(v), &strct.PhysicalTableMap); err != nil {
                return err
             }
        case "RowLevelPermissionDataSet":
            if err := json.Unmarshal([]byte(v), &strct.RowLevelPermissionDataSet); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ResourcePermission) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Actions" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Actions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Actions\": ")
	if tmp, err := json.Marshal(strct.Actions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Principal" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Principal" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Principal\": ")
	if tmp, err := json.Marshal(strct.Principal); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ResourcePermission) UnmarshalJSON(b []byte) error {
    ActionsReceived := false
    PrincipalReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Actions":
            if err := json.Unmarshal([]byte(v), &strct.Actions); err != nil {
                return err
             }
            ActionsReceived = true
        case "Principal":
            if err := json.Unmarshal([]byte(v), &strct.Principal); err != nil {
                return err
             }
            PrincipalReceived = true
        }
    }
    // check if Actions (a required property) was received
    if !ActionsReceived {
        return errors.New("\"Actions\" is required but was not present")
    }
    // check if Principal (a required property) was received
    if !PrincipalReceived {
        return errors.New("\"Principal\" is required but was not present")
    }
    return nil
}

func (strct *RowLevelPermissionDataSet) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Arn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Arn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Arn\": ")
	if tmp, err := json.Marshal(strct.Arn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FormatVersion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FormatVersion\": ")
	if tmp, err := json.Marshal(strct.FormatVersion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Namespace" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Namespace\": ")
	if tmp, err := json.Marshal(strct.Namespace); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "PermissionPolicy" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "PermissionPolicy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PermissionPolicy\": ")
	if tmp, err := json.Marshal(strct.PermissionPolicy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RowLevelPermissionDataSet) UnmarshalJSON(b []byte) error {
    ArnReceived := false
    PermissionPolicyReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Arn":
            if err := json.Unmarshal([]byte(v), &strct.Arn); err != nil {
                return err
             }
            ArnReceived = true
        case "FormatVersion":
            if err := json.Unmarshal([]byte(v), &strct.FormatVersion); err != nil {
                return err
             }
        case "Namespace":
            if err := json.Unmarshal([]byte(v), &strct.Namespace); err != nil {
                return err
             }
        case "PermissionPolicy":
            if err := json.Unmarshal([]byte(v), &strct.PermissionPolicy); err != nil {
                return err
             }
            PermissionPolicyReceived = true
        }
    }
    // check if Arn (a required property) was received
    if !ArnReceived {
        return errors.New("\"Arn\" is required but was not present")
    }
    // check if PermissionPolicy (a required property) was received
    if !PermissionPolicyReceived {
        return errors.New("\"PermissionPolicy\" is required but was not present")
    }
    return nil
}

func (strct *S3Source) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "DataSourceArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "DataSourceArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DataSourceArn\": ")
	if tmp, err := json.Marshal(strct.DataSourceArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "InputColumns" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "InputColumns" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InputColumns\": ")
	if tmp, err := json.Marshal(strct.InputColumns); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "UploadSettings" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UploadSettings\": ")
	if tmp, err := json.Marshal(strct.UploadSettings); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *S3Source) UnmarshalJSON(b []byte) error {
    DataSourceArnReceived := false
    InputColumnsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DataSourceArn":
            if err := json.Unmarshal([]byte(v), &strct.DataSourceArn); err != nil {
                return err
             }
            DataSourceArnReceived = true
        case "InputColumns":
            if err := json.Unmarshal([]byte(v), &strct.InputColumns); err != nil {
                return err
             }
            InputColumnsReceived = true
        case "UploadSettings":
            if err := json.Unmarshal([]byte(v), &strct.UploadSettings); err != nil {
                return err
             }
        }
    }
    // check if DataSourceArn (a required property) was received
    if !DataSourceArnReceived {
        return errors.New("\"DataSourceArn\" is required but was not present")
    }
    // check if InputColumns (a required property) was received
    if !InputColumnsReceived {
        return errors.New("\"InputColumns\" is required but was not present")
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *TagColumnOperation) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ColumnName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ColumnName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ColumnName\": ")
	if tmp, err := json.Marshal(strct.ColumnName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Tags" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TagColumnOperation) UnmarshalJSON(b []byte) error {
    ColumnNameReceived := false
    TagsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ColumnName":
            if err := json.Unmarshal([]byte(v), &strct.ColumnName); err != nil {
                return err
             }
            ColumnNameReceived = true
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
            TagsReceived = true
        }
    }
    // check if ColumnName (a required property) was received
    if !ColumnNameReceived {
        return errors.New("\"ColumnName\" is required but was not present")
    }
    // check if Tags (a required property) was received
    if !TagsReceived {
        return errors.New("\"Tags\" is required but was not present")
    }
    return nil
}
