// Code generated by schema-generate. DO NOT EDIT.

package theme

import (
    "fmt"
    "errors"
    "bytes"
    "encoding/json"
)

// BorderStyle <p>The display options for tile borders for visuals.</p>
type BorderStyle struct {

  // <p>The option to enable display of borders for visuals.</p>
  Show bool `json:"Show,omitempty"`
}

// DataColorPalette <p>The theme colors that are used for data colors in charts. The colors description is a
//             hexadecimal color code that consists of six alphanumerical characters, prefixed with
//                 <code>#</code>, for example #37BFF5. </p>
type DataColorPalette struct {

  // <p>The hexadecimal codes for the colors.</p>
  Colors []string `json:"Colors,omitempty"`

  // <p>The hexadecimal code of a color that applies to charts where a lack of data is
  //             highlighted.</p>
  EmptyFillColor string `json:"EmptyFillColor,omitempty"`

  // <p>The minimum and maximum hexadecimal codes that describe a color gradient. </p>
  MinMaxGradient []string `json:"MinMaxGradient,omitempty"`
}

// Font 
type Font struct {
  FontFamily string `json:"FontFamily,omitempty"`
}

// GutterStyle <p>The display options for gutter spacing between tiles on a sheet.</p>
type GutterStyle struct {

  // <p>This Boolean value controls whether to display a gutter space between sheet tiles.
  //         </p>
  Show bool `json:"Show,omitempty"`
}

// MarginStyle <p>The display options for margins around the outside edge of sheets.</p>
type MarginStyle struct {

  // <p>This Boolean value controls whether to display sheet margins.</p>
  Show bool `json:"Show,omitempty"`
}

// Resource Definition of the AWS::QuickSight::Theme Resource Type.
type Resource struct {

  // <p>The Amazon Resource Name (ARN) of the theme.</p>
  Arn string `json:"Arn,omitempty"`
  AwsAccountId string `json:"AwsAccountId"`

  // <p>The ID of the theme that a custom theme will inherit from. All themes inherit from one of
  // 			the starting themes defined by Amazon QuickSight. For a list of the starting themes, use
  // 				<code>ListThemes</code> or choose <b>Themes</b> from
  // 			within a QuickSight analysis. </p>
  BaseThemeId string `json:"BaseThemeId,omitempty"`
  Configuration *ThemeConfiguration `json:"Configuration,omitempty"`

  // <p>The date and time that the theme was created.</p>
  CreatedTime string `json:"CreatedTime,omitempty"`

  // <p>The date and time that the theme was last updated.</p>
  LastUpdatedTime string `json:"LastUpdatedTime,omitempty"`

  // <p>A display name for the theme.</p>
  Name string `json:"Name,omitempty"`

  // <p>A valid grouping of resource permissions to apply to the new theme.
  // 			</p>
  Permissions []*ResourcePermission `json:"Permissions,omitempty"`

  // <p>A map of the key-value pairs for the resource tag or tags that you want to add to the
  // 			resource.</p>
  Tags []*Tag `json:"Tags,omitempty"`
  ThemeId string `json:"ThemeId"`
  Type string `json:"Type,omitempty"`
  Version *ThemeVersion `json:"Version,omitempty"`

  // <p>A description of the first version of the theme that you're creating. Every time
  // 				<code>UpdateTheme</code> is called, a new version is created. Each version of the
  // 			theme has a description of the version in the <code>VersionDescription</code>
  // 			field.</p>
  VersionDescription string `json:"VersionDescription,omitempty"`
}

// ResourcePermission <p>Permission for the resource.</p>
type ResourcePermission struct {

  // <p>The IAM action to grant or revoke permissions on.</p>
  Actions []string `json:"Actions"`

  // <p>The Amazon Resource Name (ARN) of the principal. This can be one of the
  //             following:</p>
  //         <ul>
  //             <li>
  //                 <p>The ARN of an Amazon QuickSight user or group associated with a data source or dataset. (This is common.)</p>
  //             </li>
  //             <li>
  //                 <p>The ARN of an Amazon QuickSight user, group, or namespace associated with an analysis, dashboard, template, or theme. (This is common.)</p>
  //             </li>
  //             <li>
  //                 <p>The ARN of an AWS account root: This is an IAM ARN rather than a QuickSight
  //                     ARN. Use this option only to share resources (templates) across AWS accounts.
  //                     (This is less common.) </p>
  //             </li>
  //          </ul>
  Principal string `json:"Principal"`
}

// SheetStyle <p>The theme display options for sheets. </p>
type SheetStyle struct {
  Tile *TileStyle `json:"Tile,omitempty"`
  TileLayout *TileLayoutStyle `json:"TileLayout,omitempty"`
}

// Tag <p>The key or keys of the key-value pairs for the resource tag or tags assigned to the
//             resource.</p>
type Tag struct {

  // <p>Tag key.</p>
  Key string `json:"Key"`

  // <p>Tag value.</p>
  Value string `json:"Value"`
}

// ThemeConfiguration <p>The theme configuration. This configuration contains all of the display properties for
//             a theme.</p>
type ThemeConfiguration struct {
  DataColorPalette *DataColorPalette `json:"DataColorPalette,omitempty"`
  Sheet *SheetStyle `json:"Sheet,omitempty"`
  Typography *Typography `json:"Typography,omitempty"`
  UIColorPalette *UIColorPalette `json:"UIColorPalette,omitempty"`
}

// ThemeError <p>Theme error.</p>
type ThemeError struct {

  // <p>The error message.</p>
  Message string `json:"Message,omitempty"`
  Type string `json:"Type,omitempty"`
}

// ThemeVersion <p>A version of a theme.</p>
type ThemeVersion struct {

  // <p>The Amazon Resource Name (ARN) of the resource.</p>
  Arn string `json:"Arn,omitempty"`

  // <p>The Amazon QuickSight-defined ID of the theme that a custom theme inherits from. All
  //             themes initially inherit from a default QuickSight theme.</p>
  BaseThemeId string `json:"BaseThemeId,omitempty"`
  Configuration *ThemeConfiguration `json:"Configuration,omitempty"`

  // <p>The date and time that this theme version was created.</p>
  CreatedTime string `json:"CreatedTime,omitempty"`

  // <p>The description of the theme.</p>
  Description string `json:"Description,omitempty"`

  // <p>Errors associated with the theme.</p>
  Errors []*ThemeError `json:"Errors,omitempty"`
  Status string `json:"Status,omitempty"`

  // <p>The version number of the theme.</p>
  VersionNumber float64 `json:"VersionNumber,omitempty"`
}

// TileLayoutStyle <p>The display options for the layout of tiles on a sheet.</p>
type TileLayoutStyle struct {
  Gutter *GutterStyle `json:"Gutter,omitempty"`
  Margin *MarginStyle `json:"Margin,omitempty"`
}

// TileStyle <p>Display options related to tiles on a sheet.</p>
type TileStyle struct {
  Border *BorderStyle `json:"Border,omitempty"`
}

// Typography <p>The typeface for the theme.</p>
type Typography struct {
  FontFamilies []*Font `json:"FontFamilies,omitempty"`
}

// UIColorPalette <p>The theme colors that apply to UI and to charts, excluding data colors. The colors
//             description is a hexadecimal color code that consists of six alphanumerical characters,
//             prefixed with <code>#</code>, for example #37BFF5. For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/themes-in-quicksight.html">Using Themes in Amazon QuickSight</a> in the <i>Amazon QuickSight User
//                 Guide.</i>
//         </p>
type UIColorPalette struct {

  // <p>This color is that applies to selected states and buttons.</p>
  Accent string `json:"Accent,omitempty"`

  // <p>The foreground color that applies to any text or other elements that appear over the
  //             accent color.</p>
  AccentForeground string `json:"AccentForeground,omitempty"`

  // <p>The color that applies to error messages.</p>
  Danger string `json:"Danger,omitempty"`

  // <p>The foreground color that applies to any text or other elements that appear over the
  //             error color.</p>
  DangerForeground string `json:"DangerForeground,omitempty"`

  // <p>The color that applies to the names of fields that are identified as
  //             dimensions.</p>
  Dimension string `json:"Dimension,omitempty"`

  // <p>The foreground color that applies to any text or other elements that appear over the
  //             dimension color.</p>
  DimensionForeground string `json:"DimensionForeground,omitempty"`

  // <p>The color that applies to the names of fields that are identified as measures.</p>
  Measure string `json:"Measure,omitempty"`

  // <p>The foreground color that applies to any text or other elements that appear over the
  //             measure color.</p>
  MeasureForeground string `json:"MeasureForeground,omitempty"`

  // <p>The background color that applies to visuals and other high emphasis UI.</p>
  PrimaryBackground string `json:"PrimaryBackground,omitempty"`

  // <p>The color of text and other foreground elements that appear over the primary
  //             background regions, such as grid lines, borders, table banding, icons, and so on.</p>
  PrimaryForeground string `json:"PrimaryForeground,omitempty"`

  // <p>The background color that applies to the sheet background and sheet controls.</p>
  SecondaryBackground string `json:"SecondaryBackground,omitempty"`

  // <p>The foreground color that applies to any sheet title, sheet control text, or UI that
  //             appears over the secondary background.</p>
  SecondaryForeground string `json:"SecondaryForeground,omitempty"`

  // <p>The color that applies to success messages, for example the check mark for a
  //             successful download.</p>
  Success string `json:"Success,omitempty"`

  // <p>The foreground color that applies to any text or other elements that appear over the
  //             success color.</p>
  SuccessForeground string `json:"SuccessForeground,omitempty"`

  // <p>This color that applies to warning and informational messages.</p>
  Warning string `json:"Warning,omitempty"`

  // <p>The foreground color that applies to any text or other elements that appear over the
  //             warning color.</p>
  WarningForeground string `json:"WarningForeground,omitempty"`
}

func (strct *BorderStyle) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Show" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Show\": ")
	if tmp, err := json.Marshal(strct.Show); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BorderStyle) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Show":
            if err := json.Unmarshal([]byte(v), &strct.Show); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *DataColorPalette) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Colors" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Colors\": ")
	if tmp, err := json.Marshal(strct.Colors); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EmptyFillColor" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EmptyFillColor\": ")
	if tmp, err := json.Marshal(strct.EmptyFillColor); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MinMaxGradient" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MinMaxGradient\": ")
	if tmp, err := json.Marshal(strct.MinMaxGradient); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DataColorPalette) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Colors":
            if err := json.Unmarshal([]byte(v), &strct.Colors); err != nil {
                return err
             }
        case "EmptyFillColor":
            if err := json.Unmarshal([]byte(v), &strct.EmptyFillColor); err != nil {
                return err
             }
        case "MinMaxGradient":
            if err := json.Unmarshal([]byte(v), &strct.MinMaxGradient); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Font) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "FontFamily" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FontFamily\": ")
	if tmp, err := json.Marshal(strct.FontFamily); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Font) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "FontFamily":
            if err := json.Unmarshal([]byte(v), &strct.FontFamily); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *GutterStyle) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Show" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Show\": ")
	if tmp, err := json.Marshal(strct.Show); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *GutterStyle) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Show":
            if err := json.Unmarshal([]byte(v), &strct.Show); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *MarginStyle) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Show" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Show\": ")
	if tmp, err := json.Marshal(strct.Show); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MarginStyle) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Show":
            if err := json.Unmarshal([]byte(v), &strct.Show); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Arn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Arn\": ")
	if tmp, err := json.Marshal(strct.Arn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "AwsAccountId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AwsAccountId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AwsAccountId\": ")
	if tmp, err := json.Marshal(strct.AwsAccountId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BaseThemeId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BaseThemeId\": ")
	if tmp, err := json.Marshal(strct.BaseThemeId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Configuration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Configuration\": ")
	if tmp, err := json.Marshal(strct.Configuration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CreatedTime" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CreatedTime\": ")
	if tmp, err := json.Marshal(strct.CreatedTime); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LastUpdatedTime" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LastUpdatedTime\": ")
	if tmp, err := json.Marshal(strct.LastUpdatedTime); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Permissions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Permissions\": ")
	if tmp, err := json.Marshal(strct.Permissions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ThemeId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ThemeId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ThemeId\": ")
	if tmp, err := json.Marshal(strct.ThemeId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Version" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Version\": ")
	if tmp, err := json.Marshal(strct.Version); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VersionDescription" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VersionDescription\": ")
	if tmp, err := json.Marshal(strct.VersionDescription); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    AwsAccountIdReceived := false
    ThemeIdReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Arn":
            if err := json.Unmarshal([]byte(v), &strct.Arn); err != nil {
                return err
             }
        case "AwsAccountId":
            if err := json.Unmarshal([]byte(v), &strct.AwsAccountId); err != nil {
                return err
             }
            AwsAccountIdReceived = true
        case "BaseThemeId":
            if err := json.Unmarshal([]byte(v), &strct.BaseThemeId); err != nil {
                return err
             }
        case "Configuration":
            if err := json.Unmarshal([]byte(v), &strct.Configuration); err != nil {
                return err
             }
        case "CreatedTime":
            if err := json.Unmarshal([]byte(v), &strct.CreatedTime); err != nil {
                return err
             }
        case "LastUpdatedTime":
            if err := json.Unmarshal([]byte(v), &strct.LastUpdatedTime); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "Permissions":
            if err := json.Unmarshal([]byte(v), &strct.Permissions); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        case "ThemeId":
            if err := json.Unmarshal([]byte(v), &strct.ThemeId); err != nil {
                return err
             }
            ThemeIdReceived = true
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
        case "Version":
            if err := json.Unmarshal([]byte(v), &strct.Version); err != nil {
                return err
             }
        case "VersionDescription":
            if err := json.Unmarshal([]byte(v), &strct.VersionDescription); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if AwsAccountId (a required property) was received
    if !AwsAccountIdReceived {
        return errors.New("\"AwsAccountId\" is required but was not present")
    }
    // check if ThemeId (a required property) was received
    if !ThemeIdReceived {
        return errors.New("\"ThemeId\" is required but was not present")
    }
    return nil
}

func (strct *ResourcePermission) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Actions" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Actions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Actions\": ")
	if tmp, err := json.Marshal(strct.Actions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Principal" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Principal" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Principal\": ")
	if tmp, err := json.Marshal(strct.Principal); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ResourcePermission) UnmarshalJSON(b []byte) error {
    ActionsReceived := false
    PrincipalReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Actions":
            if err := json.Unmarshal([]byte(v), &strct.Actions); err != nil {
                return err
             }
            ActionsReceived = true
        case "Principal":
            if err := json.Unmarshal([]byte(v), &strct.Principal); err != nil {
                return err
             }
            PrincipalReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Actions (a required property) was received
    if !ActionsReceived {
        return errors.New("\"Actions\" is required but was not present")
    }
    // check if Principal (a required property) was received
    if !PrincipalReceived {
        return errors.New("\"Principal\" is required but was not present")
    }
    return nil
}

func (strct *SheetStyle) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Tile" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tile\": ")
	if tmp, err := json.Marshal(strct.Tile); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TileLayout" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TileLayout\": ")
	if tmp, err := json.Marshal(strct.TileLayout); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SheetStyle) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Tile":
            if err := json.Unmarshal([]byte(v), &strct.Tile); err != nil {
                return err
             }
        case "TileLayout":
            if err := json.Unmarshal([]byte(v), &strct.TileLayout); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *ThemeConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DataColorPalette" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DataColorPalette\": ")
	if tmp, err := json.Marshal(strct.DataColorPalette); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Sheet" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Sheet\": ")
	if tmp, err := json.Marshal(strct.Sheet); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Typography" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Typography\": ")
	if tmp, err := json.Marshal(strct.Typography); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "UIColorPalette" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UIColorPalette\": ")
	if tmp, err := json.Marshal(strct.UIColorPalette); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ThemeConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DataColorPalette":
            if err := json.Unmarshal([]byte(v), &strct.DataColorPalette); err != nil {
                return err
             }
        case "Sheet":
            if err := json.Unmarshal([]byte(v), &strct.Sheet); err != nil {
                return err
             }
        case "Typography":
            if err := json.Unmarshal([]byte(v), &strct.Typography); err != nil {
                return err
             }
        case "UIColorPalette":
            if err := json.Unmarshal([]byte(v), &strct.UIColorPalette); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ThemeError) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Message" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Message\": ")
	if tmp, err := json.Marshal(strct.Message); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ThemeError) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Message":
            if err := json.Unmarshal([]byte(v), &strct.Message); err != nil {
                return err
             }
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ThemeVersion) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Arn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Arn\": ")
	if tmp, err := json.Marshal(strct.Arn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BaseThemeId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BaseThemeId\": ")
	if tmp, err := json.Marshal(strct.BaseThemeId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Configuration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Configuration\": ")
	if tmp, err := json.Marshal(strct.Configuration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CreatedTime" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CreatedTime\": ")
	if tmp, err := json.Marshal(strct.CreatedTime); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Errors" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Errors\": ")
	if tmp, err := json.Marshal(strct.Errors); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Status" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Status\": ")
	if tmp, err := json.Marshal(strct.Status); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VersionNumber" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VersionNumber\": ")
	if tmp, err := json.Marshal(strct.VersionNumber); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ThemeVersion) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Arn":
            if err := json.Unmarshal([]byte(v), &strct.Arn); err != nil {
                return err
             }
        case "BaseThemeId":
            if err := json.Unmarshal([]byte(v), &strct.BaseThemeId); err != nil {
                return err
             }
        case "Configuration":
            if err := json.Unmarshal([]byte(v), &strct.Configuration); err != nil {
                return err
             }
        case "CreatedTime":
            if err := json.Unmarshal([]byte(v), &strct.CreatedTime); err != nil {
                return err
             }
        case "Description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "Errors":
            if err := json.Unmarshal([]byte(v), &strct.Errors); err != nil {
                return err
             }
        case "Status":
            if err := json.Unmarshal([]byte(v), &strct.Status); err != nil {
                return err
             }
        case "VersionNumber":
            if err := json.Unmarshal([]byte(v), &strct.VersionNumber); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *TileLayoutStyle) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Gutter" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Gutter\": ")
	if tmp, err := json.Marshal(strct.Gutter); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Margin" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Margin\": ")
	if tmp, err := json.Marshal(strct.Margin); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TileLayoutStyle) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Gutter":
            if err := json.Unmarshal([]byte(v), &strct.Gutter); err != nil {
                return err
             }
        case "Margin":
            if err := json.Unmarshal([]byte(v), &strct.Margin); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *TileStyle) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Border" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Border\": ")
	if tmp, err := json.Marshal(strct.Border); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TileStyle) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Border":
            if err := json.Unmarshal([]byte(v), &strct.Border); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Typography) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "FontFamilies" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FontFamilies\": ")
	if tmp, err := json.Marshal(strct.FontFamilies); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Typography) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "FontFamilies":
            if err := json.Unmarshal([]byte(v), &strct.FontFamilies); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *UIColorPalette) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Accent" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Accent\": ")
	if tmp, err := json.Marshal(strct.Accent); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AccentForeground" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AccentForeground\": ")
	if tmp, err := json.Marshal(strct.AccentForeground); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Danger" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Danger\": ")
	if tmp, err := json.Marshal(strct.Danger); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DangerForeground" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DangerForeground\": ")
	if tmp, err := json.Marshal(strct.DangerForeground); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Dimension" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Dimension\": ")
	if tmp, err := json.Marshal(strct.Dimension); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DimensionForeground" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DimensionForeground\": ")
	if tmp, err := json.Marshal(strct.DimensionForeground); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Measure" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Measure\": ")
	if tmp, err := json.Marshal(strct.Measure); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MeasureForeground" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MeasureForeground\": ")
	if tmp, err := json.Marshal(strct.MeasureForeground); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PrimaryBackground" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PrimaryBackground\": ")
	if tmp, err := json.Marshal(strct.PrimaryBackground); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PrimaryForeground" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PrimaryForeground\": ")
	if tmp, err := json.Marshal(strct.PrimaryForeground); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SecondaryBackground" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SecondaryBackground\": ")
	if tmp, err := json.Marshal(strct.SecondaryBackground); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SecondaryForeground" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SecondaryForeground\": ")
	if tmp, err := json.Marshal(strct.SecondaryForeground); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Success" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Success\": ")
	if tmp, err := json.Marshal(strct.Success); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SuccessForeground" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SuccessForeground\": ")
	if tmp, err := json.Marshal(strct.SuccessForeground); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Warning" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Warning\": ")
	if tmp, err := json.Marshal(strct.Warning); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "WarningForeground" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"WarningForeground\": ")
	if tmp, err := json.Marshal(strct.WarningForeground); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *UIColorPalette) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Accent":
            if err := json.Unmarshal([]byte(v), &strct.Accent); err != nil {
                return err
             }
        case "AccentForeground":
            if err := json.Unmarshal([]byte(v), &strct.AccentForeground); err != nil {
                return err
             }
        case "Danger":
            if err := json.Unmarshal([]byte(v), &strct.Danger); err != nil {
                return err
             }
        case "DangerForeground":
            if err := json.Unmarshal([]byte(v), &strct.DangerForeground); err != nil {
                return err
             }
        case "Dimension":
            if err := json.Unmarshal([]byte(v), &strct.Dimension); err != nil {
                return err
             }
        case "DimensionForeground":
            if err := json.Unmarshal([]byte(v), &strct.DimensionForeground); err != nil {
                return err
             }
        case "Measure":
            if err := json.Unmarshal([]byte(v), &strct.Measure); err != nil {
                return err
             }
        case "MeasureForeground":
            if err := json.Unmarshal([]byte(v), &strct.MeasureForeground); err != nil {
                return err
             }
        case "PrimaryBackground":
            if err := json.Unmarshal([]byte(v), &strct.PrimaryBackground); err != nil {
                return err
             }
        case "PrimaryForeground":
            if err := json.Unmarshal([]byte(v), &strct.PrimaryForeground); err != nil {
                return err
             }
        case "SecondaryBackground":
            if err := json.Unmarshal([]byte(v), &strct.SecondaryBackground); err != nil {
                return err
             }
        case "SecondaryForeground":
            if err := json.Unmarshal([]byte(v), &strct.SecondaryForeground); err != nil {
                return err
             }
        case "Success":
            if err := json.Unmarshal([]byte(v), &strct.Success); err != nil {
                return err
             }
        case "SuccessForeground":
            if err := json.Unmarshal([]byte(v), &strct.SuccessForeground); err != nil {
                return err
             }
        case "Warning":
            if err := json.Unmarshal([]byte(v), &strct.Warning); err != nil {
                return err
             }
        case "WarningForeground":
            if err := json.Unmarshal([]byte(v), &strct.WarningForeground); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}
