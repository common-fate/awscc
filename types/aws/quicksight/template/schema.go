// Code generated by schema-generate. DO NOT EDIT.

package template

import (
    "errors"
    "bytes"
    "encoding/json"
    "fmt"
)

// ColumnGroupColumnSchema <p>A structure describing the name, data type, and geographic role of the columns.</p>
type ColumnGroupColumnSchema struct {

  // <p>The name of the column group's column schema.</p>
  Name string `json:"Name,omitempty"`
}

// ColumnGroupSchema <p>The column group schema.</p>
type ColumnGroupSchema struct {

  // <p>A structure containing the list of schemas for column group columns.</p>
  ColumnGroupColumnSchemaList []*ColumnGroupColumnSchema `json:"ColumnGroupColumnSchemaList,omitempty"`

  // <p>The name of the column group schema.</p>
  Name string `json:"Name,omitempty"`
}

// ColumnSchema <p>The column schema.</p>
type ColumnSchema struct {

  // <p>The data type of the column schema.</p>
  DataType string `json:"DataType,omitempty"`

  // <p>The geographic role of the column schema.</p>
  GeographicRole string `json:"GeographicRole,omitempty"`

  // <p>The name of the column schema.</p>
  Name string `json:"Name,omitempty"`
}

// DataSetConfiguration <p>Dataset configuration.</p>
type DataSetConfiguration struct {

  // <p>A structure containing the list of column group schemas.</p>
  ColumnGroupSchemaList []*ColumnGroupSchema `json:"ColumnGroupSchemaList,omitempty"`
  DataSetSchema *DataSetSchema `json:"DataSetSchema,omitempty"`

  // <p>Placeholder.</p>
  Placeholder string `json:"Placeholder,omitempty"`
}

// DataSetReference <p>Dataset reference.</p>
type DataSetReference struct {

  // <p>Dataset Amazon Resource Name (ARN).</p>
  DataSetArn string `json:"DataSetArn"`

  // <p>Dataset placeholder.</p>
  DataSetPlaceholder string `json:"DataSetPlaceholder"`
}

// DataSetSchema <p>Dataset schema.</p>
type DataSetSchema struct {

  // <p>A structure containing the list of column schemas.</p>
  ColumnSchemaList []*ColumnSchema `json:"ColumnSchemaList,omitempty"`
}

// Resource Definition of the AWS::QuickSight::Template Resource Type.
type Resource struct {

  // <p>The Amazon Resource Name (ARN) of the template.</p>
  Arn string `json:"Arn,omitempty"`
  AwsAccountId string `json:"AwsAccountId"`

  // <p>Time when this was created.</p>
  CreatedTime string `json:"CreatedTime,omitempty"`

  // <p>Time when this was last updated.</p>
  LastUpdatedTime string `json:"LastUpdatedTime,omitempty"`

  // <p>A display name for the template.</p>
  Name string `json:"Name,omitempty"`

  // <p>A list of resource permissions to be set on the template. </p>
  Permissions []*ResourcePermission `json:"Permissions,omitempty"`
  SourceEntity *TemplateSourceEntity `json:"SourceEntity"`

  // <p>Contains a map of the key-value pairs for the resource tag or tags assigned to the resource.</p>
  Tags []*Tag `json:"Tags,omitempty"`
  TemplateId string `json:"TemplateId"`
  Version *TemplateVersion `json:"Version,omitempty"`

  // <p>A description of the current template version being created. This API operation creates the
  // 			first version of the template. Every time <code>UpdateTemplate</code> is called, a new
  // 			version is created. Each version of the template maintains a description of the version
  // 			in the <code>VersionDescription</code> field.</p>
  VersionDescription string `json:"VersionDescription,omitempty"`
}

// ResourcePermission <p>Permission for the resource.</p>
type ResourcePermission struct {

  // <p>The IAM action to grant or revoke permissions on.</p>
  Actions []string `json:"Actions"`

  // <p>The Amazon Resource Name (ARN) of the principal. This can be one of the
  //             following:</p>
  //         <ul>
  //             <li>
  //                 <p>The ARN of an Amazon QuickSight user or group associated with a data source or dataset. (This is common.)</p>
  //             </li>
  //             <li>
  //                 <p>The ARN of an Amazon QuickSight user, group, or namespace associated with an analysis, dashboard, template, or theme. (This is common.)</p>
  //             </li>
  //             <li>
  //                 <p>The ARN of an AWS account root: This is an IAM ARN rather than a QuickSight
  //                     ARN. Use this option only to share resources (templates) across AWS accounts.
  //                     (This is less common.) </p>
  //             </li>
  //          </ul>
  Principal string `json:"Principal"`
}

// Sheet <p>A <i>sheet</i>, which is an object that contains a set of visuals that
//             are viewed together on one page in the Amazon QuickSight console. Every analysis and dashboard
//             contains at least one sheet. Each sheet contains at least one visualization widget, for
//             example a chart, pivot table, or narrative insight. Sheets can be associated with other
//             components, such as controls, filters, and so on.</p>
type Sheet struct {

  // <p>The name of a sheet. This name is displayed on the sheet's tab in the QuickSight
  //             console.</p>
  Name string `json:"Name,omitempty"`

  // <p>The unique identifier associated with a sheet.</p>
  SheetId string `json:"SheetId,omitempty"`
}

// Tag <p>The key or keys of the key-value pairs for the resource tag or tags assigned to the
//             resource.</p>
type Tag struct {

  // <p>Tag key.</p>
  Key string `json:"Key"`

  // <p>Tag value.</p>
  Value string `json:"Value"`
}

// TemplateError <p>List of errors that occurred when the template version creation failed.</p>
type TemplateError struct {

  // <p>Description of the error type.</p>
  Message string `json:"Message,omitempty"`
  Type string `json:"Type,omitempty"`
}

// TemplateSourceAnalysis <p>The source analysis of the template.</p>
type TemplateSourceAnalysis struct {

  // <p>The Amazon Resource Name (ARN) of the resource.</p>
  Arn string `json:"Arn"`

  // <p>A structure containing information about the dataset references used as placeholders
  //             in the template.</p>
  DataSetReferences []*DataSetReference `json:"DataSetReferences"`
}

// TemplateSourceEntity <p>The source entity of the template.</p>
type TemplateSourceEntity struct {
  SourceAnalysis *TemplateSourceAnalysis `json:"SourceAnalysis,omitempty"`
  SourceTemplate *TemplateSourceTemplate `json:"SourceTemplate,omitempty"`
}

// TemplateSourceTemplate <p>The source template of the template.</p>
type TemplateSourceTemplate struct {

  // <p>The Amazon Resource Name (ARN) of the resource.</p>
  Arn string `json:"Arn"`
}

// TemplateVersion <p>A version of a template.</p>
type TemplateVersion struct {

  // <p>The time that this template version was created.</p>
  CreatedTime string `json:"CreatedTime,omitempty"`

  // <p>Schema of the dataset identified by the placeholder. Any dashboard created from this
  //             template should be bound to new datasets matching the same schema described through this
  //             API operation.</p>
  DataSetConfigurations []*DataSetConfiguration `json:"DataSetConfigurations,omitempty"`

  // <p>The description of the template.</p>
  Description string `json:"Description,omitempty"`

  // <p>Errors associated with this template version.</p>
  Errors []*TemplateError `json:"Errors,omitempty"`

  // <p>A list of the associated sheets with the unique identifier and name of each sheet.</p>
  Sheets []*Sheet `json:"Sheets,omitempty"`

  // <p>The Amazon Resource Name (ARN) of an analysis or template that was used to create this
  //             template.</p>
  SourceEntityArn string `json:"SourceEntityArn,omitempty"`
  Status string `json:"Status,omitempty"`

  // <p>The ARN of the theme associated with this version of the template.</p>
  ThemeArn string `json:"ThemeArn,omitempty"`

  // <p>The version number of the template version.</p>
  VersionNumber float64 `json:"VersionNumber,omitempty"`
}

func (strct *ColumnGroupColumnSchema) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ColumnGroupColumnSchema) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ColumnGroupSchema) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ColumnGroupColumnSchemaList" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ColumnGroupColumnSchemaList\": ")
	if tmp, err := json.Marshal(strct.ColumnGroupColumnSchemaList); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ColumnGroupSchema) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ColumnGroupColumnSchemaList":
            if err := json.Unmarshal([]byte(v), &strct.ColumnGroupColumnSchemaList); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ColumnSchema) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DataType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DataType\": ")
	if tmp, err := json.Marshal(strct.DataType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "GeographicRole" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"GeographicRole\": ")
	if tmp, err := json.Marshal(strct.GeographicRole); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ColumnSchema) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DataType":
            if err := json.Unmarshal([]byte(v), &strct.DataType); err != nil {
                return err
             }
        case "GeographicRole":
            if err := json.Unmarshal([]byte(v), &strct.GeographicRole); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *DataSetConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ColumnGroupSchemaList" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ColumnGroupSchemaList\": ")
	if tmp, err := json.Marshal(strct.ColumnGroupSchemaList); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DataSetSchema" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DataSetSchema\": ")
	if tmp, err := json.Marshal(strct.DataSetSchema); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Placeholder" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Placeholder\": ")
	if tmp, err := json.Marshal(strct.Placeholder); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DataSetConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ColumnGroupSchemaList":
            if err := json.Unmarshal([]byte(v), &strct.ColumnGroupSchemaList); err != nil {
                return err
             }
        case "DataSetSchema":
            if err := json.Unmarshal([]byte(v), &strct.DataSetSchema); err != nil {
                return err
             }
        case "Placeholder":
            if err := json.Unmarshal([]byte(v), &strct.Placeholder); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *DataSetReference) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "DataSetArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "DataSetArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DataSetArn\": ")
	if tmp, err := json.Marshal(strct.DataSetArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "DataSetPlaceholder" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "DataSetPlaceholder" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DataSetPlaceholder\": ")
	if tmp, err := json.Marshal(strct.DataSetPlaceholder); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DataSetReference) UnmarshalJSON(b []byte) error {
    DataSetArnReceived := false
    DataSetPlaceholderReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DataSetArn":
            if err := json.Unmarshal([]byte(v), &strct.DataSetArn); err != nil {
                return err
             }
            DataSetArnReceived = true
        case "DataSetPlaceholder":
            if err := json.Unmarshal([]byte(v), &strct.DataSetPlaceholder); err != nil {
                return err
             }
            DataSetPlaceholderReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if DataSetArn (a required property) was received
    if !DataSetArnReceived {
        return errors.New("\"DataSetArn\" is required but was not present")
    }
    // check if DataSetPlaceholder (a required property) was received
    if !DataSetPlaceholderReceived {
        return errors.New("\"DataSetPlaceholder\" is required but was not present")
    }
    return nil
}

func (strct *DataSetSchema) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ColumnSchemaList" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ColumnSchemaList\": ")
	if tmp, err := json.Marshal(strct.ColumnSchemaList); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DataSetSchema) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ColumnSchemaList":
            if err := json.Unmarshal([]byte(v), &strct.ColumnSchemaList); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Arn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Arn\": ")
	if tmp, err := json.Marshal(strct.Arn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "AwsAccountId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AwsAccountId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AwsAccountId\": ")
	if tmp, err := json.Marshal(strct.AwsAccountId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CreatedTime" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CreatedTime\": ")
	if tmp, err := json.Marshal(strct.CreatedTime); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LastUpdatedTime" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LastUpdatedTime\": ")
	if tmp, err := json.Marshal(strct.LastUpdatedTime); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Permissions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Permissions\": ")
	if tmp, err := json.Marshal(strct.Permissions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "SourceEntity" field is required
    if strct.SourceEntity == nil {
        return nil, errors.New("SourceEntity is a required field")
    }
    // Marshal the "SourceEntity" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SourceEntity\": ")
	if tmp, err := json.Marshal(strct.SourceEntity); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TemplateId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TemplateId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TemplateId\": ")
	if tmp, err := json.Marshal(strct.TemplateId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Version" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Version\": ")
	if tmp, err := json.Marshal(strct.Version); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VersionDescription" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VersionDescription\": ")
	if tmp, err := json.Marshal(strct.VersionDescription); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    AwsAccountIdReceived := false
    SourceEntityReceived := false
    TemplateIdReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Arn":
            if err := json.Unmarshal([]byte(v), &strct.Arn); err != nil {
                return err
             }
        case "AwsAccountId":
            if err := json.Unmarshal([]byte(v), &strct.AwsAccountId); err != nil {
                return err
             }
            AwsAccountIdReceived = true
        case "CreatedTime":
            if err := json.Unmarshal([]byte(v), &strct.CreatedTime); err != nil {
                return err
             }
        case "LastUpdatedTime":
            if err := json.Unmarshal([]byte(v), &strct.LastUpdatedTime); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "Permissions":
            if err := json.Unmarshal([]byte(v), &strct.Permissions); err != nil {
                return err
             }
        case "SourceEntity":
            if err := json.Unmarshal([]byte(v), &strct.SourceEntity); err != nil {
                return err
             }
            SourceEntityReceived = true
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        case "TemplateId":
            if err := json.Unmarshal([]byte(v), &strct.TemplateId); err != nil {
                return err
             }
            TemplateIdReceived = true
        case "Version":
            if err := json.Unmarshal([]byte(v), &strct.Version); err != nil {
                return err
             }
        case "VersionDescription":
            if err := json.Unmarshal([]byte(v), &strct.VersionDescription); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if AwsAccountId (a required property) was received
    if !AwsAccountIdReceived {
        return errors.New("\"AwsAccountId\" is required but was not present")
    }
    // check if SourceEntity (a required property) was received
    if !SourceEntityReceived {
        return errors.New("\"SourceEntity\" is required but was not present")
    }
    // check if TemplateId (a required property) was received
    if !TemplateIdReceived {
        return errors.New("\"TemplateId\" is required but was not present")
    }
    return nil
}

func (strct *ResourcePermission) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Actions" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Actions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Actions\": ")
	if tmp, err := json.Marshal(strct.Actions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Principal" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Principal" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Principal\": ")
	if tmp, err := json.Marshal(strct.Principal); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ResourcePermission) UnmarshalJSON(b []byte) error {
    ActionsReceived := false
    PrincipalReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Actions":
            if err := json.Unmarshal([]byte(v), &strct.Actions); err != nil {
                return err
             }
            ActionsReceived = true
        case "Principal":
            if err := json.Unmarshal([]byte(v), &strct.Principal); err != nil {
                return err
             }
            PrincipalReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Actions (a required property) was received
    if !ActionsReceived {
        return errors.New("\"Actions\" is required but was not present")
    }
    // check if Principal (a required property) was received
    if !PrincipalReceived {
        return errors.New("\"Principal\" is required but was not present")
    }
    return nil
}

func (strct *Sheet) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SheetId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SheetId\": ")
	if tmp, err := json.Marshal(strct.SheetId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Sheet) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "SheetId":
            if err := json.Unmarshal([]byte(v), &strct.SheetId); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *TemplateError) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Message" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Message\": ")
	if tmp, err := json.Marshal(strct.Message); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TemplateError) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Message":
            if err := json.Unmarshal([]byte(v), &strct.Message); err != nil {
                return err
             }
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *TemplateSourceAnalysis) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Arn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Arn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Arn\": ")
	if tmp, err := json.Marshal(strct.Arn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "DataSetReferences" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "DataSetReferences" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DataSetReferences\": ")
	if tmp, err := json.Marshal(strct.DataSetReferences); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TemplateSourceAnalysis) UnmarshalJSON(b []byte) error {
    ArnReceived := false
    DataSetReferencesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Arn":
            if err := json.Unmarshal([]byte(v), &strct.Arn); err != nil {
                return err
             }
            ArnReceived = true
        case "DataSetReferences":
            if err := json.Unmarshal([]byte(v), &strct.DataSetReferences); err != nil {
                return err
             }
            DataSetReferencesReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Arn (a required property) was received
    if !ArnReceived {
        return errors.New("\"Arn\" is required but was not present")
    }
    // check if DataSetReferences (a required property) was received
    if !DataSetReferencesReceived {
        return errors.New("\"DataSetReferences\" is required but was not present")
    }
    return nil
}

func (strct *TemplateSourceEntity) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "SourceAnalysis" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SourceAnalysis\": ")
	if tmp, err := json.Marshal(strct.SourceAnalysis); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SourceTemplate" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SourceTemplate\": ")
	if tmp, err := json.Marshal(strct.SourceTemplate); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TemplateSourceEntity) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "SourceAnalysis":
            if err := json.Unmarshal([]byte(v), &strct.SourceAnalysis); err != nil {
                return err
             }
        case "SourceTemplate":
            if err := json.Unmarshal([]byte(v), &strct.SourceTemplate); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *TemplateSourceTemplate) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Arn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Arn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Arn\": ")
	if tmp, err := json.Marshal(strct.Arn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TemplateSourceTemplate) UnmarshalJSON(b []byte) error {
    ArnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Arn":
            if err := json.Unmarshal([]byte(v), &strct.Arn); err != nil {
                return err
             }
            ArnReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Arn (a required property) was received
    if !ArnReceived {
        return errors.New("\"Arn\" is required but was not present")
    }
    return nil
}

func (strct *TemplateVersion) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CreatedTime" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CreatedTime\": ")
	if tmp, err := json.Marshal(strct.CreatedTime); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DataSetConfigurations" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DataSetConfigurations\": ")
	if tmp, err := json.Marshal(strct.DataSetConfigurations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Errors" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Errors\": ")
	if tmp, err := json.Marshal(strct.Errors); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Sheets" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Sheets\": ")
	if tmp, err := json.Marshal(strct.Sheets); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SourceEntityArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SourceEntityArn\": ")
	if tmp, err := json.Marshal(strct.SourceEntityArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Status" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Status\": ")
	if tmp, err := json.Marshal(strct.Status); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ThemeArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ThemeArn\": ")
	if tmp, err := json.Marshal(strct.ThemeArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VersionNumber" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VersionNumber\": ")
	if tmp, err := json.Marshal(strct.VersionNumber); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TemplateVersion) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CreatedTime":
            if err := json.Unmarshal([]byte(v), &strct.CreatedTime); err != nil {
                return err
             }
        case "DataSetConfigurations":
            if err := json.Unmarshal([]byte(v), &strct.DataSetConfigurations); err != nil {
                return err
             }
        case "Description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "Errors":
            if err := json.Unmarshal([]byte(v), &strct.Errors); err != nil {
                return err
             }
        case "Sheets":
            if err := json.Unmarshal([]byte(v), &strct.Sheets); err != nil {
                return err
             }
        case "SourceEntityArn":
            if err := json.Unmarshal([]byte(v), &strct.SourceEntityArn); err != nil {
                return err
             }
        case "Status":
            if err := json.Unmarshal([]byte(v), &strct.Status); err != nil {
                return err
             }
        case "ThemeArn":
            if err := json.Unmarshal([]byte(v), &strct.ThemeArn); err != nil {
                return err
             }
        case "VersionNumber":
            if err := json.Unmarshal([]byte(v), &strct.VersionNumber); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}
