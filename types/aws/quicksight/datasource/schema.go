// Code generated by schema-generate. DO NOT EDIT.

package datasource

import (
    "bytes"
    "encoding/json"
    "errors"
    "fmt"
)

// AmazonElasticsearchParameters <p>Amazon Elasticsearch Service parameters.</p>
type AmazonElasticsearchParameters struct {

  // <p>The Amazon Elasticsearch Service domain.</p>
  Domain string `json:"Domain"`
}

// AmazonOpenSearchParameters <p>Amazon OpenSearch Service parameters.</p>
type AmazonOpenSearchParameters struct {

  // <p>The Amazon OpenSearch Service domain.</p>
  Domain string `json:"Domain"`
}

// AthenaParameters <p>Amazon Athena parameters.</p>
type AthenaParameters struct {

  // <p>The workgroup that Amazon Athena uses.</p>
  WorkGroup string `json:"WorkGroup,omitempty"`
}

// AuroraParameters <p>Amazon Aurora parameters.</p>
type AuroraParameters struct {

  // <p>Database.</p>
  Database string `json:"Database"`

  // <p>Host.</p>
  Host string `json:"Host"`

  // <p>Port.</p>
  Port float64 `json:"Port"`
}

// AuroraPostgreSqlParameters <p>Amazon Aurora with PostgreSQL compatibility parameters.</p>
type AuroraPostgreSqlParameters struct {

  // <p>Database.</p>
  Database string `json:"Database"`

  // <p>Host.</p>
  Host string `json:"Host"`

  // <p>Port.</p>
  Port float64 `json:"Port"`
}

// AwsIotAnalyticsParameters <p>AWS IoT Analytics parameters.</p>
type AwsIotAnalyticsParameters struct {

  // <p>Dataset name.</p>
  DataSetName string `json:"DataSetName"`
}

// CredentialPair <p>The combination of user name and password that are used as credentials.</p>
type CredentialPair struct {

  // <p>A set of alternate data source parameters that you want to share for these
  //             credentials. The credentials are applied in tandem with the data source parameters when
  //             you copy a data source by using a create or update request. The API operation compares
  //             the <code>DataSourceParameters</code> structure that's in the request with the
  //             structures in the <code>AlternateDataSourceParameters</code> allow list. If the
  //             structures are an exact match, the request is allowed to use the new data source with
  //             the existing credentials. If the <code>AlternateDataSourceParameters</code> list is
  //             null, the <code>DataSourceParameters</code> originally used with these
  //                 <code>Credentials</code> is automatically allowed.</p>
  AlternateDataSourceParameters []*DataSourceParameters `json:"AlternateDataSourceParameters,omitempty"`

  // <p>Password.</p>
  Password string `json:"Password"`

  // <p>User name.</p>
  Username string `json:"Username"`
}

// DataSourceCredentials <p>Data source credentials. This is a variant type structure. For this structure to be
//             valid, only one of the attributes can be non-null.</p>
type DataSourceCredentials struct {

  // <p>The Amazon Resource Name (ARN) of a data source that has the credential pair that you
  //             want to use. When <code>CopySourceArn</code> is not null, the credential pair from the
  //             data source in the ARN is used as the credentials for the
  //             <code>DataSourceCredentials</code> structure.</p>
  CopySourceArn string `json:"CopySourceArn,omitempty"`
  CredentialPair *CredentialPair `json:"CredentialPair,omitempty"`

  // <p>The Amazon Resource Name (ARN) of the secret associated with the data source in Amazon Secrets Manager.</p>
  SecretArn string `json:"SecretArn,omitempty"`
}

// DataSourceErrorInfo <p>Error information for the data source creation or update.</p>
type DataSourceErrorInfo struct {

  // <p>Error message.</p>
  Message string `json:"Message,omitempty"`
  Type string `json:"Type,omitempty"`
}

// DataSourceParameters <p>The parameters that Amazon QuickSight uses to connect to your underlying data source.
//             This is a variant type structure. For this structure to be valid, only one of the
//             attributes can be non-null.</p>
type DataSourceParameters struct {
  AmazonElasticsearchParameters *AmazonElasticsearchParameters `json:"AmazonElasticsearchParameters,omitempty"`
  AmazonOpenSearchParameters *AmazonOpenSearchParameters `json:"AmazonOpenSearchParameters,omitempty"`
  AthenaParameters *AthenaParameters `json:"AthenaParameters,omitempty"`
  AuroraParameters *AuroraParameters `json:"AuroraParameters,omitempty"`
  AuroraPostgreSqlParameters *AuroraPostgreSqlParameters `json:"AuroraPostgreSqlParameters,omitempty"`
  DatabricksParameters *DatabricksParameters `json:"DatabricksParameters,omitempty"`
  MariaDbParameters *MariaDbParameters `json:"MariaDbParameters,omitempty"`
  MySqlParameters *MySqlParameters `json:"MySqlParameters,omitempty"`
  OracleParameters *OracleParameters `json:"OracleParameters,omitempty"`
  PostgreSqlParameters *PostgreSqlParameters `json:"PostgreSqlParameters,omitempty"`
  PrestoParameters *PrestoParameters `json:"PrestoParameters,omitempty"`
  RdsParameters *RdsParameters `json:"RdsParameters,omitempty"`
  RedshiftParameters *RedshiftParameters `json:"RedshiftParameters,omitempty"`
  S3Parameters *S3Parameters `json:"S3Parameters,omitempty"`
  SnowflakeParameters *SnowflakeParameters `json:"SnowflakeParameters,omitempty"`
  SparkParameters *SparkParameters `json:"SparkParameters,omitempty"`
  SqlServerParameters *SqlServerParameters `json:"SqlServerParameters,omitempty"`
  TeradataParameters *TeradataParameters `json:"TeradataParameters,omitempty"`
}

// DatabricksParameters <p>Databricks parameters.</p>
type DatabricksParameters struct {

  // <p>Host.</p>
  Host string `json:"Host"`

  // <p>Port.</p>
  Port float64 `json:"Port"`

  // <p>The HTTP Path of the Databricks data source.</p>
  SqlEndpointPath string `json:"SqlEndpointPath"`
}

// ManifestFileLocation <p>Amazon S3 manifest file location.</p>
type ManifestFileLocation struct {

  // <p>Amazon S3 bucket.</p>
  Bucket string `json:"Bucket"`

  // <p>Amazon S3 key that identifies an object.</p>
  Key string `json:"Key"`
}

// MariaDbParameters <p>MariaDB parameters.</p>
type MariaDbParameters struct {

  // <p>Database.</p>
  Database string `json:"Database"`

  // <p>Host.</p>
  Host string `json:"Host"`

  // <p>Port.</p>
  Port float64 `json:"Port"`
}

// MySqlParameters <p>MySQL parameters.</p>
type MySqlParameters struct {

  // <p>Database.</p>
  Database string `json:"Database"`

  // <p>Host.</p>
  Host string `json:"Host"`

  // <p>Port.</p>
  Port float64 `json:"Port"`
}

// OracleParameters 
type OracleParameters struct {
  Database string `json:"Database"`
  Host string `json:"Host"`
  Port float64 `json:"Port"`
}

// PostgreSqlParameters <p>PostgreSQL parameters.</p>
type PostgreSqlParameters struct {

  // <p>Database.</p>
  Database string `json:"Database"`

  // <p>Host.</p>
  Host string `json:"Host"`

  // <p>Port.</p>
  Port float64 `json:"Port"`
}

// PrestoParameters <p>Presto parameters.</p>
type PrestoParameters struct {

  // <p>Catalog.</p>
  Catalog string `json:"Catalog"`

  // <p>Host.</p>
  Host string `json:"Host"`

  // <p>Port.</p>
  Port float64 `json:"Port"`
}

// RdsParameters <p>Amazon RDS parameters.</p>
type RdsParameters struct {

  // <p>Database.</p>
  Database string `json:"Database"`

  // <p>Instance ID.</p>
  InstanceId string `json:"InstanceId"`
}

// RedshiftParameters <p>Amazon Redshift parameters. The <code>ClusterId</code> field can be blank if
//             <code>Host</code> and <code>Port</code> are both set. The <code>Host</code> and
//             <code>Port</code> fields can be blank if the <code>ClusterId</code> field is set.</p>
type RedshiftParameters struct {

  // <p>Cluster ID. This field can be blank if the <code>Host</code> and <code>Port</code> are
  //             provided.</p>
  ClusterId string `json:"ClusterId,omitempty"`

  // <p>Database.</p>
  Database string `json:"Database"`

  // <p>Host. This field can be blank if <code>ClusterId</code> is provided.</p>
  Host string `json:"Host,omitempty"`

  // <p>Port. This field can be blank if the <code>ClusterId</code> is provided.</p>
  Port float64 `json:"Port,omitempty"`
}

// Resource Definition of the AWS::QuickSight::DataSource Resource Type.
type Resource struct {

  // <p>A set of alternate data source parameters that you want to share for the credentials
  //             stored with this data source. The credentials are applied in tandem with the data source
  //             parameters when you copy a data source by using a create or update request. The API
  //             operation compares the <code>DataSourceParameters</code> structure that's in the request
  //             with the structures in the <code>AlternateDataSourceParameters</code> allow list. If the
  //             structures are an exact match, the request is allowed to use the credentials from this
  //             existing data source. If the <code>AlternateDataSourceParameters</code> list is null,
  //             the <code>Credentials</code> originally used with this <code>DataSourceParameters</code>
  //             are automatically allowed.</p>
  AlternateDataSourceParameters []*DataSourceParameters `json:"AlternateDataSourceParameters,omitempty"`

  // <p>The Amazon Resource Name (ARN) of the data source.</p>
  Arn string `json:"Arn,omitempty"`
  AwsAccountId string `json:"AwsAccountId,omitempty"`

  // <p>The time that this data source was created.</p>
  CreatedTime string `json:"CreatedTime,omitempty"`
  Credentials *DataSourceCredentials `json:"Credentials,omitempty"`
  DataSourceId string `json:"DataSourceId,omitempty"`
  DataSourceParameters *DataSourceParameters `json:"DataSourceParameters,omitempty"`
  ErrorInfo *DataSourceErrorInfo `json:"ErrorInfo,omitempty"`

  // <p>The last time that this data source was updated.</p>
  LastUpdatedTime string `json:"LastUpdatedTime,omitempty"`

  // <p>A display name for the data source.</p>
  Name string `json:"Name,omitempty"`

  // <p>A list of resource permissions on the data source.</p>
  Permissions []*ResourcePermission `json:"Permissions,omitempty"`
  SslProperties *SslProperties `json:"SslProperties,omitempty"`
  Status string `json:"Status,omitempty"`

  // <p>Contains a map of the key-value pairs for the resource tag or tags assigned to the data source.</p>
  Tags []*Tag `json:"Tags,omitempty"`
  Type string `json:"Type,omitempty"`
  VpcConnectionProperties *VpcConnectionProperties `json:"VpcConnectionProperties,omitempty"`
}

// ResourcePermission <p>Permission for the resource.</p>
type ResourcePermission struct {

  // <p>The IAM action to grant or revoke permissions on.</p>
  Actions []string `json:"Actions"`

  // <p>The Amazon Resource Name (ARN) of the principal. This can be one of the
  //             following:</p>
  //         <ul>
  //             <li>
  //                 <p>The ARN of an Amazon QuickSight user or group associated with a data source or dataset. (This is common.)</p>
  //             </li>
  //             <li>
  //                 <p>The ARN of an Amazon QuickSight user, group, or namespace associated with an analysis, dashboard, template, or theme. (This is common.)</p>
  //             </li>
  //             <li>
  //                 <p>The ARN of an AWS account root: This is an IAM ARN rather than a QuickSight
  //                     ARN. Use this option only to share resources (templates) across AWS accounts.
  //                     (This is less common.) </p>
  //             </li>
  //          </ul>
  Principal string `json:"Principal"`
}

// S3Parameters <p>S3 parameters.</p>
type S3Parameters struct {
  ManifestFileLocation *ManifestFileLocation `json:"ManifestFileLocation"`
}

// SnowflakeParameters <p>Snowflake parameters.</p>
type SnowflakeParameters struct {

  // <p>Database.</p>
  Database string `json:"Database"`

  // <p>Host.</p>
  Host string `json:"Host"`

  // <p>Warehouse.</p>
  Warehouse string `json:"Warehouse"`
}

// SparkParameters <p>Spark parameters.</p>
type SparkParameters struct {

  // <p>Host.</p>
  Host string `json:"Host"`

  // <p>Port.</p>
  Port float64 `json:"Port"`
}

// SqlServerParameters <p>SQL Server parameters.</p>
type SqlServerParameters struct {

  // <p>Database.</p>
  Database string `json:"Database"`

  // <p>Host.</p>
  Host string `json:"Host"`

  // <p>Port.</p>
  Port float64 `json:"Port"`
}

// SslProperties <p>Secure Socket Layer (SSL) properties that apply when QuickSight connects to your
//             underlying data source.</p>
type SslProperties struct {

  // <p>A Boolean option to control whether SSL should be disabled.</p>
  DisableSsl bool `json:"DisableSsl,omitempty"`
}

// Tag <p>The key or keys of the key-value pairs for the resource tag or tags assigned to the
//             resource.</p>
type Tag struct {

  // <p>Tag key.</p>
  Key string `json:"Key"`

  // <p>Tag value.</p>
  Value string `json:"Value"`
}

// TeradataParameters <p>Teradata parameters.</p>
type TeradataParameters struct {

  // <p>Database.</p>
  Database string `json:"Database"`

  // <p>Host.</p>
  Host string `json:"Host"`

  // <p>Port.</p>
  Port float64 `json:"Port"`
}

// VpcConnectionProperties <p>VPC connection properties.</p>
type VpcConnectionProperties struct {

  // <p>The Amazon Resource Name (ARN) for the VPC connection.</p>
  VpcConnectionArn string `json:"VpcConnectionArn"`
}

func (strct *AmazonElasticsearchParameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Domain" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Domain" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Domain\": ")
	if tmp, err := json.Marshal(strct.Domain); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AmazonElasticsearchParameters) UnmarshalJSON(b []byte) error {
    DomainReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Domain":
            if err := json.Unmarshal([]byte(v), &strct.Domain); err != nil {
                return err
             }
            DomainReceived = true
        }
    }
    // check if Domain (a required property) was received
    if !DomainReceived {
        return errors.New("\"Domain\" is required but was not present")
    }
    return nil
}

func (strct *AmazonOpenSearchParameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Domain" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Domain" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Domain\": ")
	if tmp, err := json.Marshal(strct.Domain); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AmazonOpenSearchParameters) UnmarshalJSON(b []byte) error {
    DomainReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Domain":
            if err := json.Unmarshal([]byte(v), &strct.Domain); err != nil {
                return err
             }
            DomainReceived = true
        }
    }
    // check if Domain (a required property) was received
    if !DomainReceived {
        return errors.New("\"Domain\" is required but was not present")
    }
    return nil
}

func (strct *AuroraParameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Database" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Database" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Database\": ")
	if tmp, err := json.Marshal(strct.Database); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Host" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Host" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Host\": ")
	if tmp, err := json.Marshal(strct.Host); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Port" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Port" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Port\": ")
	if tmp, err := json.Marshal(strct.Port); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AuroraParameters) UnmarshalJSON(b []byte) error {
    DatabaseReceived := false
    HostReceived := false
    PortReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Database":
            if err := json.Unmarshal([]byte(v), &strct.Database); err != nil {
                return err
             }
            DatabaseReceived = true
        case "Host":
            if err := json.Unmarshal([]byte(v), &strct.Host); err != nil {
                return err
             }
            HostReceived = true
        case "Port":
            if err := json.Unmarshal([]byte(v), &strct.Port); err != nil {
                return err
             }
            PortReceived = true
        }
    }
    // check if Database (a required property) was received
    if !DatabaseReceived {
        return errors.New("\"Database\" is required but was not present")
    }
    // check if Host (a required property) was received
    if !HostReceived {
        return errors.New("\"Host\" is required but was not present")
    }
    // check if Port (a required property) was received
    if !PortReceived {
        return errors.New("\"Port\" is required but was not present")
    }
    return nil
}

func (strct *AuroraPostgreSqlParameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Database" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Database" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Database\": ")
	if tmp, err := json.Marshal(strct.Database); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Host" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Host" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Host\": ")
	if tmp, err := json.Marshal(strct.Host); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Port" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Port" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Port\": ")
	if tmp, err := json.Marshal(strct.Port); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AuroraPostgreSqlParameters) UnmarshalJSON(b []byte) error {
    DatabaseReceived := false
    HostReceived := false
    PortReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Database":
            if err := json.Unmarshal([]byte(v), &strct.Database); err != nil {
                return err
             }
            DatabaseReceived = true
        case "Host":
            if err := json.Unmarshal([]byte(v), &strct.Host); err != nil {
                return err
             }
            HostReceived = true
        case "Port":
            if err := json.Unmarshal([]byte(v), &strct.Port); err != nil {
                return err
             }
            PortReceived = true
        }
    }
    // check if Database (a required property) was received
    if !DatabaseReceived {
        return errors.New("\"Database\" is required but was not present")
    }
    // check if Host (a required property) was received
    if !HostReceived {
        return errors.New("\"Host\" is required but was not present")
    }
    // check if Port (a required property) was received
    if !PortReceived {
        return errors.New("\"Port\" is required but was not present")
    }
    return nil
}

func (strct *AwsIotAnalyticsParameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "DataSetName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "DataSetName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DataSetName\": ")
	if tmp, err := json.Marshal(strct.DataSetName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AwsIotAnalyticsParameters) UnmarshalJSON(b []byte) error {
    DataSetNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DataSetName":
            if err := json.Unmarshal([]byte(v), &strct.DataSetName); err != nil {
                return err
             }
            DataSetNameReceived = true
        }
    }
    // check if DataSetName (a required property) was received
    if !DataSetNameReceived {
        return errors.New("\"DataSetName\" is required but was not present")
    }
    return nil
}

func (strct *CredentialPair) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AlternateDataSourceParameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AlternateDataSourceParameters\": ")
	if tmp, err := json.Marshal(strct.AlternateDataSourceParameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Password" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Password" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Password\": ")
	if tmp, err := json.Marshal(strct.Password); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Username" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Username" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Username\": ")
	if tmp, err := json.Marshal(strct.Username); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CredentialPair) UnmarshalJSON(b []byte) error {
    PasswordReceived := false
    UsernameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AlternateDataSourceParameters":
            if err := json.Unmarshal([]byte(v), &strct.AlternateDataSourceParameters); err != nil {
                return err
             }
        case "Password":
            if err := json.Unmarshal([]byte(v), &strct.Password); err != nil {
                return err
             }
            PasswordReceived = true
        case "Username":
            if err := json.Unmarshal([]byte(v), &strct.Username); err != nil {
                return err
             }
            UsernameReceived = true
        }
    }
    // check if Password (a required property) was received
    if !PasswordReceived {
        return errors.New("\"Password\" is required but was not present")
    }
    // check if Username (a required property) was received
    if !UsernameReceived {
        return errors.New("\"Username\" is required but was not present")
    }
    return nil
}

func (strct *DatabricksParameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Host" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Host" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Host\": ")
	if tmp, err := json.Marshal(strct.Host); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Port" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Port" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Port\": ")
	if tmp, err := json.Marshal(strct.Port); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "SqlEndpointPath" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "SqlEndpointPath" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SqlEndpointPath\": ")
	if tmp, err := json.Marshal(strct.SqlEndpointPath); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DatabricksParameters) UnmarshalJSON(b []byte) error {
    HostReceived := false
    PortReceived := false
    SqlEndpointPathReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Host":
            if err := json.Unmarshal([]byte(v), &strct.Host); err != nil {
                return err
             }
            HostReceived = true
        case "Port":
            if err := json.Unmarshal([]byte(v), &strct.Port); err != nil {
                return err
             }
            PortReceived = true
        case "SqlEndpointPath":
            if err := json.Unmarshal([]byte(v), &strct.SqlEndpointPath); err != nil {
                return err
             }
            SqlEndpointPathReceived = true
        }
    }
    // check if Host (a required property) was received
    if !HostReceived {
        return errors.New("\"Host\" is required but was not present")
    }
    // check if Port (a required property) was received
    if !PortReceived {
        return errors.New("\"Port\" is required but was not present")
    }
    // check if SqlEndpointPath (a required property) was received
    if !SqlEndpointPathReceived {
        return errors.New("\"SqlEndpointPath\" is required but was not present")
    }
    return nil
}

func (strct *ManifestFileLocation) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Bucket" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Bucket" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Bucket\": ")
	if tmp, err := json.Marshal(strct.Bucket); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ManifestFileLocation) UnmarshalJSON(b []byte) error {
    BucketReceived := false
    KeyReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Bucket":
            if err := json.Unmarshal([]byte(v), &strct.Bucket); err != nil {
                return err
             }
            BucketReceived = true
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        }
    }
    // check if Bucket (a required property) was received
    if !BucketReceived {
        return errors.New("\"Bucket\" is required but was not present")
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    return nil
}

func (strct *MariaDbParameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Database" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Database" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Database\": ")
	if tmp, err := json.Marshal(strct.Database); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Host" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Host" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Host\": ")
	if tmp, err := json.Marshal(strct.Host); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Port" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Port" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Port\": ")
	if tmp, err := json.Marshal(strct.Port); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MariaDbParameters) UnmarshalJSON(b []byte) error {
    DatabaseReceived := false
    HostReceived := false
    PortReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Database":
            if err := json.Unmarshal([]byte(v), &strct.Database); err != nil {
                return err
             }
            DatabaseReceived = true
        case "Host":
            if err := json.Unmarshal([]byte(v), &strct.Host); err != nil {
                return err
             }
            HostReceived = true
        case "Port":
            if err := json.Unmarshal([]byte(v), &strct.Port); err != nil {
                return err
             }
            PortReceived = true
        }
    }
    // check if Database (a required property) was received
    if !DatabaseReceived {
        return errors.New("\"Database\" is required but was not present")
    }
    // check if Host (a required property) was received
    if !HostReceived {
        return errors.New("\"Host\" is required but was not present")
    }
    // check if Port (a required property) was received
    if !PortReceived {
        return errors.New("\"Port\" is required but was not present")
    }
    return nil
}

func (strct *MySqlParameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Database" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Database" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Database\": ")
	if tmp, err := json.Marshal(strct.Database); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Host" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Host" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Host\": ")
	if tmp, err := json.Marshal(strct.Host); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Port" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Port" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Port\": ")
	if tmp, err := json.Marshal(strct.Port); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MySqlParameters) UnmarshalJSON(b []byte) error {
    DatabaseReceived := false
    HostReceived := false
    PortReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Database":
            if err := json.Unmarshal([]byte(v), &strct.Database); err != nil {
                return err
             }
            DatabaseReceived = true
        case "Host":
            if err := json.Unmarshal([]byte(v), &strct.Host); err != nil {
                return err
             }
            HostReceived = true
        case "Port":
            if err := json.Unmarshal([]byte(v), &strct.Port); err != nil {
                return err
             }
            PortReceived = true
        }
    }
    // check if Database (a required property) was received
    if !DatabaseReceived {
        return errors.New("\"Database\" is required but was not present")
    }
    // check if Host (a required property) was received
    if !HostReceived {
        return errors.New("\"Host\" is required but was not present")
    }
    // check if Port (a required property) was received
    if !PortReceived {
        return errors.New("\"Port\" is required but was not present")
    }
    return nil
}

func (strct *OracleParameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Database" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Database" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Database\": ")
	if tmp, err := json.Marshal(strct.Database); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Host" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Host" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Host\": ")
	if tmp, err := json.Marshal(strct.Host); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Port" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Port" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Port\": ")
	if tmp, err := json.Marshal(strct.Port); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *OracleParameters) UnmarshalJSON(b []byte) error {
    DatabaseReceived := false
    HostReceived := false
    PortReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Database":
            if err := json.Unmarshal([]byte(v), &strct.Database); err != nil {
                return err
             }
            DatabaseReceived = true
        case "Host":
            if err := json.Unmarshal([]byte(v), &strct.Host); err != nil {
                return err
             }
            HostReceived = true
        case "Port":
            if err := json.Unmarshal([]byte(v), &strct.Port); err != nil {
                return err
             }
            PortReceived = true
        }
    }
    // check if Database (a required property) was received
    if !DatabaseReceived {
        return errors.New("\"Database\" is required but was not present")
    }
    // check if Host (a required property) was received
    if !HostReceived {
        return errors.New("\"Host\" is required but was not present")
    }
    // check if Port (a required property) was received
    if !PortReceived {
        return errors.New("\"Port\" is required but was not present")
    }
    return nil
}

func (strct *PostgreSqlParameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Database" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Database" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Database\": ")
	if tmp, err := json.Marshal(strct.Database); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Host" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Host" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Host\": ")
	if tmp, err := json.Marshal(strct.Host); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Port" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Port" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Port\": ")
	if tmp, err := json.Marshal(strct.Port); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PostgreSqlParameters) UnmarshalJSON(b []byte) error {
    DatabaseReceived := false
    HostReceived := false
    PortReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Database":
            if err := json.Unmarshal([]byte(v), &strct.Database); err != nil {
                return err
             }
            DatabaseReceived = true
        case "Host":
            if err := json.Unmarshal([]byte(v), &strct.Host); err != nil {
                return err
             }
            HostReceived = true
        case "Port":
            if err := json.Unmarshal([]byte(v), &strct.Port); err != nil {
                return err
             }
            PortReceived = true
        }
    }
    // check if Database (a required property) was received
    if !DatabaseReceived {
        return errors.New("\"Database\" is required but was not present")
    }
    // check if Host (a required property) was received
    if !HostReceived {
        return errors.New("\"Host\" is required but was not present")
    }
    // check if Port (a required property) was received
    if !PortReceived {
        return errors.New("\"Port\" is required but was not present")
    }
    return nil
}

func (strct *PrestoParameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Catalog" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Catalog" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Catalog\": ")
	if tmp, err := json.Marshal(strct.Catalog); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Host" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Host" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Host\": ")
	if tmp, err := json.Marshal(strct.Host); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Port" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Port" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Port\": ")
	if tmp, err := json.Marshal(strct.Port); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PrestoParameters) UnmarshalJSON(b []byte) error {
    CatalogReceived := false
    HostReceived := false
    PortReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Catalog":
            if err := json.Unmarshal([]byte(v), &strct.Catalog); err != nil {
                return err
             }
            CatalogReceived = true
        case "Host":
            if err := json.Unmarshal([]byte(v), &strct.Host); err != nil {
                return err
             }
            HostReceived = true
        case "Port":
            if err := json.Unmarshal([]byte(v), &strct.Port); err != nil {
                return err
             }
            PortReceived = true
        }
    }
    // check if Catalog (a required property) was received
    if !CatalogReceived {
        return errors.New("\"Catalog\" is required but was not present")
    }
    // check if Host (a required property) was received
    if !HostReceived {
        return errors.New("\"Host\" is required but was not present")
    }
    // check if Port (a required property) was received
    if !PortReceived {
        return errors.New("\"Port\" is required but was not present")
    }
    return nil
}

func (strct *RdsParameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Database" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Database" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Database\": ")
	if tmp, err := json.Marshal(strct.Database); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "InstanceId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "InstanceId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InstanceId\": ")
	if tmp, err := json.Marshal(strct.InstanceId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RdsParameters) UnmarshalJSON(b []byte) error {
    DatabaseReceived := false
    InstanceIdReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Database":
            if err := json.Unmarshal([]byte(v), &strct.Database); err != nil {
                return err
             }
            DatabaseReceived = true
        case "InstanceId":
            if err := json.Unmarshal([]byte(v), &strct.InstanceId); err != nil {
                return err
             }
            InstanceIdReceived = true
        }
    }
    // check if Database (a required property) was received
    if !DatabaseReceived {
        return errors.New("\"Database\" is required but was not present")
    }
    // check if InstanceId (a required property) was received
    if !InstanceIdReceived {
        return errors.New("\"InstanceId\" is required but was not present")
    }
    return nil
}

func (strct *RedshiftParameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ClusterId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ClusterId\": ")
	if tmp, err := json.Marshal(strct.ClusterId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Database" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Database" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Database\": ")
	if tmp, err := json.Marshal(strct.Database); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Host" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Host\": ")
	if tmp, err := json.Marshal(strct.Host); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Port" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Port\": ")
	if tmp, err := json.Marshal(strct.Port); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RedshiftParameters) UnmarshalJSON(b []byte) error {
    DatabaseReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ClusterId":
            if err := json.Unmarshal([]byte(v), &strct.ClusterId); err != nil {
                return err
             }
        case "Database":
            if err := json.Unmarshal([]byte(v), &strct.Database); err != nil {
                return err
             }
            DatabaseReceived = true
        case "Host":
            if err := json.Unmarshal([]byte(v), &strct.Host); err != nil {
                return err
             }
        case "Port":
            if err := json.Unmarshal([]byte(v), &strct.Port); err != nil {
                return err
             }
        }
    }
    // check if Database (a required property) was received
    if !DatabaseReceived {
        return errors.New("\"Database\" is required but was not present")
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AlternateDataSourceParameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AlternateDataSourceParameters\": ")
	if tmp, err := json.Marshal(strct.AlternateDataSourceParameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Arn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Arn\": ")
	if tmp, err := json.Marshal(strct.Arn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AwsAccountId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AwsAccountId\": ")
	if tmp, err := json.Marshal(strct.AwsAccountId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CreatedTime" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CreatedTime\": ")
	if tmp, err := json.Marshal(strct.CreatedTime); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Credentials" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Credentials\": ")
	if tmp, err := json.Marshal(strct.Credentials); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DataSourceId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DataSourceId\": ")
	if tmp, err := json.Marshal(strct.DataSourceId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DataSourceParameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DataSourceParameters\": ")
	if tmp, err := json.Marshal(strct.DataSourceParameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ErrorInfo" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ErrorInfo\": ")
	if tmp, err := json.Marshal(strct.ErrorInfo); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LastUpdatedTime" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LastUpdatedTime\": ")
	if tmp, err := json.Marshal(strct.LastUpdatedTime); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Permissions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Permissions\": ")
	if tmp, err := json.Marshal(strct.Permissions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SslProperties" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SslProperties\": ")
	if tmp, err := json.Marshal(strct.SslProperties); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Status" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Status\": ")
	if tmp, err := json.Marshal(strct.Status); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VpcConnectionProperties" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VpcConnectionProperties\": ")
	if tmp, err := json.Marshal(strct.VpcConnectionProperties); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AlternateDataSourceParameters":
            if err := json.Unmarshal([]byte(v), &strct.AlternateDataSourceParameters); err != nil {
                return err
             }
        case "Arn":
            if err := json.Unmarshal([]byte(v), &strct.Arn); err != nil {
                return err
             }
        case "AwsAccountId":
            if err := json.Unmarshal([]byte(v), &strct.AwsAccountId); err != nil {
                return err
             }
        case "CreatedTime":
            if err := json.Unmarshal([]byte(v), &strct.CreatedTime); err != nil {
                return err
             }
        case "Credentials":
            if err := json.Unmarshal([]byte(v), &strct.Credentials); err != nil {
                return err
             }
        case "DataSourceId":
            if err := json.Unmarshal([]byte(v), &strct.DataSourceId); err != nil {
                return err
             }
        case "DataSourceParameters":
            if err := json.Unmarshal([]byte(v), &strct.DataSourceParameters); err != nil {
                return err
             }
        case "ErrorInfo":
            if err := json.Unmarshal([]byte(v), &strct.ErrorInfo); err != nil {
                return err
             }
        case "LastUpdatedTime":
            if err := json.Unmarshal([]byte(v), &strct.LastUpdatedTime); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "Permissions":
            if err := json.Unmarshal([]byte(v), &strct.Permissions); err != nil {
                return err
             }
        case "SslProperties":
            if err := json.Unmarshal([]byte(v), &strct.SslProperties); err != nil {
                return err
             }
        case "Status":
            if err := json.Unmarshal([]byte(v), &strct.Status); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
        case "VpcConnectionProperties":
            if err := json.Unmarshal([]byte(v), &strct.VpcConnectionProperties); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ResourcePermission) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Actions" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Actions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Actions\": ")
	if tmp, err := json.Marshal(strct.Actions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Principal" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Principal" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Principal\": ")
	if tmp, err := json.Marshal(strct.Principal); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ResourcePermission) UnmarshalJSON(b []byte) error {
    ActionsReceived := false
    PrincipalReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Actions":
            if err := json.Unmarshal([]byte(v), &strct.Actions); err != nil {
                return err
             }
            ActionsReceived = true
        case "Principal":
            if err := json.Unmarshal([]byte(v), &strct.Principal); err != nil {
                return err
             }
            PrincipalReceived = true
        }
    }
    // check if Actions (a required property) was received
    if !ActionsReceived {
        return errors.New("\"Actions\" is required but was not present")
    }
    // check if Principal (a required property) was received
    if !PrincipalReceived {
        return errors.New("\"Principal\" is required but was not present")
    }
    return nil
}

func (strct *S3Parameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ManifestFileLocation" field is required
    if strct.ManifestFileLocation == nil {
        return nil, errors.New("ManifestFileLocation is a required field")
    }
    // Marshal the "ManifestFileLocation" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ManifestFileLocation\": ")
	if tmp, err := json.Marshal(strct.ManifestFileLocation); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *S3Parameters) UnmarshalJSON(b []byte) error {
    ManifestFileLocationReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ManifestFileLocation":
            if err := json.Unmarshal([]byte(v), &strct.ManifestFileLocation); err != nil {
                return err
             }
            ManifestFileLocationReceived = true
        }
    }
    // check if ManifestFileLocation (a required property) was received
    if !ManifestFileLocationReceived {
        return errors.New("\"ManifestFileLocation\" is required but was not present")
    }
    return nil
}

func (strct *SnowflakeParameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Database" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Database" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Database\": ")
	if tmp, err := json.Marshal(strct.Database); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Host" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Host" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Host\": ")
	if tmp, err := json.Marshal(strct.Host); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Warehouse" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Warehouse" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Warehouse\": ")
	if tmp, err := json.Marshal(strct.Warehouse); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SnowflakeParameters) UnmarshalJSON(b []byte) error {
    DatabaseReceived := false
    HostReceived := false
    WarehouseReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Database":
            if err := json.Unmarshal([]byte(v), &strct.Database); err != nil {
                return err
             }
            DatabaseReceived = true
        case "Host":
            if err := json.Unmarshal([]byte(v), &strct.Host); err != nil {
                return err
             }
            HostReceived = true
        case "Warehouse":
            if err := json.Unmarshal([]byte(v), &strct.Warehouse); err != nil {
                return err
             }
            WarehouseReceived = true
        }
    }
    // check if Database (a required property) was received
    if !DatabaseReceived {
        return errors.New("\"Database\" is required but was not present")
    }
    // check if Host (a required property) was received
    if !HostReceived {
        return errors.New("\"Host\" is required but was not present")
    }
    // check if Warehouse (a required property) was received
    if !WarehouseReceived {
        return errors.New("\"Warehouse\" is required but was not present")
    }
    return nil
}

func (strct *SparkParameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Host" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Host" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Host\": ")
	if tmp, err := json.Marshal(strct.Host); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Port" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Port" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Port\": ")
	if tmp, err := json.Marshal(strct.Port); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SparkParameters) UnmarshalJSON(b []byte) error {
    HostReceived := false
    PortReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Host":
            if err := json.Unmarshal([]byte(v), &strct.Host); err != nil {
                return err
             }
            HostReceived = true
        case "Port":
            if err := json.Unmarshal([]byte(v), &strct.Port); err != nil {
                return err
             }
            PortReceived = true
        }
    }
    // check if Host (a required property) was received
    if !HostReceived {
        return errors.New("\"Host\" is required but was not present")
    }
    // check if Port (a required property) was received
    if !PortReceived {
        return errors.New("\"Port\" is required but was not present")
    }
    return nil
}

func (strct *SqlServerParameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Database" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Database" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Database\": ")
	if tmp, err := json.Marshal(strct.Database); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Host" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Host" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Host\": ")
	if tmp, err := json.Marshal(strct.Host); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Port" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Port" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Port\": ")
	if tmp, err := json.Marshal(strct.Port); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SqlServerParameters) UnmarshalJSON(b []byte) error {
    DatabaseReceived := false
    HostReceived := false
    PortReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Database":
            if err := json.Unmarshal([]byte(v), &strct.Database); err != nil {
                return err
             }
            DatabaseReceived = true
        case "Host":
            if err := json.Unmarshal([]byte(v), &strct.Host); err != nil {
                return err
             }
            HostReceived = true
        case "Port":
            if err := json.Unmarshal([]byte(v), &strct.Port); err != nil {
                return err
             }
            PortReceived = true
        }
    }
    // check if Database (a required property) was received
    if !DatabaseReceived {
        return errors.New("\"Database\" is required but was not present")
    }
    // check if Host (a required property) was received
    if !HostReceived {
        return errors.New("\"Host\" is required but was not present")
    }
    // check if Port (a required property) was received
    if !PortReceived {
        return errors.New("\"Port\" is required but was not present")
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *TeradataParameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Database" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Database" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Database\": ")
	if tmp, err := json.Marshal(strct.Database); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Host" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Host" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Host\": ")
	if tmp, err := json.Marshal(strct.Host); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Port" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Port" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Port\": ")
	if tmp, err := json.Marshal(strct.Port); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TeradataParameters) UnmarshalJSON(b []byte) error {
    DatabaseReceived := false
    HostReceived := false
    PortReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Database":
            if err := json.Unmarshal([]byte(v), &strct.Database); err != nil {
                return err
             }
            DatabaseReceived = true
        case "Host":
            if err := json.Unmarshal([]byte(v), &strct.Host); err != nil {
                return err
             }
            HostReceived = true
        case "Port":
            if err := json.Unmarshal([]byte(v), &strct.Port); err != nil {
                return err
             }
            PortReceived = true
        }
    }
    // check if Database (a required property) was received
    if !DatabaseReceived {
        return errors.New("\"Database\" is required but was not present")
    }
    // check if Host (a required property) was received
    if !HostReceived {
        return errors.New("\"Host\" is required but was not present")
    }
    // check if Port (a required property) was received
    if !PortReceived {
        return errors.New("\"Port\" is required but was not present")
    }
    return nil
}

func (strct *VpcConnectionProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "VpcConnectionArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "VpcConnectionArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VpcConnectionArn\": ")
	if tmp, err := json.Marshal(strct.VpcConnectionArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *VpcConnectionProperties) UnmarshalJSON(b []byte) error {
    VpcConnectionArnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "VpcConnectionArn":
            if err := json.Unmarshal([]byte(v), &strct.VpcConnectionArn); err != nil {
                return err
             }
            VpcConnectionArnReceived = true
        }
    }
    // check if VpcConnectionArn (a required property) was received
    if !VpcConnectionArnReceived {
        return errors.New("\"VpcConnectionArn\" is required but was not present")
    }
    return nil
}
