// Code generated by schema-generate. DO NOT EDIT.

package document

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// AttachmentsSource 
type AttachmentsSource struct {

  // The key of a key-value pair that identifies the location of an attachment to a document.
  Key string `json:"Key,omitempty"`

  // The name of the document attachment file.
  Name string `json:"Name,omitempty"`

  // The value of a key-value pair that identifies the location of an attachment to a document. The format for Value depends on the type of key you specify.
  Values []string `json:"Values,omitempty"`
}

// Content_object The content for the Systems Manager document in JSON, YAML or String format.
type Content_object struct {
}

// DocumentRequires 
type DocumentRequires struct {

  // The name of the required SSM document. The name can be an Amazon Resource Name (ARN).
  Name string `json:"Name,omitempty"`

  // The document version required by the current document.
  Version string `json:"Version,omitempty"`
}

// Resource The AWS::SSM::Document resource is an SSM document in AWS Systems Manager that defines the actions that Systems Manager performs, which can be used to set up and run commands on your instances.
type Resource struct {

  // A list of key and value pairs that describe attachments to a version of a document.
  Attachments []*AttachmentsSource `json:"Attachments,omitempty"`

  // The content for the Systems Manager document in JSON, YAML or String format.
  Content interface{} `json:"Content"`

  // Specify the document format for the request. The document format can be either JSON or YAML. JSON is the default format.
  DocumentFormat string `json:"DocumentFormat,omitempty"`

  // The type of document to create.
  DocumentType string `json:"DocumentType,omitempty"`

  // A name for the Systems Manager document.
  Name string `json:"Name,omitempty"`

  // A list of SSM documents required by a document. For example, an ApplicationConfiguration document requires an ApplicationConfigurationSchema document.
  Requires []*DocumentRequires `json:"Requires,omitempty"`

  // Optional metadata that you assign to a resource. Tags enable you to categorize a resource in different ways, such as by purpose, owner, or environment.
  Tags []*Tag `json:"Tags,omitempty"`

  // Specify a target type to define the kinds of resources the document can run on.
  TargetType string `json:"TargetType,omitempty"`

  // Update method - when set to 'Replace', the update will replace the existing document; when set to 'NewVersion', the update will create a new version.
  UpdateMethod string `json:"UpdateMethod,omitempty"`

  // An optional field specifying the version of the artifact you are creating with the document. This value is unique across all versions of a document, and cannot be changed.
  VersionName string `json:"VersionName,omitempty"`
}

// Tag 
type Tag struct {

  // The name of the tag.
  Key string `json:"Key,omitempty"`

  // The value of the tag.
  Value string `json:"Value,omitempty"`
}

func (strct *AttachmentsSource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Values" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Values\": ")
	if tmp, err := json.Marshal(strct.Values); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AttachmentsSource) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "Values":
            if err := json.Unmarshal([]byte(v), &strct.Values); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *DocumentRequires) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Version" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Version\": ")
	if tmp, err := json.Marshal(strct.Version); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DocumentRequires) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "Version":
            if err := json.Unmarshal([]byte(v), &strct.Version); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Attachments" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Attachments\": ")
	if tmp, err := json.Marshal(strct.Attachments); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Content" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Content" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Content\": ")
	if tmp, err := json.Marshal(strct.Content); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DocumentFormat" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DocumentFormat\": ")
	if tmp, err := json.Marshal(strct.DocumentFormat); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DocumentType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DocumentType\": ")
	if tmp, err := json.Marshal(strct.DocumentType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Requires" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Requires\": ")
	if tmp, err := json.Marshal(strct.Requires); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TargetType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TargetType\": ")
	if tmp, err := json.Marshal(strct.TargetType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "UpdateMethod" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UpdateMethod\": ")
	if tmp, err := json.Marshal(strct.UpdateMethod); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VersionName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VersionName\": ")
	if tmp, err := json.Marshal(strct.VersionName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    ContentReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Attachments":
            if err := json.Unmarshal([]byte(v), &strct.Attachments); err != nil {
                return err
             }
        case "Content":
            if err := json.Unmarshal([]byte(v), &strct.Content); err != nil {
                return err
             }
            ContentReceived = true
        case "DocumentFormat":
            if err := json.Unmarshal([]byte(v), &strct.DocumentFormat); err != nil {
                return err
             }
        case "DocumentType":
            if err := json.Unmarshal([]byte(v), &strct.DocumentType); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "Requires":
            if err := json.Unmarshal([]byte(v), &strct.Requires); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        case "TargetType":
            if err := json.Unmarshal([]byte(v), &strct.TargetType); err != nil {
                return err
             }
        case "UpdateMethod":
            if err := json.Unmarshal([]byte(v), &strct.UpdateMethod); err != nil {
                return err
             }
        case "VersionName":
            if err := json.Unmarshal([]byte(v), &strct.VersionName); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Content (a required property) was received
    if !ContentReceived {
        return errors.New("\"Content\" is required but was not present")
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}
