// Code generated by schema-generate. DO NOT EDIT.

package integration

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// ConnectorOperator 
type ConnectorOperator struct {
  Marketo string `json:"Marketo,omitempty"`
  S3 string `json:"S3,omitempty"`
  Salesforce string `json:"Salesforce,omitempty"`
  ServiceNow string `json:"ServiceNow,omitempty"`
  Zendesk string `json:"Zendesk,omitempty"`
}

// FlowDefinition 
type FlowDefinition struct {
  Description string `json:"Description,omitempty"`
  FlowName string `json:"FlowName"`
  KmsArn string `json:"KmsArn"`
  SourceFlowConfig *SourceFlowConfig `json:"SourceFlowConfig"`
  Tasks []*Task `json:"Tasks"`
  TriggerConfig *TriggerConfig `json:"TriggerConfig"`
}

// IncrementalPullConfig 
type IncrementalPullConfig struct {
  DatetimeTypeFieldName string `json:"DatetimeTypeFieldName,omitempty"`
}

// MarketoSourceProperties 
type MarketoSourceProperties struct {
  Object string `json:"Object"`
}

// ObjectTypeMapping 
type ObjectTypeMapping struct {
  Key string `json:"Key"`
  Value string `json:"Value"`
}

// Resource The resource schema for creating an Amazon Connect Customer Profiles Integration.
type Resource struct {

  // The time of this integration got created
  CreatedAt string `json:"CreatedAt,omitempty"`

  // The unique name of the domain.
  DomainName string `json:"DomainName"`
  FlowDefinition *FlowDefinition `json:"FlowDefinition,omitempty"`

  // The time of this integration got last updated at
  LastUpdatedAt string `json:"LastUpdatedAt,omitempty"`

  // The name of the ObjectType defined for the 3rd party data in Profile Service
  ObjectTypeName string `json:"ObjectTypeName,omitempty"`

  // The mapping between 3rd party event types and ObjectType names
  ObjectTypeNames []*ObjectTypeMapping `json:"ObjectTypeNames,omitempty"`

  // The tags (keys and values) associated with the integration
  Tags []*Tag `json:"Tags,omitempty"`

  // The URI of the S3 bucket or any other type of data source.
  Uri string `json:"Uri,omitempty"`
}

// S3SourceProperties 
type S3SourceProperties struct {
  BucketName string `json:"BucketName"`
  BucketPrefix string `json:"BucketPrefix,omitempty"`
}

// SalesforceSourceProperties 
type SalesforceSourceProperties struct {
  EnableDynamicFieldUpdate bool `json:"EnableDynamicFieldUpdate,omitempty"`
  IncludeDeletedRecords bool `json:"IncludeDeletedRecords,omitempty"`
  Object string `json:"Object"`
}

// ScheduledTriggerProperties 
type ScheduledTriggerProperties struct {
  DataPullMode string `json:"DataPullMode,omitempty"`
  FirstExecutionFrom float64 `json:"FirstExecutionFrom,omitempty"`
  ScheduleEndTime float64 `json:"ScheduleEndTime,omitempty"`
  ScheduleExpression string `json:"ScheduleExpression"`
  ScheduleOffset int `json:"ScheduleOffset,omitempty"`
  ScheduleStartTime float64 `json:"ScheduleStartTime,omitempty"`
  Timezone string `json:"Timezone,omitempty"`
}

// ServiceNowSourceProperties 
type ServiceNowSourceProperties struct {
  Object string `json:"Object"`
}

// SourceConnectorProperties 
type SourceConnectorProperties struct {
  Marketo *MarketoSourceProperties `json:"Marketo,omitempty"`
  S3 *S3SourceProperties `json:"S3,omitempty"`
  Salesforce *SalesforceSourceProperties `json:"Salesforce,omitempty"`
  ServiceNow *ServiceNowSourceProperties `json:"ServiceNow,omitempty"`
  Zendesk *ZendeskSourceProperties `json:"Zendesk,omitempty"`
}

// SourceFlowConfig 
type SourceFlowConfig struct {
  ConnectorProfileName string `json:"ConnectorProfileName,omitempty"`
  ConnectorType string `json:"ConnectorType"`
  IncrementalPullConfig *IncrementalPullConfig `json:"IncrementalPullConfig,omitempty"`
  SourceConnectorProperties *SourceConnectorProperties `json:"SourceConnectorProperties"`
}

// Tag 
type Tag struct {
  Key string `json:"Key"`
  Value string `json:"Value"`
}

// Task 
type Task struct {
  ConnectorOperator *ConnectorOperator `json:"ConnectorOperator,omitempty"`
  DestinationField string `json:"DestinationField,omitempty"`
  SourceFields []string `json:"SourceFields"`
  TaskProperties []*TaskPropertiesMap `json:"TaskProperties,omitempty"`
  TaskType string `json:"TaskType"`
}

// TaskPropertiesMap 
type TaskPropertiesMap struct {
  OperatorPropertyKey string `json:"OperatorPropertyKey"`
  Property string `json:"Property"`
}

// TriggerConfig 
type TriggerConfig struct {
  TriggerProperties *TriggerProperties `json:"TriggerProperties,omitempty"`
  TriggerType string `json:"TriggerType"`
}

// TriggerProperties 
type TriggerProperties struct {
  Scheduled *ScheduledTriggerProperties `json:"Scheduled,omitempty"`
}

// ZendeskSourceProperties 
type ZendeskSourceProperties struct {
  Object string `json:"Object"`
}

func (strct *ConnectorOperator) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Marketo" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Marketo\": ")
	if tmp, err := json.Marshal(strct.Marketo); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "S3" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3\": ")
	if tmp, err := json.Marshal(strct.S3); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Salesforce" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Salesforce\": ")
	if tmp, err := json.Marshal(strct.Salesforce); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ServiceNow" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ServiceNow\": ")
	if tmp, err := json.Marshal(strct.ServiceNow); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Zendesk" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Zendesk\": ")
	if tmp, err := json.Marshal(strct.Zendesk); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ConnectorOperator) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Marketo":
            if err := json.Unmarshal([]byte(v), &strct.Marketo); err != nil {
                return err
             }
        case "S3":
            if err := json.Unmarshal([]byte(v), &strct.S3); err != nil {
                return err
             }
        case "Salesforce":
            if err := json.Unmarshal([]byte(v), &strct.Salesforce); err != nil {
                return err
             }
        case "ServiceNow":
            if err := json.Unmarshal([]byte(v), &strct.ServiceNow); err != nil {
                return err
             }
        case "Zendesk":
            if err := json.Unmarshal([]byte(v), &strct.Zendesk); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *FlowDefinition) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "FlowName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "FlowName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FlowName\": ")
	if tmp, err := json.Marshal(strct.FlowName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "KmsArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "KmsArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KmsArn\": ")
	if tmp, err := json.Marshal(strct.KmsArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "SourceFlowConfig" field is required
    if strct.SourceFlowConfig == nil {
        return nil, errors.New("SourceFlowConfig is a required field")
    }
    // Marshal the "SourceFlowConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SourceFlowConfig\": ")
	if tmp, err := json.Marshal(strct.SourceFlowConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Tasks" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Tasks" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tasks\": ")
	if tmp, err := json.Marshal(strct.Tasks); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TriggerConfig" field is required
    if strct.TriggerConfig == nil {
        return nil, errors.New("TriggerConfig is a required field")
    }
    // Marshal the "TriggerConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TriggerConfig\": ")
	if tmp, err := json.Marshal(strct.TriggerConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FlowDefinition) UnmarshalJSON(b []byte) error {
    FlowNameReceived := false
    KmsArnReceived := false
    SourceFlowConfigReceived := false
    TasksReceived := false
    TriggerConfigReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "FlowName":
            if err := json.Unmarshal([]byte(v), &strct.FlowName); err != nil {
                return err
             }
            FlowNameReceived = true
        case "KmsArn":
            if err := json.Unmarshal([]byte(v), &strct.KmsArn); err != nil {
                return err
             }
            KmsArnReceived = true
        case "SourceFlowConfig":
            if err := json.Unmarshal([]byte(v), &strct.SourceFlowConfig); err != nil {
                return err
             }
            SourceFlowConfigReceived = true
        case "Tasks":
            if err := json.Unmarshal([]byte(v), &strct.Tasks); err != nil {
                return err
             }
            TasksReceived = true
        case "TriggerConfig":
            if err := json.Unmarshal([]byte(v), &strct.TriggerConfig); err != nil {
                return err
             }
            TriggerConfigReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if FlowName (a required property) was received
    if !FlowNameReceived {
        return errors.New("\"FlowName\" is required but was not present")
    }
    // check if KmsArn (a required property) was received
    if !KmsArnReceived {
        return errors.New("\"KmsArn\" is required but was not present")
    }
    // check if SourceFlowConfig (a required property) was received
    if !SourceFlowConfigReceived {
        return errors.New("\"SourceFlowConfig\" is required but was not present")
    }
    // check if Tasks (a required property) was received
    if !TasksReceived {
        return errors.New("\"Tasks\" is required but was not present")
    }
    // check if TriggerConfig (a required property) was received
    if !TriggerConfigReceived {
        return errors.New("\"TriggerConfig\" is required but was not present")
    }
    return nil
}

func (strct *IncrementalPullConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DatetimeTypeFieldName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DatetimeTypeFieldName\": ")
	if tmp, err := json.Marshal(strct.DatetimeTypeFieldName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *IncrementalPullConfig) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DatetimeTypeFieldName":
            if err := json.Unmarshal([]byte(v), &strct.DatetimeTypeFieldName); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *MarketoSourceProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Object" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Object" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Object\": ")
	if tmp, err := json.Marshal(strct.Object); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MarketoSourceProperties) UnmarshalJSON(b []byte) error {
    ObjectReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Object":
            if err := json.Unmarshal([]byte(v), &strct.Object); err != nil {
                return err
             }
            ObjectReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Object (a required property) was received
    if !ObjectReceived {
        return errors.New("\"Object\" is required but was not present")
    }
    return nil
}

func (strct *ObjectTypeMapping) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ObjectTypeMapping) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CreatedAt" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CreatedAt\": ")
	if tmp, err := json.Marshal(strct.CreatedAt); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "DomainName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "DomainName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DomainName\": ")
	if tmp, err := json.Marshal(strct.DomainName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FlowDefinition" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FlowDefinition\": ")
	if tmp, err := json.Marshal(strct.FlowDefinition); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LastUpdatedAt" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LastUpdatedAt\": ")
	if tmp, err := json.Marshal(strct.LastUpdatedAt); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ObjectTypeName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ObjectTypeName\": ")
	if tmp, err := json.Marshal(strct.ObjectTypeName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ObjectTypeNames" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ObjectTypeNames\": ")
	if tmp, err := json.Marshal(strct.ObjectTypeNames); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Uri" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Uri\": ")
	if tmp, err := json.Marshal(strct.Uri); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    DomainNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CreatedAt":
            if err := json.Unmarshal([]byte(v), &strct.CreatedAt); err != nil {
                return err
             }
        case "DomainName":
            if err := json.Unmarshal([]byte(v), &strct.DomainName); err != nil {
                return err
             }
            DomainNameReceived = true
        case "FlowDefinition":
            if err := json.Unmarshal([]byte(v), &strct.FlowDefinition); err != nil {
                return err
             }
        case "LastUpdatedAt":
            if err := json.Unmarshal([]byte(v), &strct.LastUpdatedAt); err != nil {
                return err
             }
        case "ObjectTypeName":
            if err := json.Unmarshal([]byte(v), &strct.ObjectTypeName); err != nil {
                return err
             }
        case "ObjectTypeNames":
            if err := json.Unmarshal([]byte(v), &strct.ObjectTypeNames); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        case "Uri":
            if err := json.Unmarshal([]byte(v), &strct.Uri); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if DomainName (a required property) was received
    if !DomainNameReceived {
        return errors.New("\"DomainName\" is required but was not present")
    }
    return nil
}

func (strct *S3SourceProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "BucketName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "BucketName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BucketName\": ")
	if tmp, err := json.Marshal(strct.BucketName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BucketPrefix" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BucketPrefix\": ")
	if tmp, err := json.Marshal(strct.BucketPrefix); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *S3SourceProperties) UnmarshalJSON(b []byte) error {
    BucketNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BucketName":
            if err := json.Unmarshal([]byte(v), &strct.BucketName); err != nil {
                return err
             }
            BucketNameReceived = true
        case "BucketPrefix":
            if err := json.Unmarshal([]byte(v), &strct.BucketPrefix); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if BucketName (a required property) was received
    if !BucketNameReceived {
        return errors.New("\"BucketName\" is required but was not present")
    }
    return nil
}

func (strct *SalesforceSourceProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "EnableDynamicFieldUpdate" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EnableDynamicFieldUpdate\": ")
	if tmp, err := json.Marshal(strct.EnableDynamicFieldUpdate); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IncludeDeletedRecords" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IncludeDeletedRecords\": ")
	if tmp, err := json.Marshal(strct.IncludeDeletedRecords); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Object" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Object" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Object\": ")
	if tmp, err := json.Marshal(strct.Object); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SalesforceSourceProperties) UnmarshalJSON(b []byte) error {
    ObjectReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "EnableDynamicFieldUpdate":
            if err := json.Unmarshal([]byte(v), &strct.EnableDynamicFieldUpdate); err != nil {
                return err
             }
        case "IncludeDeletedRecords":
            if err := json.Unmarshal([]byte(v), &strct.IncludeDeletedRecords); err != nil {
                return err
             }
        case "Object":
            if err := json.Unmarshal([]byte(v), &strct.Object); err != nil {
                return err
             }
            ObjectReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Object (a required property) was received
    if !ObjectReceived {
        return errors.New("\"Object\" is required but was not present")
    }
    return nil
}

func (strct *ScheduledTriggerProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DataPullMode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DataPullMode\": ")
	if tmp, err := json.Marshal(strct.DataPullMode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FirstExecutionFrom" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FirstExecutionFrom\": ")
	if tmp, err := json.Marshal(strct.FirstExecutionFrom); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ScheduleEndTime" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ScheduleEndTime\": ")
	if tmp, err := json.Marshal(strct.ScheduleEndTime); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ScheduleExpression" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ScheduleExpression" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ScheduleExpression\": ")
	if tmp, err := json.Marshal(strct.ScheduleExpression); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ScheduleOffset" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ScheduleOffset\": ")
	if tmp, err := json.Marshal(strct.ScheduleOffset); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ScheduleStartTime" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ScheduleStartTime\": ")
	if tmp, err := json.Marshal(strct.ScheduleStartTime); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Timezone" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Timezone\": ")
	if tmp, err := json.Marshal(strct.Timezone); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ScheduledTriggerProperties) UnmarshalJSON(b []byte) error {
    ScheduleExpressionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DataPullMode":
            if err := json.Unmarshal([]byte(v), &strct.DataPullMode); err != nil {
                return err
             }
        case "FirstExecutionFrom":
            if err := json.Unmarshal([]byte(v), &strct.FirstExecutionFrom); err != nil {
                return err
             }
        case "ScheduleEndTime":
            if err := json.Unmarshal([]byte(v), &strct.ScheduleEndTime); err != nil {
                return err
             }
        case "ScheduleExpression":
            if err := json.Unmarshal([]byte(v), &strct.ScheduleExpression); err != nil {
                return err
             }
            ScheduleExpressionReceived = true
        case "ScheduleOffset":
            if err := json.Unmarshal([]byte(v), &strct.ScheduleOffset); err != nil {
                return err
             }
        case "ScheduleStartTime":
            if err := json.Unmarshal([]byte(v), &strct.ScheduleStartTime); err != nil {
                return err
             }
        case "Timezone":
            if err := json.Unmarshal([]byte(v), &strct.Timezone); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ScheduleExpression (a required property) was received
    if !ScheduleExpressionReceived {
        return errors.New("\"ScheduleExpression\" is required but was not present")
    }
    return nil
}

func (strct *ServiceNowSourceProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Object" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Object" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Object\": ")
	if tmp, err := json.Marshal(strct.Object); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ServiceNowSourceProperties) UnmarshalJSON(b []byte) error {
    ObjectReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Object":
            if err := json.Unmarshal([]byte(v), &strct.Object); err != nil {
                return err
             }
            ObjectReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Object (a required property) was received
    if !ObjectReceived {
        return errors.New("\"Object\" is required but was not present")
    }
    return nil
}

func (strct *SourceConnectorProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Marketo" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Marketo\": ")
	if tmp, err := json.Marshal(strct.Marketo); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "S3" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3\": ")
	if tmp, err := json.Marshal(strct.S3); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Salesforce" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Salesforce\": ")
	if tmp, err := json.Marshal(strct.Salesforce); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ServiceNow" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ServiceNow\": ")
	if tmp, err := json.Marshal(strct.ServiceNow); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Zendesk" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Zendesk\": ")
	if tmp, err := json.Marshal(strct.Zendesk); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SourceConnectorProperties) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Marketo":
            if err := json.Unmarshal([]byte(v), &strct.Marketo); err != nil {
                return err
             }
        case "S3":
            if err := json.Unmarshal([]byte(v), &strct.S3); err != nil {
                return err
             }
        case "Salesforce":
            if err := json.Unmarshal([]byte(v), &strct.Salesforce); err != nil {
                return err
             }
        case "ServiceNow":
            if err := json.Unmarshal([]byte(v), &strct.ServiceNow); err != nil {
                return err
             }
        case "Zendesk":
            if err := json.Unmarshal([]byte(v), &strct.Zendesk); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *SourceFlowConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ConnectorProfileName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConnectorProfileName\": ")
	if tmp, err := json.Marshal(strct.ConnectorProfileName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ConnectorType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ConnectorType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConnectorType\": ")
	if tmp, err := json.Marshal(strct.ConnectorType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IncrementalPullConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IncrementalPullConfig\": ")
	if tmp, err := json.Marshal(strct.IncrementalPullConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "SourceConnectorProperties" field is required
    if strct.SourceConnectorProperties == nil {
        return nil, errors.New("SourceConnectorProperties is a required field")
    }
    // Marshal the "SourceConnectorProperties" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SourceConnectorProperties\": ")
	if tmp, err := json.Marshal(strct.SourceConnectorProperties); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SourceFlowConfig) UnmarshalJSON(b []byte) error {
    ConnectorTypeReceived := false
    SourceConnectorPropertiesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ConnectorProfileName":
            if err := json.Unmarshal([]byte(v), &strct.ConnectorProfileName); err != nil {
                return err
             }
        case "ConnectorType":
            if err := json.Unmarshal([]byte(v), &strct.ConnectorType); err != nil {
                return err
             }
            ConnectorTypeReceived = true
        case "IncrementalPullConfig":
            if err := json.Unmarshal([]byte(v), &strct.IncrementalPullConfig); err != nil {
                return err
             }
        case "SourceConnectorProperties":
            if err := json.Unmarshal([]byte(v), &strct.SourceConnectorProperties); err != nil {
                return err
             }
            SourceConnectorPropertiesReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ConnectorType (a required property) was received
    if !ConnectorTypeReceived {
        return errors.New("\"ConnectorType\" is required but was not present")
    }
    // check if SourceConnectorProperties (a required property) was received
    if !SourceConnectorPropertiesReceived {
        return errors.New("\"SourceConnectorProperties\" is required but was not present")
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *Task) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ConnectorOperator" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConnectorOperator\": ")
	if tmp, err := json.Marshal(strct.ConnectorOperator); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DestinationField" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DestinationField\": ")
	if tmp, err := json.Marshal(strct.DestinationField); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "SourceFields" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "SourceFields" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SourceFields\": ")
	if tmp, err := json.Marshal(strct.SourceFields); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TaskProperties" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TaskProperties\": ")
	if tmp, err := json.Marshal(strct.TaskProperties); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TaskType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TaskType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TaskType\": ")
	if tmp, err := json.Marshal(strct.TaskType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Task) UnmarshalJSON(b []byte) error {
    SourceFieldsReceived := false
    TaskTypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ConnectorOperator":
            if err := json.Unmarshal([]byte(v), &strct.ConnectorOperator); err != nil {
                return err
             }
        case "DestinationField":
            if err := json.Unmarshal([]byte(v), &strct.DestinationField); err != nil {
                return err
             }
        case "SourceFields":
            if err := json.Unmarshal([]byte(v), &strct.SourceFields); err != nil {
                return err
             }
            SourceFieldsReceived = true
        case "TaskProperties":
            if err := json.Unmarshal([]byte(v), &strct.TaskProperties); err != nil {
                return err
             }
        case "TaskType":
            if err := json.Unmarshal([]byte(v), &strct.TaskType); err != nil {
                return err
             }
            TaskTypeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if SourceFields (a required property) was received
    if !SourceFieldsReceived {
        return errors.New("\"SourceFields\" is required but was not present")
    }
    // check if TaskType (a required property) was received
    if !TaskTypeReceived {
        return errors.New("\"TaskType\" is required but was not present")
    }
    return nil
}

func (strct *TaskPropertiesMap) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "OperatorPropertyKey" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "OperatorPropertyKey" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OperatorPropertyKey\": ")
	if tmp, err := json.Marshal(strct.OperatorPropertyKey); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Property" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Property" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Property\": ")
	if tmp, err := json.Marshal(strct.Property); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TaskPropertiesMap) UnmarshalJSON(b []byte) error {
    OperatorPropertyKeyReceived := false
    PropertyReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "OperatorPropertyKey":
            if err := json.Unmarshal([]byte(v), &strct.OperatorPropertyKey); err != nil {
                return err
             }
            OperatorPropertyKeyReceived = true
        case "Property":
            if err := json.Unmarshal([]byte(v), &strct.Property); err != nil {
                return err
             }
            PropertyReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if OperatorPropertyKey (a required property) was received
    if !OperatorPropertyKeyReceived {
        return errors.New("\"OperatorPropertyKey\" is required but was not present")
    }
    // check if Property (a required property) was received
    if !PropertyReceived {
        return errors.New("\"Property\" is required but was not present")
    }
    return nil
}

func (strct *TriggerConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "TriggerProperties" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TriggerProperties\": ")
	if tmp, err := json.Marshal(strct.TriggerProperties); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TriggerType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TriggerType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TriggerType\": ")
	if tmp, err := json.Marshal(strct.TriggerType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TriggerConfig) UnmarshalJSON(b []byte) error {
    TriggerTypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "TriggerProperties":
            if err := json.Unmarshal([]byte(v), &strct.TriggerProperties); err != nil {
                return err
             }
        case "TriggerType":
            if err := json.Unmarshal([]byte(v), &strct.TriggerType); err != nil {
                return err
             }
            TriggerTypeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if TriggerType (a required property) was received
    if !TriggerTypeReceived {
        return errors.New("\"TriggerType\" is required but was not present")
    }
    return nil
}

func (strct *TriggerProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Scheduled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Scheduled\": ")
	if tmp, err := json.Marshal(strct.Scheduled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TriggerProperties) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Scheduled":
            if err := json.Unmarshal([]byte(v), &strct.Scheduled); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ZendeskSourceProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Object" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Object" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Object\": ")
	if tmp, err := json.Marshal(strct.Object); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ZendeskSourceProperties) UnmarshalJSON(b []byte) error {
    ObjectReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Object":
            if err := json.Unmarshal([]byte(v), &strct.Object); err != nil {
                return err
             }
            ObjectReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Object (a required property) was received
    if !ObjectReceived {
        return errors.New("\"Object\" is required but was not present")
    }
    return nil
}
