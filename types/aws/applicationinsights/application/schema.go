// Code generated by schema-generate. DO NOT EDIT.

package application

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// Alarm A CloudWatch alarm to be monitored for the component.
type Alarm struct {

  // The name of the CloudWatch alarm to be monitored for the component.
  AlarmName string `json:"AlarmName"`

  // Indicates the degree of outage when the alarm goes off.
  Severity string `json:"Severity,omitempty"`
}

// AlarmMetric A metric to be monitored for the component.
type AlarmMetric struct {

  // The name of the metric to be monitored for the component.
  AlarmMetricName string `json:"AlarmMetricName"`
}

// ComponentConfiguration The configuration settings of the component.
type ComponentConfiguration struct {

  // The configuration settings
  ConfigurationDetails *ConfigurationDetails `json:"ConfigurationDetails,omitempty"`

  // Sub component configurations of the component.
  SubComponentTypeConfigurations []*SubComponentTypeConfiguration `json:"SubComponentTypeConfigurations,omitempty"`
}

// ComponentMonitoringSetting The monitoring setting of the component.
type ComponentMonitoringSetting struct {

  // The ARN of the compnonent.
  ComponentARN string `json:"ComponentARN,omitempty"`

  // The component monitoring configuration mode.
  ComponentConfigurationMode string `json:"ComponentConfigurationMode"`

  // The name of the component.
  ComponentName string `json:"ComponentName,omitempty"`

  // The monitoring configuration of the component.
  CustomComponentConfiguration *ComponentConfiguration `json:"CustomComponentConfiguration,omitempty"`

  // The overwritten settings on default component monitoring configuration.
  DefaultOverwriteComponentConfiguration *ComponentConfiguration `json:"DefaultOverwriteComponentConfiguration,omitempty"`

  // The tier of the application component.
  Tier string `json:"Tier"`
}

// ConfigurationDetails The configuration settings.
type ConfigurationDetails struct {

  // A list of metrics to monitor for the component.
  AlarmMetrics []*AlarmMetric `json:"AlarmMetrics,omitempty"`

  // A list of alarms to monitor for the component.
  Alarms []*Alarm `json:"Alarms,omitempty"`

  // The HA cluster Prometheus Exporter settings.
  HAClusterPrometheusExporter *HAClusterPrometheusExporter `json:"HAClusterPrometheusExporter,omitempty"`

  // The HANA DB Prometheus Exporter settings.
  HANAPrometheusExporter *HANAPrometheusExporter `json:"HANAPrometheusExporter,omitempty"`

  // The JMX Prometheus Exporter settings.
  JMXPrometheusExporter *JMXPrometheusExporter `json:"JMXPrometheusExporter,omitempty"`

  // A list of logs to monitor for the component.
  Logs []*Log `json:"Logs,omitempty"`

  // A list of Windows Events to log.
  WindowsEvents []*WindowsEvent `json:"WindowsEvents,omitempty"`
}

// CustomComponent The custom grouped component.
type CustomComponent struct {

  // The name of the component.
  ComponentName string `json:"ComponentName"`

  // The list of resource ARNs that belong to the component.
  ResourceList []string `json:"ResourceList"`
}

// HAClusterPrometheusExporter The HA cluster Prometheus Exporter settings.
type HAClusterPrometheusExporter struct {

  // Prometheus exporter port.
  PrometheusPort string `json:"PrometheusPort,omitempty"`
}

// HANAPrometheusExporter The HANA DB Prometheus Exporter settings.
type HANAPrometheusExporter struct {

  // A flag which indicates agreeing to install SAP HANA DB client.
  AgreeToInstallHANADBClient bool `json:"AgreeToInstallHANADBClient"`

  // The HANA DB port.
  HANAPort string `json:"HANAPort"`

  // HANA DB SID.
  HANASID string `json:"HANASID"`

  // The secret name which manages the HANA DB credentials e.g. {
  //   "username": "<>",
  //   "password": "<>"
  // }.
  HANASecretName string `json:"HANASecretName"`

  // Prometheus exporter port.
  PrometheusPort string `json:"PrometheusPort,omitempty"`
}

// JMXPrometheusExporter The JMX Prometheus Exporter settings.
type JMXPrometheusExporter struct {

  // Java agent host port
  HostPort string `json:"HostPort,omitempty"`

  // JMX service URL.
  JMXURL string `json:"JMXURL,omitempty"`

  // Prometheus exporter port.
  PrometheusPort string `json:"PrometheusPort,omitempty"`
}

// Log A log to be monitored for the component.
type Log struct {

  // The type of encoding of the logs to be monitored.
  Encoding string `json:"Encoding,omitempty"`

  // The CloudWatch log group name to be associated to the monitored log.
  LogGroupName string `json:"LogGroupName,omitempty"`

  // The path of the logs to be monitored.
  LogPath string `json:"LogPath,omitempty"`

  // The log type decides the log patterns against which Application Insights analyzes the log.
  LogType string `json:"LogType"`

  // The name of the log pattern set.
  PatternSet string `json:"PatternSet,omitempty"`
}

// LogPattern The log pattern.
type LogPattern struct {

  // The log pattern.
  Pattern string `json:"Pattern"`

  // The name of the log pattern.
  PatternName string `json:"PatternName"`

  // Rank of the log pattern.
  Rank int `json:"Rank"`
}

// LogPatternSet The log pattern set.
type LogPatternSet struct {

  // The log patterns of a set.
  LogPatterns []*LogPattern `json:"LogPatterns"`

  // The name of the log pattern set.
  PatternSetName string `json:"PatternSetName"`
}

// Resource Resource schema for AWS::ApplicationInsights::Application
type Resource struct {

  // The ARN of the ApplicationInsights application.
  ApplicationARN string `json:"ApplicationARN,omitempty"`

  // If set to true, application will be configured with recommended monitoring configuration.
  AutoConfigurationEnabled bool `json:"AutoConfigurationEnabled,omitempty"`

  // Indicates whether Application Insights can listen to CloudWatch events for the application resources.
  CWEMonitorEnabled bool `json:"CWEMonitorEnabled,omitempty"`

  // The monitoring settings of the components.
  ComponentMonitoringSettings []*ComponentMonitoringSetting `json:"ComponentMonitoringSettings,omitempty"`

  // The custom grouped components.
  CustomComponents []*CustomComponent `json:"CustomComponents,omitempty"`

  // The grouping type of the application
  GroupingType string `json:"GroupingType,omitempty"`

  // The log pattern sets.
  LogPatternSets []*LogPatternSet `json:"LogPatternSets,omitempty"`

  // When set to true, creates opsItems for any problems detected on an application.
  OpsCenterEnabled bool `json:"OpsCenterEnabled,omitempty"`

  // The SNS topic provided to Application Insights that is associated to the created opsItem.
  OpsItemSNSTopicArn string `json:"OpsItemSNSTopicArn,omitempty"`

  // The name of the resource group.
  ResourceGroupName string `json:"ResourceGroupName"`

  // The tags of Application Insights application.
  Tags []*Tag `json:"Tags,omitempty"`
}

// SubComponentConfigurationDetails The configuration settings of sub components.
type SubComponentConfigurationDetails struct {

  // A list of metrics to monitor for the component.
  AlarmMetrics []*AlarmMetric `json:"AlarmMetrics,omitempty"`

  // A list of logs to monitor for the component.
  Logs []*Log `json:"Logs,omitempty"`

  // A list of Windows Events to log.
  WindowsEvents []*WindowsEvent `json:"WindowsEvents,omitempty"`
}

// SubComponentTypeConfiguration One type sub component configurations for the component.
type SubComponentTypeConfiguration struct {

  // The configuration settings of sub components.
  SubComponentConfigurationDetails *SubComponentConfigurationDetails `json:"SubComponentConfigurationDetails"`

  // The sub component type.
  SubComponentType string `json:"SubComponentType"`
}

// Tag A key-value pair to associate with a resource.
type Tag struct {

  // The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
  Key string `json:"Key"`

  // The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
  Value string `json:"Value"`
}

// WindowsEvent A Windows Event to be monitored for the component.
type WindowsEvent struct {

  // The levels of event to log. 
  EventLevels []string `json:"EventLevels"`

  // The type of Windows Events to log.
  EventName string `json:"EventName"`

  // The CloudWatch log group name to be associated to the monitored log.
  LogGroupName string `json:"LogGroupName"`

  // The name of the log pattern set.
  PatternSet string `json:"PatternSet,omitempty"`
}

func (strct *Alarm) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AlarmName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AlarmName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AlarmName\": ")
	if tmp, err := json.Marshal(strct.AlarmName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Severity" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Severity\": ")
	if tmp, err := json.Marshal(strct.Severity); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Alarm) UnmarshalJSON(b []byte) error {
    AlarmNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AlarmName":
            if err := json.Unmarshal([]byte(v), &strct.AlarmName); err != nil {
                return err
             }
            AlarmNameReceived = true
        case "Severity":
            if err := json.Unmarshal([]byte(v), &strct.Severity); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if AlarmName (a required property) was received
    if !AlarmNameReceived {
        return errors.New("\"AlarmName\" is required but was not present")
    }
    return nil
}

func (strct *AlarmMetric) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AlarmMetricName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AlarmMetricName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AlarmMetricName\": ")
	if tmp, err := json.Marshal(strct.AlarmMetricName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AlarmMetric) UnmarshalJSON(b []byte) error {
    AlarmMetricNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AlarmMetricName":
            if err := json.Unmarshal([]byte(v), &strct.AlarmMetricName); err != nil {
                return err
             }
            AlarmMetricNameReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if AlarmMetricName (a required property) was received
    if !AlarmMetricNameReceived {
        return errors.New("\"AlarmMetricName\" is required but was not present")
    }
    return nil
}

func (strct *ComponentConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ConfigurationDetails" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConfigurationDetails\": ")
	if tmp, err := json.Marshal(strct.ConfigurationDetails); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SubComponentTypeConfigurations" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SubComponentTypeConfigurations\": ")
	if tmp, err := json.Marshal(strct.SubComponentTypeConfigurations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ComponentConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ConfigurationDetails":
            if err := json.Unmarshal([]byte(v), &strct.ConfigurationDetails); err != nil {
                return err
             }
        case "SubComponentTypeConfigurations":
            if err := json.Unmarshal([]byte(v), &strct.SubComponentTypeConfigurations); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ComponentMonitoringSetting) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ComponentARN" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ComponentARN\": ")
	if tmp, err := json.Marshal(strct.ComponentARN); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ComponentConfigurationMode" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ComponentConfigurationMode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ComponentConfigurationMode\": ")
	if tmp, err := json.Marshal(strct.ComponentConfigurationMode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ComponentName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ComponentName\": ")
	if tmp, err := json.Marshal(strct.ComponentName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CustomComponentConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CustomComponentConfiguration\": ")
	if tmp, err := json.Marshal(strct.CustomComponentConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DefaultOverwriteComponentConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DefaultOverwriteComponentConfiguration\": ")
	if tmp, err := json.Marshal(strct.DefaultOverwriteComponentConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Tier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Tier" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tier\": ")
	if tmp, err := json.Marshal(strct.Tier); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ComponentMonitoringSetting) UnmarshalJSON(b []byte) error {
    ComponentConfigurationModeReceived := false
    TierReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ComponentARN":
            if err := json.Unmarshal([]byte(v), &strct.ComponentARN); err != nil {
                return err
             }
        case "ComponentConfigurationMode":
            if err := json.Unmarshal([]byte(v), &strct.ComponentConfigurationMode); err != nil {
                return err
             }
            ComponentConfigurationModeReceived = true
        case "ComponentName":
            if err := json.Unmarshal([]byte(v), &strct.ComponentName); err != nil {
                return err
             }
        case "CustomComponentConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.CustomComponentConfiguration); err != nil {
                return err
             }
        case "DefaultOverwriteComponentConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.DefaultOverwriteComponentConfiguration); err != nil {
                return err
             }
        case "Tier":
            if err := json.Unmarshal([]byte(v), &strct.Tier); err != nil {
                return err
             }
            TierReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ComponentConfigurationMode (a required property) was received
    if !ComponentConfigurationModeReceived {
        return errors.New("\"ComponentConfigurationMode\" is required but was not present")
    }
    // check if Tier (a required property) was received
    if !TierReceived {
        return errors.New("\"Tier\" is required but was not present")
    }
    return nil
}

func (strct *ConfigurationDetails) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AlarmMetrics" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AlarmMetrics\": ")
	if tmp, err := json.Marshal(strct.AlarmMetrics); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Alarms" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Alarms\": ")
	if tmp, err := json.Marshal(strct.Alarms); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "HAClusterPrometheusExporter" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HAClusterPrometheusExporter\": ")
	if tmp, err := json.Marshal(strct.HAClusterPrometheusExporter); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "HANAPrometheusExporter" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HANAPrometheusExporter\": ")
	if tmp, err := json.Marshal(strct.HANAPrometheusExporter); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "JMXPrometheusExporter" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"JMXPrometheusExporter\": ")
	if tmp, err := json.Marshal(strct.JMXPrometheusExporter); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Logs" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Logs\": ")
	if tmp, err := json.Marshal(strct.Logs); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "WindowsEvents" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"WindowsEvents\": ")
	if tmp, err := json.Marshal(strct.WindowsEvents); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ConfigurationDetails) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AlarmMetrics":
            if err := json.Unmarshal([]byte(v), &strct.AlarmMetrics); err != nil {
                return err
             }
        case "Alarms":
            if err := json.Unmarshal([]byte(v), &strct.Alarms); err != nil {
                return err
             }
        case "HAClusterPrometheusExporter":
            if err := json.Unmarshal([]byte(v), &strct.HAClusterPrometheusExporter); err != nil {
                return err
             }
        case "HANAPrometheusExporter":
            if err := json.Unmarshal([]byte(v), &strct.HANAPrometheusExporter); err != nil {
                return err
             }
        case "JMXPrometheusExporter":
            if err := json.Unmarshal([]byte(v), &strct.JMXPrometheusExporter); err != nil {
                return err
             }
        case "Logs":
            if err := json.Unmarshal([]byte(v), &strct.Logs); err != nil {
                return err
             }
        case "WindowsEvents":
            if err := json.Unmarshal([]byte(v), &strct.WindowsEvents); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *CustomComponent) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ComponentName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ComponentName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ComponentName\": ")
	if tmp, err := json.Marshal(strct.ComponentName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ResourceList" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ResourceList" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ResourceList\": ")
	if tmp, err := json.Marshal(strct.ResourceList); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CustomComponent) UnmarshalJSON(b []byte) error {
    ComponentNameReceived := false
    ResourceListReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ComponentName":
            if err := json.Unmarshal([]byte(v), &strct.ComponentName); err != nil {
                return err
             }
            ComponentNameReceived = true
        case "ResourceList":
            if err := json.Unmarshal([]byte(v), &strct.ResourceList); err != nil {
                return err
             }
            ResourceListReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ComponentName (a required property) was received
    if !ComponentNameReceived {
        return errors.New("\"ComponentName\" is required but was not present")
    }
    // check if ResourceList (a required property) was received
    if !ResourceListReceived {
        return errors.New("\"ResourceList\" is required but was not present")
    }
    return nil
}

func (strct *HAClusterPrometheusExporter) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "PrometheusPort" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PrometheusPort\": ")
	if tmp, err := json.Marshal(strct.PrometheusPort); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *HAClusterPrometheusExporter) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "PrometheusPort":
            if err := json.Unmarshal([]byte(v), &strct.PrometheusPort); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *HANAPrometheusExporter) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AgreeToInstallHANADBClient" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AgreeToInstallHANADBClient" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AgreeToInstallHANADBClient\": ")
	if tmp, err := json.Marshal(strct.AgreeToInstallHANADBClient); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "HANAPort" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "HANAPort" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HANAPort\": ")
	if tmp, err := json.Marshal(strct.HANAPort); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "HANASID" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "HANASID" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HANASID\": ")
	if tmp, err := json.Marshal(strct.HANASID); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "HANASecretName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "HANASecretName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HANASecretName\": ")
	if tmp, err := json.Marshal(strct.HANASecretName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PrometheusPort" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PrometheusPort\": ")
	if tmp, err := json.Marshal(strct.PrometheusPort); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *HANAPrometheusExporter) UnmarshalJSON(b []byte) error {
    AgreeToInstallHANADBClientReceived := false
    HANAPortReceived := false
    HANASIDReceived := false
    HANASecretNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AgreeToInstallHANADBClient":
            if err := json.Unmarshal([]byte(v), &strct.AgreeToInstallHANADBClient); err != nil {
                return err
             }
            AgreeToInstallHANADBClientReceived = true
        case "HANAPort":
            if err := json.Unmarshal([]byte(v), &strct.HANAPort); err != nil {
                return err
             }
            HANAPortReceived = true
        case "HANASID":
            if err := json.Unmarshal([]byte(v), &strct.HANASID); err != nil {
                return err
             }
            HANASIDReceived = true
        case "HANASecretName":
            if err := json.Unmarshal([]byte(v), &strct.HANASecretName); err != nil {
                return err
             }
            HANASecretNameReceived = true
        case "PrometheusPort":
            if err := json.Unmarshal([]byte(v), &strct.PrometheusPort); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if AgreeToInstallHANADBClient (a required property) was received
    if !AgreeToInstallHANADBClientReceived {
        return errors.New("\"AgreeToInstallHANADBClient\" is required but was not present")
    }
    // check if HANAPort (a required property) was received
    if !HANAPortReceived {
        return errors.New("\"HANAPort\" is required but was not present")
    }
    // check if HANASID (a required property) was received
    if !HANASIDReceived {
        return errors.New("\"HANASID\" is required but was not present")
    }
    // check if HANASecretName (a required property) was received
    if !HANASecretNameReceived {
        return errors.New("\"HANASecretName\" is required but was not present")
    }
    return nil
}

func (strct *JMXPrometheusExporter) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "HostPort" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HostPort\": ")
	if tmp, err := json.Marshal(strct.HostPort); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "JMXURL" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"JMXURL\": ")
	if tmp, err := json.Marshal(strct.JMXURL); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PrometheusPort" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PrometheusPort\": ")
	if tmp, err := json.Marshal(strct.PrometheusPort); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *JMXPrometheusExporter) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "HostPort":
            if err := json.Unmarshal([]byte(v), &strct.HostPort); err != nil {
                return err
             }
        case "JMXURL":
            if err := json.Unmarshal([]byte(v), &strct.JMXURL); err != nil {
                return err
             }
        case "PrometheusPort":
            if err := json.Unmarshal([]byte(v), &strct.PrometheusPort); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Log) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Encoding" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Encoding\": ")
	if tmp, err := json.Marshal(strct.Encoding); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LogGroupName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LogGroupName\": ")
	if tmp, err := json.Marshal(strct.LogGroupName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LogPath" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LogPath\": ")
	if tmp, err := json.Marshal(strct.LogPath); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "LogType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "LogType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LogType\": ")
	if tmp, err := json.Marshal(strct.LogType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PatternSet" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PatternSet\": ")
	if tmp, err := json.Marshal(strct.PatternSet); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Log) UnmarshalJSON(b []byte) error {
    LogTypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Encoding":
            if err := json.Unmarshal([]byte(v), &strct.Encoding); err != nil {
                return err
             }
        case "LogGroupName":
            if err := json.Unmarshal([]byte(v), &strct.LogGroupName); err != nil {
                return err
             }
        case "LogPath":
            if err := json.Unmarshal([]byte(v), &strct.LogPath); err != nil {
                return err
             }
        case "LogType":
            if err := json.Unmarshal([]byte(v), &strct.LogType); err != nil {
                return err
             }
            LogTypeReceived = true
        case "PatternSet":
            if err := json.Unmarshal([]byte(v), &strct.PatternSet); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if LogType (a required property) was received
    if !LogTypeReceived {
        return errors.New("\"LogType\" is required but was not present")
    }
    return nil
}

func (strct *LogPattern) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Pattern" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Pattern" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Pattern\": ")
	if tmp, err := json.Marshal(strct.Pattern); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "PatternName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "PatternName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PatternName\": ")
	if tmp, err := json.Marshal(strct.PatternName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Rank" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Rank" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Rank\": ")
	if tmp, err := json.Marshal(strct.Rank); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LogPattern) UnmarshalJSON(b []byte) error {
    PatternReceived := false
    PatternNameReceived := false
    RankReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Pattern":
            if err := json.Unmarshal([]byte(v), &strct.Pattern); err != nil {
                return err
             }
            PatternReceived = true
        case "PatternName":
            if err := json.Unmarshal([]byte(v), &strct.PatternName); err != nil {
                return err
             }
            PatternNameReceived = true
        case "Rank":
            if err := json.Unmarshal([]byte(v), &strct.Rank); err != nil {
                return err
             }
            RankReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Pattern (a required property) was received
    if !PatternReceived {
        return errors.New("\"Pattern\" is required but was not present")
    }
    // check if PatternName (a required property) was received
    if !PatternNameReceived {
        return errors.New("\"PatternName\" is required but was not present")
    }
    // check if Rank (a required property) was received
    if !RankReceived {
        return errors.New("\"Rank\" is required but was not present")
    }
    return nil
}

func (strct *LogPatternSet) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "LogPatterns" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "LogPatterns" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LogPatterns\": ")
	if tmp, err := json.Marshal(strct.LogPatterns); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "PatternSetName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "PatternSetName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PatternSetName\": ")
	if tmp, err := json.Marshal(strct.PatternSetName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LogPatternSet) UnmarshalJSON(b []byte) error {
    LogPatternsReceived := false
    PatternSetNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "LogPatterns":
            if err := json.Unmarshal([]byte(v), &strct.LogPatterns); err != nil {
                return err
             }
            LogPatternsReceived = true
        case "PatternSetName":
            if err := json.Unmarshal([]byte(v), &strct.PatternSetName); err != nil {
                return err
             }
            PatternSetNameReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if LogPatterns (a required property) was received
    if !LogPatternsReceived {
        return errors.New("\"LogPatterns\" is required but was not present")
    }
    // check if PatternSetName (a required property) was received
    if !PatternSetNameReceived {
        return errors.New("\"PatternSetName\" is required but was not present")
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ApplicationARN" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ApplicationARN\": ")
	if tmp, err := json.Marshal(strct.ApplicationARN); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AutoConfigurationEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AutoConfigurationEnabled\": ")
	if tmp, err := json.Marshal(strct.AutoConfigurationEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CWEMonitorEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CWEMonitorEnabled\": ")
	if tmp, err := json.Marshal(strct.CWEMonitorEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ComponentMonitoringSettings" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ComponentMonitoringSettings\": ")
	if tmp, err := json.Marshal(strct.ComponentMonitoringSettings); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CustomComponents" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CustomComponents\": ")
	if tmp, err := json.Marshal(strct.CustomComponents); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "GroupingType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"GroupingType\": ")
	if tmp, err := json.Marshal(strct.GroupingType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LogPatternSets" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LogPatternSets\": ")
	if tmp, err := json.Marshal(strct.LogPatternSets); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OpsCenterEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OpsCenterEnabled\": ")
	if tmp, err := json.Marshal(strct.OpsCenterEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OpsItemSNSTopicArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OpsItemSNSTopicArn\": ")
	if tmp, err := json.Marshal(strct.OpsItemSNSTopicArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ResourceGroupName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ResourceGroupName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ResourceGroupName\": ")
	if tmp, err := json.Marshal(strct.ResourceGroupName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    ResourceGroupNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ApplicationARN":
            if err := json.Unmarshal([]byte(v), &strct.ApplicationARN); err != nil {
                return err
             }
        case "AutoConfigurationEnabled":
            if err := json.Unmarshal([]byte(v), &strct.AutoConfigurationEnabled); err != nil {
                return err
             }
        case "CWEMonitorEnabled":
            if err := json.Unmarshal([]byte(v), &strct.CWEMonitorEnabled); err != nil {
                return err
             }
        case "ComponentMonitoringSettings":
            if err := json.Unmarshal([]byte(v), &strct.ComponentMonitoringSettings); err != nil {
                return err
             }
        case "CustomComponents":
            if err := json.Unmarshal([]byte(v), &strct.CustomComponents); err != nil {
                return err
             }
        case "GroupingType":
            if err := json.Unmarshal([]byte(v), &strct.GroupingType); err != nil {
                return err
             }
        case "LogPatternSets":
            if err := json.Unmarshal([]byte(v), &strct.LogPatternSets); err != nil {
                return err
             }
        case "OpsCenterEnabled":
            if err := json.Unmarshal([]byte(v), &strct.OpsCenterEnabled); err != nil {
                return err
             }
        case "OpsItemSNSTopicArn":
            if err := json.Unmarshal([]byte(v), &strct.OpsItemSNSTopicArn); err != nil {
                return err
             }
        case "ResourceGroupName":
            if err := json.Unmarshal([]byte(v), &strct.ResourceGroupName); err != nil {
                return err
             }
            ResourceGroupNameReceived = true
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ResourceGroupName (a required property) was received
    if !ResourceGroupNameReceived {
        return errors.New("\"ResourceGroupName\" is required but was not present")
    }
    return nil
}

func (strct *SubComponentConfigurationDetails) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AlarmMetrics" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AlarmMetrics\": ")
	if tmp, err := json.Marshal(strct.AlarmMetrics); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Logs" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Logs\": ")
	if tmp, err := json.Marshal(strct.Logs); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "WindowsEvents" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"WindowsEvents\": ")
	if tmp, err := json.Marshal(strct.WindowsEvents); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SubComponentConfigurationDetails) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AlarmMetrics":
            if err := json.Unmarshal([]byte(v), &strct.AlarmMetrics); err != nil {
                return err
             }
        case "Logs":
            if err := json.Unmarshal([]byte(v), &strct.Logs); err != nil {
                return err
             }
        case "WindowsEvents":
            if err := json.Unmarshal([]byte(v), &strct.WindowsEvents); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *SubComponentTypeConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "SubComponentConfigurationDetails" field is required
    if strct.SubComponentConfigurationDetails == nil {
        return nil, errors.New("SubComponentConfigurationDetails is a required field")
    }
    // Marshal the "SubComponentConfigurationDetails" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SubComponentConfigurationDetails\": ")
	if tmp, err := json.Marshal(strct.SubComponentConfigurationDetails); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "SubComponentType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "SubComponentType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SubComponentType\": ")
	if tmp, err := json.Marshal(strct.SubComponentType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SubComponentTypeConfiguration) UnmarshalJSON(b []byte) error {
    SubComponentConfigurationDetailsReceived := false
    SubComponentTypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "SubComponentConfigurationDetails":
            if err := json.Unmarshal([]byte(v), &strct.SubComponentConfigurationDetails); err != nil {
                return err
             }
            SubComponentConfigurationDetailsReceived = true
        case "SubComponentType":
            if err := json.Unmarshal([]byte(v), &strct.SubComponentType); err != nil {
                return err
             }
            SubComponentTypeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if SubComponentConfigurationDetails (a required property) was received
    if !SubComponentConfigurationDetailsReceived {
        return errors.New("\"SubComponentConfigurationDetails\" is required but was not present")
    }
    // check if SubComponentType (a required property) was received
    if !SubComponentTypeReceived {
        return errors.New("\"SubComponentType\" is required but was not present")
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *WindowsEvent) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "EventLevels" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "EventLevels" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EventLevels\": ")
	if tmp, err := json.Marshal(strct.EventLevels); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "EventName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "EventName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EventName\": ")
	if tmp, err := json.Marshal(strct.EventName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "LogGroupName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "LogGroupName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LogGroupName\": ")
	if tmp, err := json.Marshal(strct.LogGroupName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PatternSet" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PatternSet\": ")
	if tmp, err := json.Marshal(strct.PatternSet); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *WindowsEvent) UnmarshalJSON(b []byte) error {
    EventLevelsReceived := false
    EventNameReceived := false
    LogGroupNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "EventLevels":
            if err := json.Unmarshal([]byte(v), &strct.EventLevels); err != nil {
                return err
             }
            EventLevelsReceived = true
        case "EventName":
            if err := json.Unmarshal([]byte(v), &strct.EventName); err != nil {
                return err
             }
            EventNameReceived = true
        case "LogGroupName":
            if err := json.Unmarshal([]byte(v), &strct.LogGroupName); err != nil {
                return err
             }
            LogGroupNameReceived = true
        case "PatternSet":
            if err := json.Unmarshal([]byte(v), &strct.PatternSet); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if EventLevels (a required property) was received
    if !EventLevelsReceived {
        return errors.New("\"EventLevels\" is required but was not present")
    }
    // check if EventName (a required property) was received
    if !EventNameReceived {
        return errors.New("\"EventName\" is required but was not present")
    }
    // check if LogGroupName (a required property) was received
    if !LogGroupNameReceived {
        return errors.New("\"LogGroupName\" is required but was not present")
    }
    return nil
}
