// Code generated by schema-generate. DO NOT EDIT.

package canary

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// ArtifactConfig 
type ArtifactConfig struct {

  // Encryption configuration for uploading artifacts to S3
  S3Encryption *S3Encryption `json:"S3Encryption,omitempty"`
}

// BaseScreenshot 
type BaseScreenshot struct {

  // List of coordinates of rectangles to be ignored during visual testing
  IgnoreCoordinates []string `json:"IgnoreCoordinates,omitempty"`

  // Name of the screenshot to be used as base reference for visual testing
  ScreenshotName string `json:"ScreenshotName"`
}

// Code 
type Code struct {
  Handler string `json:"Handler"`
  S3Bucket string `json:"S3Bucket,omitempty"`
  S3Key string `json:"S3Key,omitempty"`
  S3ObjectVersion string `json:"S3ObjectVersion,omitempty"`
  Script string `json:"Script,omitempty"`
}

// EnvironmentVariables Environment variable key-value pairs.
type EnvironmentVariables struct {
}

// Resource Resource Type definition for AWS::Synthetics::Canary
type Resource struct {

  // Provide artifact configuration
  ArtifactConfig *ArtifactConfig `json:"ArtifactConfig,omitempty"`

  // Provide the s3 bucket output location for test results
  ArtifactS3Location string `json:"ArtifactS3Location"`

  // Provide the canary script source
  Code *Code `json:"Code"`

  // Deletes associated lambda resources created by Synthetics if set to True. Default is False
  DeleteLambdaResourcesOnCanaryDeletion bool `json:"DeleteLambdaResourcesOnCanaryDeletion,omitempty"`

  // Lambda Execution role used to run your canaries
  ExecutionRoleArn string `json:"ExecutionRoleArn"`

  // Retention period of failed canary runs represented in number of days
  FailureRetentionPeriod int `json:"FailureRetentionPeriod,omitempty"`

  // Id of the canary
  Id string `json:"Id,omitempty"`

  // Name of the canary.
  Name string `json:"Name"`

  // Provide canary run configuration
  RunConfig *RunConfig `json:"RunConfig,omitempty"`

  // Runtime version of Synthetics Library
  RuntimeVersion string `json:"RuntimeVersion"`

  // Frequency to run your canaries
  Schedule *Schedule `json:"Schedule"`

  // Runs canary if set to True. Default is False
  StartCanaryAfterCreation bool `json:"StartCanaryAfterCreation"`

  // State of the canary
  State string `json:"State,omitempty"`

  // Retention period of successful canary runs represented in number of days
  SuccessRetentionPeriod int `json:"SuccessRetentionPeriod,omitempty"`
  Tags []*Tag `json:"Tags,omitempty"`

  // Provide VPC Configuration if enabled.
  VPCConfig *VPCConfig `json:"VPCConfig,omitempty"`

  // Visual reference configuration for visual testing
  VisualReference *VisualReference `json:"VisualReference,omitempty"`
}

// RunConfig 
type RunConfig struct {

  // Enable active tracing if set to true
  ActiveTracing bool `json:"ActiveTracing,omitempty"`

  // Environment variable key-value pairs.
  EnvironmentVariables *EnvironmentVariables `json:"EnvironmentVariables,omitempty"`

  // Provide maximum memory available for canary in MB
  MemoryInMB int `json:"MemoryInMB,omitempty"`

  // Provide maximum canary timeout per run in seconds
  TimeoutInSeconds int `json:"TimeoutInSeconds,omitempty"`
}

// S3Encryption 
type S3Encryption struct {

  // Encryption mode for encrypting artifacts when uploading to S3. Valid values: SSE_S3 and SSE_KMS.
  EncryptionMode string `json:"EncryptionMode,omitempty"`

  // KMS key Arn for encrypting artifacts when uploading to S3. You must specify KMS key Arn for SSE_KMS encryption mode only.
  KmsKeyArn string `json:"KmsKeyArn,omitempty"`
}

// Schedule 
type Schedule struct {
  DurationInSeconds string `json:"DurationInSeconds,omitempty"`
  Expression string `json:"Expression"`
}

// Tag A key-value pair to associate with a resource.
type Tag struct {

  // The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
  Key string `json:"Key"`

  // The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
  Value string `json:"Value"`
}

// VPCConfig 
type VPCConfig struct {
  SecurityGroupIds []string `json:"SecurityGroupIds"`
  SubnetIds []string `json:"SubnetIds"`
  VpcId string `json:"VpcId,omitempty"`
}

// VisualReference 
type VisualReference struct {

  // Canary run id to be used as base reference for visual testing
  BaseCanaryRunId string `json:"BaseCanaryRunId"`

  // List of screenshots used as base reference for visual testing
  BaseScreenshots []*BaseScreenshot `json:"BaseScreenshots,omitempty"`
}

func (strct *ArtifactConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "S3Encryption" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3Encryption\": ")
	if tmp, err := json.Marshal(strct.S3Encryption); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ArtifactConfig) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "S3Encryption":
            if err := json.Unmarshal([]byte(v), &strct.S3Encryption); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *BaseScreenshot) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "IgnoreCoordinates" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IgnoreCoordinates\": ")
	if tmp, err := json.Marshal(strct.IgnoreCoordinates); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ScreenshotName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ScreenshotName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ScreenshotName\": ")
	if tmp, err := json.Marshal(strct.ScreenshotName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BaseScreenshot) UnmarshalJSON(b []byte) error {
    ScreenshotNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "IgnoreCoordinates":
            if err := json.Unmarshal([]byte(v), &strct.IgnoreCoordinates); err != nil {
                return err
             }
        case "ScreenshotName":
            if err := json.Unmarshal([]byte(v), &strct.ScreenshotName); err != nil {
                return err
             }
            ScreenshotNameReceived = true
        }
    }
    // check if ScreenshotName (a required property) was received
    if !ScreenshotNameReceived {
        return errors.New("\"ScreenshotName\" is required but was not present")
    }
    return nil
}

func (strct *Code) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Handler" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Handler" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Handler\": ")
	if tmp, err := json.Marshal(strct.Handler); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "S3Bucket" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3Bucket\": ")
	if tmp, err := json.Marshal(strct.S3Bucket); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "S3Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3Key\": ")
	if tmp, err := json.Marshal(strct.S3Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "S3ObjectVersion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3ObjectVersion\": ")
	if tmp, err := json.Marshal(strct.S3ObjectVersion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Script" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Script\": ")
	if tmp, err := json.Marshal(strct.Script); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Code) UnmarshalJSON(b []byte) error {
    HandlerReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Handler":
            if err := json.Unmarshal([]byte(v), &strct.Handler); err != nil {
                return err
             }
            HandlerReceived = true
        case "S3Bucket":
            if err := json.Unmarshal([]byte(v), &strct.S3Bucket); err != nil {
                return err
             }
        case "S3Key":
            if err := json.Unmarshal([]byte(v), &strct.S3Key); err != nil {
                return err
             }
        case "S3ObjectVersion":
            if err := json.Unmarshal([]byte(v), &strct.S3ObjectVersion); err != nil {
                return err
             }
        case "Script":
            if err := json.Unmarshal([]byte(v), &strct.Script); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Handler (a required property) was received
    if !HandlerReceived {
        return errors.New("\"Handler\" is required but was not present")
    }
    return nil
}

func (strct *EnvironmentVariables) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *EnvironmentVariables) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ArtifactConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ArtifactConfig\": ")
	if tmp, err := json.Marshal(strct.ArtifactConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ArtifactS3Location" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ArtifactS3Location" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ArtifactS3Location\": ")
	if tmp, err := json.Marshal(strct.ArtifactS3Location); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Code" field is required
    if strct.Code == nil {
        return nil, errors.New("Code is a required field")
    }
    // Marshal the "Code" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Code\": ")
	if tmp, err := json.Marshal(strct.Code); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DeleteLambdaResourcesOnCanaryDeletion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DeleteLambdaResourcesOnCanaryDeletion\": ")
	if tmp, err := json.Marshal(strct.DeleteLambdaResourcesOnCanaryDeletion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ExecutionRoleArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ExecutionRoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ExecutionRoleArn\": ")
	if tmp, err := json.Marshal(strct.ExecutionRoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FailureRetentionPeriod" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FailureRetentionPeriod\": ")
	if tmp, err := json.Marshal(strct.FailureRetentionPeriod); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Id" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RunConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RunConfig\": ")
	if tmp, err := json.Marshal(strct.RunConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RuntimeVersion" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RuntimeVersion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RuntimeVersion\": ")
	if tmp, err := json.Marshal(strct.RuntimeVersion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Schedule" field is required
    if strct.Schedule == nil {
        return nil, errors.New("Schedule is a required field")
    }
    // Marshal the "Schedule" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Schedule\": ")
	if tmp, err := json.Marshal(strct.Schedule); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "StartCanaryAfterCreation" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "StartCanaryAfterCreation" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StartCanaryAfterCreation\": ")
	if tmp, err := json.Marshal(strct.StartCanaryAfterCreation); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "State" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"State\": ")
	if tmp, err := json.Marshal(strct.State); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SuccessRetentionPeriod" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SuccessRetentionPeriod\": ")
	if tmp, err := json.Marshal(strct.SuccessRetentionPeriod); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VPCConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VPCConfig\": ")
	if tmp, err := json.Marshal(strct.VPCConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VisualReference" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VisualReference\": ")
	if tmp, err := json.Marshal(strct.VisualReference); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    ArtifactS3LocationReceived := false
    CodeReceived := false
    ExecutionRoleArnReceived := false
    NameReceived := false
    RuntimeVersionReceived := false
    ScheduleReceived := false
    StartCanaryAfterCreationReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ArtifactConfig":
            if err := json.Unmarshal([]byte(v), &strct.ArtifactConfig); err != nil {
                return err
             }
        case "ArtifactS3Location":
            if err := json.Unmarshal([]byte(v), &strct.ArtifactS3Location); err != nil {
                return err
             }
            ArtifactS3LocationReceived = true
        case "Code":
            if err := json.Unmarshal([]byte(v), &strct.Code); err != nil {
                return err
             }
            CodeReceived = true
        case "DeleteLambdaResourcesOnCanaryDeletion":
            if err := json.Unmarshal([]byte(v), &strct.DeleteLambdaResourcesOnCanaryDeletion); err != nil {
                return err
             }
        case "ExecutionRoleArn":
            if err := json.Unmarshal([]byte(v), &strct.ExecutionRoleArn); err != nil {
                return err
             }
            ExecutionRoleArnReceived = true
        case "FailureRetentionPeriod":
            if err := json.Unmarshal([]byte(v), &strct.FailureRetentionPeriod); err != nil {
                return err
             }
        case "Id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        case "RunConfig":
            if err := json.Unmarshal([]byte(v), &strct.RunConfig); err != nil {
                return err
             }
        case "RuntimeVersion":
            if err := json.Unmarshal([]byte(v), &strct.RuntimeVersion); err != nil {
                return err
             }
            RuntimeVersionReceived = true
        case "Schedule":
            if err := json.Unmarshal([]byte(v), &strct.Schedule); err != nil {
                return err
             }
            ScheduleReceived = true
        case "StartCanaryAfterCreation":
            if err := json.Unmarshal([]byte(v), &strct.StartCanaryAfterCreation); err != nil {
                return err
             }
            StartCanaryAfterCreationReceived = true
        case "State":
            if err := json.Unmarshal([]byte(v), &strct.State); err != nil {
                return err
             }
        case "SuccessRetentionPeriod":
            if err := json.Unmarshal([]byte(v), &strct.SuccessRetentionPeriod); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        case "VPCConfig":
            if err := json.Unmarshal([]byte(v), &strct.VPCConfig); err != nil {
                return err
             }
        case "VisualReference":
            if err := json.Unmarshal([]byte(v), &strct.VisualReference); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ArtifactS3Location (a required property) was received
    if !ArtifactS3LocationReceived {
        return errors.New("\"ArtifactS3Location\" is required but was not present")
    }
    // check if Code (a required property) was received
    if !CodeReceived {
        return errors.New("\"Code\" is required but was not present")
    }
    // check if ExecutionRoleArn (a required property) was received
    if !ExecutionRoleArnReceived {
        return errors.New("\"ExecutionRoleArn\" is required but was not present")
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    // check if RuntimeVersion (a required property) was received
    if !RuntimeVersionReceived {
        return errors.New("\"RuntimeVersion\" is required but was not present")
    }
    // check if Schedule (a required property) was received
    if !ScheduleReceived {
        return errors.New("\"Schedule\" is required but was not present")
    }
    // check if StartCanaryAfterCreation (a required property) was received
    if !StartCanaryAfterCreationReceived {
        return errors.New("\"StartCanaryAfterCreation\" is required but was not present")
    }
    return nil
}

func (strct *RunConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ActiveTracing" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ActiveTracing\": ")
	if tmp, err := json.Marshal(strct.ActiveTracing); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EnvironmentVariables" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EnvironmentVariables\": ")
	if tmp, err := json.Marshal(strct.EnvironmentVariables); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MemoryInMB" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MemoryInMB\": ")
	if tmp, err := json.Marshal(strct.MemoryInMB); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TimeoutInSeconds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TimeoutInSeconds\": ")
	if tmp, err := json.Marshal(strct.TimeoutInSeconds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RunConfig) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ActiveTracing":
            if err := json.Unmarshal([]byte(v), &strct.ActiveTracing); err != nil {
                return err
             }
        case "EnvironmentVariables":
            if err := json.Unmarshal([]byte(v), &strct.EnvironmentVariables); err != nil {
                return err
             }
        case "MemoryInMB":
            if err := json.Unmarshal([]byte(v), &strct.MemoryInMB); err != nil {
                return err
             }
        case "TimeoutInSeconds":
            if err := json.Unmarshal([]byte(v), &strct.TimeoutInSeconds); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *S3Encryption) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "EncryptionMode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EncryptionMode\": ")
	if tmp, err := json.Marshal(strct.EncryptionMode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "KmsKeyArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KmsKeyArn\": ")
	if tmp, err := json.Marshal(strct.KmsKeyArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *S3Encryption) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "EncryptionMode":
            if err := json.Unmarshal([]byte(v), &strct.EncryptionMode); err != nil {
                return err
             }
        case "KmsKeyArn":
            if err := json.Unmarshal([]byte(v), &strct.KmsKeyArn); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Schedule) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DurationInSeconds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DurationInSeconds\": ")
	if tmp, err := json.Marshal(strct.DurationInSeconds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Expression" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Expression" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Expression\": ")
	if tmp, err := json.Marshal(strct.Expression); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Schedule) UnmarshalJSON(b []byte) error {
    ExpressionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DurationInSeconds":
            if err := json.Unmarshal([]byte(v), &strct.DurationInSeconds); err != nil {
                return err
             }
        case "Expression":
            if err := json.Unmarshal([]byte(v), &strct.Expression); err != nil {
                return err
             }
            ExpressionReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Expression (a required property) was received
    if !ExpressionReceived {
        return errors.New("\"Expression\" is required but was not present")
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *VPCConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "SecurityGroupIds" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "SecurityGroupIds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SecurityGroupIds\": ")
	if tmp, err := json.Marshal(strct.SecurityGroupIds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "SubnetIds" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "SubnetIds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SubnetIds\": ")
	if tmp, err := json.Marshal(strct.SubnetIds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VpcId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VpcId\": ")
	if tmp, err := json.Marshal(strct.VpcId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *VPCConfig) UnmarshalJSON(b []byte) error {
    SecurityGroupIdsReceived := false
    SubnetIdsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "SecurityGroupIds":
            if err := json.Unmarshal([]byte(v), &strct.SecurityGroupIds); err != nil {
                return err
             }
            SecurityGroupIdsReceived = true
        case "SubnetIds":
            if err := json.Unmarshal([]byte(v), &strct.SubnetIds); err != nil {
                return err
             }
            SubnetIdsReceived = true
        case "VpcId":
            if err := json.Unmarshal([]byte(v), &strct.VpcId); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if SecurityGroupIds (a required property) was received
    if !SecurityGroupIdsReceived {
        return errors.New("\"SecurityGroupIds\" is required but was not present")
    }
    // check if SubnetIds (a required property) was received
    if !SubnetIdsReceived {
        return errors.New("\"SubnetIds\" is required but was not present")
    }
    return nil
}

func (strct *VisualReference) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "BaseCanaryRunId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "BaseCanaryRunId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BaseCanaryRunId\": ")
	if tmp, err := json.Marshal(strct.BaseCanaryRunId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BaseScreenshots" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BaseScreenshots\": ")
	if tmp, err := json.Marshal(strct.BaseScreenshots); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *VisualReference) UnmarshalJSON(b []byte) error {
    BaseCanaryRunIdReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BaseCanaryRunId":
            if err := json.Unmarshal([]byte(v), &strct.BaseCanaryRunId); err != nil {
                return err
             }
            BaseCanaryRunIdReceived = true
        case "BaseScreenshots":
            if err := json.Unmarshal([]byte(v), &strct.BaseScreenshots); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if BaseCanaryRunId (a required property) was received
    if !BaseCanaryRunIdReceived {
        return errors.New("\"BaseCanaryRunId\" is required but was not present")
    }
    return nil
}
