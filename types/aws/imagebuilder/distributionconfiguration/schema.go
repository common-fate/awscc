// Code generated by schema-generate. DO NOT EDIT.

package distributionconfiguration

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// AmiDistributionConfiguration The specific AMI settings (for example, launch permissions, AMI tags).
type AmiDistributionConfiguration struct {

  // The tags to apply to AMIs distributed to this Region.
  AmiTags *AmiTags `json:"AmiTags,omitempty"`

  // The description of the AMI distribution configuration.
  Description string `json:"Description,omitempty"`

  // The KMS key identifier used to encrypt the distributed image.
  KmsKeyId string `json:"KmsKeyId,omitempty"`
  LaunchPermissionConfiguration *LaunchPermissionConfiguration `json:"LaunchPermissionConfiguration,omitempty"`

  // The name of the AMI distribution configuration.
  Name string `json:"Name,omitempty"`

  // The ID of accounts to which you want to distribute an image.
  TargetAccountIds []string `json:"TargetAccountIds,omitempty"`
}

// AmiTags The tags to apply to AMIs distributed to this Region.
type AmiTags struct {
}

// ContainerDistributionConfiguration Container distribution settings for encryption, licensing, and sharing in a specific Region.
type ContainerDistributionConfiguration struct {

  // Tags that are attached to the container distribution configuration.
  ContainerTags []string `json:"ContainerTags,omitempty"`

  // The description of the container distribution configuration.
  Description string `json:"Description,omitempty"`

  // The destination repository for the container distribution configuration.
  TargetRepository *TargetContainerRepository `json:"TargetRepository,omitempty"`
}

// Distribution The distributions of the distribution configuration.
type Distribution struct {
  AmiDistributionConfiguration *AmiDistributionConfiguration `json:"AmiDistributionConfiguration,omitempty"`
  ContainerDistributionConfiguration *ContainerDistributionConfiguration `json:"ContainerDistributionConfiguration,omitempty"`

  // The Windows faster-launching configurations to use for AMI distribution.
  FastLaunchConfigurations []*FastLaunchConfiguration `json:"FastLaunchConfigurations,omitempty"`

  // A group of launchTemplateConfiguration settings that apply to image distribution.
  LaunchTemplateConfigurations []*LaunchTemplateConfiguration `json:"LaunchTemplateConfigurations,omitempty"`

  // The License Manager Configuration to associate with the AMI in the specified Region.
  LicenseConfigurationArns []string `json:"LicenseConfigurationArns,omitempty"`

  // region
  Region string `json:"Region"`
}

// FastLaunchConfiguration The Windows faster-launching configuration to use for AMI distribution.
type FastLaunchConfiguration struct {

  // The owner account ID for the fast-launch enabled Windows AMI.
  AccountId string `json:"AccountId,omitempty"`

  // A Boolean that represents the current state of faster launching for the Windows AMI. Set to true to start using Windows faster launching, or false to stop using it.
  Enabled bool `json:"Enabled,omitempty"`

  // The launch template that the fast-launch enabled Windows AMI uses when it launches Windows instances to create pre-provisioned snapshots.
  LaunchTemplate *FastLaunchLaunchTemplateSpecification `json:"LaunchTemplate,omitempty"`

  // The maximum number of parallel instances that are launched for creating resources.
  MaxParallelLaunches int `json:"MaxParallelLaunches,omitempty"`

  // Configuration settings for managing the number of snapshots that are created from pre-provisioned instances for the Windows AMI when faster launching is enabled.
  SnapshotConfiguration *FastLaunchSnapshotConfiguration `json:"SnapshotConfiguration,omitempty"`
}

// FastLaunchLaunchTemplateSpecification The launch template that the fast-launch enabled Windows AMI uses when it launches Windows instances to create pre-provisioned snapshots.
type FastLaunchLaunchTemplateSpecification struct {

  // The ID of the launch template to use for faster launching for a Windows AMI.
  LaunchTemplateId string `json:"LaunchTemplateId,omitempty"`

  // The name of the launch template to use for faster launching for a Windows AMI.
  LaunchTemplateName string `json:"LaunchTemplateName,omitempty"`

  // The version of the launch template to use for faster launching for a Windows AMI.
  LaunchTemplateVersion string `json:"LaunchTemplateVersion,omitempty"`
}

// FastLaunchSnapshotConfiguration Configuration settings for managing the number of snapshots that are created from pre-provisioned instances for the Windows AMI when faster launching is enabled.
type FastLaunchSnapshotConfiguration struct {

  // The number of pre-provisioned snapshots to keep on hand for a fast-launch enabled Windows AMI.
  TargetResourceCount int `json:"TargetResourceCount,omitempty"`
}

// LaunchPermissionConfiguration Launch permissions can be used to configure which AWS accounts can use the AMI to launch instances.
type LaunchPermissionConfiguration struct {

  // The ARN for an Amazon Web Services Organization that you want to share your AMI with.
  OrganizationArns []string `json:"OrganizationArns,omitempty"`

  // The ARN for an Organizations organizational unit (OU) that you want to share your AMI with.
  OrganizationalUnitArns []string `json:"OrganizationalUnitArns,omitempty"`

  // The name of the group.
  UserGroups []string `json:"UserGroups,omitempty"`

  // The AWS account ID.
  UserIds []string `json:"UserIds,omitempty"`
}

// LaunchTemplateConfiguration launchTemplateConfiguration settings that apply to image distribution.
type LaunchTemplateConfiguration struct {

  // The account ID that this configuration applies to.
  AccountId string `json:"AccountId,omitempty"`

  // Identifies the EC2 launch template to use.
  LaunchTemplateId string `json:"LaunchTemplateId,omitempty"`

  // Set the specified EC2 launch template as the default launch template for the specified account.
  SetDefaultVersion bool `json:"SetDefaultVersion,omitempty"`
}

// Resource Resource schema for AWS::ImageBuilder::DistributionConfiguration
type Resource struct {

  // The Amazon Resource Name (ARN) of the distribution configuration.
  Arn string `json:"Arn,omitempty"`

  // The description of the distribution configuration.
  Description string `json:"Description,omitempty"`

  // The distributions of the distribution configuration.
  Distributions []*Distribution `json:"Distributions"`

  // The name of the distribution configuration.
  Name string `json:"Name"`

  // The tags associated with the component.
  Tags *Tags `json:"Tags,omitempty"`
}

// Tags The tags associated with the component.
type Tags struct {
}

// TargetContainerRepository The destination repository for the container image.
type TargetContainerRepository struct {

  // The repository name of target container repository.
  RepositoryName string `json:"RepositoryName,omitempty"`

  // The service of target container repository.
  Service string `json:"Service,omitempty"`
}

func (strct *AmiDistributionConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AmiTags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AmiTags\": ")
	if tmp, err := json.Marshal(strct.AmiTags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "KmsKeyId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KmsKeyId\": ")
	if tmp, err := json.Marshal(strct.KmsKeyId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LaunchPermissionConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LaunchPermissionConfiguration\": ")
	if tmp, err := json.Marshal(strct.LaunchPermissionConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TargetAccountIds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TargetAccountIds\": ")
	if tmp, err := json.Marshal(strct.TargetAccountIds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AmiDistributionConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AmiTags":
            if err := json.Unmarshal([]byte(v), &strct.AmiTags); err != nil {
                return err
             }
        case "Description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "KmsKeyId":
            if err := json.Unmarshal([]byte(v), &strct.KmsKeyId); err != nil {
                return err
             }
        case "LaunchPermissionConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.LaunchPermissionConfiguration); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "TargetAccountIds":
            if err := json.Unmarshal([]byte(v), &strct.TargetAccountIds); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *AmiTags) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AmiTags) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ContainerDistributionConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ContainerTags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ContainerTags\": ")
	if tmp, err := json.Marshal(strct.ContainerTags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TargetRepository" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TargetRepository\": ")
	if tmp, err := json.Marshal(strct.TargetRepository); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ContainerDistributionConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ContainerTags":
            if err := json.Unmarshal([]byte(v), &strct.ContainerTags); err != nil {
                return err
             }
        case "Description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "TargetRepository":
            if err := json.Unmarshal([]byte(v), &strct.TargetRepository); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Distribution) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AmiDistributionConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AmiDistributionConfiguration\": ")
	if tmp, err := json.Marshal(strct.AmiDistributionConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ContainerDistributionConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ContainerDistributionConfiguration\": ")
	if tmp, err := json.Marshal(strct.ContainerDistributionConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FastLaunchConfigurations" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FastLaunchConfigurations\": ")
	if tmp, err := json.Marshal(strct.FastLaunchConfigurations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LaunchTemplateConfigurations" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LaunchTemplateConfigurations\": ")
	if tmp, err := json.Marshal(strct.LaunchTemplateConfigurations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LicenseConfigurationArns" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LicenseConfigurationArns\": ")
	if tmp, err := json.Marshal(strct.LicenseConfigurationArns); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Region" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Region" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Region\": ")
	if tmp, err := json.Marshal(strct.Region); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Distribution) UnmarshalJSON(b []byte) error {
    RegionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AmiDistributionConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.AmiDistributionConfiguration); err != nil {
                return err
             }
        case "ContainerDistributionConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.ContainerDistributionConfiguration); err != nil {
                return err
             }
        case "FastLaunchConfigurations":
            if err := json.Unmarshal([]byte(v), &strct.FastLaunchConfigurations); err != nil {
                return err
             }
        case "LaunchTemplateConfigurations":
            if err := json.Unmarshal([]byte(v), &strct.LaunchTemplateConfigurations); err != nil {
                return err
             }
        case "LicenseConfigurationArns":
            if err := json.Unmarshal([]byte(v), &strct.LicenseConfigurationArns); err != nil {
                return err
             }
        case "Region":
            if err := json.Unmarshal([]byte(v), &strct.Region); err != nil {
                return err
             }
            RegionReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Region (a required property) was received
    if !RegionReceived {
        return errors.New("\"Region\" is required but was not present")
    }
    return nil
}

func (strct *FastLaunchConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AccountId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AccountId\": ")
	if tmp, err := json.Marshal(strct.AccountId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Enabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LaunchTemplate" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LaunchTemplate\": ")
	if tmp, err := json.Marshal(strct.LaunchTemplate); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MaxParallelLaunches" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaxParallelLaunches\": ")
	if tmp, err := json.Marshal(strct.MaxParallelLaunches); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SnapshotConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SnapshotConfiguration\": ")
	if tmp, err := json.Marshal(strct.SnapshotConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FastLaunchConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AccountId":
            if err := json.Unmarshal([]byte(v), &strct.AccountId); err != nil {
                return err
             }
        case "Enabled":
            if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
                return err
             }
        case "LaunchTemplate":
            if err := json.Unmarshal([]byte(v), &strct.LaunchTemplate); err != nil {
                return err
             }
        case "MaxParallelLaunches":
            if err := json.Unmarshal([]byte(v), &strct.MaxParallelLaunches); err != nil {
                return err
             }
        case "SnapshotConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.SnapshotConfiguration); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *FastLaunchLaunchTemplateSpecification) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "LaunchTemplateId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LaunchTemplateId\": ")
	if tmp, err := json.Marshal(strct.LaunchTemplateId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LaunchTemplateName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LaunchTemplateName\": ")
	if tmp, err := json.Marshal(strct.LaunchTemplateName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LaunchTemplateVersion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LaunchTemplateVersion\": ")
	if tmp, err := json.Marshal(strct.LaunchTemplateVersion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FastLaunchLaunchTemplateSpecification) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "LaunchTemplateId":
            if err := json.Unmarshal([]byte(v), &strct.LaunchTemplateId); err != nil {
                return err
             }
        case "LaunchTemplateName":
            if err := json.Unmarshal([]byte(v), &strct.LaunchTemplateName); err != nil {
                return err
             }
        case "LaunchTemplateVersion":
            if err := json.Unmarshal([]byte(v), &strct.LaunchTemplateVersion); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *FastLaunchSnapshotConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "TargetResourceCount" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TargetResourceCount\": ")
	if tmp, err := json.Marshal(strct.TargetResourceCount); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FastLaunchSnapshotConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "TargetResourceCount":
            if err := json.Unmarshal([]byte(v), &strct.TargetResourceCount); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *LaunchPermissionConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "OrganizationArns" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OrganizationArns\": ")
	if tmp, err := json.Marshal(strct.OrganizationArns); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OrganizationalUnitArns" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OrganizationalUnitArns\": ")
	if tmp, err := json.Marshal(strct.OrganizationalUnitArns); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "UserGroups" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UserGroups\": ")
	if tmp, err := json.Marshal(strct.UserGroups); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "UserIds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UserIds\": ")
	if tmp, err := json.Marshal(strct.UserIds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LaunchPermissionConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "OrganizationArns":
            if err := json.Unmarshal([]byte(v), &strct.OrganizationArns); err != nil {
                return err
             }
        case "OrganizationalUnitArns":
            if err := json.Unmarshal([]byte(v), &strct.OrganizationalUnitArns); err != nil {
                return err
             }
        case "UserGroups":
            if err := json.Unmarshal([]byte(v), &strct.UserGroups); err != nil {
                return err
             }
        case "UserIds":
            if err := json.Unmarshal([]byte(v), &strct.UserIds); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *LaunchTemplateConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AccountId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AccountId\": ")
	if tmp, err := json.Marshal(strct.AccountId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LaunchTemplateId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LaunchTemplateId\": ")
	if tmp, err := json.Marshal(strct.LaunchTemplateId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SetDefaultVersion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SetDefaultVersion\": ")
	if tmp, err := json.Marshal(strct.SetDefaultVersion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LaunchTemplateConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AccountId":
            if err := json.Unmarshal([]byte(v), &strct.AccountId); err != nil {
                return err
             }
        case "LaunchTemplateId":
            if err := json.Unmarshal([]byte(v), &strct.LaunchTemplateId); err != nil {
                return err
             }
        case "SetDefaultVersion":
            if err := json.Unmarshal([]byte(v), &strct.SetDefaultVersion); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Arn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Arn\": ")
	if tmp, err := json.Marshal(strct.Arn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Distributions" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Distributions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Distributions\": ")
	if tmp, err := json.Marshal(strct.Distributions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    DistributionsReceived := false
    NameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Arn":
            if err := json.Unmarshal([]byte(v), &strct.Arn); err != nil {
                return err
             }
        case "Description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "Distributions":
            if err := json.Unmarshal([]byte(v), &strct.Distributions); err != nil {
                return err
             }
            DistributionsReceived = true
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Distributions (a required property) was received
    if !DistributionsReceived {
        return errors.New("\"Distributions\" is required but was not present")
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    return nil
}

func (strct *Tags) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tags) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *TargetContainerRepository) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "RepositoryName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RepositoryName\": ")
	if tmp, err := json.Marshal(strct.RepositoryName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Service" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Service\": ")
	if tmp, err := json.Marshal(strct.Service); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TargetContainerRepository) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "RepositoryName":
            if err := json.Unmarshal([]byte(v), &strct.RepositoryName); err != nil {
                return err
             }
        case "Service":
            if err := json.Unmarshal([]byte(v), &strct.Service); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}
