// Code generated by schema-generate. DO NOT EDIT.

package listener

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// Action 
type Action struct {
  AuthenticateCognitoConfig *AuthenticateCognitoConfig `json:"AuthenticateCognitoConfig,omitempty"`
  AuthenticateOidcConfig *AuthenticateOidcConfig `json:"AuthenticateOidcConfig,omitempty"`
  FixedResponseConfig *FixedResponseConfig `json:"FixedResponseConfig,omitempty"`
  ForwardConfig *ForwardConfig `json:"ForwardConfig,omitempty"`
  Order int `json:"Order,omitempty"`
  RedirectConfig *RedirectConfig `json:"RedirectConfig,omitempty"`
  TargetGroupArn string `json:"TargetGroupArn,omitempty"`
  Type string `json:"Type"`
}

// AuthenticateCognitoConfig 
type AuthenticateCognitoConfig struct {
  AuthenticationRequestExtraParams *AuthenticationRequestExtraParams `json:"AuthenticationRequestExtraParams,omitempty"`
  OnUnauthenticatedRequest string `json:"OnUnauthenticatedRequest,omitempty"`
  Scope string `json:"Scope,omitempty"`
  SessionCookieName string `json:"SessionCookieName,omitempty"`
  SessionTimeout string `json:"SessionTimeout,omitempty"`
  UserPoolArn string `json:"UserPoolArn"`
  UserPoolClientId string `json:"UserPoolClientId"`
  UserPoolDomain string `json:"UserPoolDomain"`
}

// AuthenticateOidcConfig 
type AuthenticateOidcConfig struct {
  AuthenticationRequestExtraParams *AuthenticationRequestExtraParams `json:"AuthenticationRequestExtraParams,omitempty"`
  AuthorizationEndpoint string `json:"AuthorizationEndpoint"`
  ClientId string `json:"ClientId"`
  ClientSecret string `json:"ClientSecret,omitempty"`
  Issuer string `json:"Issuer"`
  OnUnauthenticatedRequest string `json:"OnUnauthenticatedRequest,omitempty"`
  Scope string `json:"Scope,omitempty"`
  SessionCookieName string `json:"SessionCookieName,omitempty"`
  SessionTimeout string `json:"SessionTimeout,omitempty"`
  TokenEndpoint string `json:"TokenEndpoint"`
  UseExistingClientSecret bool `json:"UseExistingClientSecret,omitempty"`
  UserInfoEndpoint string `json:"UserInfoEndpoint"`
}

// AuthenticationRequestExtraParams 
type AuthenticationRequestExtraParams struct {
}

// Certificate 
type Certificate struct {
  CertificateArn string `json:"CertificateArn,omitempty"`
}

// FixedResponseConfig 
type FixedResponseConfig struct {
  ContentType string `json:"ContentType,omitempty"`
  MessageBody string `json:"MessageBody,omitempty"`
  StatusCode string `json:"StatusCode"`
}

// ForwardConfig 
type ForwardConfig struct {
  TargetGroupStickinessConfig *TargetGroupStickinessConfig `json:"TargetGroupStickinessConfig,omitempty"`
  TargetGroups []*TargetGroupTuple `json:"TargetGroups,omitempty"`
}

// RedirectConfig 
type RedirectConfig struct {
  Host string `json:"Host,omitempty"`
  Path string `json:"Path,omitempty"`
  Port string `json:"Port,omitempty"`
  Protocol string `json:"Protocol,omitempty"`
  Query string `json:"Query,omitempty"`
  StatusCode string `json:"StatusCode"`
}

// Resource Resource Type definition for AWS::ElasticLoadBalancingV2::Listener
type Resource struct {
  AlpnPolicy []string `json:"AlpnPolicy,omitempty"`
  Certificates []*Certificate `json:"Certificates,omitempty"`
  DefaultActions []*Action `json:"DefaultActions"`
  ListenerArn string `json:"ListenerArn,omitempty"`
  LoadBalancerArn string `json:"LoadBalancerArn"`
  Port int `json:"Port,omitempty"`
  Protocol string `json:"Protocol,omitempty"`
  SslPolicy string `json:"SslPolicy,omitempty"`
}

// TargetGroupStickinessConfig 
type TargetGroupStickinessConfig struct {
  DurationSeconds int `json:"DurationSeconds,omitempty"`
  Enabled bool `json:"Enabled,omitempty"`
}

// TargetGroupTuple 
type TargetGroupTuple struct {
  TargetGroupArn string `json:"TargetGroupArn,omitempty"`
  Weight int `json:"Weight,omitempty"`
}

func (strct *Action) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AuthenticateCognitoConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AuthenticateCognitoConfig\": ")
	if tmp, err := json.Marshal(strct.AuthenticateCognitoConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AuthenticateOidcConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AuthenticateOidcConfig\": ")
	if tmp, err := json.Marshal(strct.AuthenticateOidcConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FixedResponseConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FixedResponseConfig\": ")
	if tmp, err := json.Marshal(strct.FixedResponseConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ForwardConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ForwardConfig\": ")
	if tmp, err := json.Marshal(strct.ForwardConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Order" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Order\": ")
	if tmp, err := json.Marshal(strct.Order); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RedirectConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RedirectConfig\": ")
	if tmp, err := json.Marshal(strct.RedirectConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TargetGroupArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TargetGroupArn\": ")
	if tmp, err := json.Marshal(strct.TargetGroupArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Action) UnmarshalJSON(b []byte) error {
    TypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AuthenticateCognitoConfig":
            if err := json.Unmarshal([]byte(v), &strct.AuthenticateCognitoConfig); err != nil {
                return err
             }
        case "AuthenticateOidcConfig":
            if err := json.Unmarshal([]byte(v), &strct.AuthenticateOidcConfig); err != nil {
                return err
             }
        case "FixedResponseConfig":
            if err := json.Unmarshal([]byte(v), &strct.FixedResponseConfig); err != nil {
                return err
             }
        case "ForwardConfig":
            if err := json.Unmarshal([]byte(v), &strct.ForwardConfig); err != nil {
                return err
             }
        case "Order":
            if err := json.Unmarshal([]byte(v), &strct.Order); err != nil {
                return err
             }
        case "RedirectConfig":
            if err := json.Unmarshal([]byte(v), &strct.RedirectConfig); err != nil {
                return err
             }
        case "TargetGroupArn":
            if err := json.Unmarshal([]byte(v), &strct.TargetGroupArn); err != nil {
                return err
             }
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            TypeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Type (a required property) was received
    if !TypeReceived {
        return errors.New("\"Type\" is required but was not present")
    }
    return nil
}

func (strct *AuthenticateCognitoConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AuthenticationRequestExtraParams" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AuthenticationRequestExtraParams\": ")
	if tmp, err := json.Marshal(strct.AuthenticationRequestExtraParams); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OnUnauthenticatedRequest" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OnUnauthenticatedRequest\": ")
	if tmp, err := json.Marshal(strct.OnUnauthenticatedRequest); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Scope" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Scope\": ")
	if tmp, err := json.Marshal(strct.Scope); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SessionCookieName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SessionCookieName\": ")
	if tmp, err := json.Marshal(strct.SessionCookieName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SessionTimeout" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SessionTimeout\": ")
	if tmp, err := json.Marshal(strct.SessionTimeout); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "UserPoolArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "UserPoolArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UserPoolArn\": ")
	if tmp, err := json.Marshal(strct.UserPoolArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "UserPoolClientId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "UserPoolClientId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UserPoolClientId\": ")
	if tmp, err := json.Marshal(strct.UserPoolClientId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "UserPoolDomain" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "UserPoolDomain" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UserPoolDomain\": ")
	if tmp, err := json.Marshal(strct.UserPoolDomain); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AuthenticateCognitoConfig) UnmarshalJSON(b []byte) error {
    UserPoolArnReceived := false
    UserPoolClientIdReceived := false
    UserPoolDomainReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AuthenticationRequestExtraParams":
            if err := json.Unmarshal([]byte(v), &strct.AuthenticationRequestExtraParams); err != nil {
                return err
             }
        case "OnUnauthenticatedRequest":
            if err := json.Unmarshal([]byte(v), &strct.OnUnauthenticatedRequest); err != nil {
                return err
             }
        case "Scope":
            if err := json.Unmarshal([]byte(v), &strct.Scope); err != nil {
                return err
             }
        case "SessionCookieName":
            if err := json.Unmarshal([]byte(v), &strct.SessionCookieName); err != nil {
                return err
             }
        case "SessionTimeout":
            if err := json.Unmarshal([]byte(v), &strct.SessionTimeout); err != nil {
                return err
             }
        case "UserPoolArn":
            if err := json.Unmarshal([]byte(v), &strct.UserPoolArn); err != nil {
                return err
             }
            UserPoolArnReceived = true
        case "UserPoolClientId":
            if err := json.Unmarshal([]byte(v), &strct.UserPoolClientId); err != nil {
                return err
             }
            UserPoolClientIdReceived = true
        case "UserPoolDomain":
            if err := json.Unmarshal([]byte(v), &strct.UserPoolDomain); err != nil {
                return err
             }
            UserPoolDomainReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if UserPoolArn (a required property) was received
    if !UserPoolArnReceived {
        return errors.New("\"UserPoolArn\" is required but was not present")
    }
    // check if UserPoolClientId (a required property) was received
    if !UserPoolClientIdReceived {
        return errors.New("\"UserPoolClientId\" is required but was not present")
    }
    // check if UserPoolDomain (a required property) was received
    if !UserPoolDomainReceived {
        return errors.New("\"UserPoolDomain\" is required but was not present")
    }
    return nil
}

func (strct *AuthenticateOidcConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AuthenticationRequestExtraParams" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AuthenticationRequestExtraParams\": ")
	if tmp, err := json.Marshal(strct.AuthenticationRequestExtraParams); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "AuthorizationEndpoint" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AuthorizationEndpoint" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AuthorizationEndpoint\": ")
	if tmp, err := json.Marshal(strct.AuthorizationEndpoint); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ClientId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ClientId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ClientId\": ")
	if tmp, err := json.Marshal(strct.ClientId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ClientSecret" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ClientSecret\": ")
	if tmp, err := json.Marshal(strct.ClientSecret); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Issuer" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Issuer" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Issuer\": ")
	if tmp, err := json.Marshal(strct.Issuer); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OnUnauthenticatedRequest" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OnUnauthenticatedRequest\": ")
	if tmp, err := json.Marshal(strct.OnUnauthenticatedRequest); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Scope" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Scope\": ")
	if tmp, err := json.Marshal(strct.Scope); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SessionCookieName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SessionCookieName\": ")
	if tmp, err := json.Marshal(strct.SessionCookieName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SessionTimeout" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SessionTimeout\": ")
	if tmp, err := json.Marshal(strct.SessionTimeout); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TokenEndpoint" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TokenEndpoint" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TokenEndpoint\": ")
	if tmp, err := json.Marshal(strct.TokenEndpoint); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "UseExistingClientSecret" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UseExistingClientSecret\": ")
	if tmp, err := json.Marshal(strct.UseExistingClientSecret); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "UserInfoEndpoint" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "UserInfoEndpoint" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UserInfoEndpoint\": ")
	if tmp, err := json.Marshal(strct.UserInfoEndpoint); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AuthenticateOidcConfig) UnmarshalJSON(b []byte) error {
    AuthorizationEndpointReceived := false
    ClientIdReceived := false
    IssuerReceived := false
    TokenEndpointReceived := false
    UserInfoEndpointReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AuthenticationRequestExtraParams":
            if err := json.Unmarshal([]byte(v), &strct.AuthenticationRequestExtraParams); err != nil {
                return err
             }
        case "AuthorizationEndpoint":
            if err := json.Unmarshal([]byte(v), &strct.AuthorizationEndpoint); err != nil {
                return err
             }
            AuthorizationEndpointReceived = true
        case "ClientId":
            if err := json.Unmarshal([]byte(v), &strct.ClientId); err != nil {
                return err
             }
            ClientIdReceived = true
        case "ClientSecret":
            if err := json.Unmarshal([]byte(v), &strct.ClientSecret); err != nil {
                return err
             }
        case "Issuer":
            if err := json.Unmarshal([]byte(v), &strct.Issuer); err != nil {
                return err
             }
            IssuerReceived = true
        case "OnUnauthenticatedRequest":
            if err := json.Unmarshal([]byte(v), &strct.OnUnauthenticatedRequest); err != nil {
                return err
             }
        case "Scope":
            if err := json.Unmarshal([]byte(v), &strct.Scope); err != nil {
                return err
             }
        case "SessionCookieName":
            if err := json.Unmarshal([]byte(v), &strct.SessionCookieName); err != nil {
                return err
             }
        case "SessionTimeout":
            if err := json.Unmarshal([]byte(v), &strct.SessionTimeout); err != nil {
                return err
             }
        case "TokenEndpoint":
            if err := json.Unmarshal([]byte(v), &strct.TokenEndpoint); err != nil {
                return err
             }
            TokenEndpointReceived = true
        case "UseExistingClientSecret":
            if err := json.Unmarshal([]byte(v), &strct.UseExistingClientSecret); err != nil {
                return err
             }
        case "UserInfoEndpoint":
            if err := json.Unmarshal([]byte(v), &strct.UserInfoEndpoint); err != nil {
                return err
             }
            UserInfoEndpointReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if AuthorizationEndpoint (a required property) was received
    if !AuthorizationEndpointReceived {
        return errors.New("\"AuthorizationEndpoint\" is required but was not present")
    }
    // check if ClientId (a required property) was received
    if !ClientIdReceived {
        return errors.New("\"ClientId\" is required but was not present")
    }
    // check if Issuer (a required property) was received
    if !IssuerReceived {
        return errors.New("\"Issuer\" is required but was not present")
    }
    // check if TokenEndpoint (a required property) was received
    if !TokenEndpointReceived {
        return errors.New("\"TokenEndpoint\" is required but was not present")
    }
    // check if UserInfoEndpoint (a required property) was received
    if !UserInfoEndpointReceived {
        return errors.New("\"UserInfoEndpoint\" is required but was not present")
    }
    return nil
}

func (strct *Certificate) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CertificateArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CertificateArn\": ")
	if tmp, err := json.Marshal(strct.CertificateArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Certificate) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CertificateArn":
            if err := json.Unmarshal([]byte(v), &strct.CertificateArn); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *FixedResponseConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ContentType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ContentType\": ")
	if tmp, err := json.Marshal(strct.ContentType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MessageBody" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MessageBody\": ")
	if tmp, err := json.Marshal(strct.MessageBody); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "StatusCode" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "StatusCode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StatusCode\": ")
	if tmp, err := json.Marshal(strct.StatusCode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FixedResponseConfig) UnmarshalJSON(b []byte) error {
    StatusCodeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ContentType":
            if err := json.Unmarshal([]byte(v), &strct.ContentType); err != nil {
                return err
             }
        case "MessageBody":
            if err := json.Unmarshal([]byte(v), &strct.MessageBody); err != nil {
                return err
             }
        case "StatusCode":
            if err := json.Unmarshal([]byte(v), &strct.StatusCode); err != nil {
                return err
             }
            StatusCodeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if StatusCode (a required property) was received
    if !StatusCodeReceived {
        return errors.New("\"StatusCode\" is required but was not present")
    }
    return nil
}

func (strct *ForwardConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "TargetGroupStickinessConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TargetGroupStickinessConfig\": ")
	if tmp, err := json.Marshal(strct.TargetGroupStickinessConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TargetGroups" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TargetGroups\": ")
	if tmp, err := json.Marshal(strct.TargetGroups); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ForwardConfig) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "TargetGroupStickinessConfig":
            if err := json.Unmarshal([]byte(v), &strct.TargetGroupStickinessConfig); err != nil {
                return err
             }
        case "TargetGroups":
            if err := json.Unmarshal([]byte(v), &strct.TargetGroups); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *RedirectConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Host" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Host\": ")
	if tmp, err := json.Marshal(strct.Host); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Path" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Path\": ")
	if tmp, err := json.Marshal(strct.Path); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Port" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Port\": ")
	if tmp, err := json.Marshal(strct.Port); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Protocol" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Protocol\": ")
	if tmp, err := json.Marshal(strct.Protocol); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Query" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Query\": ")
	if tmp, err := json.Marshal(strct.Query); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "StatusCode" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "StatusCode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StatusCode\": ")
	if tmp, err := json.Marshal(strct.StatusCode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RedirectConfig) UnmarshalJSON(b []byte) error {
    StatusCodeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Host":
            if err := json.Unmarshal([]byte(v), &strct.Host); err != nil {
                return err
             }
        case "Path":
            if err := json.Unmarshal([]byte(v), &strct.Path); err != nil {
                return err
             }
        case "Port":
            if err := json.Unmarshal([]byte(v), &strct.Port); err != nil {
                return err
             }
        case "Protocol":
            if err := json.Unmarshal([]byte(v), &strct.Protocol); err != nil {
                return err
             }
        case "Query":
            if err := json.Unmarshal([]byte(v), &strct.Query); err != nil {
                return err
             }
        case "StatusCode":
            if err := json.Unmarshal([]byte(v), &strct.StatusCode); err != nil {
                return err
             }
            StatusCodeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if StatusCode (a required property) was received
    if !StatusCodeReceived {
        return errors.New("\"StatusCode\" is required but was not present")
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AlpnPolicy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AlpnPolicy\": ")
	if tmp, err := json.Marshal(strct.AlpnPolicy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Certificates" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Certificates\": ")
	if tmp, err := json.Marshal(strct.Certificates); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "DefaultActions" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "DefaultActions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DefaultActions\": ")
	if tmp, err := json.Marshal(strct.DefaultActions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ListenerArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ListenerArn\": ")
	if tmp, err := json.Marshal(strct.ListenerArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "LoadBalancerArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "LoadBalancerArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LoadBalancerArn\": ")
	if tmp, err := json.Marshal(strct.LoadBalancerArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Port" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Port\": ")
	if tmp, err := json.Marshal(strct.Port); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Protocol" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Protocol\": ")
	if tmp, err := json.Marshal(strct.Protocol); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SslPolicy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SslPolicy\": ")
	if tmp, err := json.Marshal(strct.SslPolicy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    DefaultActionsReceived := false
    LoadBalancerArnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AlpnPolicy":
            if err := json.Unmarshal([]byte(v), &strct.AlpnPolicy); err != nil {
                return err
             }
        case "Certificates":
            if err := json.Unmarshal([]byte(v), &strct.Certificates); err != nil {
                return err
             }
        case "DefaultActions":
            if err := json.Unmarshal([]byte(v), &strct.DefaultActions); err != nil {
                return err
             }
            DefaultActionsReceived = true
        case "ListenerArn":
            if err := json.Unmarshal([]byte(v), &strct.ListenerArn); err != nil {
                return err
             }
        case "LoadBalancerArn":
            if err := json.Unmarshal([]byte(v), &strct.LoadBalancerArn); err != nil {
                return err
             }
            LoadBalancerArnReceived = true
        case "Port":
            if err := json.Unmarshal([]byte(v), &strct.Port); err != nil {
                return err
             }
        case "Protocol":
            if err := json.Unmarshal([]byte(v), &strct.Protocol); err != nil {
                return err
             }
        case "SslPolicy":
            if err := json.Unmarshal([]byte(v), &strct.SslPolicy); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if DefaultActions (a required property) was received
    if !DefaultActionsReceived {
        return errors.New("\"DefaultActions\" is required but was not present")
    }
    // check if LoadBalancerArn (a required property) was received
    if !LoadBalancerArnReceived {
        return errors.New("\"LoadBalancerArn\" is required but was not present")
    }
    return nil
}

func (strct *TargetGroupStickinessConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DurationSeconds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DurationSeconds\": ")
	if tmp, err := json.Marshal(strct.DurationSeconds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Enabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TargetGroupStickinessConfig) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DurationSeconds":
            if err := json.Unmarshal([]byte(v), &strct.DurationSeconds); err != nil {
                return err
             }
        case "Enabled":
            if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *TargetGroupTuple) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "TargetGroupArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TargetGroupArn\": ")
	if tmp, err := json.Marshal(strct.TargetGroupArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Weight" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Weight\": ")
	if tmp, err := json.Marshal(strct.Weight); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TargetGroupTuple) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "TargetGroupArn":
            if err := json.Unmarshal([]byte(v), &strct.TargetGroupArn); err != nil {
                return err
             }
        case "Weight":
            if err := json.Unmarshal([]byte(v), &strct.Weight); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}
