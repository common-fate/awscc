// Code generated by schema-generate. DO NOT EDIT.

package listenerrule

import (
    "fmt"
    "errors"
    "bytes"
    "encoding/json"
)

// Action 
type Action struct {
  AuthenticateCognitoConfig *AuthenticateCognitoConfig `json:"AuthenticateCognitoConfig,omitempty"`
  AuthenticateOidcConfig *AuthenticateOidcConfig `json:"AuthenticateOidcConfig,omitempty"`
  FixedResponseConfig *FixedResponseConfig `json:"FixedResponseConfig,omitempty"`
  ForwardConfig *ForwardConfig `json:"ForwardConfig,omitempty"`
  Order int `json:"Order,omitempty"`
  RedirectConfig *RedirectConfig `json:"RedirectConfig,omitempty"`
  TargetGroupArn string `json:"TargetGroupArn,omitempty"`
  Type string `json:"Type"`
}

// AuthenticateCognitoConfig 
type AuthenticateCognitoConfig struct {
  AuthenticationRequestExtraParams *AuthenticationRequestExtraParams `json:"AuthenticationRequestExtraParams,omitempty"`
  OnUnauthenticatedRequest string `json:"OnUnauthenticatedRequest,omitempty"`
  Scope string `json:"Scope,omitempty"`
  SessionCookieName string `json:"SessionCookieName,omitempty"`
  SessionTimeout int `json:"SessionTimeout,omitempty"`
  UserPoolArn string `json:"UserPoolArn"`
  UserPoolClientId string `json:"UserPoolClientId"`
  UserPoolDomain string `json:"UserPoolDomain"`
}

// AuthenticateOidcConfig 
type AuthenticateOidcConfig struct {
  AuthenticationRequestExtraParams *AuthenticationRequestExtraParams `json:"AuthenticationRequestExtraParams,omitempty"`
  AuthorizationEndpoint string `json:"AuthorizationEndpoint"`
  ClientId string `json:"ClientId"`
  ClientSecret string `json:"ClientSecret,omitempty"`
  Issuer string `json:"Issuer"`
  OnUnauthenticatedRequest string `json:"OnUnauthenticatedRequest,omitempty"`
  Scope string `json:"Scope,omitempty"`
  SessionCookieName string `json:"SessionCookieName,omitempty"`
  SessionTimeout int `json:"SessionTimeout,omitempty"`
  TokenEndpoint string `json:"TokenEndpoint"`
  UseExistingClientSecret bool `json:"UseExistingClientSecret,omitempty"`
  UserInfoEndpoint string `json:"UserInfoEndpoint"`
}

// AuthenticationRequestExtraParams 
type AuthenticationRequestExtraParams struct {
}

// FixedResponseConfig 
type FixedResponseConfig struct {
  ContentType string `json:"ContentType,omitempty"`
  MessageBody string `json:"MessageBody,omitempty"`
  StatusCode string `json:"StatusCode"`
}

// ForwardConfig 
type ForwardConfig struct {
  TargetGroupStickinessConfig *TargetGroupStickinessConfig `json:"TargetGroupStickinessConfig,omitempty"`
  TargetGroups []*TargetGroupTuple `json:"TargetGroups,omitempty"`
}

// HostHeaderConfig 
type HostHeaderConfig struct {
  Values []string `json:"Values,omitempty"`
}

// HttpHeaderConfig 
type HttpHeaderConfig struct {
  HttpHeaderName string `json:"HttpHeaderName,omitempty"`
  Values []string `json:"Values,omitempty"`
}

// HttpRequestMethodConfig 
type HttpRequestMethodConfig struct {
  Values []string `json:"Values,omitempty"`
}

// PathPatternConfig 
type PathPatternConfig struct {
  Values []string `json:"Values,omitempty"`
}

// QueryStringConfig 
type QueryStringConfig struct {
  Values []*QueryStringKeyValue `json:"Values,omitempty"`
}

// QueryStringKeyValue 
type QueryStringKeyValue struct {
  Key string `json:"Key,omitempty"`
  Value string `json:"Value,omitempty"`
}

// RedirectConfig 
type RedirectConfig struct {
  Host string `json:"Host,omitempty"`
  Path string `json:"Path,omitempty"`
  Port string `json:"Port,omitempty"`
  Protocol string `json:"Protocol,omitempty"`
  Query string `json:"Query,omitempty"`
  StatusCode string `json:"StatusCode"`
}

// Resource Resource Type definition for AWS::ElasticLoadBalancingV2::ListenerRule
type Resource struct {
  Actions []*Action `json:"Actions"`
  Conditions []*RuleCondition `json:"Conditions"`
  IsDefault bool `json:"IsDefault,omitempty"`
  ListenerArn string `json:"ListenerArn"`
  Priority int `json:"Priority"`
  RuleArn string `json:"RuleArn,omitempty"`
}

// RuleCondition 
type RuleCondition struct {
  Field string `json:"Field,omitempty"`
  HostHeaderConfig *HostHeaderConfig `json:"HostHeaderConfig,omitempty"`
  HttpHeaderConfig *HttpHeaderConfig `json:"HttpHeaderConfig,omitempty"`
  HttpRequestMethodConfig *HttpRequestMethodConfig `json:"HttpRequestMethodConfig,omitempty"`
  PathPatternConfig *PathPatternConfig `json:"PathPatternConfig,omitempty"`
  QueryStringConfig *QueryStringConfig `json:"QueryStringConfig,omitempty"`
  SourceIpConfig *SourceIpConfig `json:"SourceIpConfig,omitempty"`
  Values []string `json:"Values,omitempty"`
}

// SourceIpConfig 
type SourceIpConfig struct {
  Values []string `json:"Values,omitempty"`
}

// TargetGroupStickinessConfig 
type TargetGroupStickinessConfig struct {
  DurationSeconds int `json:"DurationSeconds,omitempty"`
  Enabled bool `json:"Enabled,omitempty"`
}

// TargetGroupTuple 
type TargetGroupTuple struct {
  TargetGroupArn string `json:"TargetGroupArn,omitempty"`
  Weight int `json:"Weight,omitempty"`
}

func (strct *Action) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AuthenticateCognitoConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AuthenticateCognitoConfig\": ")
	if tmp, err := json.Marshal(strct.AuthenticateCognitoConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AuthenticateOidcConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AuthenticateOidcConfig\": ")
	if tmp, err := json.Marshal(strct.AuthenticateOidcConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FixedResponseConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FixedResponseConfig\": ")
	if tmp, err := json.Marshal(strct.FixedResponseConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ForwardConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ForwardConfig\": ")
	if tmp, err := json.Marshal(strct.ForwardConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Order" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Order\": ")
	if tmp, err := json.Marshal(strct.Order); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RedirectConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RedirectConfig\": ")
	if tmp, err := json.Marshal(strct.RedirectConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TargetGroupArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TargetGroupArn\": ")
	if tmp, err := json.Marshal(strct.TargetGroupArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Action) UnmarshalJSON(b []byte) error {
    TypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AuthenticateCognitoConfig":
            if err := json.Unmarshal([]byte(v), &strct.AuthenticateCognitoConfig); err != nil {
                return err
             }
        case "AuthenticateOidcConfig":
            if err := json.Unmarshal([]byte(v), &strct.AuthenticateOidcConfig); err != nil {
                return err
             }
        case "FixedResponseConfig":
            if err := json.Unmarshal([]byte(v), &strct.FixedResponseConfig); err != nil {
                return err
             }
        case "ForwardConfig":
            if err := json.Unmarshal([]byte(v), &strct.ForwardConfig); err != nil {
                return err
             }
        case "Order":
            if err := json.Unmarshal([]byte(v), &strct.Order); err != nil {
                return err
             }
        case "RedirectConfig":
            if err := json.Unmarshal([]byte(v), &strct.RedirectConfig); err != nil {
                return err
             }
        case "TargetGroupArn":
            if err := json.Unmarshal([]byte(v), &strct.TargetGroupArn); err != nil {
                return err
             }
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            TypeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Type (a required property) was received
    if !TypeReceived {
        return errors.New("\"Type\" is required but was not present")
    }
    return nil
}

func (strct *AuthenticateCognitoConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AuthenticationRequestExtraParams" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AuthenticationRequestExtraParams\": ")
	if tmp, err := json.Marshal(strct.AuthenticationRequestExtraParams); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OnUnauthenticatedRequest" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OnUnauthenticatedRequest\": ")
	if tmp, err := json.Marshal(strct.OnUnauthenticatedRequest); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Scope" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Scope\": ")
	if tmp, err := json.Marshal(strct.Scope); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SessionCookieName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SessionCookieName\": ")
	if tmp, err := json.Marshal(strct.SessionCookieName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SessionTimeout" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SessionTimeout\": ")
	if tmp, err := json.Marshal(strct.SessionTimeout); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "UserPoolArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "UserPoolArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UserPoolArn\": ")
	if tmp, err := json.Marshal(strct.UserPoolArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "UserPoolClientId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "UserPoolClientId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UserPoolClientId\": ")
	if tmp, err := json.Marshal(strct.UserPoolClientId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "UserPoolDomain" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "UserPoolDomain" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UserPoolDomain\": ")
	if tmp, err := json.Marshal(strct.UserPoolDomain); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AuthenticateCognitoConfig) UnmarshalJSON(b []byte) error {
    UserPoolArnReceived := false
    UserPoolClientIdReceived := false
    UserPoolDomainReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AuthenticationRequestExtraParams":
            if err := json.Unmarshal([]byte(v), &strct.AuthenticationRequestExtraParams); err != nil {
                return err
             }
        case "OnUnauthenticatedRequest":
            if err := json.Unmarshal([]byte(v), &strct.OnUnauthenticatedRequest); err != nil {
                return err
             }
        case "Scope":
            if err := json.Unmarshal([]byte(v), &strct.Scope); err != nil {
                return err
             }
        case "SessionCookieName":
            if err := json.Unmarshal([]byte(v), &strct.SessionCookieName); err != nil {
                return err
             }
        case "SessionTimeout":
            if err := json.Unmarshal([]byte(v), &strct.SessionTimeout); err != nil {
                return err
             }
        case "UserPoolArn":
            if err := json.Unmarshal([]byte(v), &strct.UserPoolArn); err != nil {
                return err
             }
            UserPoolArnReceived = true
        case "UserPoolClientId":
            if err := json.Unmarshal([]byte(v), &strct.UserPoolClientId); err != nil {
                return err
             }
            UserPoolClientIdReceived = true
        case "UserPoolDomain":
            if err := json.Unmarshal([]byte(v), &strct.UserPoolDomain); err != nil {
                return err
             }
            UserPoolDomainReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if UserPoolArn (a required property) was received
    if !UserPoolArnReceived {
        return errors.New("\"UserPoolArn\" is required but was not present")
    }
    // check if UserPoolClientId (a required property) was received
    if !UserPoolClientIdReceived {
        return errors.New("\"UserPoolClientId\" is required but was not present")
    }
    // check if UserPoolDomain (a required property) was received
    if !UserPoolDomainReceived {
        return errors.New("\"UserPoolDomain\" is required but was not present")
    }
    return nil
}

func (strct *AuthenticateOidcConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AuthenticationRequestExtraParams" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AuthenticationRequestExtraParams\": ")
	if tmp, err := json.Marshal(strct.AuthenticationRequestExtraParams); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "AuthorizationEndpoint" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AuthorizationEndpoint" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AuthorizationEndpoint\": ")
	if tmp, err := json.Marshal(strct.AuthorizationEndpoint); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ClientId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ClientId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ClientId\": ")
	if tmp, err := json.Marshal(strct.ClientId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ClientSecret" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ClientSecret\": ")
	if tmp, err := json.Marshal(strct.ClientSecret); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Issuer" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Issuer" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Issuer\": ")
	if tmp, err := json.Marshal(strct.Issuer); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OnUnauthenticatedRequest" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OnUnauthenticatedRequest\": ")
	if tmp, err := json.Marshal(strct.OnUnauthenticatedRequest); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Scope" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Scope\": ")
	if tmp, err := json.Marshal(strct.Scope); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SessionCookieName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SessionCookieName\": ")
	if tmp, err := json.Marshal(strct.SessionCookieName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SessionTimeout" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SessionTimeout\": ")
	if tmp, err := json.Marshal(strct.SessionTimeout); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TokenEndpoint" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TokenEndpoint" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TokenEndpoint\": ")
	if tmp, err := json.Marshal(strct.TokenEndpoint); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "UseExistingClientSecret" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UseExistingClientSecret\": ")
	if tmp, err := json.Marshal(strct.UseExistingClientSecret); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "UserInfoEndpoint" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "UserInfoEndpoint" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UserInfoEndpoint\": ")
	if tmp, err := json.Marshal(strct.UserInfoEndpoint); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AuthenticateOidcConfig) UnmarshalJSON(b []byte) error {
    AuthorizationEndpointReceived := false
    ClientIdReceived := false
    IssuerReceived := false
    TokenEndpointReceived := false
    UserInfoEndpointReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AuthenticationRequestExtraParams":
            if err := json.Unmarshal([]byte(v), &strct.AuthenticationRequestExtraParams); err != nil {
                return err
             }
        case "AuthorizationEndpoint":
            if err := json.Unmarshal([]byte(v), &strct.AuthorizationEndpoint); err != nil {
                return err
             }
            AuthorizationEndpointReceived = true
        case "ClientId":
            if err := json.Unmarshal([]byte(v), &strct.ClientId); err != nil {
                return err
             }
            ClientIdReceived = true
        case "ClientSecret":
            if err := json.Unmarshal([]byte(v), &strct.ClientSecret); err != nil {
                return err
             }
        case "Issuer":
            if err := json.Unmarshal([]byte(v), &strct.Issuer); err != nil {
                return err
             }
            IssuerReceived = true
        case "OnUnauthenticatedRequest":
            if err := json.Unmarshal([]byte(v), &strct.OnUnauthenticatedRequest); err != nil {
                return err
             }
        case "Scope":
            if err := json.Unmarshal([]byte(v), &strct.Scope); err != nil {
                return err
             }
        case "SessionCookieName":
            if err := json.Unmarshal([]byte(v), &strct.SessionCookieName); err != nil {
                return err
             }
        case "SessionTimeout":
            if err := json.Unmarshal([]byte(v), &strct.SessionTimeout); err != nil {
                return err
             }
        case "TokenEndpoint":
            if err := json.Unmarshal([]byte(v), &strct.TokenEndpoint); err != nil {
                return err
             }
            TokenEndpointReceived = true
        case "UseExistingClientSecret":
            if err := json.Unmarshal([]byte(v), &strct.UseExistingClientSecret); err != nil {
                return err
             }
        case "UserInfoEndpoint":
            if err := json.Unmarshal([]byte(v), &strct.UserInfoEndpoint); err != nil {
                return err
             }
            UserInfoEndpointReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if AuthorizationEndpoint (a required property) was received
    if !AuthorizationEndpointReceived {
        return errors.New("\"AuthorizationEndpoint\" is required but was not present")
    }
    // check if ClientId (a required property) was received
    if !ClientIdReceived {
        return errors.New("\"ClientId\" is required but was not present")
    }
    // check if Issuer (a required property) was received
    if !IssuerReceived {
        return errors.New("\"Issuer\" is required but was not present")
    }
    // check if TokenEndpoint (a required property) was received
    if !TokenEndpointReceived {
        return errors.New("\"TokenEndpoint\" is required but was not present")
    }
    // check if UserInfoEndpoint (a required property) was received
    if !UserInfoEndpointReceived {
        return errors.New("\"UserInfoEndpoint\" is required but was not present")
    }
    return nil
}

func (strct *AuthenticationRequestExtraParams) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AuthenticationRequestExtraParams) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *FixedResponseConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ContentType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ContentType\": ")
	if tmp, err := json.Marshal(strct.ContentType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MessageBody" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MessageBody\": ")
	if tmp, err := json.Marshal(strct.MessageBody); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "StatusCode" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "StatusCode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StatusCode\": ")
	if tmp, err := json.Marshal(strct.StatusCode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FixedResponseConfig) UnmarshalJSON(b []byte) error {
    StatusCodeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ContentType":
            if err := json.Unmarshal([]byte(v), &strct.ContentType); err != nil {
                return err
             }
        case "MessageBody":
            if err := json.Unmarshal([]byte(v), &strct.MessageBody); err != nil {
                return err
             }
        case "StatusCode":
            if err := json.Unmarshal([]byte(v), &strct.StatusCode); err != nil {
                return err
             }
            StatusCodeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if StatusCode (a required property) was received
    if !StatusCodeReceived {
        return errors.New("\"StatusCode\" is required but was not present")
    }
    return nil
}

func (strct *ForwardConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "TargetGroupStickinessConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TargetGroupStickinessConfig\": ")
	if tmp, err := json.Marshal(strct.TargetGroupStickinessConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TargetGroups" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TargetGroups\": ")
	if tmp, err := json.Marshal(strct.TargetGroups); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ForwardConfig) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "TargetGroupStickinessConfig":
            if err := json.Unmarshal([]byte(v), &strct.TargetGroupStickinessConfig); err != nil {
                return err
             }
        case "TargetGroups":
            if err := json.Unmarshal([]byte(v), &strct.TargetGroups); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *HostHeaderConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Values" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Values\": ")
	if tmp, err := json.Marshal(strct.Values); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *HostHeaderConfig) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Values":
            if err := json.Unmarshal([]byte(v), &strct.Values); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *HttpHeaderConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "HttpHeaderName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HttpHeaderName\": ")
	if tmp, err := json.Marshal(strct.HttpHeaderName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Values" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Values\": ")
	if tmp, err := json.Marshal(strct.Values); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *HttpHeaderConfig) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "HttpHeaderName":
            if err := json.Unmarshal([]byte(v), &strct.HttpHeaderName); err != nil {
                return err
             }
        case "Values":
            if err := json.Unmarshal([]byte(v), &strct.Values); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *HttpRequestMethodConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Values" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Values\": ")
	if tmp, err := json.Marshal(strct.Values); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *HttpRequestMethodConfig) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Values":
            if err := json.Unmarshal([]byte(v), &strct.Values); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *PathPatternConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Values" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Values\": ")
	if tmp, err := json.Marshal(strct.Values); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PathPatternConfig) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Values":
            if err := json.Unmarshal([]byte(v), &strct.Values); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *QueryStringConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Values" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Values\": ")
	if tmp, err := json.Marshal(strct.Values); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *QueryStringConfig) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Values":
            if err := json.Unmarshal([]byte(v), &strct.Values); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *QueryStringKeyValue) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *QueryStringKeyValue) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *RedirectConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Host" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Host\": ")
	if tmp, err := json.Marshal(strct.Host); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Path" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Path\": ")
	if tmp, err := json.Marshal(strct.Path); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Port" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Port\": ")
	if tmp, err := json.Marshal(strct.Port); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Protocol" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Protocol\": ")
	if tmp, err := json.Marshal(strct.Protocol); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Query" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Query\": ")
	if tmp, err := json.Marshal(strct.Query); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "StatusCode" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "StatusCode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StatusCode\": ")
	if tmp, err := json.Marshal(strct.StatusCode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RedirectConfig) UnmarshalJSON(b []byte) error {
    StatusCodeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Host":
            if err := json.Unmarshal([]byte(v), &strct.Host); err != nil {
                return err
             }
        case "Path":
            if err := json.Unmarshal([]byte(v), &strct.Path); err != nil {
                return err
             }
        case "Port":
            if err := json.Unmarshal([]byte(v), &strct.Port); err != nil {
                return err
             }
        case "Protocol":
            if err := json.Unmarshal([]byte(v), &strct.Protocol); err != nil {
                return err
             }
        case "Query":
            if err := json.Unmarshal([]byte(v), &strct.Query); err != nil {
                return err
             }
        case "StatusCode":
            if err := json.Unmarshal([]byte(v), &strct.StatusCode); err != nil {
                return err
             }
            StatusCodeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if StatusCode (a required property) was received
    if !StatusCodeReceived {
        return errors.New("\"StatusCode\" is required but was not present")
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Actions" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Actions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Actions\": ")
	if tmp, err := json.Marshal(strct.Actions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Conditions" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Conditions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Conditions\": ")
	if tmp, err := json.Marshal(strct.Conditions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IsDefault" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IsDefault\": ")
	if tmp, err := json.Marshal(strct.IsDefault); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ListenerArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ListenerArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ListenerArn\": ")
	if tmp, err := json.Marshal(strct.ListenerArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Priority" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Priority" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Priority\": ")
	if tmp, err := json.Marshal(strct.Priority); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RuleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RuleArn\": ")
	if tmp, err := json.Marshal(strct.RuleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    ActionsReceived := false
    ConditionsReceived := false
    ListenerArnReceived := false
    PriorityReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Actions":
            if err := json.Unmarshal([]byte(v), &strct.Actions); err != nil {
                return err
             }
            ActionsReceived = true
        case "Conditions":
            if err := json.Unmarshal([]byte(v), &strct.Conditions); err != nil {
                return err
             }
            ConditionsReceived = true
        case "IsDefault":
            if err := json.Unmarshal([]byte(v), &strct.IsDefault); err != nil {
                return err
             }
        case "ListenerArn":
            if err := json.Unmarshal([]byte(v), &strct.ListenerArn); err != nil {
                return err
             }
            ListenerArnReceived = true
        case "Priority":
            if err := json.Unmarshal([]byte(v), &strct.Priority); err != nil {
                return err
             }
            PriorityReceived = true
        case "RuleArn":
            if err := json.Unmarshal([]byte(v), &strct.RuleArn); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Actions (a required property) was received
    if !ActionsReceived {
        return errors.New("\"Actions\" is required but was not present")
    }
    // check if Conditions (a required property) was received
    if !ConditionsReceived {
        return errors.New("\"Conditions\" is required but was not present")
    }
    // check if ListenerArn (a required property) was received
    if !ListenerArnReceived {
        return errors.New("\"ListenerArn\" is required but was not present")
    }
    // check if Priority (a required property) was received
    if !PriorityReceived {
        return errors.New("\"Priority\" is required but was not present")
    }
    return nil
}

func (strct *RuleCondition) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Field" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Field\": ")
	if tmp, err := json.Marshal(strct.Field); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "HostHeaderConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HostHeaderConfig\": ")
	if tmp, err := json.Marshal(strct.HostHeaderConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "HttpHeaderConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HttpHeaderConfig\": ")
	if tmp, err := json.Marshal(strct.HttpHeaderConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "HttpRequestMethodConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HttpRequestMethodConfig\": ")
	if tmp, err := json.Marshal(strct.HttpRequestMethodConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PathPatternConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PathPatternConfig\": ")
	if tmp, err := json.Marshal(strct.PathPatternConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "QueryStringConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"QueryStringConfig\": ")
	if tmp, err := json.Marshal(strct.QueryStringConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SourceIpConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SourceIpConfig\": ")
	if tmp, err := json.Marshal(strct.SourceIpConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Values" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Values\": ")
	if tmp, err := json.Marshal(strct.Values); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RuleCondition) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Field":
            if err := json.Unmarshal([]byte(v), &strct.Field); err != nil {
                return err
             }
        case "HostHeaderConfig":
            if err := json.Unmarshal([]byte(v), &strct.HostHeaderConfig); err != nil {
                return err
             }
        case "HttpHeaderConfig":
            if err := json.Unmarshal([]byte(v), &strct.HttpHeaderConfig); err != nil {
                return err
             }
        case "HttpRequestMethodConfig":
            if err := json.Unmarshal([]byte(v), &strct.HttpRequestMethodConfig); err != nil {
                return err
             }
        case "PathPatternConfig":
            if err := json.Unmarshal([]byte(v), &strct.PathPatternConfig); err != nil {
                return err
             }
        case "QueryStringConfig":
            if err := json.Unmarshal([]byte(v), &strct.QueryStringConfig); err != nil {
                return err
             }
        case "SourceIpConfig":
            if err := json.Unmarshal([]byte(v), &strct.SourceIpConfig); err != nil {
                return err
             }
        case "Values":
            if err := json.Unmarshal([]byte(v), &strct.Values); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *SourceIpConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Values" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Values\": ")
	if tmp, err := json.Marshal(strct.Values); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SourceIpConfig) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Values":
            if err := json.Unmarshal([]byte(v), &strct.Values); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *TargetGroupStickinessConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DurationSeconds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DurationSeconds\": ")
	if tmp, err := json.Marshal(strct.DurationSeconds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Enabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TargetGroupStickinessConfig) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DurationSeconds":
            if err := json.Unmarshal([]byte(v), &strct.DurationSeconds); err != nil {
                return err
             }
        case "Enabled":
            if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *TargetGroupTuple) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "TargetGroupArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TargetGroupArn\": ")
	if tmp, err := json.Marshal(strct.TargetGroupArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Weight" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Weight\": ")
	if tmp, err := json.Marshal(strct.Weight); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TargetGroupTuple) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "TargetGroupArn":
            if err := json.Unmarshal([]byte(v), &strct.TargetGroupArn); err != nil {
                return err
             }
        case "Weight":
            if err := json.Unmarshal([]byte(v), &strct.Weight); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}
