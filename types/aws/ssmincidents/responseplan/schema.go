// Code generated by schema-generate. DO NOT EDIT.

package responseplan

import (
    "errors"
    "bytes"
    "encoding/json"
    "fmt"
)

// Action The automation configuration to launch.
type Action struct {
  SsmAutomation *SsmAutomation `json:"SsmAutomation,omitempty"`
}

// ChatChannel The chat channel configuration.
type ChatChannel struct {
  ChatbotSns []string `json:"ChatbotSns,omitempty"`
}

// DynamicSsmParameter A parameter with a dynamic value to set when starting the SSM automation document.
type DynamicSsmParameter struct {
  Key string `json:"Key"`
  Value *DynamicSsmParameterValue `json:"Value"`
}

// DynamicSsmParameterValue Value of the dynamic parameter to set when starting the SSM automation document.
type DynamicSsmParameterValue struct {
  Variable string `json:"Variable,omitempty"`
}

// IncidentTemplate The incident template configuration.
type IncidentTemplate struct {

  // The deduplication string.
  DedupeString string `json:"DedupeString,omitempty"`

  // The impact value.
  Impact int `json:"Impact"`

  // Tags that get applied to incidents created by the StartIncident API action.
  IncidentTags []*Tag `json:"IncidentTags,omitempty"`

  // The list of notification targets.
  NotificationTargets []*NotificationTargetItem `json:"NotificationTargets,omitempty"`

  // The summary string.
  Summary string `json:"Summary,omitempty"`

  // The title string.
  Title string `json:"Title"`
}

// Integration 
type Integration struct {
  PagerDutyConfiguration *PagerDutyConfiguration `json:"PagerDutyConfiguration,omitempty"`
}

// NotificationTargetItem A notification target.
type NotificationTargetItem struct {
  SnsTopicArn string `json:"SnsTopicArn,omitempty"`
}

// PagerDutyConfiguration The pagerDuty configuration to use when starting the incident.
type PagerDutyConfiguration struct {

  // The name of the pagerDuty configuration.
  Name string `json:"Name"`
  PagerDutyIncidentConfiguration *PagerDutyIncidentConfiguration `json:"PagerDutyIncidentConfiguration"`

  // The AWS secrets manager secretId storing the pagerDuty token.
  SecretId string `json:"SecretId"`
}

// PagerDutyIncidentConfiguration The pagerDuty incident configuration.
type PagerDutyIncidentConfiguration struct {

  // The pagerDuty serviceId.
  ServiceId string `json:"ServiceId"`
}

// Resource Resource type definition for AWS::SSMIncidents::ResponsePlan
type Resource struct {

  // The list of actions.
  Actions []*Action `json:"Actions,omitempty"`

  // The ARN of the response plan.
  Arn string `json:"Arn,omitempty"`
  ChatChannel *ChatChannel `json:"ChatChannel,omitempty"`

  // The display name of the response plan.
  DisplayName string `json:"DisplayName,omitempty"`

  // The list of engagements to use.
  Engagements []string `json:"Engagements,omitempty"`
  IncidentTemplate *IncidentTemplate `json:"IncidentTemplate"`

  // The list of integrations.
  Integrations []*Integration `json:"Integrations,omitempty"`

  // The name of the response plan.
  Name string `json:"Name"`

  // The tags to apply to the response plan.
  Tags []*Tag `json:"Tags,omitempty"`
}

// SsmAutomation The configuration to use when starting the SSM automation document.
type SsmAutomation struct {

  // The document name to use when starting the SSM automation document.
  DocumentName string `json:"DocumentName"`

  // The version of the document to use when starting the SSM automation document.
  DocumentVersion string `json:"DocumentVersion,omitempty"`

  // The parameters with dynamic values to set when starting the SSM automation document.
  DynamicParameters []*DynamicSsmParameter `json:"DynamicParameters,omitempty"`

  // The parameters to set when starting the SSM automation document.
  Parameters []*SsmParameter `json:"Parameters,omitempty"`

  // The role ARN to use when starting the SSM automation document.
  RoleArn string `json:"RoleArn"`

  // The account type to use when starting the SSM automation document.
  TargetAccount string `json:"TargetAccount,omitempty"`
}

// SsmParameter A parameter to set when starting the SSM automation document.
type SsmParameter struct {
  Key string `json:"Key"`
  Values []string `json:"Values"`
}

// Tag A key-value pair to tag a resource.
type Tag struct {
  Key string `json:"Key"`
  Value string `json:"Value"`
}

func (strct *Action) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "SsmAutomation" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SsmAutomation\": ")
	if tmp, err := json.Marshal(strct.SsmAutomation); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Action) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "SsmAutomation":
            if err := json.Unmarshal([]byte(v), &strct.SsmAutomation); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ChatChannel) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ChatbotSns" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ChatbotSns\": ")
	if tmp, err := json.Marshal(strct.ChatbotSns); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ChatChannel) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ChatbotSns":
            if err := json.Unmarshal([]byte(v), &strct.ChatbotSns); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *DynamicSsmParameter) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    if strct.Value == nil {
        return nil, errors.New("Value is a required field")
    }
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DynamicSsmParameter) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *DynamicSsmParameterValue) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Variable" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Variable\": ")
	if tmp, err := json.Marshal(strct.Variable); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DynamicSsmParameterValue) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Variable":
            if err := json.Unmarshal([]byte(v), &strct.Variable); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *IncidentTemplate) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DedupeString" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DedupeString\": ")
	if tmp, err := json.Marshal(strct.DedupeString); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Impact" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Impact" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Impact\": ")
	if tmp, err := json.Marshal(strct.Impact); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IncidentTags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IncidentTags\": ")
	if tmp, err := json.Marshal(strct.IncidentTags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "NotificationTargets" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NotificationTargets\": ")
	if tmp, err := json.Marshal(strct.NotificationTargets); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Summary" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Summary\": ")
	if tmp, err := json.Marshal(strct.Summary); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Title" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Title" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Title\": ")
	if tmp, err := json.Marshal(strct.Title); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *IncidentTemplate) UnmarshalJSON(b []byte) error {
    ImpactReceived := false
    TitleReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DedupeString":
            if err := json.Unmarshal([]byte(v), &strct.DedupeString); err != nil {
                return err
             }
        case "Impact":
            if err := json.Unmarshal([]byte(v), &strct.Impact); err != nil {
                return err
             }
            ImpactReceived = true
        case "IncidentTags":
            if err := json.Unmarshal([]byte(v), &strct.IncidentTags); err != nil {
                return err
             }
        case "NotificationTargets":
            if err := json.Unmarshal([]byte(v), &strct.NotificationTargets); err != nil {
                return err
             }
        case "Summary":
            if err := json.Unmarshal([]byte(v), &strct.Summary); err != nil {
                return err
             }
        case "Title":
            if err := json.Unmarshal([]byte(v), &strct.Title); err != nil {
                return err
             }
            TitleReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Impact (a required property) was received
    if !ImpactReceived {
        return errors.New("\"Impact\" is required but was not present")
    }
    // check if Title (a required property) was received
    if !TitleReceived {
        return errors.New("\"Title\" is required but was not present")
    }
    return nil
}

func (strct *Integration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "PagerDutyConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PagerDutyConfiguration\": ")
	if tmp, err := json.Marshal(strct.PagerDutyConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Integration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "PagerDutyConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.PagerDutyConfiguration); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *NotificationTargetItem) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "SnsTopicArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SnsTopicArn\": ")
	if tmp, err := json.Marshal(strct.SnsTopicArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *NotificationTargetItem) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "SnsTopicArn":
            if err := json.Unmarshal([]byte(v), &strct.SnsTopicArn); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *PagerDutyConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "PagerDutyIncidentConfiguration" field is required
    if strct.PagerDutyIncidentConfiguration == nil {
        return nil, errors.New("PagerDutyIncidentConfiguration is a required field")
    }
    // Marshal the "PagerDutyIncidentConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PagerDutyIncidentConfiguration\": ")
	if tmp, err := json.Marshal(strct.PagerDutyIncidentConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "SecretId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "SecretId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SecretId\": ")
	if tmp, err := json.Marshal(strct.SecretId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PagerDutyConfiguration) UnmarshalJSON(b []byte) error {
    NameReceived := false
    PagerDutyIncidentConfigurationReceived := false
    SecretIdReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        case "PagerDutyIncidentConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.PagerDutyIncidentConfiguration); err != nil {
                return err
             }
            PagerDutyIncidentConfigurationReceived = true
        case "SecretId":
            if err := json.Unmarshal([]byte(v), &strct.SecretId); err != nil {
                return err
             }
            SecretIdReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    // check if PagerDutyIncidentConfiguration (a required property) was received
    if !PagerDutyIncidentConfigurationReceived {
        return errors.New("\"PagerDutyIncidentConfiguration\" is required but was not present")
    }
    // check if SecretId (a required property) was received
    if !SecretIdReceived {
        return errors.New("\"SecretId\" is required but was not present")
    }
    return nil
}

func (strct *PagerDutyIncidentConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ServiceId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ServiceId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ServiceId\": ")
	if tmp, err := json.Marshal(strct.ServiceId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PagerDutyIncidentConfiguration) UnmarshalJSON(b []byte) error {
    ServiceIdReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ServiceId":
            if err := json.Unmarshal([]byte(v), &strct.ServiceId); err != nil {
                return err
             }
            ServiceIdReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ServiceId (a required property) was received
    if !ServiceIdReceived {
        return errors.New("\"ServiceId\" is required but was not present")
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Actions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Actions\": ")
	if tmp, err := json.Marshal(strct.Actions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Arn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Arn\": ")
	if tmp, err := json.Marshal(strct.Arn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ChatChannel" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ChatChannel\": ")
	if tmp, err := json.Marshal(strct.ChatChannel); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DisplayName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DisplayName\": ")
	if tmp, err := json.Marshal(strct.DisplayName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Engagements" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Engagements\": ")
	if tmp, err := json.Marshal(strct.Engagements); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "IncidentTemplate" field is required
    if strct.IncidentTemplate == nil {
        return nil, errors.New("IncidentTemplate is a required field")
    }
    // Marshal the "IncidentTemplate" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IncidentTemplate\": ")
	if tmp, err := json.Marshal(strct.IncidentTemplate); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Integrations" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Integrations\": ")
	if tmp, err := json.Marshal(strct.Integrations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    IncidentTemplateReceived := false
    NameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Actions":
            if err := json.Unmarshal([]byte(v), &strct.Actions); err != nil {
                return err
             }
        case "Arn":
            if err := json.Unmarshal([]byte(v), &strct.Arn); err != nil {
                return err
             }
        case "ChatChannel":
            if err := json.Unmarshal([]byte(v), &strct.ChatChannel); err != nil {
                return err
             }
        case "DisplayName":
            if err := json.Unmarshal([]byte(v), &strct.DisplayName); err != nil {
                return err
             }
        case "Engagements":
            if err := json.Unmarshal([]byte(v), &strct.Engagements); err != nil {
                return err
             }
        case "IncidentTemplate":
            if err := json.Unmarshal([]byte(v), &strct.IncidentTemplate); err != nil {
                return err
             }
            IncidentTemplateReceived = true
        case "Integrations":
            if err := json.Unmarshal([]byte(v), &strct.Integrations); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if IncidentTemplate (a required property) was received
    if !IncidentTemplateReceived {
        return errors.New("\"IncidentTemplate\" is required but was not present")
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    return nil
}

func (strct *SsmAutomation) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "DocumentName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "DocumentName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DocumentName\": ")
	if tmp, err := json.Marshal(strct.DocumentName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DocumentVersion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DocumentVersion\": ")
	if tmp, err := json.Marshal(strct.DocumentVersion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DynamicParameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DynamicParameters\": ")
	if tmp, err := json.Marshal(strct.DynamicParameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Parameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Parameters\": ")
	if tmp, err := json.Marshal(strct.Parameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RoleArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoleArn\": ")
	if tmp, err := json.Marshal(strct.RoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TargetAccount" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TargetAccount\": ")
	if tmp, err := json.Marshal(strct.TargetAccount); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SsmAutomation) UnmarshalJSON(b []byte) error {
    DocumentNameReceived := false
    RoleArnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DocumentName":
            if err := json.Unmarshal([]byte(v), &strct.DocumentName); err != nil {
                return err
             }
            DocumentNameReceived = true
        case "DocumentVersion":
            if err := json.Unmarshal([]byte(v), &strct.DocumentVersion); err != nil {
                return err
             }
        case "DynamicParameters":
            if err := json.Unmarshal([]byte(v), &strct.DynamicParameters); err != nil {
                return err
             }
        case "Parameters":
            if err := json.Unmarshal([]byte(v), &strct.Parameters); err != nil {
                return err
             }
        case "RoleArn":
            if err := json.Unmarshal([]byte(v), &strct.RoleArn); err != nil {
                return err
             }
            RoleArnReceived = true
        case "TargetAccount":
            if err := json.Unmarshal([]byte(v), &strct.TargetAccount); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if DocumentName (a required property) was received
    if !DocumentNameReceived {
        return errors.New("\"DocumentName\" is required but was not present")
    }
    // check if RoleArn (a required property) was received
    if !RoleArnReceived {
        return errors.New("\"RoleArn\" is required but was not present")
    }
    return nil
}

func (strct *SsmParameter) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Values" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Values" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Values\": ")
	if tmp, err := json.Marshal(strct.Values); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SsmParameter) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValuesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Values":
            if err := json.Unmarshal([]byte(v), &strct.Values); err != nil {
                return err
             }
            ValuesReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Values (a required property) was received
    if !ValuesReceived {
        return errors.New("\"Values\" is required but was not present")
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}
