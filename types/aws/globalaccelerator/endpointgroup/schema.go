// Code generated by schema-generate. DO NOT EDIT.

package endpointgroup

import (
    "fmt"
    "errors"
    "bytes"
    "encoding/json"
)

// EndpointConfiguration The configuration for a given endpoint
type EndpointConfiguration struct {

  // true if client ip should be preserved
  ClientIPPreservationEnabled bool `json:"ClientIPPreservationEnabled,omitempty"`

  // Id of the endpoint. For Network/Application Load Balancer this value is the ARN.  For EIP, this value is the allocation ID.  For EC2 instances, this is the EC2 instance ID
  EndpointId string `json:"EndpointId"`

  // The weight for the endpoint.
  Weight int `json:"Weight,omitempty"`
}

// PortOverride listener to endpoint port mapping.
type PortOverride struct {
  EndpointPort int `json:"EndpointPort"`
  ListenerPort int `json:"ListenerPort"`
}

// Resource Resource Type definition for AWS::GlobalAccelerator::EndpointGroup
type Resource struct {

  // The list of endpoint objects.
  EndpointConfigurations []*EndpointConfiguration `json:"EndpointConfigurations,omitempty"`

  // The Amazon Resource Name (ARN) of the endpoint group
  EndpointGroupArn string `json:"EndpointGroupArn,omitempty"`

  // The name of the AWS Region where the endpoint group is located
  EndpointGroupRegion string `json:"EndpointGroupRegion"`

  // The time in seconds between each health check for an endpoint. Must be a value of 10 or 30
  HealthCheckIntervalSeconds int `json:"HealthCheckIntervalSeconds,omitempty"`
  HealthCheckPath string `json:"HealthCheckPath,omitempty"`

  // The port that AWS Global Accelerator uses to check the health of endpoints in this endpoint group.
  HealthCheckPort int `json:"HealthCheckPort,omitempty"`

  // The protocol that AWS Global Accelerator uses to check the health of endpoints in this endpoint group.
  HealthCheckProtocol string `json:"HealthCheckProtocol,omitempty"`

  // The Amazon Resource Name (ARN) of the listener
  ListenerArn string `json:"ListenerArn"`
  PortOverrides []*PortOverride `json:"PortOverrides,omitempty"`

  // The number of consecutive health checks required to set the state of the endpoint to unhealthy.
  ThresholdCount int `json:"ThresholdCount,omitempty"`

  // The percentage of traffic to sent to an AWS Region
  TrafficDialPercentage float64 `json:"TrafficDialPercentage,omitempty"`
}

func (strct *EndpointConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ClientIPPreservationEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ClientIPPreservationEnabled\": ")
	if tmp, err := json.Marshal(strct.ClientIPPreservationEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "EndpointId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "EndpointId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EndpointId\": ")
	if tmp, err := json.Marshal(strct.EndpointId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Weight" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Weight\": ")
	if tmp, err := json.Marshal(strct.Weight); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *EndpointConfiguration) UnmarshalJSON(b []byte) error {
    EndpointIdReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ClientIPPreservationEnabled":
            if err := json.Unmarshal([]byte(v), &strct.ClientIPPreservationEnabled); err != nil {
                return err
             }
        case "EndpointId":
            if err := json.Unmarshal([]byte(v), &strct.EndpointId); err != nil {
                return err
             }
            EndpointIdReceived = true
        case "Weight":
            if err := json.Unmarshal([]byte(v), &strct.Weight); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if EndpointId (a required property) was received
    if !EndpointIdReceived {
        return errors.New("\"EndpointId\" is required but was not present")
    }
    return nil
}

func (strct *PortOverride) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "EndpointPort" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "EndpointPort" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EndpointPort\": ")
	if tmp, err := json.Marshal(strct.EndpointPort); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ListenerPort" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ListenerPort" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ListenerPort\": ")
	if tmp, err := json.Marshal(strct.ListenerPort); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PortOverride) UnmarshalJSON(b []byte) error {
    EndpointPortReceived := false
    ListenerPortReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "EndpointPort":
            if err := json.Unmarshal([]byte(v), &strct.EndpointPort); err != nil {
                return err
             }
            EndpointPortReceived = true
        case "ListenerPort":
            if err := json.Unmarshal([]byte(v), &strct.ListenerPort); err != nil {
                return err
             }
            ListenerPortReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if EndpointPort (a required property) was received
    if !EndpointPortReceived {
        return errors.New("\"EndpointPort\" is required but was not present")
    }
    // check if ListenerPort (a required property) was received
    if !ListenerPortReceived {
        return errors.New("\"ListenerPort\" is required but was not present")
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "EndpointConfigurations" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EndpointConfigurations\": ")
	if tmp, err := json.Marshal(strct.EndpointConfigurations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EndpointGroupArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EndpointGroupArn\": ")
	if tmp, err := json.Marshal(strct.EndpointGroupArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "EndpointGroupRegion" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "EndpointGroupRegion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EndpointGroupRegion\": ")
	if tmp, err := json.Marshal(strct.EndpointGroupRegion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "HealthCheckIntervalSeconds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HealthCheckIntervalSeconds\": ")
	if tmp, err := json.Marshal(strct.HealthCheckIntervalSeconds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "HealthCheckPath" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HealthCheckPath\": ")
	if tmp, err := json.Marshal(strct.HealthCheckPath); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "HealthCheckPort" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HealthCheckPort\": ")
	if tmp, err := json.Marshal(strct.HealthCheckPort); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "HealthCheckProtocol" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HealthCheckProtocol\": ")
	if tmp, err := json.Marshal(strct.HealthCheckProtocol); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ListenerArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ListenerArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ListenerArn\": ")
	if tmp, err := json.Marshal(strct.ListenerArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PortOverrides" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PortOverrides\": ")
	if tmp, err := json.Marshal(strct.PortOverrides); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ThresholdCount" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ThresholdCount\": ")
	if tmp, err := json.Marshal(strct.ThresholdCount); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TrafficDialPercentage" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TrafficDialPercentage\": ")
	if tmp, err := json.Marshal(strct.TrafficDialPercentage); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    EndpointGroupRegionReceived := false
    ListenerArnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "EndpointConfigurations":
            if err := json.Unmarshal([]byte(v), &strct.EndpointConfigurations); err != nil {
                return err
             }
        case "EndpointGroupArn":
            if err := json.Unmarshal([]byte(v), &strct.EndpointGroupArn); err != nil {
                return err
             }
        case "EndpointGroupRegion":
            if err := json.Unmarshal([]byte(v), &strct.EndpointGroupRegion); err != nil {
                return err
             }
            EndpointGroupRegionReceived = true
        case "HealthCheckIntervalSeconds":
            if err := json.Unmarshal([]byte(v), &strct.HealthCheckIntervalSeconds); err != nil {
                return err
             }
        case "HealthCheckPath":
            if err := json.Unmarshal([]byte(v), &strct.HealthCheckPath); err != nil {
                return err
             }
        case "HealthCheckPort":
            if err := json.Unmarshal([]byte(v), &strct.HealthCheckPort); err != nil {
                return err
             }
        case "HealthCheckProtocol":
            if err := json.Unmarshal([]byte(v), &strct.HealthCheckProtocol); err != nil {
                return err
             }
        case "ListenerArn":
            if err := json.Unmarshal([]byte(v), &strct.ListenerArn); err != nil {
                return err
             }
            ListenerArnReceived = true
        case "PortOverrides":
            if err := json.Unmarshal([]byte(v), &strct.PortOverrides); err != nil {
                return err
             }
        case "ThresholdCount":
            if err := json.Unmarshal([]byte(v), &strct.ThresholdCount); err != nil {
                return err
             }
        case "TrafficDialPercentage":
            if err := json.Unmarshal([]byte(v), &strct.TrafficDialPercentage); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if EndpointGroupRegion (a required property) was received
    if !EndpointGroupRegionReceived {
        return errors.New("\"EndpointGroupRegion\" is required but was not present")
    }
    // check if ListenerArn (a required property) was received
    if !ListenerArnReceived {
        return errors.New("\"ListenerArn\" is required but was not present")
    }
    return nil
}
