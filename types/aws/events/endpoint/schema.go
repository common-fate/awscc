// Code generated by schema-generate. DO NOT EDIT.

package endpoint

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// EndpointEventBus 
type EndpointEventBus struct {
  EventBusArn string `json:"EventBusArn"`
}

// FailoverConfig 
type FailoverConfig struct {
  Primary *Primary `json:"Primary"`
  Secondary *Secondary `json:"Secondary"`
}

// Primary 
type Primary struct {
  HealthCheck string `json:"HealthCheck"`
}

// ReplicationConfig 
type ReplicationConfig struct {
  State string `json:"State"`
}

// Resource Resource Type definition for AWS::Events::Endpoint.
type Resource struct {
  Arn string `json:"Arn,omitempty"`
  Description string `json:"Description,omitempty"`
  EndpointId string `json:"EndpointId,omitempty"`
  EndpointUrl string `json:"EndpointUrl,omitempty"`
  EventBuses []*EndpointEventBus `json:"EventBuses"`
  Name string `json:"Name,omitempty"`
  ReplicationConfig *ReplicationConfig `json:"ReplicationConfig,omitempty"`
  RoleArn string `json:"RoleArn,omitempty"`
  RoutingConfig *RoutingConfig `json:"RoutingConfig"`
  State string `json:"State,omitempty"`
  StateReason string `json:"StateReason,omitempty"`
}

// RoutingConfig 
type RoutingConfig struct {
  FailoverConfig *FailoverConfig `json:"FailoverConfig"`
}

// Secondary 
type Secondary struct {
  Route string `json:"Route"`
}

func (strct *EndpointEventBus) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "EventBusArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "EventBusArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EventBusArn\": ")
	if tmp, err := json.Marshal(strct.EventBusArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *EndpointEventBus) UnmarshalJSON(b []byte) error {
    EventBusArnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "EventBusArn":
            if err := json.Unmarshal([]byte(v), &strct.EventBusArn); err != nil {
                return err
             }
            EventBusArnReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if EventBusArn (a required property) was received
    if !EventBusArnReceived {
        return errors.New("\"EventBusArn\" is required but was not present")
    }
    return nil
}

func (strct *FailoverConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Primary" field is required
    if strct.Primary == nil {
        return nil, errors.New("Primary is a required field")
    }
    // Marshal the "Primary" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Primary\": ")
	if tmp, err := json.Marshal(strct.Primary); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Secondary" field is required
    if strct.Secondary == nil {
        return nil, errors.New("Secondary is a required field")
    }
    // Marshal the "Secondary" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Secondary\": ")
	if tmp, err := json.Marshal(strct.Secondary); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FailoverConfig) UnmarshalJSON(b []byte) error {
    PrimaryReceived := false
    SecondaryReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Primary":
            if err := json.Unmarshal([]byte(v), &strct.Primary); err != nil {
                return err
             }
            PrimaryReceived = true
        case "Secondary":
            if err := json.Unmarshal([]byte(v), &strct.Secondary); err != nil {
                return err
             }
            SecondaryReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Primary (a required property) was received
    if !PrimaryReceived {
        return errors.New("\"Primary\" is required but was not present")
    }
    // check if Secondary (a required property) was received
    if !SecondaryReceived {
        return errors.New("\"Secondary\" is required but was not present")
    }
    return nil
}

func (strct *Primary) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "HealthCheck" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "HealthCheck" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HealthCheck\": ")
	if tmp, err := json.Marshal(strct.HealthCheck); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Primary) UnmarshalJSON(b []byte) error {
    HealthCheckReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "HealthCheck":
            if err := json.Unmarshal([]byte(v), &strct.HealthCheck); err != nil {
                return err
             }
            HealthCheckReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if HealthCheck (a required property) was received
    if !HealthCheckReceived {
        return errors.New("\"HealthCheck\" is required but was not present")
    }
    return nil
}

func (strct *ReplicationConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "State" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "State" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"State\": ")
	if tmp, err := json.Marshal(strct.State); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ReplicationConfig) UnmarshalJSON(b []byte) error {
    StateReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "State":
            if err := json.Unmarshal([]byte(v), &strct.State); err != nil {
                return err
             }
            StateReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if State (a required property) was received
    if !StateReceived {
        return errors.New("\"State\" is required but was not present")
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Arn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Arn\": ")
	if tmp, err := json.Marshal(strct.Arn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EndpointId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EndpointId\": ")
	if tmp, err := json.Marshal(strct.EndpointId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EndpointUrl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EndpointUrl\": ")
	if tmp, err := json.Marshal(strct.EndpointUrl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "EventBuses" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "EventBuses" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EventBuses\": ")
	if tmp, err := json.Marshal(strct.EventBuses); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ReplicationConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ReplicationConfig\": ")
	if tmp, err := json.Marshal(strct.ReplicationConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoleArn\": ")
	if tmp, err := json.Marshal(strct.RoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RoutingConfig" field is required
    if strct.RoutingConfig == nil {
        return nil, errors.New("RoutingConfig is a required field")
    }
    // Marshal the "RoutingConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoutingConfig\": ")
	if tmp, err := json.Marshal(strct.RoutingConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "State" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"State\": ")
	if tmp, err := json.Marshal(strct.State); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StateReason" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StateReason\": ")
	if tmp, err := json.Marshal(strct.StateReason); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    EventBusesReceived := false
    RoutingConfigReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Arn":
            if err := json.Unmarshal([]byte(v), &strct.Arn); err != nil {
                return err
             }
        case "Description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "EndpointId":
            if err := json.Unmarshal([]byte(v), &strct.EndpointId); err != nil {
                return err
             }
        case "EndpointUrl":
            if err := json.Unmarshal([]byte(v), &strct.EndpointUrl); err != nil {
                return err
             }
        case "EventBuses":
            if err := json.Unmarshal([]byte(v), &strct.EventBuses); err != nil {
                return err
             }
            EventBusesReceived = true
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "ReplicationConfig":
            if err := json.Unmarshal([]byte(v), &strct.ReplicationConfig); err != nil {
                return err
             }
        case "RoleArn":
            if err := json.Unmarshal([]byte(v), &strct.RoleArn); err != nil {
                return err
             }
        case "RoutingConfig":
            if err := json.Unmarshal([]byte(v), &strct.RoutingConfig); err != nil {
                return err
             }
            RoutingConfigReceived = true
        case "State":
            if err := json.Unmarshal([]byte(v), &strct.State); err != nil {
                return err
             }
        case "StateReason":
            if err := json.Unmarshal([]byte(v), &strct.StateReason); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if EventBuses (a required property) was received
    if !EventBusesReceived {
        return errors.New("\"EventBuses\" is required but was not present")
    }
    // check if RoutingConfig (a required property) was received
    if !RoutingConfigReceived {
        return errors.New("\"RoutingConfig\" is required but was not present")
    }
    return nil
}

func (strct *RoutingConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "FailoverConfig" field is required
    if strct.FailoverConfig == nil {
        return nil, errors.New("FailoverConfig is a required field")
    }
    // Marshal the "FailoverConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FailoverConfig\": ")
	if tmp, err := json.Marshal(strct.FailoverConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RoutingConfig) UnmarshalJSON(b []byte) error {
    FailoverConfigReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "FailoverConfig":
            if err := json.Unmarshal([]byte(v), &strct.FailoverConfig); err != nil {
                return err
             }
            FailoverConfigReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if FailoverConfig (a required property) was received
    if !FailoverConfigReceived {
        return errors.New("\"FailoverConfig\" is required but was not present")
    }
    return nil
}

func (strct *Secondary) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Route" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Route" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Route\": ")
	if tmp, err := json.Marshal(strct.Route); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Secondary) UnmarshalJSON(b []byte) error {
    RouteReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Route":
            if err := json.Unmarshal([]byte(v), &strct.Route); err != nil {
                return err
             }
            RouteReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Route (a required property) was received
    if !RouteReceived {
        return errors.New("\"Route\" is required but was not present")
    }
    return nil
}
