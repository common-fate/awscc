// Code generated by schema-generate. DO NOT EDIT.

package alias

import (
    "fmt"
    "errors"
    "bytes"
    "encoding/json"
)

// Resource The AWS::KMS::Alias resource specifies a display name for an AWS KMS key in AWS Key Management Service (AWS KMS). You can use an alias to identify an AWS KMS key in cryptographic operations.
type Resource struct {

  // Specifies the alias name. This value must begin with alias/ followed by a name, such as alias/ExampleAlias. The alias name cannot begin with alias/aws/. The alias/aws/ prefix is reserved for AWS managed keys.
  AliasName string `json:"AliasName"`

  // Identifies the AWS KMS key to which the alias refers. Specify the key ID or the Amazon Resource Name (ARN) of the AWS KMS key. You cannot specify another alias. For help finding the key ID and ARN, see Finding the Key ID and ARN in the AWS Key Management Service Developer Guide.
  TargetKeyId string `json:"TargetKeyId"`
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AliasName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AliasName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AliasName\": ")
	if tmp, err := json.Marshal(strct.AliasName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TargetKeyId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TargetKeyId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TargetKeyId\": ")
	if tmp, err := json.Marshal(strct.TargetKeyId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    AliasNameReceived := false
    TargetKeyIdReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AliasName":
            if err := json.Unmarshal([]byte(v), &strct.AliasName); err != nil {
                return err
             }
            AliasNameReceived = true
        case "TargetKeyId":
            if err := json.Unmarshal([]byte(v), &strct.TargetKeyId); err != nil {
                return err
             }
            TargetKeyIdReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if AliasName (a required property) was received
    if !AliasNameReceived {
        return errors.New("\"AliasName\" is required but was not present")
    }
    // check if TargetKeyId (a required property) was received
    if !TargetKeyIdReceived {
        return errors.New("\"TargetKeyId\" is required but was not present")
    }
    return nil
}
