// Code generated by schema-generate. DO NOT EDIT.

package certificate

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// ApiPassthrough Structure that specifies fields to be overridden in a certificate at the time of issuance. These requires an API Passthrough template be used or they will be ignored.
type ApiPassthrough struct {
  Extensions *Extensions `json:"Extensions,omitempty"`
  Subject *Subject `json:"Subject,omitempty"`
}

// CustomAttribute Structure that contains X.500 attribute type and value.
type CustomAttribute struct {
  ObjectIdentifier string `json:"ObjectIdentifier"`
  Value string `json:"Value"`
}

// CustomExtension Structure that contains X.509 extension information for a certificate.
type CustomExtension struct {
  Critical bool `json:"Critical,omitempty"`
  ObjectIdentifier string `json:"ObjectIdentifier"`
  Value string `json:"Value"`
}

// EdiPartyName Structure that contains X.509 EdiPartyName information.
type EdiPartyName struct {
  NameAssigner string `json:"NameAssigner"`
  PartyName string `json:"PartyName"`
}

// ExtendedKeyUsage Structure that contains X.509 ExtendedKeyUsage information.
type ExtendedKeyUsage struct {
  ExtendedKeyUsageObjectIdentifier string `json:"ExtendedKeyUsageObjectIdentifier,omitempty"`
  ExtendedKeyUsageType string `json:"ExtendedKeyUsageType,omitempty"`
}

// Extensions Structure that contains X.500 extensions for a Certificate.
type Extensions struct {
  CertificatePolicies []*PolicyInformation `json:"CertificatePolicies,omitempty"`
  CustomExtensions []*CustomExtension `json:"CustomExtensions,omitempty"`
  ExtendedKeyUsage []*ExtendedKeyUsage `json:"ExtendedKeyUsage,omitempty"`
  KeyUsage *KeyUsage `json:"KeyUsage,omitempty"`
  SubjectAlternativeNames []*GeneralName `json:"SubjectAlternativeNames,omitempty"`
}

// GeneralName Structure that contains X.509 GeneralName information. Assign one and ONLY one field.
type GeneralName struct {
  DirectoryName *Subject `json:"DirectoryName,omitempty"`
  DnsName string `json:"DnsName,omitempty"`
  EdiPartyName *EdiPartyName `json:"EdiPartyName,omitempty"`
  IpAddress string `json:"IpAddress,omitempty"`
  OtherName *OtherName `json:"OtherName,omitempty"`
  RegisteredId string `json:"RegisteredId,omitempty"`
  Rfc822Name string `json:"Rfc822Name,omitempty"`
  UniformResourceIdentifier string `json:"UniformResourceIdentifier,omitempty"`
}

// KeyUsage Structure that contains X.509 KeyUsage information.
type KeyUsage struct {
  CRLSign bool `json:"CRLSign,omitempty"`
  DataEncipherment bool `json:"DataEncipherment,omitempty"`
  DecipherOnly bool `json:"DecipherOnly,omitempty"`
  DigitalSignature bool `json:"DigitalSignature,omitempty"`
  EncipherOnly bool `json:"EncipherOnly,omitempty"`
  KeyAgreement bool `json:"KeyAgreement,omitempty"`
  KeyCertSign bool `json:"KeyCertSign,omitempty"`
  KeyEncipherment bool `json:"KeyEncipherment,omitempty"`
  NonRepudiation bool `json:"NonRepudiation,omitempty"`
}

// OtherName Structure that contains X.509 OtherName information.
type OtherName struct {
  TypeId string `json:"TypeId"`
  Value string `json:"Value"`
}

// PolicyInformation Structure that contains X.509 Policy information.
type PolicyInformation struct {
  CertPolicyId string `json:"CertPolicyId"`
  PolicyQualifiers []*PolicyQualifierInfo `json:"PolicyQualifiers,omitempty"`
}

// PolicyQualifierInfo Structure that contains X.509 Policy qualifier information.
type PolicyQualifierInfo struct {
  PolicyQualifierId string `json:"PolicyQualifierId"`
  Qualifier *Qualifier `json:"Qualifier"`
}

// Qualifier Structure that contains a X.509 policy qualifier.
type Qualifier struct {
  CpsUri string `json:"CpsUri"`
}

// Resource A certificate issued via a private certificate authority
type Resource struct {

  // These are fields to be overridden in a certificate at the time of issuance. These requires an API_Passthrough template be used or they will be ignored.
  ApiPassthrough *ApiPassthrough `json:"ApiPassthrough,omitempty"`

  // The ARN of the issued certificate.
  Arn string `json:"Arn,omitempty"`

  // The issued certificate in base 64 PEM-encoded format.
  Certificate string `json:"Certificate,omitempty"`

  // The Amazon Resource Name (ARN) for the private CA to issue the certificate.
  CertificateAuthorityArn string `json:"CertificateAuthorityArn"`

  // The certificate signing request (CSR) for the Certificate.
  CertificateSigningRequest string `json:"CertificateSigningRequest"`

  // The name of the algorithm that will be used to sign the Certificate.
  SigningAlgorithm string `json:"SigningAlgorithm"`

  // Specifies a custom configuration template to use when issuing a certificate. If this parameter is not provided, ACM Private CA defaults to the EndEntityCertificate/V1 template.
  TemplateArn string `json:"TemplateArn,omitempty"`

  // The time before which the Certificate will be valid.
  Validity *Validity `json:"Validity"`

  // The time after which the Certificate will be valid.
  ValidityNotBefore *Validity `json:"ValidityNotBefore,omitempty"`
}

// Subject Structure that contains X.500 distinguished name information.
type Subject struct {
  CommonName string `json:"CommonName,omitempty"`
  Country string `json:"Country,omitempty"`
  CustomAttributes []*CustomAttribute `json:"CustomAttributes,omitempty"`
  DistinguishedNameQualifier string `json:"DistinguishedNameQualifier,omitempty"`
  GenerationQualifier string `json:"GenerationQualifier,omitempty"`
  GivenName string `json:"GivenName,omitempty"`
  Initials string `json:"Initials,omitempty"`
  Locality string `json:"Locality,omitempty"`
  Organization string `json:"Organization,omitempty"`
  OrganizationalUnit string `json:"OrganizationalUnit,omitempty"`
  Pseudonym string `json:"Pseudonym,omitempty"`
  SerialNumber string `json:"SerialNumber,omitempty"`
  State string `json:"State,omitempty"`
  Surname string `json:"Surname,omitempty"`
  Title string `json:"Title,omitempty"`
}

// Validity Validity for a certificate.
type Validity struct {
  Type string `json:"Type"`
  Value float64 `json:"Value"`
}

func (strct *ApiPassthrough) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Extensions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Extensions\": ")
	if tmp, err := json.Marshal(strct.Extensions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Subject" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Subject\": ")
	if tmp, err := json.Marshal(strct.Subject); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ApiPassthrough) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Extensions":
            if err := json.Unmarshal([]byte(v), &strct.Extensions); err != nil {
                return err
             }
        case "Subject":
            if err := json.Unmarshal([]byte(v), &strct.Subject); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *CustomAttribute) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ObjectIdentifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ObjectIdentifier" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ObjectIdentifier\": ")
	if tmp, err := json.Marshal(strct.ObjectIdentifier); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CustomAttribute) UnmarshalJSON(b []byte) error {
    ObjectIdentifierReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ObjectIdentifier":
            if err := json.Unmarshal([]byte(v), &strct.ObjectIdentifier); err != nil {
                return err
             }
            ObjectIdentifierReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ObjectIdentifier (a required property) was received
    if !ObjectIdentifierReceived {
        return errors.New("\"ObjectIdentifier\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *CustomExtension) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Critical" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Critical\": ")
	if tmp, err := json.Marshal(strct.Critical); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ObjectIdentifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ObjectIdentifier" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ObjectIdentifier\": ")
	if tmp, err := json.Marshal(strct.ObjectIdentifier); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CustomExtension) UnmarshalJSON(b []byte) error {
    ObjectIdentifierReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Critical":
            if err := json.Unmarshal([]byte(v), &strct.Critical); err != nil {
                return err
             }
        case "ObjectIdentifier":
            if err := json.Unmarshal([]byte(v), &strct.ObjectIdentifier); err != nil {
                return err
             }
            ObjectIdentifierReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ObjectIdentifier (a required property) was received
    if !ObjectIdentifierReceived {
        return errors.New("\"ObjectIdentifier\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *EdiPartyName) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "NameAssigner" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "NameAssigner" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NameAssigner\": ")
	if tmp, err := json.Marshal(strct.NameAssigner); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "PartyName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "PartyName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PartyName\": ")
	if tmp, err := json.Marshal(strct.PartyName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *EdiPartyName) UnmarshalJSON(b []byte) error {
    NameAssignerReceived := false
    PartyNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "NameAssigner":
            if err := json.Unmarshal([]byte(v), &strct.NameAssigner); err != nil {
                return err
             }
            NameAssignerReceived = true
        case "PartyName":
            if err := json.Unmarshal([]byte(v), &strct.PartyName); err != nil {
                return err
             }
            PartyNameReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if NameAssigner (a required property) was received
    if !NameAssignerReceived {
        return errors.New("\"NameAssigner\" is required but was not present")
    }
    // check if PartyName (a required property) was received
    if !PartyNameReceived {
        return errors.New("\"PartyName\" is required but was not present")
    }
    return nil
}

func (strct *ExtendedKeyUsage) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ExtendedKeyUsageObjectIdentifier" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ExtendedKeyUsageObjectIdentifier\": ")
	if tmp, err := json.Marshal(strct.ExtendedKeyUsageObjectIdentifier); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ExtendedKeyUsageType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ExtendedKeyUsageType\": ")
	if tmp, err := json.Marshal(strct.ExtendedKeyUsageType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ExtendedKeyUsage) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ExtendedKeyUsageObjectIdentifier":
            if err := json.Unmarshal([]byte(v), &strct.ExtendedKeyUsageObjectIdentifier); err != nil {
                return err
             }
        case "ExtendedKeyUsageType":
            if err := json.Unmarshal([]byte(v), &strct.ExtendedKeyUsageType); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Extensions) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CertificatePolicies" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CertificatePolicies\": ")
	if tmp, err := json.Marshal(strct.CertificatePolicies); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CustomExtensions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CustomExtensions\": ")
	if tmp, err := json.Marshal(strct.CustomExtensions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ExtendedKeyUsage" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ExtendedKeyUsage\": ")
	if tmp, err := json.Marshal(strct.ExtendedKeyUsage); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "KeyUsage" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KeyUsage\": ")
	if tmp, err := json.Marshal(strct.KeyUsage); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SubjectAlternativeNames" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SubjectAlternativeNames\": ")
	if tmp, err := json.Marshal(strct.SubjectAlternativeNames); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Extensions) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CertificatePolicies":
            if err := json.Unmarshal([]byte(v), &strct.CertificatePolicies); err != nil {
                return err
             }
        case "CustomExtensions":
            if err := json.Unmarshal([]byte(v), &strct.CustomExtensions); err != nil {
                return err
             }
        case "ExtendedKeyUsage":
            if err := json.Unmarshal([]byte(v), &strct.ExtendedKeyUsage); err != nil {
                return err
             }
        case "KeyUsage":
            if err := json.Unmarshal([]byte(v), &strct.KeyUsage); err != nil {
                return err
             }
        case "SubjectAlternativeNames":
            if err := json.Unmarshal([]byte(v), &strct.SubjectAlternativeNames); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *GeneralName) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DirectoryName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DirectoryName\": ")
	if tmp, err := json.Marshal(strct.DirectoryName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DnsName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DnsName\": ")
	if tmp, err := json.Marshal(strct.DnsName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EdiPartyName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EdiPartyName\": ")
	if tmp, err := json.Marshal(strct.EdiPartyName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IpAddress" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IpAddress\": ")
	if tmp, err := json.Marshal(strct.IpAddress); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OtherName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OtherName\": ")
	if tmp, err := json.Marshal(strct.OtherName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RegisteredId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RegisteredId\": ")
	if tmp, err := json.Marshal(strct.RegisteredId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Rfc822Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Rfc822Name\": ")
	if tmp, err := json.Marshal(strct.Rfc822Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "UniformResourceIdentifier" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UniformResourceIdentifier\": ")
	if tmp, err := json.Marshal(strct.UniformResourceIdentifier); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *GeneralName) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DirectoryName":
            if err := json.Unmarshal([]byte(v), &strct.DirectoryName); err != nil {
                return err
             }
        case "DnsName":
            if err := json.Unmarshal([]byte(v), &strct.DnsName); err != nil {
                return err
             }
        case "EdiPartyName":
            if err := json.Unmarshal([]byte(v), &strct.EdiPartyName); err != nil {
                return err
             }
        case "IpAddress":
            if err := json.Unmarshal([]byte(v), &strct.IpAddress); err != nil {
                return err
             }
        case "OtherName":
            if err := json.Unmarshal([]byte(v), &strct.OtherName); err != nil {
                return err
             }
        case "RegisteredId":
            if err := json.Unmarshal([]byte(v), &strct.RegisteredId); err != nil {
                return err
             }
        case "Rfc822Name":
            if err := json.Unmarshal([]byte(v), &strct.Rfc822Name); err != nil {
                return err
             }
        case "UniformResourceIdentifier":
            if err := json.Unmarshal([]byte(v), &strct.UniformResourceIdentifier); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *KeyUsage) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CRLSign" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CRLSign\": ")
	if tmp, err := json.Marshal(strct.CRLSign); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DataEncipherment" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DataEncipherment\": ")
	if tmp, err := json.Marshal(strct.DataEncipherment); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DecipherOnly" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DecipherOnly\": ")
	if tmp, err := json.Marshal(strct.DecipherOnly); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DigitalSignature" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DigitalSignature\": ")
	if tmp, err := json.Marshal(strct.DigitalSignature); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EncipherOnly" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EncipherOnly\": ")
	if tmp, err := json.Marshal(strct.EncipherOnly); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "KeyAgreement" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KeyAgreement\": ")
	if tmp, err := json.Marshal(strct.KeyAgreement); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "KeyCertSign" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KeyCertSign\": ")
	if tmp, err := json.Marshal(strct.KeyCertSign); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "KeyEncipherment" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KeyEncipherment\": ")
	if tmp, err := json.Marshal(strct.KeyEncipherment); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "NonRepudiation" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NonRepudiation\": ")
	if tmp, err := json.Marshal(strct.NonRepudiation); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *KeyUsage) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CRLSign":
            if err := json.Unmarshal([]byte(v), &strct.CRLSign); err != nil {
                return err
             }
        case "DataEncipherment":
            if err := json.Unmarshal([]byte(v), &strct.DataEncipherment); err != nil {
                return err
             }
        case "DecipherOnly":
            if err := json.Unmarshal([]byte(v), &strct.DecipherOnly); err != nil {
                return err
             }
        case "DigitalSignature":
            if err := json.Unmarshal([]byte(v), &strct.DigitalSignature); err != nil {
                return err
             }
        case "EncipherOnly":
            if err := json.Unmarshal([]byte(v), &strct.EncipherOnly); err != nil {
                return err
             }
        case "KeyAgreement":
            if err := json.Unmarshal([]byte(v), &strct.KeyAgreement); err != nil {
                return err
             }
        case "KeyCertSign":
            if err := json.Unmarshal([]byte(v), &strct.KeyCertSign); err != nil {
                return err
             }
        case "KeyEncipherment":
            if err := json.Unmarshal([]byte(v), &strct.KeyEncipherment); err != nil {
                return err
             }
        case "NonRepudiation":
            if err := json.Unmarshal([]byte(v), &strct.NonRepudiation); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *OtherName) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "TypeId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TypeId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TypeId\": ")
	if tmp, err := json.Marshal(strct.TypeId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *OtherName) UnmarshalJSON(b []byte) error {
    TypeIdReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "TypeId":
            if err := json.Unmarshal([]byte(v), &strct.TypeId); err != nil {
                return err
             }
            TypeIdReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if TypeId (a required property) was received
    if !TypeIdReceived {
        return errors.New("\"TypeId\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *PolicyInformation) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "CertPolicyId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "CertPolicyId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CertPolicyId\": ")
	if tmp, err := json.Marshal(strct.CertPolicyId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PolicyQualifiers" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PolicyQualifiers\": ")
	if tmp, err := json.Marshal(strct.PolicyQualifiers); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PolicyInformation) UnmarshalJSON(b []byte) error {
    CertPolicyIdReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CertPolicyId":
            if err := json.Unmarshal([]byte(v), &strct.CertPolicyId); err != nil {
                return err
             }
            CertPolicyIdReceived = true
        case "PolicyQualifiers":
            if err := json.Unmarshal([]byte(v), &strct.PolicyQualifiers); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if CertPolicyId (a required property) was received
    if !CertPolicyIdReceived {
        return errors.New("\"CertPolicyId\" is required but was not present")
    }
    return nil
}

func (strct *PolicyQualifierInfo) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "PolicyQualifierId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "PolicyQualifierId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PolicyQualifierId\": ")
	if tmp, err := json.Marshal(strct.PolicyQualifierId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Qualifier" field is required
    if strct.Qualifier == nil {
        return nil, errors.New("Qualifier is a required field")
    }
    // Marshal the "Qualifier" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Qualifier\": ")
	if tmp, err := json.Marshal(strct.Qualifier); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PolicyQualifierInfo) UnmarshalJSON(b []byte) error {
    PolicyQualifierIdReceived := false
    QualifierReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "PolicyQualifierId":
            if err := json.Unmarshal([]byte(v), &strct.PolicyQualifierId); err != nil {
                return err
             }
            PolicyQualifierIdReceived = true
        case "Qualifier":
            if err := json.Unmarshal([]byte(v), &strct.Qualifier); err != nil {
                return err
             }
            QualifierReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if PolicyQualifierId (a required property) was received
    if !PolicyQualifierIdReceived {
        return errors.New("\"PolicyQualifierId\" is required but was not present")
    }
    // check if Qualifier (a required property) was received
    if !QualifierReceived {
        return errors.New("\"Qualifier\" is required but was not present")
    }
    return nil
}

func (strct *Qualifier) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "CpsUri" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "CpsUri" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CpsUri\": ")
	if tmp, err := json.Marshal(strct.CpsUri); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Qualifier) UnmarshalJSON(b []byte) error {
    CpsUriReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CpsUri":
            if err := json.Unmarshal([]byte(v), &strct.CpsUri); err != nil {
                return err
             }
            CpsUriReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if CpsUri (a required property) was received
    if !CpsUriReceived {
        return errors.New("\"CpsUri\" is required but was not present")
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ApiPassthrough" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ApiPassthrough\": ")
	if tmp, err := json.Marshal(strct.ApiPassthrough); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Arn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Arn\": ")
	if tmp, err := json.Marshal(strct.Arn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Certificate" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Certificate\": ")
	if tmp, err := json.Marshal(strct.Certificate); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "CertificateAuthorityArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "CertificateAuthorityArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CertificateAuthorityArn\": ")
	if tmp, err := json.Marshal(strct.CertificateAuthorityArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "CertificateSigningRequest" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "CertificateSigningRequest" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CertificateSigningRequest\": ")
	if tmp, err := json.Marshal(strct.CertificateSigningRequest); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "SigningAlgorithm" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "SigningAlgorithm" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SigningAlgorithm\": ")
	if tmp, err := json.Marshal(strct.SigningAlgorithm); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TemplateArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TemplateArn\": ")
	if tmp, err := json.Marshal(strct.TemplateArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Validity" field is required
    if strct.Validity == nil {
        return nil, errors.New("Validity is a required field")
    }
    // Marshal the "Validity" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Validity\": ")
	if tmp, err := json.Marshal(strct.Validity); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ValidityNotBefore" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ValidityNotBefore\": ")
	if tmp, err := json.Marshal(strct.ValidityNotBefore); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    CertificateAuthorityArnReceived := false
    CertificateSigningRequestReceived := false
    SigningAlgorithmReceived := false
    ValidityReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ApiPassthrough":
            if err := json.Unmarshal([]byte(v), &strct.ApiPassthrough); err != nil {
                return err
             }
        case "Arn":
            if err := json.Unmarshal([]byte(v), &strct.Arn); err != nil {
                return err
             }
        case "Certificate":
            if err := json.Unmarshal([]byte(v), &strct.Certificate); err != nil {
                return err
             }
        case "CertificateAuthorityArn":
            if err := json.Unmarshal([]byte(v), &strct.CertificateAuthorityArn); err != nil {
                return err
             }
            CertificateAuthorityArnReceived = true
        case "CertificateSigningRequest":
            if err := json.Unmarshal([]byte(v), &strct.CertificateSigningRequest); err != nil {
                return err
             }
            CertificateSigningRequestReceived = true
        case "SigningAlgorithm":
            if err := json.Unmarshal([]byte(v), &strct.SigningAlgorithm); err != nil {
                return err
             }
            SigningAlgorithmReceived = true
        case "TemplateArn":
            if err := json.Unmarshal([]byte(v), &strct.TemplateArn); err != nil {
                return err
             }
        case "Validity":
            if err := json.Unmarshal([]byte(v), &strct.Validity); err != nil {
                return err
             }
            ValidityReceived = true
        case "ValidityNotBefore":
            if err := json.Unmarshal([]byte(v), &strct.ValidityNotBefore); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if CertificateAuthorityArn (a required property) was received
    if !CertificateAuthorityArnReceived {
        return errors.New("\"CertificateAuthorityArn\" is required but was not present")
    }
    // check if CertificateSigningRequest (a required property) was received
    if !CertificateSigningRequestReceived {
        return errors.New("\"CertificateSigningRequest\" is required but was not present")
    }
    // check if SigningAlgorithm (a required property) was received
    if !SigningAlgorithmReceived {
        return errors.New("\"SigningAlgorithm\" is required but was not present")
    }
    // check if Validity (a required property) was received
    if !ValidityReceived {
        return errors.New("\"Validity\" is required but was not present")
    }
    return nil
}

func (strct *Subject) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CommonName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CommonName\": ")
	if tmp, err := json.Marshal(strct.CommonName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Country" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Country\": ")
	if tmp, err := json.Marshal(strct.Country); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CustomAttributes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CustomAttributes\": ")
	if tmp, err := json.Marshal(strct.CustomAttributes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DistinguishedNameQualifier" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DistinguishedNameQualifier\": ")
	if tmp, err := json.Marshal(strct.DistinguishedNameQualifier); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "GenerationQualifier" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"GenerationQualifier\": ")
	if tmp, err := json.Marshal(strct.GenerationQualifier); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "GivenName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"GivenName\": ")
	if tmp, err := json.Marshal(strct.GivenName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Initials" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Initials\": ")
	if tmp, err := json.Marshal(strct.Initials); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Locality" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Locality\": ")
	if tmp, err := json.Marshal(strct.Locality); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Organization" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Organization\": ")
	if tmp, err := json.Marshal(strct.Organization); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OrganizationalUnit" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OrganizationalUnit\": ")
	if tmp, err := json.Marshal(strct.OrganizationalUnit); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Pseudonym" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Pseudonym\": ")
	if tmp, err := json.Marshal(strct.Pseudonym); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SerialNumber" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SerialNumber\": ")
	if tmp, err := json.Marshal(strct.SerialNumber); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "State" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"State\": ")
	if tmp, err := json.Marshal(strct.State); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Surname" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Surname\": ")
	if tmp, err := json.Marshal(strct.Surname); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Title" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Title\": ")
	if tmp, err := json.Marshal(strct.Title); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Subject) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CommonName":
            if err := json.Unmarshal([]byte(v), &strct.CommonName); err != nil {
                return err
             }
        case "Country":
            if err := json.Unmarshal([]byte(v), &strct.Country); err != nil {
                return err
             }
        case "CustomAttributes":
            if err := json.Unmarshal([]byte(v), &strct.CustomAttributes); err != nil {
                return err
             }
        case "DistinguishedNameQualifier":
            if err := json.Unmarshal([]byte(v), &strct.DistinguishedNameQualifier); err != nil {
                return err
             }
        case "GenerationQualifier":
            if err := json.Unmarshal([]byte(v), &strct.GenerationQualifier); err != nil {
                return err
             }
        case "GivenName":
            if err := json.Unmarshal([]byte(v), &strct.GivenName); err != nil {
                return err
             }
        case "Initials":
            if err := json.Unmarshal([]byte(v), &strct.Initials); err != nil {
                return err
             }
        case "Locality":
            if err := json.Unmarshal([]byte(v), &strct.Locality); err != nil {
                return err
             }
        case "Organization":
            if err := json.Unmarshal([]byte(v), &strct.Organization); err != nil {
                return err
             }
        case "OrganizationalUnit":
            if err := json.Unmarshal([]byte(v), &strct.OrganizationalUnit); err != nil {
                return err
             }
        case "Pseudonym":
            if err := json.Unmarshal([]byte(v), &strct.Pseudonym); err != nil {
                return err
             }
        case "SerialNumber":
            if err := json.Unmarshal([]byte(v), &strct.SerialNumber); err != nil {
                return err
             }
        case "State":
            if err := json.Unmarshal([]byte(v), &strct.State); err != nil {
                return err
             }
        case "Surname":
            if err := json.Unmarshal([]byte(v), &strct.Surname); err != nil {
                return err
             }
        case "Title":
            if err := json.Unmarshal([]byte(v), &strct.Title); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Validity) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Validity) UnmarshalJSON(b []byte) error {
    TypeReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            TypeReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Type (a required property) was received
    if !TypeReceived {
        return errors.New("\"Type\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}
