// Code generated by schema-generate. DO NOT EDIT.

package certificateauthority

import (
    "bytes"
    "errors"
    "encoding/json"
    "fmt"
)

// AccessDescription Structure that contains X.509 AccessDescription information.
type AccessDescription struct {
  AccessLocation *GeneralName `json:"AccessLocation"`
  AccessMethod *AccessMethod `json:"AccessMethod"`
}

// AccessMethod Structure that contains X.509 AccessMethod information. Assign one and ONLY one field.
type AccessMethod struct {
  AccessMethodType string `json:"AccessMethodType,omitempty"`
  CustomObjectIdentifier string `json:"CustomObjectIdentifier,omitempty"`
}

// CrlConfiguration Your certificate authority can create and maintain a certificate revocation list (CRL). A CRL contains information about certificates that have been revoked.
type CrlConfiguration struct {
  CustomCname string `json:"CustomCname,omitempty"`
  Enabled bool `json:"Enabled,omitempty"`
  ExpirationInDays int `json:"ExpirationInDays,omitempty"`
  S3BucketName string `json:"S3BucketName,omitempty"`
  S3ObjectAcl string `json:"S3ObjectAcl,omitempty"`
}

// CsrExtensions Structure that contains CSR pass though extensions information.
type CsrExtensions struct {
  KeyUsage *KeyUsage `json:"KeyUsage,omitempty"`
  SubjectInformationAccess []*AccessDescription `json:"SubjectInformationAccess,omitempty"`
}

// CustomAttribute Structure that contains X.500 attribute type and value.
type CustomAttribute struct {
  ObjectIdentifier string `json:"ObjectIdentifier"`
  Value string `json:"Value"`
}

// EdiPartyName Structure that contains X.509 EdiPartyName information.
type EdiPartyName struct {
  NameAssigner string `json:"NameAssigner"`
  PartyName string `json:"PartyName"`
}

// GeneralName Structure that contains X.509 GeneralName information. Assign one and ONLY one field.
type GeneralName struct {
  DirectoryName *Subject `json:"DirectoryName,omitempty"`
  DnsName string `json:"DnsName,omitempty"`
  EdiPartyName *EdiPartyName `json:"EdiPartyName,omitempty"`
  IpAddress string `json:"IpAddress,omitempty"`
  OtherName *OtherName `json:"OtherName,omitempty"`
  RegisteredId string `json:"RegisteredId,omitempty"`
  Rfc822Name string `json:"Rfc822Name,omitempty"`
  UniformResourceIdentifier string `json:"UniformResourceIdentifier,omitempty"`
}

// KeyUsage Structure that contains X.509 KeyUsage information.
type KeyUsage struct {
  CRLSign bool `json:"CRLSign,omitempty"`
  DataEncipherment bool `json:"DataEncipherment,omitempty"`
  DecipherOnly bool `json:"DecipherOnly,omitempty"`
  DigitalSignature bool `json:"DigitalSignature,omitempty"`
  EncipherOnly bool `json:"EncipherOnly,omitempty"`
  KeyAgreement bool `json:"KeyAgreement,omitempty"`
  KeyCertSign bool `json:"KeyCertSign,omitempty"`
  KeyEncipherment bool `json:"KeyEncipherment,omitempty"`
  NonRepudiation bool `json:"NonRepudiation,omitempty"`
}

// OcspConfiguration Helps to configure online certificate status protocol (OCSP) responder for your certificate authority
type OcspConfiguration struct {
  Enabled bool `json:"Enabled,omitempty"`
  OcspCustomCname string `json:"OcspCustomCname,omitempty"`
}

// OtherName Structure that contains X.509 OtherName information.
type OtherName struct {
  TypeId string `json:"TypeId"`
  Value string `json:"Value"`
}

// Resource Private certificate authority.
type Resource struct {

  // The Amazon Resource Name (ARN) of the certificate authority.
  Arn string `json:"Arn,omitempty"`

  // The base64 PEM-encoded certificate signing request (CSR) for your certificate authority certificate.
  CertificateSigningRequest string `json:"CertificateSigningRequest,omitempty"`

  // Structure that contains CSR pass through extension information used by the CreateCertificateAuthority action.
  CsrExtensions *CsrExtensions `json:"CsrExtensions,omitempty"`

  // Public key algorithm and size, in bits, of the key pair that your CA creates when it issues a certificate.
  KeyAlgorithm string `json:"KeyAlgorithm"`

  // KeyStorageSecurityStadard defines a cryptographic key management compliance standard used for handling CA keys.
  KeyStorageSecurityStandard string `json:"KeyStorageSecurityStandard,omitempty"`

  // Certificate revocation information used by the CreateCertificateAuthority and UpdateCertificateAuthority actions.
  RevocationConfiguration *RevocationConfiguration `json:"RevocationConfiguration,omitempty"`

  // Algorithm your CA uses to sign certificate requests.
  SigningAlgorithm string `json:"SigningAlgorithm"`

  // Structure that contains X.500 distinguished name information for your CA.
  Subject *Subject `json:"Subject"`
  Tags []*Tag `json:"Tags,omitempty"`

  // The type of the certificate authority.
  Type string `json:"Type"`

  // Usage mode of the ceritificate authority.
  UsageMode string `json:"UsageMode,omitempty"`
}

// RevocationConfiguration Certificate Authority revocation information.
type RevocationConfiguration struct {
  CrlConfiguration *CrlConfiguration `json:"CrlConfiguration,omitempty"`
  OcspConfiguration *OcspConfiguration `json:"OcspConfiguration,omitempty"`
}

// Subject Structure that contains X.500 distinguished name information for your CA.
type Subject struct {
  CommonName string `json:"CommonName,omitempty"`
  Country string `json:"Country,omitempty"`
  CustomAttributes []*CustomAttribute `json:"CustomAttributes,omitempty"`
  DistinguishedNameQualifier string `json:"DistinguishedNameQualifier,omitempty"`
  GenerationQualifier string `json:"GenerationQualifier,omitempty"`
  GivenName string `json:"GivenName,omitempty"`
  Initials string `json:"Initials,omitempty"`
  Locality string `json:"Locality,omitempty"`
  Organization string `json:"Organization,omitempty"`
  OrganizationalUnit string `json:"OrganizationalUnit,omitempty"`
  Pseudonym string `json:"Pseudonym,omitempty"`
  SerialNumber string `json:"SerialNumber,omitempty"`
  State string `json:"State,omitempty"`
  Surname string `json:"Surname,omitempty"`
  Title string `json:"Title,omitempty"`
}

// Tag 
type Tag struct {
  Key string `json:"Key,omitempty"`
  Value string `json:"Value,omitempty"`
}

func (strct *AccessDescription) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AccessLocation" field is required
    if strct.AccessLocation == nil {
        return nil, errors.New("AccessLocation is a required field")
    }
    // Marshal the "AccessLocation" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AccessLocation\": ")
	if tmp, err := json.Marshal(strct.AccessLocation); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "AccessMethod" field is required
    if strct.AccessMethod == nil {
        return nil, errors.New("AccessMethod is a required field")
    }
    // Marshal the "AccessMethod" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AccessMethod\": ")
	if tmp, err := json.Marshal(strct.AccessMethod); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AccessDescription) UnmarshalJSON(b []byte) error {
    AccessLocationReceived := false
    AccessMethodReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AccessLocation":
            if err := json.Unmarshal([]byte(v), &strct.AccessLocation); err != nil {
                return err
             }
            AccessLocationReceived = true
        case "AccessMethod":
            if err := json.Unmarshal([]byte(v), &strct.AccessMethod); err != nil {
                return err
             }
            AccessMethodReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if AccessLocation (a required property) was received
    if !AccessLocationReceived {
        return errors.New("\"AccessLocation\" is required but was not present")
    }
    // check if AccessMethod (a required property) was received
    if !AccessMethodReceived {
        return errors.New("\"AccessMethod\" is required but was not present")
    }
    return nil
}

func (strct *AccessMethod) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AccessMethodType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AccessMethodType\": ")
	if tmp, err := json.Marshal(strct.AccessMethodType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CustomObjectIdentifier" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CustomObjectIdentifier\": ")
	if tmp, err := json.Marshal(strct.CustomObjectIdentifier); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AccessMethod) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AccessMethodType":
            if err := json.Unmarshal([]byte(v), &strct.AccessMethodType); err != nil {
                return err
             }
        case "CustomObjectIdentifier":
            if err := json.Unmarshal([]byte(v), &strct.CustomObjectIdentifier); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *CrlConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CustomCname" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CustomCname\": ")
	if tmp, err := json.Marshal(strct.CustomCname); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Enabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ExpirationInDays" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ExpirationInDays\": ")
	if tmp, err := json.Marshal(strct.ExpirationInDays); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "S3BucketName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3BucketName\": ")
	if tmp, err := json.Marshal(strct.S3BucketName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "S3ObjectAcl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3ObjectAcl\": ")
	if tmp, err := json.Marshal(strct.S3ObjectAcl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CrlConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CustomCname":
            if err := json.Unmarshal([]byte(v), &strct.CustomCname); err != nil {
                return err
             }
        case "Enabled":
            if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
                return err
             }
        case "ExpirationInDays":
            if err := json.Unmarshal([]byte(v), &strct.ExpirationInDays); err != nil {
                return err
             }
        case "S3BucketName":
            if err := json.Unmarshal([]byte(v), &strct.S3BucketName); err != nil {
                return err
             }
        case "S3ObjectAcl":
            if err := json.Unmarshal([]byte(v), &strct.S3ObjectAcl); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *CsrExtensions) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "KeyUsage" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KeyUsage\": ")
	if tmp, err := json.Marshal(strct.KeyUsage); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SubjectInformationAccess" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SubjectInformationAccess\": ")
	if tmp, err := json.Marshal(strct.SubjectInformationAccess); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CsrExtensions) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "KeyUsage":
            if err := json.Unmarshal([]byte(v), &strct.KeyUsage); err != nil {
                return err
             }
        case "SubjectInformationAccess":
            if err := json.Unmarshal([]byte(v), &strct.SubjectInformationAccess); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *CustomAttribute) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ObjectIdentifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ObjectIdentifier" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ObjectIdentifier\": ")
	if tmp, err := json.Marshal(strct.ObjectIdentifier); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CustomAttribute) UnmarshalJSON(b []byte) error {
    ObjectIdentifierReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ObjectIdentifier":
            if err := json.Unmarshal([]byte(v), &strct.ObjectIdentifier); err != nil {
                return err
             }
            ObjectIdentifierReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ObjectIdentifier (a required property) was received
    if !ObjectIdentifierReceived {
        return errors.New("\"ObjectIdentifier\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *EdiPartyName) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "NameAssigner" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "NameAssigner" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NameAssigner\": ")
	if tmp, err := json.Marshal(strct.NameAssigner); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "PartyName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "PartyName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PartyName\": ")
	if tmp, err := json.Marshal(strct.PartyName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *EdiPartyName) UnmarshalJSON(b []byte) error {
    NameAssignerReceived := false
    PartyNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "NameAssigner":
            if err := json.Unmarshal([]byte(v), &strct.NameAssigner); err != nil {
                return err
             }
            NameAssignerReceived = true
        case "PartyName":
            if err := json.Unmarshal([]byte(v), &strct.PartyName); err != nil {
                return err
             }
            PartyNameReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if NameAssigner (a required property) was received
    if !NameAssignerReceived {
        return errors.New("\"NameAssigner\" is required but was not present")
    }
    // check if PartyName (a required property) was received
    if !PartyNameReceived {
        return errors.New("\"PartyName\" is required but was not present")
    }
    return nil
}

func (strct *GeneralName) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DirectoryName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DirectoryName\": ")
	if tmp, err := json.Marshal(strct.DirectoryName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DnsName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DnsName\": ")
	if tmp, err := json.Marshal(strct.DnsName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EdiPartyName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EdiPartyName\": ")
	if tmp, err := json.Marshal(strct.EdiPartyName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IpAddress" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IpAddress\": ")
	if tmp, err := json.Marshal(strct.IpAddress); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OtherName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OtherName\": ")
	if tmp, err := json.Marshal(strct.OtherName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RegisteredId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RegisteredId\": ")
	if tmp, err := json.Marshal(strct.RegisteredId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Rfc822Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Rfc822Name\": ")
	if tmp, err := json.Marshal(strct.Rfc822Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "UniformResourceIdentifier" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UniformResourceIdentifier\": ")
	if tmp, err := json.Marshal(strct.UniformResourceIdentifier); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *GeneralName) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DirectoryName":
            if err := json.Unmarshal([]byte(v), &strct.DirectoryName); err != nil {
                return err
             }
        case "DnsName":
            if err := json.Unmarshal([]byte(v), &strct.DnsName); err != nil {
                return err
             }
        case "EdiPartyName":
            if err := json.Unmarshal([]byte(v), &strct.EdiPartyName); err != nil {
                return err
             }
        case "IpAddress":
            if err := json.Unmarshal([]byte(v), &strct.IpAddress); err != nil {
                return err
             }
        case "OtherName":
            if err := json.Unmarshal([]byte(v), &strct.OtherName); err != nil {
                return err
             }
        case "RegisteredId":
            if err := json.Unmarshal([]byte(v), &strct.RegisteredId); err != nil {
                return err
             }
        case "Rfc822Name":
            if err := json.Unmarshal([]byte(v), &strct.Rfc822Name); err != nil {
                return err
             }
        case "UniformResourceIdentifier":
            if err := json.Unmarshal([]byte(v), &strct.UniformResourceIdentifier); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *KeyUsage) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CRLSign" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CRLSign\": ")
	if tmp, err := json.Marshal(strct.CRLSign); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DataEncipherment" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DataEncipherment\": ")
	if tmp, err := json.Marshal(strct.DataEncipherment); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DecipherOnly" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DecipherOnly\": ")
	if tmp, err := json.Marshal(strct.DecipherOnly); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DigitalSignature" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DigitalSignature\": ")
	if tmp, err := json.Marshal(strct.DigitalSignature); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EncipherOnly" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EncipherOnly\": ")
	if tmp, err := json.Marshal(strct.EncipherOnly); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "KeyAgreement" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KeyAgreement\": ")
	if tmp, err := json.Marshal(strct.KeyAgreement); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "KeyCertSign" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KeyCertSign\": ")
	if tmp, err := json.Marshal(strct.KeyCertSign); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "KeyEncipherment" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KeyEncipherment\": ")
	if tmp, err := json.Marshal(strct.KeyEncipherment); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "NonRepudiation" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NonRepudiation\": ")
	if tmp, err := json.Marshal(strct.NonRepudiation); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *KeyUsage) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CRLSign":
            if err := json.Unmarshal([]byte(v), &strct.CRLSign); err != nil {
                return err
             }
        case "DataEncipherment":
            if err := json.Unmarshal([]byte(v), &strct.DataEncipherment); err != nil {
                return err
             }
        case "DecipherOnly":
            if err := json.Unmarshal([]byte(v), &strct.DecipherOnly); err != nil {
                return err
             }
        case "DigitalSignature":
            if err := json.Unmarshal([]byte(v), &strct.DigitalSignature); err != nil {
                return err
             }
        case "EncipherOnly":
            if err := json.Unmarshal([]byte(v), &strct.EncipherOnly); err != nil {
                return err
             }
        case "KeyAgreement":
            if err := json.Unmarshal([]byte(v), &strct.KeyAgreement); err != nil {
                return err
             }
        case "KeyCertSign":
            if err := json.Unmarshal([]byte(v), &strct.KeyCertSign); err != nil {
                return err
             }
        case "KeyEncipherment":
            if err := json.Unmarshal([]byte(v), &strct.KeyEncipherment); err != nil {
                return err
             }
        case "NonRepudiation":
            if err := json.Unmarshal([]byte(v), &strct.NonRepudiation); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *OcspConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Enabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OcspCustomCname" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OcspCustomCname\": ")
	if tmp, err := json.Marshal(strct.OcspCustomCname); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *OcspConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Enabled":
            if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
                return err
             }
        case "OcspCustomCname":
            if err := json.Unmarshal([]byte(v), &strct.OcspCustomCname); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *OtherName) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "TypeId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TypeId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TypeId\": ")
	if tmp, err := json.Marshal(strct.TypeId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *OtherName) UnmarshalJSON(b []byte) error {
    TypeIdReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "TypeId":
            if err := json.Unmarshal([]byte(v), &strct.TypeId); err != nil {
                return err
             }
            TypeIdReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if TypeId (a required property) was received
    if !TypeIdReceived {
        return errors.New("\"TypeId\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Arn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Arn\": ")
	if tmp, err := json.Marshal(strct.Arn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CertificateSigningRequest" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CertificateSigningRequest\": ")
	if tmp, err := json.Marshal(strct.CertificateSigningRequest); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CsrExtensions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CsrExtensions\": ")
	if tmp, err := json.Marshal(strct.CsrExtensions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "KeyAlgorithm" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "KeyAlgorithm" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KeyAlgorithm\": ")
	if tmp, err := json.Marshal(strct.KeyAlgorithm); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "KeyStorageSecurityStandard" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KeyStorageSecurityStandard\": ")
	if tmp, err := json.Marshal(strct.KeyStorageSecurityStandard); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RevocationConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RevocationConfiguration\": ")
	if tmp, err := json.Marshal(strct.RevocationConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "SigningAlgorithm" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "SigningAlgorithm" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SigningAlgorithm\": ")
	if tmp, err := json.Marshal(strct.SigningAlgorithm); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Subject" field is required
    if strct.Subject == nil {
        return nil, errors.New("Subject is a required field")
    }
    // Marshal the "Subject" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Subject\": ")
	if tmp, err := json.Marshal(strct.Subject); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "UsageMode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UsageMode\": ")
	if tmp, err := json.Marshal(strct.UsageMode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    KeyAlgorithmReceived := false
    SigningAlgorithmReceived := false
    SubjectReceived := false
    TypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Arn":
            if err := json.Unmarshal([]byte(v), &strct.Arn); err != nil {
                return err
             }
        case "CertificateSigningRequest":
            if err := json.Unmarshal([]byte(v), &strct.CertificateSigningRequest); err != nil {
                return err
             }
        case "CsrExtensions":
            if err := json.Unmarshal([]byte(v), &strct.CsrExtensions); err != nil {
                return err
             }
        case "KeyAlgorithm":
            if err := json.Unmarshal([]byte(v), &strct.KeyAlgorithm); err != nil {
                return err
             }
            KeyAlgorithmReceived = true
        case "KeyStorageSecurityStandard":
            if err := json.Unmarshal([]byte(v), &strct.KeyStorageSecurityStandard); err != nil {
                return err
             }
        case "RevocationConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.RevocationConfiguration); err != nil {
                return err
             }
        case "SigningAlgorithm":
            if err := json.Unmarshal([]byte(v), &strct.SigningAlgorithm); err != nil {
                return err
             }
            SigningAlgorithmReceived = true
        case "Subject":
            if err := json.Unmarshal([]byte(v), &strct.Subject); err != nil {
                return err
             }
            SubjectReceived = true
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            TypeReceived = true
        case "UsageMode":
            if err := json.Unmarshal([]byte(v), &strct.UsageMode); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if KeyAlgorithm (a required property) was received
    if !KeyAlgorithmReceived {
        return errors.New("\"KeyAlgorithm\" is required but was not present")
    }
    // check if SigningAlgorithm (a required property) was received
    if !SigningAlgorithmReceived {
        return errors.New("\"SigningAlgorithm\" is required but was not present")
    }
    // check if Subject (a required property) was received
    if !SubjectReceived {
        return errors.New("\"Subject\" is required but was not present")
    }
    // check if Type (a required property) was received
    if !TypeReceived {
        return errors.New("\"Type\" is required but was not present")
    }
    return nil
}

func (strct *RevocationConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CrlConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CrlConfiguration\": ")
	if tmp, err := json.Marshal(strct.CrlConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OcspConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OcspConfiguration\": ")
	if tmp, err := json.Marshal(strct.OcspConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RevocationConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CrlConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.CrlConfiguration); err != nil {
                return err
             }
        case "OcspConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.OcspConfiguration); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Subject) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CommonName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CommonName\": ")
	if tmp, err := json.Marshal(strct.CommonName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Country" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Country\": ")
	if tmp, err := json.Marshal(strct.Country); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CustomAttributes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CustomAttributes\": ")
	if tmp, err := json.Marshal(strct.CustomAttributes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DistinguishedNameQualifier" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DistinguishedNameQualifier\": ")
	if tmp, err := json.Marshal(strct.DistinguishedNameQualifier); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "GenerationQualifier" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"GenerationQualifier\": ")
	if tmp, err := json.Marshal(strct.GenerationQualifier); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "GivenName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"GivenName\": ")
	if tmp, err := json.Marshal(strct.GivenName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Initials" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Initials\": ")
	if tmp, err := json.Marshal(strct.Initials); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Locality" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Locality\": ")
	if tmp, err := json.Marshal(strct.Locality); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Organization" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Organization\": ")
	if tmp, err := json.Marshal(strct.Organization); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OrganizationalUnit" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OrganizationalUnit\": ")
	if tmp, err := json.Marshal(strct.OrganizationalUnit); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Pseudonym" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Pseudonym\": ")
	if tmp, err := json.Marshal(strct.Pseudonym); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SerialNumber" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SerialNumber\": ")
	if tmp, err := json.Marshal(strct.SerialNumber); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "State" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"State\": ")
	if tmp, err := json.Marshal(strct.State); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Surname" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Surname\": ")
	if tmp, err := json.Marshal(strct.Surname); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Title" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Title\": ")
	if tmp, err := json.Marshal(strct.Title); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Subject) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CommonName":
            if err := json.Unmarshal([]byte(v), &strct.CommonName); err != nil {
                return err
             }
        case "Country":
            if err := json.Unmarshal([]byte(v), &strct.Country); err != nil {
                return err
             }
        case "CustomAttributes":
            if err := json.Unmarshal([]byte(v), &strct.CustomAttributes); err != nil {
                return err
             }
        case "DistinguishedNameQualifier":
            if err := json.Unmarshal([]byte(v), &strct.DistinguishedNameQualifier); err != nil {
                return err
             }
        case "GenerationQualifier":
            if err := json.Unmarshal([]byte(v), &strct.GenerationQualifier); err != nil {
                return err
             }
        case "GivenName":
            if err := json.Unmarshal([]byte(v), &strct.GivenName); err != nil {
                return err
             }
        case "Initials":
            if err := json.Unmarshal([]byte(v), &strct.Initials); err != nil {
                return err
             }
        case "Locality":
            if err := json.Unmarshal([]byte(v), &strct.Locality); err != nil {
                return err
             }
        case "Organization":
            if err := json.Unmarshal([]byte(v), &strct.Organization); err != nil {
                return err
             }
        case "OrganizationalUnit":
            if err := json.Unmarshal([]byte(v), &strct.OrganizationalUnit); err != nil {
                return err
             }
        case "Pseudonym":
            if err := json.Unmarshal([]byte(v), &strct.Pseudonym); err != nil {
                return err
             }
        case "SerialNumber":
            if err := json.Unmarshal([]byte(v), &strct.SerialNumber); err != nil {
                return err
             }
        case "State":
            if err := json.Unmarshal([]byte(v), &strct.State); err != nil {
                return err
             }
        case "Surname":
            if err := json.Unmarshal([]byte(v), &strct.Surname); err != nil {
                return err
             }
        case "Title":
            if err := json.Unmarshal([]byte(v), &strct.Title); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}
