// Code generated by schema-generate. DO NOT EDIT.

package application

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// AutoStartConfiguration Configuration for Auto Start of Application
type AutoStartConfiguration struct {

  // If set to true, the Application will automatically start. Defaults to true.
  Enabled bool `json:"Enabled,omitempty"`
}

// AutoStopConfiguration Configuration for Auto Stop of Application
type AutoStopConfiguration struct {

  // If set to true, the Application will automatically stop after being idle. Defaults to true.
  Enabled bool `json:"Enabled,omitempty"`

  // The amount of time [in minutes] to wait before auto stopping the Application when idle. Defaults to 15 minutes.
  IdleTimeoutMinutes int `json:"IdleTimeoutMinutes,omitempty"`
}

// ImageConfigurationInput The image configuration.
type ImageConfigurationInput struct {

  // The URI of an image in the Amazon ECR registry. This field is required when you create a new application. If you leave this field blank in an update, Amazon EMR will remove the image configuration.
  ImageUri string `json:"ImageUri,omitempty"`
}

// InitialCapacityConfig 
type InitialCapacityConfig struct {
  WorkerConfiguration *WorkerConfiguration `json:"WorkerConfiguration"`

  // Initial count of workers to be initialized when an Application is started. This count will be continued to be maintained until the Application is stopped
  WorkerCount int `json:"WorkerCount"`
}

// InitialCapacityConfigKeyValuePair 
type InitialCapacityConfigKeyValuePair struct {

  // Worker type for an analytics framework.
  Key string `json:"Key"`
  Value *InitialCapacityConfig `json:"Value"`
}

// MaximumAllowedResources 
type MaximumAllowedResources struct {

  // Per worker CPU resource. vCPU is the only supported unit and specifying vCPU is optional.
  Cpu string `json:"Cpu"`

  // Per worker Disk resource. GB is the only supported unit and specifying GB is optional
  Disk string `json:"Disk,omitempty"`

  // Per worker memory resource. GB is the only supported unit and specifying GB is optional.
  Memory string `json:"Memory"`
}

// NetworkConfiguration 
type NetworkConfiguration struct {

  // The ID of the security groups in the VPC to which you want to connect your job or application.
  SecurityGroupIds []string `json:"SecurityGroupIds,omitempty"`

  // The ID of the subnets in the VPC to which you want to connect your job or application.
  SubnetIds []string `json:"SubnetIds,omitempty"`
}

// Resource Resource schema for AWS::EMRServerless::Application Type
type Resource struct {

  // The ID of the EMR Serverless Application.
  ApplicationId string `json:"ApplicationId,omitempty"`
  Architecture string `json:"Architecture,omitempty"`

  // The Amazon Resource Name (ARN) of the EMR Serverless Application.
  Arn string `json:"Arn,omitempty"`

  // Configuration for Auto Start of Application.
  AutoStartConfiguration *AutoStartConfiguration `json:"AutoStartConfiguration,omitempty"`

  // Configuration for Auto Stop of Application.
  AutoStopConfiguration *AutoStopConfiguration `json:"AutoStopConfiguration,omitempty"`
  ImageConfiguration *ImageConfigurationInput `json:"ImageConfiguration,omitempty"`

  // Initial capacity initialized when an Application is started.
  InitialCapacity []*InitialCapacityConfigKeyValuePair `json:"InitialCapacity,omitempty"`

  // Maximum allowed cumulative resources for an Application. No new resources will be created once the limit is hit.
  MaximumCapacity *MaximumAllowedResources `json:"MaximumCapacity,omitempty"`

  // User friendly Application name.
  Name string `json:"Name,omitempty"`

  // Network Configuration for customer VPC connectivity.
  NetworkConfiguration *NetworkConfiguration `json:"NetworkConfiguration,omitempty"`

  // EMR release label.
  ReleaseLabel string `json:"ReleaseLabel"`

  // Tag map with key and value
  Tags []*Tag `json:"Tags,omitempty"`

  // The type of the application
  Type string `json:"Type"`
  WorkerTypeSpecifications *WorkerTypeSpecificationInputMap `json:"WorkerTypeSpecifications,omitempty"`
}

// Tag A key-value pair to associate with a resource.
type Tag struct {

  // The value for the tag. You can specify a value that is 1 to 128 Unicode characters in length. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
  Key string `json:"Key"`

  // The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
  Value string `json:"Value"`
}

// WorkerConfiguration 
type WorkerConfiguration struct {

  // Per worker CPU resource. vCPU is the only supported unit and specifying vCPU is optional.
  Cpu string `json:"Cpu"`

  // Per worker Disk resource. GB is the only supported unit and specifying GB is optional
  Disk string `json:"Disk,omitempty"`

  // Per worker memory resource. GB is the only supported unit and specifying GB is optional.
  Memory string `json:"Memory"`
}

// WorkerTypeSpecificationInput The specifications for a worker type.
type WorkerTypeSpecificationInput struct {
  ImageConfiguration *ImageConfigurationInput `json:"ImageConfiguration,omitempty"`
}

// WorkerTypeSpecificationInputMap 
type WorkerTypeSpecificationInputMap struct {
}

func (strct *AutoStartConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Enabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AutoStartConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Enabled":
            if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *AutoStopConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Enabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IdleTimeoutMinutes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IdleTimeoutMinutes\": ")
	if tmp, err := json.Marshal(strct.IdleTimeoutMinutes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AutoStopConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Enabled":
            if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
                return err
             }
        case "IdleTimeoutMinutes":
            if err := json.Unmarshal([]byte(v), &strct.IdleTimeoutMinutes); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ImageConfigurationInput) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ImageUri" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ImageUri\": ")
	if tmp, err := json.Marshal(strct.ImageUri); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ImageConfigurationInput) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ImageUri":
            if err := json.Unmarshal([]byte(v), &strct.ImageUri); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *InitialCapacityConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "WorkerConfiguration" field is required
    if strct.WorkerConfiguration == nil {
        return nil, errors.New("WorkerConfiguration is a required field")
    }
    // Marshal the "WorkerConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"WorkerConfiguration\": ")
	if tmp, err := json.Marshal(strct.WorkerConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "WorkerCount" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "WorkerCount" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"WorkerCount\": ")
	if tmp, err := json.Marshal(strct.WorkerCount); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *InitialCapacityConfig) UnmarshalJSON(b []byte) error {
    WorkerConfigurationReceived := false
    WorkerCountReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "WorkerConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.WorkerConfiguration); err != nil {
                return err
             }
            WorkerConfigurationReceived = true
        case "WorkerCount":
            if err := json.Unmarshal([]byte(v), &strct.WorkerCount); err != nil {
                return err
             }
            WorkerCountReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if WorkerConfiguration (a required property) was received
    if !WorkerConfigurationReceived {
        return errors.New("\"WorkerConfiguration\" is required but was not present")
    }
    // check if WorkerCount (a required property) was received
    if !WorkerCountReceived {
        return errors.New("\"WorkerCount\" is required but was not present")
    }
    return nil
}

func (strct *InitialCapacityConfigKeyValuePair) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    if strct.Value == nil {
        return nil, errors.New("Value is a required field")
    }
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *InitialCapacityConfigKeyValuePair) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *MaximumAllowedResources) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Cpu" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Cpu" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Cpu\": ")
	if tmp, err := json.Marshal(strct.Cpu); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Disk" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Disk\": ")
	if tmp, err := json.Marshal(strct.Disk); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Memory" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Memory" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Memory\": ")
	if tmp, err := json.Marshal(strct.Memory); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MaximumAllowedResources) UnmarshalJSON(b []byte) error {
    CpuReceived := false
    MemoryReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Cpu":
            if err := json.Unmarshal([]byte(v), &strct.Cpu); err != nil {
                return err
             }
            CpuReceived = true
        case "Disk":
            if err := json.Unmarshal([]byte(v), &strct.Disk); err != nil {
                return err
             }
        case "Memory":
            if err := json.Unmarshal([]byte(v), &strct.Memory); err != nil {
                return err
             }
            MemoryReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Cpu (a required property) was received
    if !CpuReceived {
        return errors.New("\"Cpu\" is required but was not present")
    }
    // check if Memory (a required property) was received
    if !MemoryReceived {
        return errors.New("\"Memory\" is required but was not present")
    }
    return nil
}

func (strct *NetworkConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "SecurityGroupIds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SecurityGroupIds\": ")
	if tmp, err := json.Marshal(strct.SecurityGroupIds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SubnetIds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SubnetIds\": ")
	if tmp, err := json.Marshal(strct.SubnetIds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *NetworkConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "SecurityGroupIds":
            if err := json.Unmarshal([]byte(v), &strct.SecurityGroupIds); err != nil {
                return err
             }
        case "SubnetIds":
            if err := json.Unmarshal([]byte(v), &strct.SubnetIds); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ApplicationId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ApplicationId\": ")
	if tmp, err := json.Marshal(strct.ApplicationId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Architecture" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Architecture\": ")
	if tmp, err := json.Marshal(strct.Architecture); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Arn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Arn\": ")
	if tmp, err := json.Marshal(strct.Arn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AutoStartConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AutoStartConfiguration\": ")
	if tmp, err := json.Marshal(strct.AutoStartConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AutoStopConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AutoStopConfiguration\": ")
	if tmp, err := json.Marshal(strct.AutoStopConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ImageConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ImageConfiguration\": ")
	if tmp, err := json.Marshal(strct.ImageConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "InitialCapacity" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InitialCapacity\": ")
	if tmp, err := json.Marshal(strct.InitialCapacity); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MaximumCapacity" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaximumCapacity\": ")
	if tmp, err := json.Marshal(strct.MaximumCapacity); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "NetworkConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NetworkConfiguration\": ")
	if tmp, err := json.Marshal(strct.NetworkConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ReleaseLabel" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ReleaseLabel" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ReleaseLabel\": ")
	if tmp, err := json.Marshal(strct.ReleaseLabel); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "WorkerTypeSpecifications" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"WorkerTypeSpecifications\": ")
	if tmp, err := json.Marshal(strct.WorkerTypeSpecifications); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    ReleaseLabelReceived := false
    TypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ApplicationId":
            if err := json.Unmarshal([]byte(v), &strct.ApplicationId); err != nil {
                return err
             }
        case "Architecture":
            if err := json.Unmarshal([]byte(v), &strct.Architecture); err != nil {
                return err
             }
        case "Arn":
            if err := json.Unmarshal([]byte(v), &strct.Arn); err != nil {
                return err
             }
        case "AutoStartConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.AutoStartConfiguration); err != nil {
                return err
             }
        case "AutoStopConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.AutoStopConfiguration); err != nil {
                return err
             }
        case "ImageConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.ImageConfiguration); err != nil {
                return err
             }
        case "InitialCapacity":
            if err := json.Unmarshal([]byte(v), &strct.InitialCapacity); err != nil {
                return err
             }
        case "MaximumCapacity":
            if err := json.Unmarshal([]byte(v), &strct.MaximumCapacity); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "NetworkConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.NetworkConfiguration); err != nil {
                return err
             }
        case "ReleaseLabel":
            if err := json.Unmarshal([]byte(v), &strct.ReleaseLabel); err != nil {
                return err
             }
            ReleaseLabelReceived = true
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            TypeReceived = true
        case "WorkerTypeSpecifications":
            if err := json.Unmarshal([]byte(v), &strct.WorkerTypeSpecifications); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ReleaseLabel (a required property) was received
    if !ReleaseLabelReceived {
        return errors.New("\"ReleaseLabel\" is required but was not present")
    }
    // check if Type (a required property) was received
    if !TypeReceived {
        return errors.New("\"Type\" is required but was not present")
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *WorkerConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Cpu" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Cpu" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Cpu\": ")
	if tmp, err := json.Marshal(strct.Cpu); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Disk" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Disk\": ")
	if tmp, err := json.Marshal(strct.Disk); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Memory" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Memory" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Memory\": ")
	if tmp, err := json.Marshal(strct.Memory); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *WorkerConfiguration) UnmarshalJSON(b []byte) error {
    CpuReceived := false
    MemoryReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Cpu":
            if err := json.Unmarshal([]byte(v), &strct.Cpu); err != nil {
                return err
             }
            CpuReceived = true
        case "Disk":
            if err := json.Unmarshal([]byte(v), &strct.Disk); err != nil {
                return err
             }
        case "Memory":
            if err := json.Unmarshal([]byte(v), &strct.Memory); err != nil {
                return err
             }
            MemoryReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Cpu (a required property) was received
    if !CpuReceived {
        return errors.New("\"Cpu\" is required but was not present")
    }
    // check if Memory (a required property) was received
    if !MemoryReceived {
        return errors.New("\"Memory\" is required but was not present")
    }
    return nil
}

func (strct *WorkerTypeSpecificationInput) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ImageConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ImageConfiguration\": ")
	if tmp, err := json.Marshal(strct.ImageConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *WorkerTypeSpecificationInput) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ImageConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.ImageConfiguration); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *WorkerTypeSpecificationInputMap) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *WorkerTypeSpecificationInputMap) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}
