// Code generated by schema-generate. DO NOT EDIT.

package botalias

import (
    "encoding/json"
    "fmt"
    "bytes"
    "errors"
)

// AudioLogDestination The location of audio log files collected when conversation logging is enabled for a bot.
type AudioLogDestination struct {
  S3Bucket *S3BucketLogDestination `json:"S3Bucket"`
}

// AudioLogSetting Settings for logging audio of conversations between Amazon Lex and a user. You specify whether to log audio and the Amazon S3 bucket where the audio file is stored.
type AudioLogSetting struct {
  Destination *AudioLogDestination `json:"Destination"`
  Enabled bool `json:"Enabled"`
}

// BotAliasLocaleSettings You can use this parameter to specify a specific Lambda function to run different functions in different locales.
type BotAliasLocaleSettings struct {
  CodeHookSpecification *CodeHookSpecification `json:"CodeHookSpecification,omitempty"`

  // Whether the Lambda code hook is enabled
  Enabled bool `json:"Enabled"`
}

// BotAliasLocaleSettingsItem A locale setting in alias
type BotAliasLocaleSettingsItem struct {
  BotAliasLocaleSetting *BotAliasLocaleSettings `json:"BotAliasLocaleSetting"`

  // A string used to identify the locale
  LocaleId string `json:"LocaleId"`
}

// CloudWatchLogGroupLogDestination 
type CloudWatchLogGroupLogDestination struct {

  // A string used to identify the groupArn for the Cloudwatch Log Group
  CloudWatchLogGroupArn string `json:"CloudWatchLogGroupArn"`

  // A string containing the value for the Log Prefix
  LogPrefix string `json:"LogPrefix"`
}

// CodeHookSpecification Contains information about code hooks that Amazon Lex calls during a conversation.
type CodeHookSpecification struct {
  LambdaCodeHook *LambdaCodeHook `json:"LambdaCodeHook"`
}

// ConversationLogSettings Contains information about code hooks that Amazon Lex calls during a conversation.
type ConversationLogSettings struct {
  AudioLogSettings []*AudioLogSetting `json:"AudioLogSettings,omitempty"`
  TextLogSettings []*TextLogSetting `json:"TextLogSettings,omitempty"`
}

// LambdaCodeHook Contains information about code hooks that Amazon Lex calls during a conversation.
type LambdaCodeHook struct {

  // The version of the request-response that you want Amazon Lex to use to invoke your Lambda function.
  CodeHookInterfaceVersion string `json:"CodeHookInterfaceVersion"`

  // The Amazon Resource Name (ARN) of the Lambda function.
  LambdaArn string `json:"LambdaArn"`
}

// Resource A Bot Alias enables you to change the version of a bot without updating applications that use the bot
type Resource struct {
  Arn string `json:"Arn,omitempty"`
  BotAliasId string `json:"BotAliasId,omitempty"`
  BotAliasLocaleSettings []*BotAliasLocaleSettingsItem `json:"BotAliasLocaleSettings,omitempty"`
  BotAliasName string `json:"BotAliasName"`
  BotAliasStatus string `json:"BotAliasStatus,omitempty"`

  // A list of tags to add to the bot alias.
  BotAliasTags []*Tag `json:"BotAliasTags,omitempty"`
  BotId string `json:"BotId"`
  BotVersion string `json:"BotVersion,omitempty"`
  ConversationLogSettings *ConversationLogSettings `json:"ConversationLogSettings,omitempty"`
  Description string `json:"Description,omitempty"`

  // Determines whether Amazon Lex will use Amazon Comprehend to detect the sentiment of user utterances.
  SentimentAnalysisSettings *SentimentAnalysisSettings `json:"SentimentAnalysisSettings,omitempty"`
}

// S3BucketLogDestination Specifies an Amazon S3 bucket for logging audio conversations
type S3BucketLogDestination struct {

  // The Amazon Resource Name (ARN) of an AWS Key Management Service (KMS) key for encrypting audio log files stored in an S3 bucket.
  KmsKeyArn string `json:"KmsKeyArn,omitempty"`

  // The Amazon S3 key of the deployment package.
  LogPrefix string `json:"LogPrefix"`

  // The Amazon Resource Name (ARN) of an Amazon S3 bucket where audio log files are stored.
  S3BucketArn string `json:"S3BucketArn"`
}

// SentimentAnalysisSettings Determines whether Amazon Lex will use Amazon Comprehend to detect the sentiment of user utterances.
type SentimentAnalysisSettings struct {

  // Enable to call Amazon Comprehend for Sentiment natively within Lex
  DetectSentiment bool `json:"DetectSentiment"`
}

// Tag A label for tagging Lex resources
type Tag struct {

  // A string used to identify this tag
  Key string `json:"Key"`

  // A string containing the value for the tag
  Value string `json:"Value"`
}

// TextLogDestination Defines the Amazon CloudWatch Logs destination log group for conversation text logs.
type TextLogDestination struct {
  CloudWatch *CloudWatchLogGroupLogDestination `json:"CloudWatch"`
}

// TextLogSetting Contains information about code hooks that Amazon Lex calls during a conversation.
type TextLogSetting struct {
  Destination *TextLogDestination `json:"Destination"`
  Enabled bool `json:"Enabled"`
}

func (strct *AudioLogDestination) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "S3Bucket" field is required
    if strct.S3Bucket == nil {
        return nil, errors.New("S3Bucket is a required field")
    }
    // Marshal the "S3Bucket" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3Bucket\": ")
	if tmp, err := json.Marshal(strct.S3Bucket); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AudioLogDestination) UnmarshalJSON(b []byte) error {
    S3BucketReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "S3Bucket":
            if err := json.Unmarshal([]byte(v), &strct.S3Bucket); err != nil {
                return err
             }
            S3BucketReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if S3Bucket (a required property) was received
    if !S3BucketReceived {
        return errors.New("\"S3Bucket\" is required but was not present")
    }
    return nil
}

func (strct *AudioLogSetting) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Destination" field is required
    if strct.Destination == nil {
        return nil, errors.New("Destination is a required field")
    }
    // Marshal the "Destination" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Destination\": ")
	if tmp, err := json.Marshal(strct.Destination); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Enabled" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Enabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AudioLogSetting) UnmarshalJSON(b []byte) error {
    DestinationReceived := false
    EnabledReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Destination":
            if err := json.Unmarshal([]byte(v), &strct.Destination); err != nil {
                return err
             }
            DestinationReceived = true
        case "Enabled":
            if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
                return err
             }
            EnabledReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Destination (a required property) was received
    if !DestinationReceived {
        return errors.New("\"Destination\" is required but was not present")
    }
    // check if Enabled (a required property) was received
    if !EnabledReceived {
        return errors.New("\"Enabled\" is required but was not present")
    }
    return nil
}

func (strct *BotAliasLocaleSettings) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CodeHookSpecification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CodeHookSpecification\": ")
	if tmp, err := json.Marshal(strct.CodeHookSpecification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Enabled" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Enabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BotAliasLocaleSettings) UnmarshalJSON(b []byte) error {
    EnabledReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CodeHookSpecification":
            if err := json.Unmarshal([]byte(v), &strct.CodeHookSpecification); err != nil {
                return err
             }
        case "Enabled":
            if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
                return err
             }
            EnabledReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Enabled (a required property) was received
    if !EnabledReceived {
        return errors.New("\"Enabled\" is required but was not present")
    }
    return nil
}

func (strct *BotAliasLocaleSettingsItem) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "BotAliasLocaleSetting" field is required
    if strct.BotAliasLocaleSetting == nil {
        return nil, errors.New("BotAliasLocaleSetting is a required field")
    }
    // Marshal the "BotAliasLocaleSetting" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BotAliasLocaleSetting\": ")
	if tmp, err := json.Marshal(strct.BotAliasLocaleSetting); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "LocaleId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "LocaleId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LocaleId\": ")
	if tmp, err := json.Marshal(strct.LocaleId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BotAliasLocaleSettingsItem) UnmarshalJSON(b []byte) error {
    BotAliasLocaleSettingReceived := false
    LocaleIdReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BotAliasLocaleSetting":
            if err := json.Unmarshal([]byte(v), &strct.BotAliasLocaleSetting); err != nil {
                return err
             }
            BotAliasLocaleSettingReceived = true
        case "LocaleId":
            if err := json.Unmarshal([]byte(v), &strct.LocaleId); err != nil {
                return err
             }
            LocaleIdReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if BotAliasLocaleSetting (a required property) was received
    if !BotAliasLocaleSettingReceived {
        return errors.New("\"BotAliasLocaleSetting\" is required but was not present")
    }
    // check if LocaleId (a required property) was received
    if !LocaleIdReceived {
        return errors.New("\"LocaleId\" is required but was not present")
    }
    return nil
}

func (strct *CloudWatchLogGroupLogDestination) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "CloudWatchLogGroupArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "CloudWatchLogGroupArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CloudWatchLogGroupArn\": ")
	if tmp, err := json.Marshal(strct.CloudWatchLogGroupArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "LogPrefix" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "LogPrefix" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LogPrefix\": ")
	if tmp, err := json.Marshal(strct.LogPrefix); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CloudWatchLogGroupLogDestination) UnmarshalJSON(b []byte) error {
    CloudWatchLogGroupArnReceived := false
    LogPrefixReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CloudWatchLogGroupArn":
            if err := json.Unmarshal([]byte(v), &strct.CloudWatchLogGroupArn); err != nil {
                return err
             }
            CloudWatchLogGroupArnReceived = true
        case "LogPrefix":
            if err := json.Unmarshal([]byte(v), &strct.LogPrefix); err != nil {
                return err
             }
            LogPrefixReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if CloudWatchLogGroupArn (a required property) was received
    if !CloudWatchLogGroupArnReceived {
        return errors.New("\"CloudWatchLogGroupArn\" is required but was not present")
    }
    // check if LogPrefix (a required property) was received
    if !LogPrefixReceived {
        return errors.New("\"LogPrefix\" is required but was not present")
    }
    return nil
}

func (strct *CodeHookSpecification) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "LambdaCodeHook" field is required
    if strct.LambdaCodeHook == nil {
        return nil, errors.New("LambdaCodeHook is a required field")
    }
    // Marshal the "LambdaCodeHook" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LambdaCodeHook\": ")
	if tmp, err := json.Marshal(strct.LambdaCodeHook); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CodeHookSpecification) UnmarshalJSON(b []byte) error {
    LambdaCodeHookReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "LambdaCodeHook":
            if err := json.Unmarshal([]byte(v), &strct.LambdaCodeHook); err != nil {
                return err
             }
            LambdaCodeHookReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if LambdaCodeHook (a required property) was received
    if !LambdaCodeHookReceived {
        return errors.New("\"LambdaCodeHook\" is required but was not present")
    }
    return nil
}

func (strct *ConversationLogSettings) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AudioLogSettings" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AudioLogSettings\": ")
	if tmp, err := json.Marshal(strct.AudioLogSettings); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TextLogSettings" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TextLogSettings\": ")
	if tmp, err := json.Marshal(strct.TextLogSettings); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ConversationLogSettings) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AudioLogSettings":
            if err := json.Unmarshal([]byte(v), &strct.AudioLogSettings); err != nil {
                return err
             }
        case "TextLogSettings":
            if err := json.Unmarshal([]byte(v), &strct.TextLogSettings); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *LambdaCodeHook) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "CodeHookInterfaceVersion" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "CodeHookInterfaceVersion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CodeHookInterfaceVersion\": ")
	if tmp, err := json.Marshal(strct.CodeHookInterfaceVersion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "LambdaArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "LambdaArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LambdaArn\": ")
	if tmp, err := json.Marshal(strct.LambdaArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LambdaCodeHook) UnmarshalJSON(b []byte) error {
    CodeHookInterfaceVersionReceived := false
    LambdaArnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CodeHookInterfaceVersion":
            if err := json.Unmarshal([]byte(v), &strct.CodeHookInterfaceVersion); err != nil {
                return err
             }
            CodeHookInterfaceVersionReceived = true
        case "LambdaArn":
            if err := json.Unmarshal([]byte(v), &strct.LambdaArn); err != nil {
                return err
             }
            LambdaArnReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if CodeHookInterfaceVersion (a required property) was received
    if !CodeHookInterfaceVersionReceived {
        return errors.New("\"CodeHookInterfaceVersion\" is required but was not present")
    }
    // check if LambdaArn (a required property) was received
    if !LambdaArnReceived {
        return errors.New("\"LambdaArn\" is required but was not present")
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Arn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Arn\": ")
	if tmp, err := json.Marshal(strct.Arn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BotAliasId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BotAliasId\": ")
	if tmp, err := json.Marshal(strct.BotAliasId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BotAliasLocaleSettings" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BotAliasLocaleSettings\": ")
	if tmp, err := json.Marshal(strct.BotAliasLocaleSettings); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "BotAliasName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "BotAliasName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BotAliasName\": ")
	if tmp, err := json.Marshal(strct.BotAliasName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BotAliasStatus" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BotAliasStatus\": ")
	if tmp, err := json.Marshal(strct.BotAliasStatus); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BotAliasTags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BotAliasTags\": ")
	if tmp, err := json.Marshal(strct.BotAliasTags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "BotId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "BotId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BotId\": ")
	if tmp, err := json.Marshal(strct.BotId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BotVersion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BotVersion\": ")
	if tmp, err := json.Marshal(strct.BotVersion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ConversationLogSettings" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConversationLogSettings\": ")
	if tmp, err := json.Marshal(strct.ConversationLogSettings); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SentimentAnalysisSettings" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SentimentAnalysisSettings\": ")
	if tmp, err := json.Marshal(strct.SentimentAnalysisSettings); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    BotAliasNameReceived := false
    BotIdReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Arn":
            if err := json.Unmarshal([]byte(v), &strct.Arn); err != nil {
                return err
             }
        case "BotAliasId":
            if err := json.Unmarshal([]byte(v), &strct.BotAliasId); err != nil {
                return err
             }
        case "BotAliasLocaleSettings":
            if err := json.Unmarshal([]byte(v), &strct.BotAliasLocaleSettings); err != nil {
                return err
             }
        case "BotAliasName":
            if err := json.Unmarshal([]byte(v), &strct.BotAliasName); err != nil {
                return err
             }
            BotAliasNameReceived = true
        case "BotAliasStatus":
            if err := json.Unmarshal([]byte(v), &strct.BotAliasStatus); err != nil {
                return err
             }
        case "BotAliasTags":
            if err := json.Unmarshal([]byte(v), &strct.BotAliasTags); err != nil {
                return err
             }
        case "BotId":
            if err := json.Unmarshal([]byte(v), &strct.BotId); err != nil {
                return err
             }
            BotIdReceived = true
        case "BotVersion":
            if err := json.Unmarshal([]byte(v), &strct.BotVersion); err != nil {
                return err
             }
        case "ConversationLogSettings":
            if err := json.Unmarshal([]byte(v), &strct.ConversationLogSettings); err != nil {
                return err
             }
        case "Description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "SentimentAnalysisSettings":
            if err := json.Unmarshal([]byte(v), &strct.SentimentAnalysisSettings); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if BotAliasName (a required property) was received
    if !BotAliasNameReceived {
        return errors.New("\"BotAliasName\" is required but was not present")
    }
    // check if BotId (a required property) was received
    if !BotIdReceived {
        return errors.New("\"BotId\" is required but was not present")
    }
    return nil
}

func (strct *S3BucketLogDestination) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "KmsKeyArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KmsKeyArn\": ")
	if tmp, err := json.Marshal(strct.KmsKeyArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "LogPrefix" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "LogPrefix" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LogPrefix\": ")
	if tmp, err := json.Marshal(strct.LogPrefix); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "S3BucketArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "S3BucketArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3BucketArn\": ")
	if tmp, err := json.Marshal(strct.S3BucketArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *S3BucketLogDestination) UnmarshalJSON(b []byte) error {
    LogPrefixReceived := false
    S3BucketArnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "KmsKeyArn":
            if err := json.Unmarshal([]byte(v), &strct.KmsKeyArn); err != nil {
                return err
             }
        case "LogPrefix":
            if err := json.Unmarshal([]byte(v), &strct.LogPrefix); err != nil {
                return err
             }
            LogPrefixReceived = true
        case "S3BucketArn":
            if err := json.Unmarshal([]byte(v), &strct.S3BucketArn); err != nil {
                return err
             }
            S3BucketArnReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if LogPrefix (a required property) was received
    if !LogPrefixReceived {
        return errors.New("\"LogPrefix\" is required but was not present")
    }
    // check if S3BucketArn (a required property) was received
    if !S3BucketArnReceived {
        return errors.New("\"S3BucketArn\" is required but was not present")
    }
    return nil
}

func (strct *SentimentAnalysisSettings) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "DetectSentiment" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "DetectSentiment" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DetectSentiment\": ")
	if tmp, err := json.Marshal(strct.DetectSentiment); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SentimentAnalysisSettings) UnmarshalJSON(b []byte) error {
    DetectSentimentReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DetectSentiment":
            if err := json.Unmarshal([]byte(v), &strct.DetectSentiment); err != nil {
                return err
             }
            DetectSentimentReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if DetectSentiment (a required property) was received
    if !DetectSentimentReceived {
        return errors.New("\"DetectSentiment\" is required but was not present")
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *TextLogDestination) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "CloudWatch" field is required
    if strct.CloudWatch == nil {
        return nil, errors.New("CloudWatch is a required field")
    }
    // Marshal the "CloudWatch" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CloudWatch\": ")
	if tmp, err := json.Marshal(strct.CloudWatch); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TextLogDestination) UnmarshalJSON(b []byte) error {
    CloudWatchReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CloudWatch":
            if err := json.Unmarshal([]byte(v), &strct.CloudWatch); err != nil {
                return err
             }
            CloudWatchReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if CloudWatch (a required property) was received
    if !CloudWatchReceived {
        return errors.New("\"CloudWatch\" is required but was not present")
    }
    return nil
}

func (strct *TextLogSetting) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Destination" field is required
    if strct.Destination == nil {
        return nil, errors.New("Destination is a required field")
    }
    // Marshal the "Destination" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Destination\": ")
	if tmp, err := json.Marshal(strct.Destination); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Enabled" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Enabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TextLogSetting) UnmarshalJSON(b []byte) error {
    DestinationReceived := false
    EnabledReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Destination":
            if err := json.Unmarshal([]byte(v), &strct.Destination); err != nil {
                return err
             }
            DestinationReceived = true
        case "Enabled":
            if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
                return err
             }
            EnabledReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Destination (a required property) was received
    if !DestinationReceived {
        return errors.New("\"Destination\" is required but was not present")
    }
    // check if Enabled (a required property) was received
    if !EnabledReceived {
        return errors.New("\"Enabled\" is required but was not present")
    }
    return nil
}
