// Code generated by schema-generate. DO NOT EDIT.

package responseheaderspolicy

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// AccessControlAllowHeaders 
type AccessControlAllowHeaders struct {
  Items []string `json:"Items"`
}

// AccessControlAllowMethods 
type AccessControlAllowMethods struct {
  Items []string `json:"Items"`
}

// AccessControlAllowOrigins 
type AccessControlAllowOrigins struct {
  Items []string `json:"Items"`
}

// AccessControlExposeHeaders 
type AccessControlExposeHeaders struct {
  Items []string `json:"Items"`
}

// ContentSecurityPolicy 
type ContentSecurityPolicy struct {
  ContentSecurityPolicy string `json:"ContentSecurityPolicy"`
  Override bool `json:"Override"`
}

// ContentTypeOptions 
type ContentTypeOptions struct {
  Override bool `json:"Override"`
}

// CorsConfig 
type CorsConfig struct {
  AccessControlAllowCredentials bool `json:"AccessControlAllowCredentials"`
  AccessControlAllowHeaders *AccessControlAllowHeaders `json:"AccessControlAllowHeaders"`
  AccessControlAllowMethods *AccessControlAllowMethods `json:"AccessControlAllowMethods"`
  AccessControlAllowOrigins *AccessControlAllowOrigins `json:"AccessControlAllowOrigins"`
  AccessControlExposeHeaders *AccessControlExposeHeaders `json:"AccessControlExposeHeaders,omitempty"`
  AccessControlMaxAgeSec int `json:"AccessControlMaxAgeSec,omitempty"`
  OriginOverride bool `json:"OriginOverride"`
}

// CustomHeader 
type CustomHeader struct {
  Header string `json:"Header"`
  Override bool `json:"Override"`
  Value string `json:"Value"`
}

// CustomHeadersConfig 
type CustomHeadersConfig struct {
  Items []*CustomHeader `json:"Items"`
}

// FrameOptions 
type FrameOptions struct {
  FrameOption string `json:"FrameOption"`
  Override bool `json:"Override"`
}

// ReferrerPolicy 
type ReferrerPolicy struct {
  Override bool `json:"Override"`
  ReferrerPolicy string `json:"ReferrerPolicy"`
}

// RemoveHeader 
type RemoveHeader struct {
  Header string `json:"Header"`
}

// RemoveHeadersConfig 
type RemoveHeadersConfig struct {
  Items []*RemoveHeader `json:"Items"`
}

// Resource Resource Type definition for AWS::CloudFront::ResponseHeadersPolicy
type Resource struct {
  Id string `json:"Id,omitempty"`
  LastModifiedTime string `json:"LastModifiedTime,omitempty"`
  ResponseHeadersPolicyConfig *ResponseHeadersPolicyConfig `json:"ResponseHeadersPolicyConfig"`
}

// ResponseHeadersPolicyConfig 
type ResponseHeadersPolicyConfig struct {
  Comment string `json:"Comment,omitempty"`
  CorsConfig *CorsConfig `json:"CorsConfig,omitempty"`
  CustomHeadersConfig *CustomHeadersConfig `json:"CustomHeadersConfig,omitempty"`
  Name string `json:"Name"`
  RemoveHeadersConfig *RemoveHeadersConfig `json:"RemoveHeadersConfig,omitempty"`
  SecurityHeadersConfig *SecurityHeadersConfig `json:"SecurityHeadersConfig,omitempty"`
  ServerTimingHeadersConfig *ServerTimingHeadersConfig `json:"ServerTimingHeadersConfig,omitempty"`
}

// SecurityHeadersConfig 
type SecurityHeadersConfig struct {
  ContentSecurityPolicy *ContentSecurityPolicy `json:"ContentSecurityPolicy,omitempty"`
  ContentTypeOptions *ContentTypeOptions `json:"ContentTypeOptions,omitempty"`
  FrameOptions *FrameOptions `json:"FrameOptions,omitempty"`
  ReferrerPolicy *ReferrerPolicy `json:"ReferrerPolicy,omitempty"`
  StrictTransportSecurity *StrictTransportSecurity `json:"StrictTransportSecurity,omitempty"`
  XSSProtection *XSSProtection `json:"XSSProtection,omitempty"`
}

// ServerTimingHeadersConfig 
type ServerTimingHeadersConfig struct {
  Enabled bool `json:"Enabled"`
  SamplingRate float64 `json:"SamplingRate,omitempty"`
}

// StrictTransportSecurity 
type StrictTransportSecurity struct {
  AccessControlMaxAgeSec int `json:"AccessControlMaxAgeSec"`
  IncludeSubdomains bool `json:"IncludeSubdomains,omitempty"`
  Override bool `json:"Override"`
  Preload bool `json:"Preload,omitempty"`
}

// XSSProtection 
type XSSProtection struct {
  ModeBlock bool `json:"ModeBlock,omitempty"`
  Override bool `json:"Override"`
  Protection bool `json:"Protection"`
  ReportUri string `json:"ReportUri,omitempty"`
}

func (strct *AccessControlAllowHeaders) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Items" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Items" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Items\": ")
	if tmp, err := json.Marshal(strct.Items); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AccessControlAllowHeaders) UnmarshalJSON(b []byte) error {
    ItemsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Items":
            if err := json.Unmarshal([]byte(v), &strct.Items); err != nil {
                return err
             }
            ItemsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Items (a required property) was received
    if !ItemsReceived {
        return errors.New("\"Items\" is required but was not present")
    }
    return nil
}

func (strct *AccessControlAllowMethods) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Items" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Items" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Items\": ")
	if tmp, err := json.Marshal(strct.Items); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AccessControlAllowMethods) UnmarshalJSON(b []byte) error {
    ItemsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Items":
            if err := json.Unmarshal([]byte(v), &strct.Items); err != nil {
                return err
             }
            ItemsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Items (a required property) was received
    if !ItemsReceived {
        return errors.New("\"Items\" is required but was not present")
    }
    return nil
}

func (strct *AccessControlAllowOrigins) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Items" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Items" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Items\": ")
	if tmp, err := json.Marshal(strct.Items); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AccessControlAllowOrigins) UnmarshalJSON(b []byte) error {
    ItemsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Items":
            if err := json.Unmarshal([]byte(v), &strct.Items); err != nil {
                return err
             }
            ItemsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Items (a required property) was received
    if !ItemsReceived {
        return errors.New("\"Items\" is required but was not present")
    }
    return nil
}

func (strct *AccessControlExposeHeaders) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Items" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Items" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Items\": ")
	if tmp, err := json.Marshal(strct.Items); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AccessControlExposeHeaders) UnmarshalJSON(b []byte) error {
    ItemsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Items":
            if err := json.Unmarshal([]byte(v), &strct.Items); err != nil {
                return err
             }
            ItemsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Items (a required property) was received
    if !ItemsReceived {
        return errors.New("\"Items\" is required but was not present")
    }
    return nil
}

func (strct *ContentSecurityPolicy) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ContentSecurityPolicy" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ContentSecurityPolicy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ContentSecurityPolicy\": ")
	if tmp, err := json.Marshal(strct.ContentSecurityPolicy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Override" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Override" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Override\": ")
	if tmp, err := json.Marshal(strct.Override); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ContentSecurityPolicy) UnmarshalJSON(b []byte) error {
    ContentSecurityPolicyReceived := false
    OverrideReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ContentSecurityPolicy":
            if err := json.Unmarshal([]byte(v), &strct.ContentSecurityPolicy); err != nil {
                return err
             }
            ContentSecurityPolicyReceived = true
        case "Override":
            if err := json.Unmarshal([]byte(v), &strct.Override); err != nil {
                return err
             }
            OverrideReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ContentSecurityPolicy (a required property) was received
    if !ContentSecurityPolicyReceived {
        return errors.New("\"ContentSecurityPolicy\" is required but was not present")
    }
    // check if Override (a required property) was received
    if !OverrideReceived {
        return errors.New("\"Override\" is required but was not present")
    }
    return nil
}

func (strct *ContentTypeOptions) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Override" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Override" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Override\": ")
	if tmp, err := json.Marshal(strct.Override); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ContentTypeOptions) UnmarshalJSON(b []byte) error {
    OverrideReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Override":
            if err := json.Unmarshal([]byte(v), &strct.Override); err != nil {
                return err
             }
            OverrideReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Override (a required property) was received
    if !OverrideReceived {
        return errors.New("\"Override\" is required but was not present")
    }
    return nil
}

func (strct *CorsConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AccessControlAllowCredentials" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AccessControlAllowCredentials" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AccessControlAllowCredentials\": ")
	if tmp, err := json.Marshal(strct.AccessControlAllowCredentials); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "AccessControlAllowHeaders" field is required
    if strct.AccessControlAllowHeaders == nil {
        return nil, errors.New("AccessControlAllowHeaders is a required field")
    }
    // Marshal the "AccessControlAllowHeaders" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AccessControlAllowHeaders\": ")
	if tmp, err := json.Marshal(strct.AccessControlAllowHeaders); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "AccessControlAllowMethods" field is required
    if strct.AccessControlAllowMethods == nil {
        return nil, errors.New("AccessControlAllowMethods is a required field")
    }
    // Marshal the "AccessControlAllowMethods" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AccessControlAllowMethods\": ")
	if tmp, err := json.Marshal(strct.AccessControlAllowMethods); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "AccessControlAllowOrigins" field is required
    if strct.AccessControlAllowOrigins == nil {
        return nil, errors.New("AccessControlAllowOrigins is a required field")
    }
    // Marshal the "AccessControlAllowOrigins" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AccessControlAllowOrigins\": ")
	if tmp, err := json.Marshal(strct.AccessControlAllowOrigins); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AccessControlExposeHeaders" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AccessControlExposeHeaders\": ")
	if tmp, err := json.Marshal(strct.AccessControlExposeHeaders); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AccessControlMaxAgeSec" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AccessControlMaxAgeSec\": ")
	if tmp, err := json.Marshal(strct.AccessControlMaxAgeSec); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "OriginOverride" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "OriginOverride" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OriginOverride\": ")
	if tmp, err := json.Marshal(strct.OriginOverride); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CorsConfig) UnmarshalJSON(b []byte) error {
    AccessControlAllowCredentialsReceived := false
    AccessControlAllowHeadersReceived := false
    AccessControlAllowMethodsReceived := false
    AccessControlAllowOriginsReceived := false
    OriginOverrideReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AccessControlAllowCredentials":
            if err := json.Unmarshal([]byte(v), &strct.AccessControlAllowCredentials); err != nil {
                return err
             }
            AccessControlAllowCredentialsReceived = true
        case "AccessControlAllowHeaders":
            if err := json.Unmarshal([]byte(v), &strct.AccessControlAllowHeaders); err != nil {
                return err
             }
            AccessControlAllowHeadersReceived = true
        case "AccessControlAllowMethods":
            if err := json.Unmarshal([]byte(v), &strct.AccessControlAllowMethods); err != nil {
                return err
             }
            AccessControlAllowMethodsReceived = true
        case "AccessControlAllowOrigins":
            if err := json.Unmarshal([]byte(v), &strct.AccessControlAllowOrigins); err != nil {
                return err
             }
            AccessControlAllowOriginsReceived = true
        case "AccessControlExposeHeaders":
            if err := json.Unmarshal([]byte(v), &strct.AccessControlExposeHeaders); err != nil {
                return err
             }
        case "AccessControlMaxAgeSec":
            if err := json.Unmarshal([]byte(v), &strct.AccessControlMaxAgeSec); err != nil {
                return err
             }
        case "OriginOverride":
            if err := json.Unmarshal([]byte(v), &strct.OriginOverride); err != nil {
                return err
             }
            OriginOverrideReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if AccessControlAllowCredentials (a required property) was received
    if !AccessControlAllowCredentialsReceived {
        return errors.New("\"AccessControlAllowCredentials\" is required but was not present")
    }
    // check if AccessControlAllowHeaders (a required property) was received
    if !AccessControlAllowHeadersReceived {
        return errors.New("\"AccessControlAllowHeaders\" is required but was not present")
    }
    // check if AccessControlAllowMethods (a required property) was received
    if !AccessControlAllowMethodsReceived {
        return errors.New("\"AccessControlAllowMethods\" is required but was not present")
    }
    // check if AccessControlAllowOrigins (a required property) was received
    if !AccessControlAllowOriginsReceived {
        return errors.New("\"AccessControlAllowOrigins\" is required but was not present")
    }
    // check if OriginOverride (a required property) was received
    if !OriginOverrideReceived {
        return errors.New("\"OriginOverride\" is required but was not present")
    }
    return nil
}

func (strct *CustomHeader) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Header" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Header" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Header\": ")
	if tmp, err := json.Marshal(strct.Header); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Override" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Override" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Override\": ")
	if tmp, err := json.Marshal(strct.Override); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CustomHeader) UnmarshalJSON(b []byte) error {
    HeaderReceived := false
    OverrideReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Header":
            if err := json.Unmarshal([]byte(v), &strct.Header); err != nil {
                return err
             }
            HeaderReceived = true
        case "Override":
            if err := json.Unmarshal([]byte(v), &strct.Override); err != nil {
                return err
             }
            OverrideReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Header (a required property) was received
    if !HeaderReceived {
        return errors.New("\"Header\" is required but was not present")
    }
    // check if Override (a required property) was received
    if !OverrideReceived {
        return errors.New("\"Override\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *CustomHeadersConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Items" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Items" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Items\": ")
	if tmp, err := json.Marshal(strct.Items); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CustomHeadersConfig) UnmarshalJSON(b []byte) error {
    ItemsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Items":
            if err := json.Unmarshal([]byte(v), &strct.Items); err != nil {
                return err
             }
            ItemsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Items (a required property) was received
    if !ItemsReceived {
        return errors.New("\"Items\" is required but was not present")
    }
    return nil
}

func (strct *FrameOptions) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "FrameOption" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "FrameOption" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FrameOption\": ")
	if tmp, err := json.Marshal(strct.FrameOption); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Override" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Override" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Override\": ")
	if tmp, err := json.Marshal(strct.Override); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FrameOptions) UnmarshalJSON(b []byte) error {
    FrameOptionReceived := false
    OverrideReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "FrameOption":
            if err := json.Unmarshal([]byte(v), &strct.FrameOption); err != nil {
                return err
             }
            FrameOptionReceived = true
        case "Override":
            if err := json.Unmarshal([]byte(v), &strct.Override); err != nil {
                return err
             }
            OverrideReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if FrameOption (a required property) was received
    if !FrameOptionReceived {
        return errors.New("\"FrameOption\" is required but was not present")
    }
    // check if Override (a required property) was received
    if !OverrideReceived {
        return errors.New("\"Override\" is required but was not present")
    }
    return nil
}

func (strct *ReferrerPolicy) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Override" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Override" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Override\": ")
	if tmp, err := json.Marshal(strct.Override); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ReferrerPolicy" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ReferrerPolicy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ReferrerPolicy\": ")
	if tmp, err := json.Marshal(strct.ReferrerPolicy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ReferrerPolicy) UnmarshalJSON(b []byte) error {
    OverrideReceived := false
    ReferrerPolicyReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Override":
            if err := json.Unmarshal([]byte(v), &strct.Override); err != nil {
                return err
             }
            OverrideReceived = true
        case "ReferrerPolicy":
            if err := json.Unmarshal([]byte(v), &strct.ReferrerPolicy); err != nil {
                return err
             }
            ReferrerPolicyReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Override (a required property) was received
    if !OverrideReceived {
        return errors.New("\"Override\" is required but was not present")
    }
    // check if ReferrerPolicy (a required property) was received
    if !ReferrerPolicyReceived {
        return errors.New("\"ReferrerPolicy\" is required but was not present")
    }
    return nil
}

func (strct *RemoveHeader) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Header" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Header" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Header\": ")
	if tmp, err := json.Marshal(strct.Header); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RemoveHeader) UnmarshalJSON(b []byte) error {
    HeaderReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Header":
            if err := json.Unmarshal([]byte(v), &strct.Header); err != nil {
                return err
             }
            HeaderReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Header (a required property) was received
    if !HeaderReceived {
        return errors.New("\"Header\" is required but was not present")
    }
    return nil
}

func (strct *RemoveHeadersConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Items" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Items" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Items\": ")
	if tmp, err := json.Marshal(strct.Items); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RemoveHeadersConfig) UnmarshalJSON(b []byte) error {
    ItemsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Items":
            if err := json.Unmarshal([]byte(v), &strct.Items); err != nil {
                return err
             }
            ItemsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Items (a required property) was received
    if !ItemsReceived {
        return errors.New("\"Items\" is required but was not present")
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Id" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LastModifiedTime" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LastModifiedTime\": ")
	if tmp, err := json.Marshal(strct.LastModifiedTime); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ResponseHeadersPolicyConfig" field is required
    if strct.ResponseHeadersPolicyConfig == nil {
        return nil, errors.New("ResponseHeadersPolicyConfig is a required field")
    }
    // Marshal the "ResponseHeadersPolicyConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ResponseHeadersPolicyConfig\": ")
	if tmp, err := json.Marshal(strct.ResponseHeadersPolicyConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    ResponseHeadersPolicyConfigReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
        case "LastModifiedTime":
            if err := json.Unmarshal([]byte(v), &strct.LastModifiedTime); err != nil {
                return err
             }
        case "ResponseHeadersPolicyConfig":
            if err := json.Unmarshal([]byte(v), &strct.ResponseHeadersPolicyConfig); err != nil {
                return err
             }
            ResponseHeadersPolicyConfigReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ResponseHeadersPolicyConfig (a required property) was received
    if !ResponseHeadersPolicyConfigReceived {
        return errors.New("\"ResponseHeadersPolicyConfig\" is required but was not present")
    }
    return nil
}

func (strct *ResponseHeadersPolicyConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Comment" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Comment\": ")
	if tmp, err := json.Marshal(strct.Comment); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CorsConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CorsConfig\": ")
	if tmp, err := json.Marshal(strct.CorsConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CustomHeadersConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CustomHeadersConfig\": ")
	if tmp, err := json.Marshal(strct.CustomHeadersConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RemoveHeadersConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RemoveHeadersConfig\": ")
	if tmp, err := json.Marshal(strct.RemoveHeadersConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SecurityHeadersConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SecurityHeadersConfig\": ")
	if tmp, err := json.Marshal(strct.SecurityHeadersConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ServerTimingHeadersConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ServerTimingHeadersConfig\": ")
	if tmp, err := json.Marshal(strct.ServerTimingHeadersConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ResponseHeadersPolicyConfig) UnmarshalJSON(b []byte) error {
    NameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Comment":
            if err := json.Unmarshal([]byte(v), &strct.Comment); err != nil {
                return err
             }
        case "CorsConfig":
            if err := json.Unmarshal([]byte(v), &strct.CorsConfig); err != nil {
                return err
             }
        case "CustomHeadersConfig":
            if err := json.Unmarshal([]byte(v), &strct.CustomHeadersConfig); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        case "RemoveHeadersConfig":
            if err := json.Unmarshal([]byte(v), &strct.RemoveHeadersConfig); err != nil {
                return err
             }
        case "SecurityHeadersConfig":
            if err := json.Unmarshal([]byte(v), &strct.SecurityHeadersConfig); err != nil {
                return err
             }
        case "ServerTimingHeadersConfig":
            if err := json.Unmarshal([]byte(v), &strct.ServerTimingHeadersConfig); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    return nil
}

func (strct *SecurityHeadersConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ContentSecurityPolicy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ContentSecurityPolicy\": ")
	if tmp, err := json.Marshal(strct.ContentSecurityPolicy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ContentTypeOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ContentTypeOptions\": ")
	if tmp, err := json.Marshal(strct.ContentTypeOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FrameOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FrameOptions\": ")
	if tmp, err := json.Marshal(strct.FrameOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ReferrerPolicy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ReferrerPolicy\": ")
	if tmp, err := json.Marshal(strct.ReferrerPolicy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StrictTransportSecurity" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StrictTransportSecurity\": ")
	if tmp, err := json.Marshal(strct.StrictTransportSecurity); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "XSSProtection" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"XSSProtection\": ")
	if tmp, err := json.Marshal(strct.XSSProtection); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SecurityHeadersConfig) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ContentSecurityPolicy":
            if err := json.Unmarshal([]byte(v), &strct.ContentSecurityPolicy); err != nil {
                return err
             }
        case "ContentTypeOptions":
            if err := json.Unmarshal([]byte(v), &strct.ContentTypeOptions); err != nil {
                return err
             }
        case "FrameOptions":
            if err := json.Unmarshal([]byte(v), &strct.FrameOptions); err != nil {
                return err
             }
        case "ReferrerPolicy":
            if err := json.Unmarshal([]byte(v), &strct.ReferrerPolicy); err != nil {
                return err
             }
        case "StrictTransportSecurity":
            if err := json.Unmarshal([]byte(v), &strct.StrictTransportSecurity); err != nil {
                return err
             }
        case "XSSProtection":
            if err := json.Unmarshal([]byte(v), &strct.XSSProtection); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ServerTimingHeadersConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Enabled" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Enabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SamplingRate" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SamplingRate\": ")
	if tmp, err := json.Marshal(strct.SamplingRate); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ServerTimingHeadersConfig) UnmarshalJSON(b []byte) error {
    EnabledReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Enabled":
            if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
                return err
             }
            EnabledReceived = true
        case "SamplingRate":
            if err := json.Unmarshal([]byte(v), &strct.SamplingRate); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Enabled (a required property) was received
    if !EnabledReceived {
        return errors.New("\"Enabled\" is required but was not present")
    }
    return nil
}

func (strct *StrictTransportSecurity) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AccessControlMaxAgeSec" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AccessControlMaxAgeSec" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AccessControlMaxAgeSec\": ")
	if tmp, err := json.Marshal(strct.AccessControlMaxAgeSec); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IncludeSubdomains" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IncludeSubdomains\": ")
	if tmp, err := json.Marshal(strct.IncludeSubdomains); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Override" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Override" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Override\": ")
	if tmp, err := json.Marshal(strct.Override); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Preload" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Preload\": ")
	if tmp, err := json.Marshal(strct.Preload); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *StrictTransportSecurity) UnmarshalJSON(b []byte) error {
    AccessControlMaxAgeSecReceived := false
    OverrideReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AccessControlMaxAgeSec":
            if err := json.Unmarshal([]byte(v), &strct.AccessControlMaxAgeSec); err != nil {
                return err
             }
            AccessControlMaxAgeSecReceived = true
        case "IncludeSubdomains":
            if err := json.Unmarshal([]byte(v), &strct.IncludeSubdomains); err != nil {
                return err
             }
        case "Override":
            if err := json.Unmarshal([]byte(v), &strct.Override); err != nil {
                return err
             }
            OverrideReceived = true
        case "Preload":
            if err := json.Unmarshal([]byte(v), &strct.Preload); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if AccessControlMaxAgeSec (a required property) was received
    if !AccessControlMaxAgeSecReceived {
        return errors.New("\"AccessControlMaxAgeSec\" is required but was not present")
    }
    // check if Override (a required property) was received
    if !OverrideReceived {
        return errors.New("\"Override\" is required but was not present")
    }
    return nil
}

func (strct *XSSProtection) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ModeBlock" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ModeBlock\": ")
	if tmp, err := json.Marshal(strct.ModeBlock); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Override" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Override" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Override\": ")
	if tmp, err := json.Marshal(strct.Override); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Protection" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Protection" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Protection\": ")
	if tmp, err := json.Marshal(strct.Protection); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ReportUri" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ReportUri\": ")
	if tmp, err := json.Marshal(strct.ReportUri); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *XSSProtection) UnmarshalJSON(b []byte) error {
    OverrideReceived := false
    ProtectionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ModeBlock":
            if err := json.Unmarshal([]byte(v), &strct.ModeBlock); err != nil {
                return err
             }
        case "Override":
            if err := json.Unmarshal([]byte(v), &strct.Override); err != nil {
                return err
             }
            OverrideReceived = true
        case "Protection":
            if err := json.Unmarshal([]byte(v), &strct.Protection); err != nil {
                return err
             }
            ProtectionReceived = true
        case "ReportUri":
            if err := json.Unmarshal([]byte(v), &strct.ReportUri); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Override (a required property) was received
    if !OverrideReceived {
        return errors.New("\"Override\" is required but was not present")
    }
    // check if Protection (a required property) was received
    if !ProtectionReceived {
        return errors.New("\"Protection\" is required but was not present")
    }
    return nil
}
