// Code generated by schema-generate. DO NOT EDIT.

package distribution

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// CacheBehavior 
type CacheBehavior struct {
  AllowedMethods []string `json:"AllowedMethods,omitempty"`
  CachePolicyId string `json:"CachePolicyId,omitempty"`
  CachedMethods []string `json:"CachedMethods,omitempty"`
  Compress bool `json:"Compress,omitempty"`
  DefaultTTL float64 `json:"DefaultTTL,omitempty"`
  FieldLevelEncryptionId string `json:"FieldLevelEncryptionId,omitempty"`
  ForwardedValues *ForwardedValues `json:"ForwardedValues,omitempty"`
  FunctionAssociations []*FunctionAssociation `json:"FunctionAssociations,omitempty"`
  LambdaFunctionAssociations []*LambdaFunctionAssociation `json:"LambdaFunctionAssociations,omitempty"`
  MaxTTL float64 `json:"MaxTTL,omitempty"`
  MinTTL float64 `json:"MinTTL,omitempty"`
  OriginRequestPolicyId string `json:"OriginRequestPolicyId,omitempty"`
  PathPattern string `json:"PathPattern"`
  RealtimeLogConfigArn string `json:"RealtimeLogConfigArn,omitempty"`
  ResponseHeadersPolicyId string `json:"ResponseHeadersPolicyId,omitempty"`
  SmoothStreaming bool `json:"SmoothStreaming,omitempty"`
  TargetOriginId string `json:"TargetOriginId"`
  TrustedKeyGroups []string `json:"TrustedKeyGroups,omitempty"`
  TrustedSigners []string `json:"TrustedSigners,omitempty"`
  ViewerProtocolPolicy string `json:"ViewerProtocolPolicy"`
}

// Cookies 
type Cookies struct {
  Forward string `json:"Forward"`
  WhitelistedNames []string `json:"WhitelistedNames,omitempty"`
}

// CustomErrorResponse 
type CustomErrorResponse struct {
  ErrorCachingMinTTL float64 `json:"ErrorCachingMinTTL,omitempty"`
  ErrorCode int `json:"ErrorCode"`
  ResponseCode int `json:"ResponseCode,omitempty"`
  ResponsePagePath string `json:"ResponsePagePath,omitempty"`
}

// CustomOriginConfig 
type CustomOriginConfig struct {
  HTTPPort int `json:"HTTPPort,omitempty"`
  HTTPSPort int `json:"HTTPSPort,omitempty"`
  OriginKeepaliveTimeout int `json:"OriginKeepaliveTimeout,omitempty"`
  OriginProtocolPolicy string `json:"OriginProtocolPolicy"`
  OriginReadTimeout int `json:"OriginReadTimeout,omitempty"`
  OriginSSLProtocols []string `json:"OriginSSLProtocols,omitempty"`
}

// DefaultCacheBehavior 
type DefaultCacheBehavior struct {
  AllowedMethods []string `json:"AllowedMethods,omitempty"`
  CachePolicyId string `json:"CachePolicyId,omitempty"`
  CachedMethods []string `json:"CachedMethods,omitempty"`
  Compress bool `json:"Compress,omitempty"`
  DefaultTTL float64 `json:"DefaultTTL,omitempty"`
  FieldLevelEncryptionId string `json:"FieldLevelEncryptionId,omitempty"`
  ForwardedValues *ForwardedValues `json:"ForwardedValues,omitempty"`
  FunctionAssociations []*FunctionAssociation `json:"FunctionAssociations,omitempty"`
  LambdaFunctionAssociations []*LambdaFunctionAssociation `json:"LambdaFunctionAssociations,omitempty"`
  MaxTTL float64 `json:"MaxTTL,omitempty"`
  MinTTL float64 `json:"MinTTL,omitempty"`
  OriginRequestPolicyId string `json:"OriginRequestPolicyId,omitempty"`
  RealtimeLogConfigArn string `json:"RealtimeLogConfigArn,omitempty"`
  ResponseHeadersPolicyId string `json:"ResponseHeadersPolicyId,omitempty"`
  SmoothStreaming bool `json:"SmoothStreaming,omitempty"`
  TargetOriginId string `json:"TargetOriginId"`
  TrustedKeyGroups []string `json:"TrustedKeyGroups,omitempty"`
  TrustedSigners []string `json:"TrustedSigners,omitempty"`
  ViewerProtocolPolicy string `json:"ViewerProtocolPolicy"`
}

// DistributionConfig 
type DistributionConfig struct {
  Aliases []string `json:"Aliases,omitempty"`
  CNAMEs []string `json:"CNAMEs,omitempty"`
  CacheBehaviors []*CacheBehavior `json:"CacheBehaviors,omitempty"`
  Comment string `json:"Comment,omitempty"`
  ContinuousDeploymentPolicyId string `json:"ContinuousDeploymentPolicyId,omitempty"`
  CustomErrorResponses []*CustomErrorResponse `json:"CustomErrorResponses,omitempty"`
  CustomOrigin *LegacyCustomOrigin `json:"CustomOrigin,omitempty"`
  DefaultCacheBehavior *DefaultCacheBehavior `json:"DefaultCacheBehavior"`
  DefaultRootObject string `json:"DefaultRootObject,omitempty"`
  Enabled bool `json:"Enabled"`
  HttpVersion string `json:"HttpVersion,omitempty"`
  IPV6Enabled bool `json:"IPV6Enabled,omitempty"`
  Logging *Logging `json:"Logging,omitempty"`
  OriginGroups *OriginGroups `json:"OriginGroups,omitempty"`
  Origins []*Origin `json:"Origins,omitempty"`
  PriceClass string `json:"PriceClass,omitempty"`
  Restrictions *Restrictions `json:"Restrictions,omitempty"`
  S3Origin *LegacyS3Origin `json:"S3Origin,omitempty"`
  Staging bool `json:"Staging,omitempty"`
  ViewerCertificate *ViewerCertificate `json:"ViewerCertificate,omitempty"`
  WebACLId string `json:"WebACLId,omitempty"`
}

// ForwardedValues 
type ForwardedValues struct {
  Cookies *Cookies `json:"Cookies,omitempty"`
  Headers []string `json:"Headers,omitempty"`
  QueryString bool `json:"QueryString"`
  QueryStringCacheKeys []string `json:"QueryStringCacheKeys,omitempty"`
}

// FunctionAssociation 
type FunctionAssociation struct {
  EventType string `json:"EventType,omitempty"`
  FunctionARN string `json:"FunctionARN,omitempty"`
}

// GeoRestriction 
type GeoRestriction struct {
  Locations []string `json:"Locations,omitempty"`
  RestrictionType string `json:"RestrictionType"`
}

// LambdaFunctionAssociation 
type LambdaFunctionAssociation struct {
  EventType string `json:"EventType,omitempty"`
  IncludeBody bool `json:"IncludeBody,omitempty"`
  LambdaFunctionARN string `json:"LambdaFunctionARN,omitempty"`
}

// LegacyCustomOrigin 
type LegacyCustomOrigin struct {
  DNSName string `json:"DNSName"`
  HTTPPort int `json:"HTTPPort,omitempty"`
  HTTPSPort int `json:"HTTPSPort,omitempty"`
  OriginProtocolPolicy string `json:"OriginProtocolPolicy"`
  OriginSSLProtocols []string `json:"OriginSSLProtocols"`
}

// LegacyS3Origin 
type LegacyS3Origin struct {
  DNSName string `json:"DNSName"`
  OriginAccessIdentity string `json:"OriginAccessIdentity,omitempty"`
}

// Logging 
type Logging struct {
  Bucket string `json:"Bucket"`
  IncludeCookies bool `json:"IncludeCookies,omitempty"`
  Prefix string `json:"Prefix,omitempty"`
}

// Origin 
type Origin struct {
  ConnectionAttempts int `json:"ConnectionAttempts,omitempty"`
  ConnectionTimeout int `json:"ConnectionTimeout,omitempty"`
  CustomOriginConfig *CustomOriginConfig `json:"CustomOriginConfig,omitempty"`
  DomainName string `json:"DomainName"`
  Id string `json:"Id"`
  OriginAccessControlId string `json:"OriginAccessControlId,omitempty"`
  OriginCustomHeaders []*OriginCustomHeader `json:"OriginCustomHeaders,omitempty"`
  OriginPath string `json:"OriginPath,omitempty"`
  OriginShield *OriginShield `json:"OriginShield,omitempty"`
  S3OriginConfig *S3OriginConfig `json:"S3OriginConfig,omitempty"`
}

// OriginCustomHeader 
type OriginCustomHeader struct {
  HeaderName string `json:"HeaderName"`
  HeaderValue string `json:"HeaderValue"`
}

// OriginGroup 
type OriginGroup struct {
  FailoverCriteria *OriginGroupFailoverCriteria `json:"FailoverCriteria"`
  Id string `json:"Id"`
  Members *OriginGroupMembers `json:"Members"`
}

// OriginGroupFailoverCriteria 
type OriginGroupFailoverCriteria struct {
  StatusCodes *StatusCodes `json:"StatusCodes"`
}

// OriginGroupMember 
type OriginGroupMember struct {
  OriginId string `json:"OriginId"`
}

// OriginGroupMembers 
type OriginGroupMembers struct {
  Items []*OriginGroupMember `json:"Items"`
  Quantity int `json:"Quantity"`
}

// OriginGroups 
type OriginGroups struct {
  Items []*OriginGroup `json:"Items,omitempty"`
  Quantity int `json:"Quantity"`
}

// OriginShield 
type OriginShield struct {
  Enabled bool `json:"Enabled,omitempty"`
  OriginShieldRegion string `json:"OriginShieldRegion,omitempty"`
}

// Resource Resource Type definition for AWS::CloudFront::Distribution
type Resource struct {
  DistributionConfig *DistributionConfig `json:"DistributionConfig"`
  DomainName string `json:"DomainName,omitempty"`
  Id string `json:"Id,omitempty"`
  Tags []*Tag `json:"Tags,omitempty"`
}

// Restrictions 
type Restrictions struct {
  GeoRestriction *GeoRestriction `json:"GeoRestriction"`
}

// S3OriginConfig 
type S3OriginConfig struct {
  OriginAccessIdentity string `json:"OriginAccessIdentity,omitempty"`
}

// StatusCodes 
type StatusCodes struct {
  Items []int `json:"Items"`
  Quantity int `json:"Quantity"`
}

// Tag 
type Tag struct {
  Key string `json:"Key"`
  Value string `json:"Value"`
}

// ViewerCertificate 
type ViewerCertificate struct {
  AcmCertificateArn string `json:"AcmCertificateArn,omitempty"`
  CloudFrontDefaultCertificate bool `json:"CloudFrontDefaultCertificate,omitempty"`
  IamCertificateId string `json:"IamCertificateId,omitempty"`
  MinimumProtocolVersion string `json:"MinimumProtocolVersion,omitempty"`
  SslSupportMethod string `json:"SslSupportMethod,omitempty"`
}

func (strct *CacheBehavior) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AllowedMethods" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AllowedMethods\": ")
	if tmp, err := json.Marshal(strct.AllowedMethods); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CachePolicyId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CachePolicyId\": ")
	if tmp, err := json.Marshal(strct.CachePolicyId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CachedMethods" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CachedMethods\": ")
	if tmp, err := json.Marshal(strct.CachedMethods); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Compress" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Compress\": ")
	if tmp, err := json.Marshal(strct.Compress); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DefaultTTL" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DefaultTTL\": ")
	if tmp, err := json.Marshal(strct.DefaultTTL); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FieldLevelEncryptionId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FieldLevelEncryptionId\": ")
	if tmp, err := json.Marshal(strct.FieldLevelEncryptionId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ForwardedValues" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ForwardedValues\": ")
	if tmp, err := json.Marshal(strct.ForwardedValues); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FunctionAssociations" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FunctionAssociations\": ")
	if tmp, err := json.Marshal(strct.FunctionAssociations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LambdaFunctionAssociations" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LambdaFunctionAssociations\": ")
	if tmp, err := json.Marshal(strct.LambdaFunctionAssociations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MaxTTL" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaxTTL\": ")
	if tmp, err := json.Marshal(strct.MaxTTL); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MinTTL" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MinTTL\": ")
	if tmp, err := json.Marshal(strct.MinTTL); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OriginRequestPolicyId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OriginRequestPolicyId\": ")
	if tmp, err := json.Marshal(strct.OriginRequestPolicyId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "PathPattern" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "PathPattern" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PathPattern\": ")
	if tmp, err := json.Marshal(strct.PathPattern); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RealtimeLogConfigArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RealtimeLogConfigArn\": ")
	if tmp, err := json.Marshal(strct.RealtimeLogConfigArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ResponseHeadersPolicyId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ResponseHeadersPolicyId\": ")
	if tmp, err := json.Marshal(strct.ResponseHeadersPolicyId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SmoothStreaming" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SmoothStreaming\": ")
	if tmp, err := json.Marshal(strct.SmoothStreaming); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TargetOriginId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TargetOriginId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TargetOriginId\": ")
	if tmp, err := json.Marshal(strct.TargetOriginId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TrustedKeyGroups" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TrustedKeyGroups\": ")
	if tmp, err := json.Marshal(strct.TrustedKeyGroups); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TrustedSigners" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TrustedSigners\": ")
	if tmp, err := json.Marshal(strct.TrustedSigners); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ViewerProtocolPolicy" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ViewerProtocolPolicy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ViewerProtocolPolicy\": ")
	if tmp, err := json.Marshal(strct.ViewerProtocolPolicy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CacheBehavior) UnmarshalJSON(b []byte) error {
    PathPatternReceived := false
    TargetOriginIdReceived := false
    ViewerProtocolPolicyReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AllowedMethods":
            if err := json.Unmarshal([]byte(v), &strct.AllowedMethods); err != nil {
                return err
             }
        case "CachePolicyId":
            if err := json.Unmarshal([]byte(v), &strct.CachePolicyId); err != nil {
                return err
             }
        case "CachedMethods":
            if err := json.Unmarshal([]byte(v), &strct.CachedMethods); err != nil {
                return err
             }
        case "Compress":
            if err := json.Unmarshal([]byte(v), &strct.Compress); err != nil {
                return err
             }
        case "DefaultTTL":
            if err := json.Unmarshal([]byte(v), &strct.DefaultTTL); err != nil {
                return err
             }
        case "FieldLevelEncryptionId":
            if err := json.Unmarshal([]byte(v), &strct.FieldLevelEncryptionId); err != nil {
                return err
             }
        case "ForwardedValues":
            if err := json.Unmarshal([]byte(v), &strct.ForwardedValues); err != nil {
                return err
             }
        case "FunctionAssociations":
            if err := json.Unmarshal([]byte(v), &strct.FunctionAssociations); err != nil {
                return err
             }
        case "LambdaFunctionAssociations":
            if err := json.Unmarshal([]byte(v), &strct.LambdaFunctionAssociations); err != nil {
                return err
             }
        case "MaxTTL":
            if err := json.Unmarshal([]byte(v), &strct.MaxTTL); err != nil {
                return err
             }
        case "MinTTL":
            if err := json.Unmarshal([]byte(v), &strct.MinTTL); err != nil {
                return err
             }
        case "OriginRequestPolicyId":
            if err := json.Unmarshal([]byte(v), &strct.OriginRequestPolicyId); err != nil {
                return err
             }
        case "PathPattern":
            if err := json.Unmarshal([]byte(v), &strct.PathPattern); err != nil {
                return err
             }
            PathPatternReceived = true
        case "RealtimeLogConfigArn":
            if err := json.Unmarshal([]byte(v), &strct.RealtimeLogConfigArn); err != nil {
                return err
             }
        case "ResponseHeadersPolicyId":
            if err := json.Unmarshal([]byte(v), &strct.ResponseHeadersPolicyId); err != nil {
                return err
             }
        case "SmoothStreaming":
            if err := json.Unmarshal([]byte(v), &strct.SmoothStreaming); err != nil {
                return err
             }
        case "TargetOriginId":
            if err := json.Unmarshal([]byte(v), &strct.TargetOriginId); err != nil {
                return err
             }
            TargetOriginIdReceived = true
        case "TrustedKeyGroups":
            if err := json.Unmarshal([]byte(v), &strct.TrustedKeyGroups); err != nil {
                return err
             }
        case "TrustedSigners":
            if err := json.Unmarshal([]byte(v), &strct.TrustedSigners); err != nil {
                return err
             }
        case "ViewerProtocolPolicy":
            if err := json.Unmarshal([]byte(v), &strct.ViewerProtocolPolicy); err != nil {
                return err
             }
            ViewerProtocolPolicyReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if PathPattern (a required property) was received
    if !PathPatternReceived {
        return errors.New("\"PathPattern\" is required but was not present")
    }
    // check if TargetOriginId (a required property) was received
    if !TargetOriginIdReceived {
        return errors.New("\"TargetOriginId\" is required but was not present")
    }
    // check if ViewerProtocolPolicy (a required property) was received
    if !ViewerProtocolPolicyReceived {
        return errors.New("\"ViewerProtocolPolicy\" is required but was not present")
    }
    return nil
}

func (strct *Cookies) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Forward" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Forward" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Forward\": ")
	if tmp, err := json.Marshal(strct.Forward); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "WhitelistedNames" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"WhitelistedNames\": ")
	if tmp, err := json.Marshal(strct.WhitelistedNames); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Cookies) UnmarshalJSON(b []byte) error {
    ForwardReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Forward":
            if err := json.Unmarshal([]byte(v), &strct.Forward); err != nil {
                return err
             }
            ForwardReceived = true
        case "WhitelistedNames":
            if err := json.Unmarshal([]byte(v), &strct.WhitelistedNames); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Forward (a required property) was received
    if !ForwardReceived {
        return errors.New("\"Forward\" is required but was not present")
    }
    return nil
}

func (strct *CustomErrorResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ErrorCachingMinTTL" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ErrorCachingMinTTL\": ")
	if tmp, err := json.Marshal(strct.ErrorCachingMinTTL); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ErrorCode" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ErrorCode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ErrorCode\": ")
	if tmp, err := json.Marshal(strct.ErrorCode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ResponseCode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ResponseCode\": ")
	if tmp, err := json.Marshal(strct.ResponseCode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ResponsePagePath" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ResponsePagePath\": ")
	if tmp, err := json.Marshal(strct.ResponsePagePath); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CustomErrorResponse) UnmarshalJSON(b []byte) error {
    ErrorCodeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ErrorCachingMinTTL":
            if err := json.Unmarshal([]byte(v), &strct.ErrorCachingMinTTL); err != nil {
                return err
             }
        case "ErrorCode":
            if err := json.Unmarshal([]byte(v), &strct.ErrorCode); err != nil {
                return err
             }
            ErrorCodeReceived = true
        case "ResponseCode":
            if err := json.Unmarshal([]byte(v), &strct.ResponseCode); err != nil {
                return err
             }
        case "ResponsePagePath":
            if err := json.Unmarshal([]byte(v), &strct.ResponsePagePath); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ErrorCode (a required property) was received
    if !ErrorCodeReceived {
        return errors.New("\"ErrorCode\" is required but was not present")
    }
    return nil
}

func (strct *CustomOriginConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "HTTPPort" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HTTPPort\": ")
	if tmp, err := json.Marshal(strct.HTTPPort); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "HTTPSPort" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HTTPSPort\": ")
	if tmp, err := json.Marshal(strct.HTTPSPort); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OriginKeepaliveTimeout" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OriginKeepaliveTimeout\": ")
	if tmp, err := json.Marshal(strct.OriginKeepaliveTimeout); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "OriginProtocolPolicy" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "OriginProtocolPolicy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OriginProtocolPolicy\": ")
	if tmp, err := json.Marshal(strct.OriginProtocolPolicy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OriginReadTimeout" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OriginReadTimeout\": ")
	if tmp, err := json.Marshal(strct.OriginReadTimeout); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OriginSSLProtocols" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OriginSSLProtocols\": ")
	if tmp, err := json.Marshal(strct.OriginSSLProtocols); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CustomOriginConfig) UnmarshalJSON(b []byte) error {
    OriginProtocolPolicyReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "HTTPPort":
            if err := json.Unmarshal([]byte(v), &strct.HTTPPort); err != nil {
                return err
             }
        case "HTTPSPort":
            if err := json.Unmarshal([]byte(v), &strct.HTTPSPort); err != nil {
                return err
             }
        case "OriginKeepaliveTimeout":
            if err := json.Unmarshal([]byte(v), &strct.OriginKeepaliveTimeout); err != nil {
                return err
             }
        case "OriginProtocolPolicy":
            if err := json.Unmarshal([]byte(v), &strct.OriginProtocolPolicy); err != nil {
                return err
             }
            OriginProtocolPolicyReceived = true
        case "OriginReadTimeout":
            if err := json.Unmarshal([]byte(v), &strct.OriginReadTimeout); err != nil {
                return err
             }
        case "OriginSSLProtocols":
            if err := json.Unmarshal([]byte(v), &strct.OriginSSLProtocols); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if OriginProtocolPolicy (a required property) was received
    if !OriginProtocolPolicyReceived {
        return errors.New("\"OriginProtocolPolicy\" is required but was not present")
    }
    return nil
}

func (strct *DefaultCacheBehavior) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AllowedMethods" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AllowedMethods\": ")
	if tmp, err := json.Marshal(strct.AllowedMethods); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CachePolicyId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CachePolicyId\": ")
	if tmp, err := json.Marshal(strct.CachePolicyId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CachedMethods" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CachedMethods\": ")
	if tmp, err := json.Marshal(strct.CachedMethods); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Compress" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Compress\": ")
	if tmp, err := json.Marshal(strct.Compress); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DefaultTTL" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DefaultTTL\": ")
	if tmp, err := json.Marshal(strct.DefaultTTL); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FieldLevelEncryptionId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FieldLevelEncryptionId\": ")
	if tmp, err := json.Marshal(strct.FieldLevelEncryptionId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ForwardedValues" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ForwardedValues\": ")
	if tmp, err := json.Marshal(strct.ForwardedValues); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FunctionAssociations" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FunctionAssociations\": ")
	if tmp, err := json.Marshal(strct.FunctionAssociations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LambdaFunctionAssociations" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LambdaFunctionAssociations\": ")
	if tmp, err := json.Marshal(strct.LambdaFunctionAssociations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MaxTTL" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaxTTL\": ")
	if tmp, err := json.Marshal(strct.MaxTTL); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MinTTL" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MinTTL\": ")
	if tmp, err := json.Marshal(strct.MinTTL); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OriginRequestPolicyId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OriginRequestPolicyId\": ")
	if tmp, err := json.Marshal(strct.OriginRequestPolicyId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RealtimeLogConfigArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RealtimeLogConfigArn\": ")
	if tmp, err := json.Marshal(strct.RealtimeLogConfigArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ResponseHeadersPolicyId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ResponseHeadersPolicyId\": ")
	if tmp, err := json.Marshal(strct.ResponseHeadersPolicyId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SmoothStreaming" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SmoothStreaming\": ")
	if tmp, err := json.Marshal(strct.SmoothStreaming); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TargetOriginId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TargetOriginId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TargetOriginId\": ")
	if tmp, err := json.Marshal(strct.TargetOriginId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TrustedKeyGroups" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TrustedKeyGroups\": ")
	if tmp, err := json.Marshal(strct.TrustedKeyGroups); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TrustedSigners" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TrustedSigners\": ")
	if tmp, err := json.Marshal(strct.TrustedSigners); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ViewerProtocolPolicy" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ViewerProtocolPolicy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ViewerProtocolPolicy\": ")
	if tmp, err := json.Marshal(strct.ViewerProtocolPolicy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DefaultCacheBehavior) UnmarshalJSON(b []byte) error {
    TargetOriginIdReceived := false
    ViewerProtocolPolicyReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AllowedMethods":
            if err := json.Unmarshal([]byte(v), &strct.AllowedMethods); err != nil {
                return err
             }
        case "CachePolicyId":
            if err := json.Unmarshal([]byte(v), &strct.CachePolicyId); err != nil {
                return err
             }
        case "CachedMethods":
            if err := json.Unmarshal([]byte(v), &strct.CachedMethods); err != nil {
                return err
             }
        case "Compress":
            if err := json.Unmarshal([]byte(v), &strct.Compress); err != nil {
                return err
             }
        case "DefaultTTL":
            if err := json.Unmarshal([]byte(v), &strct.DefaultTTL); err != nil {
                return err
             }
        case "FieldLevelEncryptionId":
            if err := json.Unmarshal([]byte(v), &strct.FieldLevelEncryptionId); err != nil {
                return err
             }
        case "ForwardedValues":
            if err := json.Unmarshal([]byte(v), &strct.ForwardedValues); err != nil {
                return err
             }
        case "FunctionAssociations":
            if err := json.Unmarshal([]byte(v), &strct.FunctionAssociations); err != nil {
                return err
             }
        case "LambdaFunctionAssociations":
            if err := json.Unmarshal([]byte(v), &strct.LambdaFunctionAssociations); err != nil {
                return err
             }
        case "MaxTTL":
            if err := json.Unmarshal([]byte(v), &strct.MaxTTL); err != nil {
                return err
             }
        case "MinTTL":
            if err := json.Unmarshal([]byte(v), &strct.MinTTL); err != nil {
                return err
             }
        case "OriginRequestPolicyId":
            if err := json.Unmarshal([]byte(v), &strct.OriginRequestPolicyId); err != nil {
                return err
             }
        case "RealtimeLogConfigArn":
            if err := json.Unmarshal([]byte(v), &strct.RealtimeLogConfigArn); err != nil {
                return err
             }
        case "ResponseHeadersPolicyId":
            if err := json.Unmarshal([]byte(v), &strct.ResponseHeadersPolicyId); err != nil {
                return err
             }
        case "SmoothStreaming":
            if err := json.Unmarshal([]byte(v), &strct.SmoothStreaming); err != nil {
                return err
             }
        case "TargetOriginId":
            if err := json.Unmarshal([]byte(v), &strct.TargetOriginId); err != nil {
                return err
             }
            TargetOriginIdReceived = true
        case "TrustedKeyGroups":
            if err := json.Unmarshal([]byte(v), &strct.TrustedKeyGroups); err != nil {
                return err
             }
        case "TrustedSigners":
            if err := json.Unmarshal([]byte(v), &strct.TrustedSigners); err != nil {
                return err
             }
        case "ViewerProtocolPolicy":
            if err := json.Unmarshal([]byte(v), &strct.ViewerProtocolPolicy); err != nil {
                return err
             }
            ViewerProtocolPolicyReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if TargetOriginId (a required property) was received
    if !TargetOriginIdReceived {
        return errors.New("\"TargetOriginId\" is required but was not present")
    }
    // check if ViewerProtocolPolicy (a required property) was received
    if !ViewerProtocolPolicyReceived {
        return errors.New("\"ViewerProtocolPolicy\" is required but was not present")
    }
    return nil
}

func (strct *DistributionConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Aliases" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Aliases\": ")
	if tmp, err := json.Marshal(strct.Aliases); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CNAMEs" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CNAMEs\": ")
	if tmp, err := json.Marshal(strct.CNAMEs); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CacheBehaviors" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CacheBehaviors\": ")
	if tmp, err := json.Marshal(strct.CacheBehaviors); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Comment" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Comment\": ")
	if tmp, err := json.Marshal(strct.Comment); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ContinuousDeploymentPolicyId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ContinuousDeploymentPolicyId\": ")
	if tmp, err := json.Marshal(strct.ContinuousDeploymentPolicyId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CustomErrorResponses" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CustomErrorResponses\": ")
	if tmp, err := json.Marshal(strct.CustomErrorResponses); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CustomOrigin" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CustomOrigin\": ")
	if tmp, err := json.Marshal(strct.CustomOrigin); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "DefaultCacheBehavior" field is required
    if strct.DefaultCacheBehavior == nil {
        return nil, errors.New("DefaultCacheBehavior is a required field")
    }
    // Marshal the "DefaultCacheBehavior" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DefaultCacheBehavior\": ")
	if tmp, err := json.Marshal(strct.DefaultCacheBehavior); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DefaultRootObject" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DefaultRootObject\": ")
	if tmp, err := json.Marshal(strct.DefaultRootObject); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Enabled" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Enabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "HttpVersion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HttpVersion\": ")
	if tmp, err := json.Marshal(strct.HttpVersion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IPV6Enabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IPV6Enabled\": ")
	if tmp, err := json.Marshal(strct.IPV6Enabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Logging" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Logging\": ")
	if tmp, err := json.Marshal(strct.Logging); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OriginGroups" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OriginGroups\": ")
	if tmp, err := json.Marshal(strct.OriginGroups); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Origins" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Origins\": ")
	if tmp, err := json.Marshal(strct.Origins); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PriceClass" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PriceClass\": ")
	if tmp, err := json.Marshal(strct.PriceClass); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Restrictions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Restrictions\": ")
	if tmp, err := json.Marshal(strct.Restrictions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "S3Origin" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3Origin\": ")
	if tmp, err := json.Marshal(strct.S3Origin); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Staging" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Staging\": ")
	if tmp, err := json.Marshal(strct.Staging); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ViewerCertificate" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ViewerCertificate\": ")
	if tmp, err := json.Marshal(strct.ViewerCertificate); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "WebACLId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"WebACLId\": ")
	if tmp, err := json.Marshal(strct.WebACLId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DistributionConfig) UnmarshalJSON(b []byte) error {
    DefaultCacheBehaviorReceived := false
    EnabledReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Aliases":
            if err := json.Unmarshal([]byte(v), &strct.Aliases); err != nil {
                return err
             }
        case "CNAMEs":
            if err := json.Unmarshal([]byte(v), &strct.CNAMEs); err != nil {
                return err
             }
        case "CacheBehaviors":
            if err := json.Unmarshal([]byte(v), &strct.CacheBehaviors); err != nil {
                return err
             }
        case "Comment":
            if err := json.Unmarshal([]byte(v), &strct.Comment); err != nil {
                return err
             }
        case "ContinuousDeploymentPolicyId":
            if err := json.Unmarshal([]byte(v), &strct.ContinuousDeploymentPolicyId); err != nil {
                return err
             }
        case "CustomErrorResponses":
            if err := json.Unmarshal([]byte(v), &strct.CustomErrorResponses); err != nil {
                return err
             }
        case "CustomOrigin":
            if err := json.Unmarshal([]byte(v), &strct.CustomOrigin); err != nil {
                return err
             }
        case "DefaultCacheBehavior":
            if err := json.Unmarshal([]byte(v), &strct.DefaultCacheBehavior); err != nil {
                return err
             }
            DefaultCacheBehaviorReceived = true
        case "DefaultRootObject":
            if err := json.Unmarshal([]byte(v), &strct.DefaultRootObject); err != nil {
                return err
             }
        case "Enabled":
            if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
                return err
             }
            EnabledReceived = true
        case "HttpVersion":
            if err := json.Unmarshal([]byte(v), &strct.HttpVersion); err != nil {
                return err
             }
        case "IPV6Enabled":
            if err := json.Unmarshal([]byte(v), &strct.IPV6Enabled); err != nil {
                return err
             }
        case "Logging":
            if err := json.Unmarshal([]byte(v), &strct.Logging); err != nil {
                return err
             }
        case "OriginGroups":
            if err := json.Unmarshal([]byte(v), &strct.OriginGroups); err != nil {
                return err
             }
        case "Origins":
            if err := json.Unmarshal([]byte(v), &strct.Origins); err != nil {
                return err
             }
        case "PriceClass":
            if err := json.Unmarshal([]byte(v), &strct.PriceClass); err != nil {
                return err
             }
        case "Restrictions":
            if err := json.Unmarshal([]byte(v), &strct.Restrictions); err != nil {
                return err
             }
        case "S3Origin":
            if err := json.Unmarshal([]byte(v), &strct.S3Origin); err != nil {
                return err
             }
        case "Staging":
            if err := json.Unmarshal([]byte(v), &strct.Staging); err != nil {
                return err
             }
        case "ViewerCertificate":
            if err := json.Unmarshal([]byte(v), &strct.ViewerCertificate); err != nil {
                return err
             }
        case "WebACLId":
            if err := json.Unmarshal([]byte(v), &strct.WebACLId); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if DefaultCacheBehavior (a required property) was received
    if !DefaultCacheBehaviorReceived {
        return errors.New("\"DefaultCacheBehavior\" is required but was not present")
    }
    // check if Enabled (a required property) was received
    if !EnabledReceived {
        return errors.New("\"Enabled\" is required but was not present")
    }
    return nil
}

func (strct *ForwardedValues) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Cookies" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Cookies\": ")
	if tmp, err := json.Marshal(strct.Cookies); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Headers" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Headers\": ")
	if tmp, err := json.Marshal(strct.Headers); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "QueryString" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "QueryString" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"QueryString\": ")
	if tmp, err := json.Marshal(strct.QueryString); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "QueryStringCacheKeys" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"QueryStringCacheKeys\": ")
	if tmp, err := json.Marshal(strct.QueryStringCacheKeys); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ForwardedValues) UnmarshalJSON(b []byte) error {
    QueryStringReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Cookies":
            if err := json.Unmarshal([]byte(v), &strct.Cookies); err != nil {
                return err
             }
        case "Headers":
            if err := json.Unmarshal([]byte(v), &strct.Headers); err != nil {
                return err
             }
        case "QueryString":
            if err := json.Unmarshal([]byte(v), &strct.QueryString); err != nil {
                return err
             }
            QueryStringReceived = true
        case "QueryStringCacheKeys":
            if err := json.Unmarshal([]byte(v), &strct.QueryStringCacheKeys); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if QueryString (a required property) was received
    if !QueryStringReceived {
        return errors.New("\"QueryString\" is required but was not present")
    }
    return nil
}

func (strct *FunctionAssociation) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "EventType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EventType\": ")
	if tmp, err := json.Marshal(strct.EventType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FunctionARN" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FunctionARN\": ")
	if tmp, err := json.Marshal(strct.FunctionARN); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FunctionAssociation) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "EventType":
            if err := json.Unmarshal([]byte(v), &strct.EventType); err != nil {
                return err
             }
        case "FunctionARN":
            if err := json.Unmarshal([]byte(v), &strct.FunctionARN); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *GeoRestriction) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Locations" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Locations\": ")
	if tmp, err := json.Marshal(strct.Locations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RestrictionType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RestrictionType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RestrictionType\": ")
	if tmp, err := json.Marshal(strct.RestrictionType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *GeoRestriction) UnmarshalJSON(b []byte) error {
    RestrictionTypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Locations":
            if err := json.Unmarshal([]byte(v), &strct.Locations); err != nil {
                return err
             }
        case "RestrictionType":
            if err := json.Unmarshal([]byte(v), &strct.RestrictionType); err != nil {
                return err
             }
            RestrictionTypeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if RestrictionType (a required property) was received
    if !RestrictionTypeReceived {
        return errors.New("\"RestrictionType\" is required but was not present")
    }
    return nil
}

func (strct *LambdaFunctionAssociation) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "EventType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EventType\": ")
	if tmp, err := json.Marshal(strct.EventType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IncludeBody" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IncludeBody\": ")
	if tmp, err := json.Marshal(strct.IncludeBody); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LambdaFunctionARN" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LambdaFunctionARN\": ")
	if tmp, err := json.Marshal(strct.LambdaFunctionARN); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LambdaFunctionAssociation) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "EventType":
            if err := json.Unmarshal([]byte(v), &strct.EventType); err != nil {
                return err
             }
        case "IncludeBody":
            if err := json.Unmarshal([]byte(v), &strct.IncludeBody); err != nil {
                return err
             }
        case "LambdaFunctionARN":
            if err := json.Unmarshal([]byte(v), &strct.LambdaFunctionARN); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *LegacyCustomOrigin) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "DNSName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "DNSName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DNSName\": ")
	if tmp, err := json.Marshal(strct.DNSName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "HTTPPort" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HTTPPort\": ")
	if tmp, err := json.Marshal(strct.HTTPPort); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "HTTPSPort" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HTTPSPort\": ")
	if tmp, err := json.Marshal(strct.HTTPSPort); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "OriginProtocolPolicy" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "OriginProtocolPolicy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OriginProtocolPolicy\": ")
	if tmp, err := json.Marshal(strct.OriginProtocolPolicy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "OriginSSLProtocols" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "OriginSSLProtocols" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OriginSSLProtocols\": ")
	if tmp, err := json.Marshal(strct.OriginSSLProtocols); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LegacyCustomOrigin) UnmarshalJSON(b []byte) error {
    DNSNameReceived := false
    OriginProtocolPolicyReceived := false
    OriginSSLProtocolsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DNSName":
            if err := json.Unmarshal([]byte(v), &strct.DNSName); err != nil {
                return err
             }
            DNSNameReceived = true
        case "HTTPPort":
            if err := json.Unmarshal([]byte(v), &strct.HTTPPort); err != nil {
                return err
             }
        case "HTTPSPort":
            if err := json.Unmarshal([]byte(v), &strct.HTTPSPort); err != nil {
                return err
             }
        case "OriginProtocolPolicy":
            if err := json.Unmarshal([]byte(v), &strct.OriginProtocolPolicy); err != nil {
                return err
             }
            OriginProtocolPolicyReceived = true
        case "OriginSSLProtocols":
            if err := json.Unmarshal([]byte(v), &strct.OriginSSLProtocols); err != nil {
                return err
             }
            OriginSSLProtocolsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if DNSName (a required property) was received
    if !DNSNameReceived {
        return errors.New("\"DNSName\" is required but was not present")
    }
    // check if OriginProtocolPolicy (a required property) was received
    if !OriginProtocolPolicyReceived {
        return errors.New("\"OriginProtocolPolicy\" is required but was not present")
    }
    // check if OriginSSLProtocols (a required property) was received
    if !OriginSSLProtocolsReceived {
        return errors.New("\"OriginSSLProtocols\" is required but was not present")
    }
    return nil
}

func (strct *LegacyS3Origin) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "DNSName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "DNSName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DNSName\": ")
	if tmp, err := json.Marshal(strct.DNSName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OriginAccessIdentity" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OriginAccessIdentity\": ")
	if tmp, err := json.Marshal(strct.OriginAccessIdentity); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LegacyS3Origin) UnmarshalJSON(b []byte) error {
    DNSNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DNSName":
            if err := json.Unmarshal([]byte(v), &strct.DNSName); err != nil {
                return err
             }
            DNSNameReceived = true
        case "OriginAccessIdentity":
            if err := json.Unmarshal([]byte(v), &strct.OriginAccessIdentity); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if DNSName (a required property) was received
    if !DNSNameReceived {
        return errors.New("\"DNSName\" is required but was not present")
    }
    return nil
}

func (strct *Logging) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Bucket" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Bucket" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Bucket\": ")
	if tmp, err := json.Marshal(strct.Bucket); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IncludeCookies" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IncludeCookies\": ")
	if tmp, err := json.Marshal(strct.IncludeCookies); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Prefix" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Prefix\": ")
	if tmp, err := json.Marshal(strct.Prefix); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Logging) UnmarshalJSON(b []byte) error {
    BucketReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Bucket":
            if err := json.Unmarshal([]byte(v), &strct.Bucket); err != nil {
                return err
             }
            BucketReceived = true
        case "IncludeCookies":
            if err := json.Unmarshal([]byte(v), &strct.IncludeCookies); err != nil {
                return err
             }
        case "Prefix":
            if err := json.Unmarshal([]byte(v), &strct.Prefix); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Bucket (a required property) was received
    if !BucketReceived {
        return errors.New("\"Bucket\" is required but was not present")
    }
    return nil
}

func (strct *Origin) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ConnectionAttempts" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConnectionAttempts\": ")
	if tmp, err := json.Marshal(strct.ConnectionAttempts); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ConnectionTimeout" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConnectionTimeout\": ")
	if tmp, err := json.Marshal(strct.ConnectionTimeout); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CustomOriginConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CustomOriginConfig\": ")
	if tmp, err := json.Marshal(strct.CustomOriginConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "DomainName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "DomainName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DomainName\": ")
	if tmp, err := json.Marshal(strct.DomainName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Id" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Id" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OriginAccessControlId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OriginAccessControlId\": ")
	if tmp, err := json.Marshal(strct.OriginAccessControlId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OriginCustomHeaders" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OriginCustomHeaders\": ")
	if tmp, err := json.Marshal(strct.OriginCustomHeaders); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OriginPath" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OriginPath\": ")
	if tmp, err := json.Marshal(strct.OriginPath); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OriginShield" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OriginShield\": ")
	if tmp, err := json.Marshal(strct.OriginShield); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "S3OriginConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3OriginConfig\": ")
	if tmp, err := json.Marshal(strct.S3OriginConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Origin) UnmarshalJSON(b []byte) error {
    DomainNameReceived := false
    IdReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ConnectionAttempts":
            if err := json.Unmarshal([]byte(v), &strct.ConnectionAttempts); err != nil {
                return err
             }
        case "ConnectionTimeout":
            if err := json.Unmarshal([]byte(v), &strct.ConnectionTimeout); err != nil {
                return err
             }
        case "CustomOriginConfig":
            if err := json.Unmarshal([]byte(v), &strct.CustomOriginConfig); err != nil {
                return err
             }
        case "DomainName":
            if err := json.Unmarshal([]byte(v), &strct.DomainName); err != nil {
                return err
             }
            DomainNameReceived = true
        case "Id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
            IdReceived = true
        case "OriginAccessControlId":
            if err := json.Unmarshal([]byte(v), &strct.OriginAccessControlId); err != nil {
                return err
             }
        case "OriginCustomHeaders":
            if err := json.Unmarshal([]byte(v), &strct.OriginCustomHeaders); err != nil {
                return err
             }
        case "OriginPath":
            if err := json.Unmarshal([]byte(v), &strct.OriginPath); err != nil {
                return err
             }
        case "OriginShield":
            if err := json.Unmarshal([]byte(v), &strct.OriginShield); err != nil {
                return err
             }
        case "S3OriginConfig":
            if err := json.Unmarshal([]byte(v), &strct.S3OriginConfig); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if DomainName (a required property) was received
    if !DomainNameReceived {
        return errors.New("\"DomainName\" is required but was not present")
    }
    // check if Id (a required property) was received
    if !IdReceived {
        return errors.New("\"Id\" is required but was not present")
    }
    return nil
}

func (strct *OriginCustomHeader) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "HeaderName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "HeaderName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HeaderName\": ")
	if tmp, err := json.Marshal(strct.HeaderName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "HeaderValue" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "HeaderValue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HeaderValue\": ")
	if tmp, err := json.Marshal(strct.HeaderValue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *OriginCustomHeader) UnmarshalJSON(b []byte) error {
    HeaderNameReceived := false
    HeaderValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "HeaderName":
            if err := json.Unmarshal([]byte(v), &strct.HeaderName); err != nil {
                return err
             }
            HeaderNameReceived = true
        case "HeaderValue":
            if err := json.Unmarshal([]byte(v), &strct.HeaderValue); err != nil {
                return err
             }
            HeaderValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if HeaderName (a required property) was received
    if !HeaderNameReceived {
        return errors.New("\"HeaderName\" is required but was not present")
    }
    // check if HeaderValue (a required property) was received
    if !HeaderValueReceived {
        return errors.New("\"HeaderValue\" is required but was not present")
    }
    return nil
}

func (strct *OriginGroup) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "FailoverCriteria" field is required
    if strct.FailoverCriteria == nil {
        return nil, errors.New("FailoverCriteria is a required field")
    }
    // Marshal the "FailoverCriteria" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FailoverCriteria\": ")
	if tmp, err := json.Marshal(strct.FailoverCriteria); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Id" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Id" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Members" field is required
    if strct.Members == nil {
        return nil, errors.New("Members is a required field")
    }
    // Marshal the "Members" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Members\": ")
	if tmp, err := json.Marshal(strct.Members); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *OriginGroup) UnmarshalJSON(b []byte) error {
    FailoverCriteriaReceived := false
    IdReceived := false
    MembersReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "FailoverCriteria":
            if err := json.Unmarshal([]byte(v), &strct.FailoverCriteria); err != nil {
                return err
             }
            FailoverCriteriaReceived = true
        case "Id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
            IdReceived = true
        case "Members":
            if err := json.Unmarshal([]byte(v), &strct.Members); err != nil {
                return err
             }
            MembersReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if FailoverCriteria (a required property) was received
    if !FailoverCriteriaReceived {
        return errors.New("\"FailoverCriteria\" is required but was not present")
    }
    // check if Id (a required property) was received
    if !IdReceived {
        return errors.New("\"Id\" is required but was not present")
    }
    // check if Members (a required property) was received
    if !MembersReceived {
        return errors.New("\"Members\" is required but was not present")
    }
    return nil
}

func (strct *OriginGroupFailoverCriteria) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "StatusCodes" field is required
    if strct.StatusCodes == nil {
        return nil, errors.New("StatusCodes is a required field")
    }
    // Marshal the "StatusCodes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StatusCodes\": ")
	if tmp, err := json.Marshal(strct.StatusCodes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *OriginGroupFailoverCriteria) UnmarshalJSON(b []byte) error {
    StatusCodesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "StatusCodes":
            if err := json.Unmarshal([]byte(v), &strct.StatusCodes); err != nil {
                return err
             }
            StatusCodesReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if StatusCodes (a required property) was received
    if !StatusCodesReceived {
        return errors.New("\"StatusCodes\" is required but was not present")
    }
    return nil
}

func (strct *OriginGroupMember) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "OriginId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "OriginId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OriginId\": ")
	if tmp, err := json.Marshal(strct.OriginId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *OriginGroupMember) UnmarshalJSON(b []byte) error {
    OriginIdReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "OriginId":
            if err := json.Unmarshal([]byte(v), &strct.OriginId); err != nil {
                return err
             }
            OriginIdReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if OriginId (a required property) was received
    if !OriginIdReceived {
        return errors.New("\"OriginId\" is required but was not present")
    }
    return nil
}

func (strct *OriginGroupMembers) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Items" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Items" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Items\": ")
	if tmp, err := json.Marshal(strct.Items); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Quantity" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Quantity" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Quantity\": ")
	if tmp, err := json.Marshal(strct.Quantity); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *OriginGroupMembers) UnmarshalJSON(b []byte) error {
    ItemsReceived := false
    QuantityReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Items":
            if err := json.Unmarshal([]byte(v), &strct.Items); err != nil {
                return err
             }
            ItemsReceived = true
        case "Quantity":
            if err := json.Unmarshal([]byte(v), &strct.Quantity); err != nil {
                return err
             }
            QuantityReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Items (a required property) was received
    if !ItemsReceived {
        return errors.New("\"Items\" is required but was not present")
    }
    // check if Quantity (a required property) was received
    if !QuantityReceived {
        return errors.New("\"Quantity\" is required but was not present")
    }
    return nil
}

func (strct *OriginGroups) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Items" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Items\": ")
	if tmp, err := json.Marshal(strct.Items); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Quantity" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Quantity" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Quantity\": ")
	if tmp, err := json.Marshal(strct.Quantity); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *OriginGroups) UnmarshalJSON(b []byte) error {
    QuantityReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Items":
            if err := json.Unmarshal([]byte(v), &strct.Items); err != nil {
                return err
             }
        case "Quantity":
            if err := json.Unmarshal([]byte(v), &strct.Quantity); err != nil {
                return err
             }
            QuantityReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Quantity (a required property) was received
    if !QuantityReceived {
        return errors.New("\"Quantity\" is required but was not present")
    }
    return nil
}

func (strct *OriginShield) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Enabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OriginShieldRegion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OriginShieldRegion\": ")
	if tmp, err := json.Marshal(strct.OriginShieldRegion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *OriginShield) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Enabled":
            if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
                return err
             }
        case "OriginShieldRegion":
            if err := json.Unmarshal([]byte(v), &strct.OriginShieldRegion); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "DistributionConfig" field is required
    if strct.DistributionConfig == nil {
        return nil, errors.New("DistributionConfig is a required field")
    }
    // Marshal the "DistributionConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DistributionConfig\": ")
	if tmp, err := json.Marshal(strct.DistributionConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DomainName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DomainName\": ")
	if tmp, err := json.Marshal(strct.DomainName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Id" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    DistributionConfigReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DistributionConfig":
            if err := json.Unmarshal([]byte(v), &strct.DistributionConfig); err != nil {
                return err
             }
            DistributionConfigReceived = true
        case "DomainName":
            if err := json.Unmarshal([]byte(v), &strct.DomainName); err != nil {
                return err
             }
        case "Id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if DistributionConfig (a required property) was received
    if !DistributionConfigReceived {
        return errors.New("\"DistributionConfig\" is required but was not present")
    }
    return nil
}

func (strct *Restrictions) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "GeoRestriction" field is required
    if strct.GeoRestriction == nil {
        return nil, errors.New("GeoRestriction is a required field")
    }
    // Marshal the "GeoRestriction" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"GeoRestriction\": ")
	if tmp, err := json.Marshal(strct.GeoRestriction); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Restrictions) UnmarshalJSON(b []byte) error {
    GeoRestrictionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "GeoRestriction":
            if err := json.Unmarshal([]byte(v), &strct.GeoRestriction); err != nil {
                return err
             }
            GeoRestrictionReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if GeoRestriction (a required property) was received
    if !GeoRestrictionReceived {
        return errors.New("\"GeoRestriction\" is required but was not present")
    }
    return nil
}

func (strct *S3OriginConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "OriginAccessIdentity" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OriginAccessIdentity\": ")
	if tmp, err := json.Marshal(strct.OriginAccessIdentity); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *S3OriginConfig) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "OriginAccessIdentity":
            if err := json.Unmarshal([]byte(v), &strct.OriginAccessIdentity); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *StatusCodes) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Items" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Items" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Items\": ")
	if tmp, err := json.Marshal(strct.Items); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Quantity" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Quantity" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Quantity\": ")
	if tmp, err := json.Marshal(strct.Quantity); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *StatusCodes) UnmarshalJSON(b []byte) error {
    ItemsReceived := false
    QuantityReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Items":
            if err := json.Unmarshal([]byte(v), &strct.Items); err != nil {
                return err
             }
            ItemsReceived = true
        case "Quantity":
            if err := json.Unmarshal([]byte(v), &strct.Quantity); err != nil {
                return err
             }
            QuantityReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Items (a required property) was received
    if !ItemsReceived {
        return errors.New("\"Items\" is required but was not present")
    }
    // check if Quantity (a required property) was received
    if !QuantityReceived {
        return errors.New("\"Quantity\" is required but was not present")
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *ViewerCertificate) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AcmCertificateArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AcmCertificateArn\": ")
	if tmp, err := json.Marshal(strct.AcmCertificateArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CloudFrontDefaultCertificate" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CloudFrontDefaultCertificate\": ")
	if tmp, err := json.Marshal(strct.CloudFrontDefaultCertificate); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IamCertificateId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IamCertificateId\": ")
	if tmp, err := json.Marshal(strct.IamCertificateId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MinimumProtocolVersion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MinimumProtocolVersion\": ")
	if tmp, err := json.Marshal(strct.MinimumProtocolVersion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SslSupportMethod" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SslSupportMethod\": ")
	if tmp, err := json.Marshal(strct.SslSupportMethod); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ViewerCertificate) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AcmCertificateArn":
            if err := json.Unmarshal([]byte(v), &strct.AcmCertificateArn); err != nil {
                return err
             }
        case "CloudFrontDefaultCertificate":
            if err := json.Unmarshal([]byte(v), &strct.CloudFrontDefaultCertificate); err != nil {
                return err
             }
        case "IamCertificateId":
            if err := json.Unmarshal([]byte(v), &strct.IamCertificateId); err != nil {
                return err
             }
        case "MinimumProtocolVersion":
            if err := json.Unmarshal([]byte(v), &strct.MinimumProtocolVersion); err != nil {
                return err
             }
        case "SslSupportMethod":
            if err := json.Unmarshal([]byte(v), &strct.SslSupportMethod); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}
