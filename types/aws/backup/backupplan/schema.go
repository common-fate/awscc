// Code generated by schema-generate. DO NOT EDIT.

package backupplan

import (
    "bytes"
    "errors"
    "encoding/json"
    "fmt"
)

// AdvancedBackupSettingResourceType 
type AdvancedBackupSettingResourceType struct {
  BackupOptions *BackupOptions `json:"BackupOptions"`
  ResourceType string `json:"ResourceType"`
}

// BackupOptions 
type BackupOptions struct {
}

// BackupPlanResourceType 
type BackupPlanResourceType struct {
  AdvancedBackupSettings []*AdvancedBackupSettingResourceType `json:"AdvancedBackupSettings,omitempty"`
  BackupPlanName string `json:"BackupPlanName"`
  BackupPlanRule []*BackupRuleResourceType `json:"BackupPlanRule"`
}

// BackupPlanTags 
type BackupPlanTags struct {
}

// BackupRuleResourceType 
type BackupRuleResourceType struct {
  CompletionWindowMinutes float64 `json:"CompletionWindowMinutes,omitempty"`
  CopyActions []*CopyActionResourceType `json:"CopyActions,omitempty"`
  EnableContinuousBackup bool `json:"EnableContinuousBackup,omitempty"`
  Lifecycle *LifecycleResourceType `json:"Lifecycle,omitempty"`
  RecoveryPointTags *RecoveryPointTags `json:"RecoveryPointTags,omitempty"`
  RuleName string `json:"RuleName"`
  ScheduleExpression string `json:"ScheduleExpression,omitempty"`
  StartWindowMinutes float64 `json:"StartWindowMinutes,omitempty"`
  TargetBackupVault string `json:"TargetBackupVault"`
}

// CopyActionResourceType 
type CopyActionResourceType struct {
  DestinationBackupVaultArn string `json:"DestinationBackupVaultArn"`
  Lifecycle *LifecycleResourceType `json:"Lifecycle,omitempty"`
}

// LifecycleResourceType 
type LifecycleResourceType struct {
  DeleteAfterDays float64 `json:"DeleteAfterDays,omitempty"`
  MoveToColdStorageAfterDays float64 `json:"MoveToColdStorageAfterDays,omitempty"`
}

// RecoveryPointTags 
type RecoveryPointTags struct {
}

// Resource Resource Type definition for AWS::Backup::BackupPlan
type Resource struct {
  BackupPlan *BackupPlanResourceType `json:"BackupPlan"`
  BackupPlanArn string `json:"BackupPlanArn,omitempty"`
  BackupPlanId string `json:"BackupPlanId,omitempty"`
  BackupPlanTags *BackupPlanTags `json:"BackupPlanTags,omitempty"`
  VersionId string `json:"VersionId,omitempty"`
}

func (strct *AdvancedBackupSettingResourceType) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "BackupOptions" field is required
    if strct.BackupOptions == nil {
        return nil, errors.New("BackupOptions is a required field")
    }
    // Marshal the "BackupOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BackupOptions\": ")
	if tmp, err := json.Marshal(strct.BackupOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ResourceType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ResourceType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ResourceType\": ")
	if tmp, err := json.Marshal(strct.ResourceType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AdvancedBackupSettingResourceType) UnmarshalJSON(b []byte) error {
    BackupOptionsReceived := false
    ResourceTypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BackupOptions":
            if err := json.Unmarshal([]byte(v), &strct.BackupOptions); err != nil {
                return err
             }
            BackupOptionsReceived = true
        case "ResourceType":
            if err := json.Unmarshal([]byte(v), &strct.ResourceType); err != nil {
                return err
             }
            ResourceTypeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if BackupOptions (a required property) was received
    if !BackupOptionsReceived {
        return errors.New("\"BackupOptions\" is required but was not present")
    }
    // check if ResourceType (a required property) was received
    if !ResourceTypeReceived {
        return errors.New("\"ResourceType\" is required but was not present")
    }
    return nil
}

func (strct *BackupPlanResourceType) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AdvancedBackupSettings" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AdvancedBackupSettings\": ")
	if tmp, err := json.Marshal(strct.AdvancedBackupSettings); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "BackupPlanName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "BackupPlanName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BackupPlanName\": ")
	if tmp, err := json.Marshal(strct.BackupPlanName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "BackupPlanRule" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "BackupPlanRule" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BackupPlanRule\": ")
	if tmp, err := json.Marshal(strct.BackupPlanRule); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BackupPlanResourceType) UnmarshalJSON(b []byte) error {
    BackupPlanNameReceived := false
    BackupPlanRuleReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AdvancedBackupSettings":
            if err := json.Unmarshal([]byte(v), &strct.AdvancedBackupSettings); err != nil {
                return err
             }
        case "BackupPlanName":
            if err := json.Unmarshal([]byte(v), &strct.BackupPlanName); err != nil {
                return err
             }
            BackupPlanNameReceived = true
        case "BackupPlanRule":
            if err := json.Unmarshal([]byte(v), &strct.BackupPlanRule); err != nil {
                return err
             }
            BackupPlanRuleReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if BackupPlanName (a required property) was received
    if !BackupPlanNameReceived {
        return errors.New("\"BackupPlanName\" is required but was not present")
    }
    // check if BackupPlanRule (a required property) was received
    if !BackupPlanRuleReceived {
        return errors.New("\"BackupPlanRule\" is required but was not present")
    }
    return nil
}

func (strct *BackupPlanTags) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BackupPlanTags) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *BackupRuleResourceType) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CompletionWindowMinutes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CompletionWindowMinutes\": ")
	if tmp, err := json.Marshal(strct.CompletionWindowMinutes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CopyActions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CopyActions\": ")
	if tmp, err := json.Marshal(strct.CopyActions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EnableContinuousBackup" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EnableContinuousBackup\": ")
	if tmp, err := json.Marshal(strct.EnableContinuousBackup); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Lifecycle" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Lifecycle\": ")
	if tmp, err := json.Marshal(strct.Lifecycle); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RecoveryPointTags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RecoveryPointTags\": ")
	if tmp, err := json.Marshal(strct.RecoveryPointTags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RuleName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RuleName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RuleName\": ")
	if tmp, err := json.Marshal(strct.RuleName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ScheduleExpression" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ScheduleExpression\": ")
	if tmp, err := json.Marshal(strct.ScheduleExpression); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StartWindowMinutes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StartWindowMinutes\": ")
	if tmp, err := json.Marshal(strct.StartWindowMinutes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TargetBackupVault" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TargetBackupVault" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TargetBackupVault\": ")
	if tmp, err := json.Marshal(strct.TargetBackupVault); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BackupRuleResourceType) UnmarshalJSON(b []byte) error {
    RuleNameReceived := false
    TargetBackupVaultReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CompletionWindowMinutes":
            if err := json.Unmarshal([]byte(v), &strct.CompletionWindowMinutes); err != nil {
                return err
             }
        case "CopyActions":
            if err := json.Unmarshal([]byte(v), &strct.CopyActions); err != nil {
                return err
             }
        case "EnableContinuousBackup":
            if err := json.Unmarshal([]byte(v), &strct.EnableContinuousBackup); err != nil {
                return err
             }
        case "Lifecycle":
            if err := json.Unmarshal([]byte(v), &strct.Lifecycle); err != nil {
                return err
             }
        case "RecoveryPointTags":
            if err := json.Unmarshal([]byte(v), &strct.RecoveryPointTags); err != nil {
                return err
             }
        case "RuleName":
            if err := json.Unmarshal([]byte(v), &strct.RuleName); err != nil {
                return err
             }
            RuleNameReceived = true
        case "ScheduleExpression":
            if err := json.Unmarshal([]byte(v), &strct.ScheduleExpression); err != nil {
                return err
             }
        case "StartWindowMinutes":
            if err := json.Unmarshal([]byte(v), &strct.StartWindowMinutes); err != nil {
                return err
             }
        case "TargetBackupVault":
            if err := json.Unmarshal([]byte(v), &strct.TargetBackupVault); err != nil {
                return err
             }
            TargetBackupVaultReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if RuleName (a required property) was received
    if !RuleNameReceived {
        return errors.New("\"RuleName\" is required but was not present")
    }
    // check if TargetBackupVault (a required property) was received
    if !TargetBackupVaultReceived {
        return errors.New("\"TargetBackupVault\" is required but was not present")
    }
    return nil
}

func (strct *CopyActionResourceType) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "DestinationBackupVaultArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "DestinationBackupVaultArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DestinationBackupVaultArn\": ")
	if tmp, err := json.Marshal(strct.DestinationBackupVaultArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Lifecycle" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Lifecycle\": ")
	if tmp, err := json.Marshal(strct.Lifecycle); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CopyActionResourceType) UnmarshalJSON(b []byte) error {
    DestinationBackupVaultArnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DestinationBackupVaultArn":
            if err := json.Unmarshal([]byte(v), &strct.DestinationBackupVaultArn); err != nil {
                return err
             }
            DestinationBackupVaultArnReceived = true
        case "Lifecycle":
            if err := json.Unmarshal([]byte(v), &strct.Lifecycle); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if DestinationBackupVaultArn (a required property) was received
    if !DestinationBackupVaultArnReceived {
        return errors.New("\"DestinationBackupVaultArn\" is required but was not present")
    }
    return nil
}

func (strct *LifecycleResourceType) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DeleteAfterDays" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DeleteAfterDays\": ")
	if tmp, err := json.Marshal(strct.DeleteAfterDays); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MoveToColdStorageAfterDays" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MoveToColdStorageAfterDays\": ")
	if tmp, err := json.Marshal(strct.MoveToColdStorageAfterDays); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LifecycleResourceType) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DeleteAfterDays":
            if err := json.Unmarshal([]byte(v), &strct.DeleteAfterDays); err != nil {
                return err
             }
        case "MoveToColdStorageAfterDays":
            if err := json.Unmarshal([]byte(v), &strct.MoveToColdStorageAfterDays); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *RecoveryPointTags) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RecoveryPointTags) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "BackupPlan" field is required
    if strct.BackupPlan == nil {
        return nil, errors.New("BackupPlan is a required field")
    }
    // Marshal the "BackupPlan" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BackupPlan\": ")
	if tmp, err := json.Marshal(strct.BackupPlan); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BackupPlanArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BackupPlanArn\": ")
	if tmp, err := json.Marshal(strct.BackupPlanArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BackupPlanId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BackupPlanId\": ")
	if tmp, err := json.Marshal(strct.BackupPlanId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BackupPlanTags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BackupPlanTags\": ")
	if tmp, err := json.Marshal(strct.BackupPlanTags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VersionId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VersionId\": ")
	if tmp, err := json.Marshal(strct.VersionId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    BackupPlanReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BackupPlan":
            if err := json.Unmarshal([]byte(v), &strct.BackupPlan); err != nil {
                return err
             }
            BackupPlanReceived = true
        case "BackupPlanArn":
            if err := json.Unmarshal([]byte(v), &strct.BackupPlanArn); err != nil {
                return err
             }
        case "BackupPlanId":
            if err := json.Unmarshal([]byte(v), &strct.BackupPlanId); err != nil {
                return err
             }
        case "BackupPlanTags":
            if err := json.Unmarshal([]byte(v), &strct.BackupPlanTags); err != nil {
                return err
             }
        case "VersionId":
            if err := json.Unmarshal([]byte(v), &strct.VersionId); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if BackupPlan (a required property) was received
    if !BackupPlanReceived {
        return errors.New("\"BackupPlan\" is required but was not present")
    }
    return nil
}
