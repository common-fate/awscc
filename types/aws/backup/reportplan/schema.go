// Code generated by schema-generate. DO NOT EDIT.

package reportplan

import (
    "errors"
    "bytes"
    "encoding/json"
    "fmt"
)

// ReportDeliveryChannel A structure that contains information about where and how to deliver your reports, specifically your Amazon S3 bucket name, S3 key prefix, and the formats of your reports.
type ReportDeliveryChannel struct {

  // A list of the format of your reports: CSV, JSON, or both. If not specified, the default format is CSV.
  Formats []string `json:"Formats,omitempty"`

  // The unique name of the S3 bucket that receives your reports.
  S3BucketName string `json:"S3BucketName"`

  // The prefix for where AWS Backup Audit Manager delivers your reports to Amazon S3. The prefix is this part of the following path: s3://your-bucket-name/prefix/Backup/us-west-2/year/month/day/report-name. If not specified, there is no prefix.
  S3KeyPrefix string `json:"S3KeyPrefix,omitempty"`
}

// ReportSetting Identifies the report template for the report. Reports are built using a report template.
type ReportSetting struct {

  // The list of AWS accounts that a report covers.
  Accounts []string `json:"Accounts,omitempty"`

  // The Amazon Resource Names (ARNs) of the frameworks a report covers.
  FrameworkArns []string `json:"FrameworkArns,omitempty"`

  // The list of AWS organization units that a report covers.
  OrganizationUnits []string `json:"OrganizationUnits,omitempty"`

  // The list of AWS regions that a report covers.
  Regions []string `json:"Regions,omitempty"`

  // Identifies the report template for the report. Reports are built using a report template. The report templates are: `BACKUP_JOB_REPORT | COPY_JOB_REPORT | RESTORE_JOB_REPORT`
  ReportTemplate string `json:"ReportTemplate"`
}

// Resource Contains detailed information about a report plan in AWS Backup Audit Manager.
type Resource struct {

  // A structure that contains information about where and how to deliver your reports, specifically your Amazon S3 bucket name, S3 key prefix, and the formats of your reports.
  ReportDeliveryChannel *ReportDeliveryChannel `json:"ReportDeliveryChannel"`

  // An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
  ReportPlanArn string `json:"ReportPlanArn,omitempty"`

  // An optional description of the report plan with a maximum of 1,024 characters.
  ReportPlanDescription string `json:"ReportPlanDescription,omitempty"`

  // The unique name of the report plan. The name must be between 1 and 256 characters, starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).
  ReportPlanName string `json:"ReportPlanName,omitempty"`

  // Metadata that you can assign to help organize the report plans that you create. Each tag is a key-value pair.
  ReportPlanTags []*Tag `json:"ReportPlanTags,omitempty"`

  // Identifies the report template for the report. Reports are built using a report template.
  ReportSetting *ReportSetting `json:"ReportSetting"`
}

// Tag A key-value pair to associate with a resource.
type Tag struct {

  // The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
  Key string `json:"Key,omitempty"`

  // The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
  Value string `json:"Value,omitempty"`
}

func (strct *ReportDeliveryChannel) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Formats" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Formats\": ")
	if tmp, err := json.Marshal(strct.Formats); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "S3BucketName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "S3BucketName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3BucketName\": ")
	if tmp, err := json.Marshal(strct.S3BucketName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "S3KeyPrefix" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3KeyPrefix\": ")
	if tmp, err := json.Marshal(strct.S3KeyPrefix); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ReportDeliveryChannel) UnmarshalJSON(b []byte) error {
    S3BucketNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Formats":
            if err := json.Unmarshal([]byte(v), &strct.Formats); err != nil {
                return err
             }
        case "S3BucketName":
            if err := json.Unmarshal([]byte(v), &strct.S3BucketName); err != nil {
                return err
             }
            S3BucketNameReceived = true
        case "S3KeyPrefix":
            if err := json.Unmarshal([]byte(v), &strct.S3KeyPrefix); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if S3BucketName (a required property) was received
    if !S3BucketNameReceived {
        return errors.New("\"S3BucketName\" is required but was not present")
    }
    return nil
}

func (strct *ReportSetting) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Accounts" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Accounts\": ")
	if tmp, err := json.Marshal(strct.Accounts); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FrameworkArns" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FrameworkArns\": ")
	if tmp, err := json.Marshal(strct.FrameworkArns); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OrganizationUnits" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OrganizationUnits\": ")
	if tmp, err := json.Marshal(strct.OrganizationUnits); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Regions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Regions\": ")
	if tmp, err := json.Marshal(strct.Regions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ReportTemplate" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ReportTemplate" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ReportTemplate\": ")
	if tmp, err := json.Marshal(strct.ReportTemplate); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ReportSetting) UnmarshalJSON(b []byte) error {
    ReportTemplateReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Accounts":
            if err := json.Unmarshal([]byte(v), &strct.Accounts); err != nil {
                return err
             }
        case "FrameworkArns":
            if err := json.Unmarshal([]byte(v), &strct.FrameworkArns); err != nil {
                return err
             }
        case "OrganizationUnits":
            if err := json.Unmarshal([]byte(v), &strct.OrganizationUnits); err != nil {
                return err
             }
        case "Regions":
            if err := json.Unmarshal([]byte(v), &strct.Regions); err != nil {
                return err
             }
        case "ReportTemplate":
            if err := json.Unmarshal([]byte(v), &strct.ReportTemplate); err != nil {
                return err
             }
            ReportTemplateReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ReportTemplate (a required property) was received
    if !ReportTemplateReceived {
        return errors.New("\"ReportTemplate\" is required but was not present")
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ReportDeliveryChannel" field is required
    if strct.ReportDeliveryChannel == nil {
        return nil, errors.New("ReportDeliveryChannel is a required field")
    }
    // Marshal the "ReportDeliveryChannel" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ReportDeliveryChannel\": ")
	if tmp, err := json.Marshal(strct.ReportDeliveryChannel); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ReportPlanArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ReportPlanArn\": ")
	if tmp, err := json.Marshal(strct.ReportPlanArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ReportPlanDescription" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ReportPlanDescription\": ")
	if tmp, err := json.Marshal(strct.ReportPlanDescription); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ReportPlanName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ReportPlanName\": ")
	if tmp, err := json.Marshal(strct.ReportPlanName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ReportPlanTags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ReportPlanTags\": ")
	if tmp, err := json.Marshal(strct.ReportPlanTags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ReportSetting" field is required
    if strct.ReportSetting == nil {
        return nil, errors.New("ReportSetting is a required field")
    }
    // Marshal the "ReportSetting" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ReportSetting\": ")
	if tmp, err := json.Marshal(strct.ReportSetting); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    ReportDeliveryChannelReceived := false
    ReportSettingReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ReportDeliveryChannel":
            if err := json.Unmarshal([]byte(v), &strct.ReportDeliveryChannel); err != nil {
                return err
             }
            ReportDeliveryChannelReceived = true
        case "ReportPlanArn":
            if err := json.Unmarshal([]byte(v), &strct.ReportPlanArn); err != nil {
                return err
             }
        case "ReportPlanDescription":
            if err := json.Unmarshal([]byte(v), &strct.ReportPlanDescription); err != nil {
                return err
             }
        case "ReportPlanName":
            if err := json.Unmarshal([]byte(v), &strct.ReportPlanName); err != nil {
                return err
             }
        case "ReportPlanTags":
            if err := json.Unmarshal([]byte(v), &strct.ReportPlanTags); err != nil {
                return err
             }
        case "ReportSetting":
            if err := json.Unmarshal([]byte(v), &strct.ReportSetting); err != nil {
                return err
             }
            ReportSettingReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ReportDeliveryChannel (a required property) was received
    if !ReportDeliveryChannelReceived {
        return errors.New("\"ReportDeliveryChannel\" is required but was not present")
    }
    // check if ReportSetting (a required property) was received
    if !ReportSettingReceived {
        return errors.New("\"ReportSetting\" is required but was not present")
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}
