// Code generated by schema-generate. DO NOT EDIT.

package backupvault

import (
    "encoding/json"
    "fmt"
    "errors"
    "bytes"
)

// AccessPolicy_object 
type AccessPolicy_object struct {
}

// BackupVaultTags 
type BackupVaultTags struct {
}

// LockConfigurationType 
type LockConfigurationType struct {
  ChangeableForDays int `json:"ChangeableForDays,omitempty"`
  MaxRetentionDays int `json:"MaxRetentionDays,omitempty"`
  MinRetentionDays int `json:"MinRetentionDays"`
}

// NotificationObjectType 
type NotificationObjectType struct {
  BackupVaultEvents []string `json:"BackupVaultEvents"`
  SNSTopicArn string `json:"SNSTopicArn"`
}

// Resource Resource Type definition for AWS::Backup::BackupVault
type Resource struct {
  AccessPolicy interface{} `json:"AccessPolicy,omitempty"`
  BackupVaultArn string `json:"BackupVaultArn,omitempty"`
  BackupVaultName string `json:"BackupVaultName"`
  BackupVaultTags *BackupVaultTags `json:"BackupVaultTags,omitempty"`
  EncryptionKeyArn string `json:"EncryptionKeyArn,omitempty"`
  LockConfiguration *LockConfigurationType `json:"LockConfiguration,omitempty"`
  Notifications *NotificationObjectType `json:"Notifications,omitempty"`
}

func (strct *BackupVaultTags) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BackupVaultTags) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *LockConfigurationType) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ChangeableForDays" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ChangeableForDays\": ")
	if tmp, err := json.Marshal(strct.ChangeableForDays); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MaxRetentionDays" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaxRetentionDays\": ")
	if tmp, err := json.Marshal(strct.MaxRetentionDays); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "MinRetentionDays" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "MinRetentionDays" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MinRetentionDays\": ")
	if tmp, err := json.Marshal(strct.MinRetentionDays); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LockConfigurationType) UnmarshalJSON(b []byte) error {
    MinRetentionDaysReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ChangeableForDays":
            if err := json.Unmarshal([]byte(v), &strct.ChangeableForDays); err != nil {
                return err
             }
        case "MaxRetentionDays":
            if err := json.Unmarshal([]byte(v), &strct.MaxRetentionDays); err != nil {
                return err
             }
        case "MinRetentionDays":
            if err := json.Unmarshal([]byte(v), &strct.MinRetentionDays); err != nil {
                return err
             }
            MinRetentionDaysReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if MinRetentionDays (a required property) was received
    if !MinRetentionDaysReceived {
        return errors.New("\"MinRetentionDays\" is required but was not present")
    }
    return nil
}

func (strct *NotificationObjectType) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "BackupVaultEvents" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "BackupVaultEvents" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BackupVaultEvents\": ")
	if tmp, err := json.Marshal(strct.BackupVaultEvents); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "SNSTopicArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "SNSTopicArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SNSTopicArn\": ")
	if tmp, err := json.Marshal(strct.SNSTopicArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *NotificationObjectType) UnmarshalJSON(b []byte) error {
    BackupVaultEventsReceived := false
    SNSTopicArnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BackupVaultEvents":
            if err := json.Unmarshal([]byte(v), &strct.BackupVaultEvents); err != nil {
                return err
             }
            BackupVaultEventsReceived = true
        case "SNSTopicArn":
            if err := json.Unmarshal([]byte(v), &strct.SNSTopicArn); err != nil {
                return err
             }
            SNSTopicArnReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if BackupVaultEvents (a required property) was received
    if !BackupVaultEventsReceived {
        return errors.New("\"BackupVaultEvents\" is required but was not present")
    }
    // check if SNSTopicArn (a required property) was received
    if !SNSTopicArnReceived {
        return errors.New("\"SNSTopicArn\" is required but was not present")
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AccessPolicy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AccessPolicy\": ")
	if tmp, err := json.Marshal(strct.AccessPolicy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BackupVaultArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BackupVaultArn\": ")
	if tmp, err := json.Marshal(strct.BackupVaultArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "BackupVaultName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "BackupVaultName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BackupVaultName\": ")
	if tmp, err := json.Marshal(strct.BackupVaultName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BackupVaultTags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BackupVaultTags\": ")
	if tmp, err := json.Marshal(strct.BackupVaultTags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EncryptionKeyArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EncryptionKeyArn\": ")
	if tmp, err := json.Marshal(strct.EncryptionKeyArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LockConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LockConfiguration\": ")
	if tmp, err := json.Marshal(strct.LockConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Notifications" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Notifications\": ")
	if tmp, err := json.Marshal(strct.Notifications); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    BackupVaultNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AccessPolicy":
            if err := json.Unmarshal([]byte(v), &strct.AccessPolicy); err != nil {
                return err
             }
        case "BackupVaultArn":
            if err := json.Unmarshal([]byte(v), &strct.BackupVaultArn); err != nil {
                return err
             }
        case "BackupVaultName":
            if err := json.Unmarshal([]byte(v), &strct.BackupVaultName); err != nil {
                return err
             }
            BackupVaultNameReceived = true
        case "BackupVaultTags":
            if err := json.Unmarshal([]byte(v), &strct.BackupVaultTags); err != nil {
                return err
             }
        case "EncryptionKeyArn":
            if err := json.Unmarshal([]byte(v), &strct.EncryptionKeyArn); err != nil {
                return err
             }
        case "LockConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.LockConfiguration); err != nil {
                return err
             }
        case "Notifications":
            if err := json.Unmarshal([]byte(v), &strct.Notifications); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if BackupVaultName (a required property) was received
    if !BackupVaultNameReceived {
        return errors.New("\"BackupVaultName\" is required but was not present")
    }
    return nil
}
