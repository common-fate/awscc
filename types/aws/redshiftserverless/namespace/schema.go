// Code generated by schema-generate. DO NOT EDIT.

package namespace

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// Namespace 
type Namespace struct {
  AdminUsername string `json:"AdminUsername,omitempty"`
  CreationDate string `json:"CreationDate,omitempty"`
  DbName string `json:"DbName,omitempty"`
  DefaultIamRoleArn string `json:"DefaultIamRoleArn,omitempty"`
  IamRoles []string `json:"IamRoles,omitempty"`
  KmsKeyId string `json:"KmsKeyId,omitempty"`
  LogExports []string `json:"LogExports,omitempty"`
  NamespaceArn string `json:"NamespaceArn,omitempty"`
  NamespaceId string `json:"NamespaceId,omitempty"`
  NamespaceName string `json:"NamespaceName,omitempty"`
  Status string `json:"Status,omitempty"`
}

// Resource Definition of AWS::RedshiftServerless::Namespace Resource Type
type Resource struct {

  // The password associated with the admin user for the namespace that is being created. Password must be at least 8 characters in length, should be any printable ASCII character. Must contain at least one lowercase letter, one uppercase letter and one decimal digit.
  AdminUserPassword string `json:"AdminUserPassword,omitempty"`

  // The user name associated with the admin user for the namespace that is being created. Only alphanumeric characters and underscores are allowed. It should start with an alphabet.
  AdminUsername string `json:"AdminUsername,omitempty"`

  // The database name associated for the namespace that is being created. Only alphanumeric characters and underscores are allowed. It should start with an alphabet.
  DbName string `json:"DbName,omitempty"`

  // The default IAM role ARN for the namespace that is being created.
  DefaultIamRoleArn string `json:"DefaultIamRoleArn,omitempty"`

  // The name of the namespace the source snapshot was created from. Please specify the name if needed before deleting namespace
  FinalSnapshotName string `json:"FinalSnapshotName,omitempty"`

  // The number of days to retain automated snapshot in the destination region after they are copied from the source region. If the value is -1, the manual snapshot is retained indefinitely. The value must be either -1 or an integer between 1 and 3,653.
  FinalSnapshotRetentionPeriod int `json:"FinalSnapshotRetentionPeriod,omitempty"`

  // A list of AWS Identity and Access Management (IAM) roles that can be used by the namespace to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. The Default role limit for each request is 10.
  IamRoles []string `json:"IamRoles,omitempty"`

  // The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the namespace.
  KmsKeyId string `json:"KmsKeyId,omitempty"`

  // The collection of log types to be exported provided by the customer. Should only be one of the three supported log types: userlog, useractivitylog and connectionlog
  LogExports []string `json:"LogExports,omitempty"`
  Namespace *Namespace `json:"Namespace,omitempty"`

  // A unique identifier for the namespace. You use this identifier to refer to the namespace for any subsequent namespace operations such as deleting or modifying. All alphabetical characters must be lower case. Namespace name should be unique for all namespaces within an AWS account.
  NamespaceName string `json:"NamespaceName"`

  // The list of tags for the namespace.
  Tags []*Tag `json:"Tags,omitempty"`
}

// Tag 
type Tag struct {
  Key string `json:"Key"`
  Value string `json:"Value"`
}

func (strct *Namespace) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AdminUsername" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AdminUsername\": ")
	if tmp, err := json.Marshal(strct.AdminUsername); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CreationDate" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CreationDate\": ")
	if tmp, err := json.Marshal(strct.CreationDate); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DbName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DbName\": ")
	if tmp, err := json.Marshal(strct.DbName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DefaultIamRoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DefaultIamRoleArn\": ")
	if tmp, err := json.Marshal(strct.DefaultIamRoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IamRoles" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IamRoles\": ")
	if tmp, err := json.Marshal(strct.IamRoles); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "KmsKeyId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KmsKeyId\": ")
	if tmp, err := json.Marshal(strct.KmsKeyId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LogExports" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LogExports\": ")
	if tmp, err := json.Marshal(strct.LogExports); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "NamespaceArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NamespaceArn\": ")
	if tmp, err := json.Marshal(strct.NamespaceArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "NamespaceId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NamespaceId\": ")
	if tmp, err := json.Marshal(strct.NamespaceId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "NamespaceName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NamespaceName\": ")
	if tmp, err := json.Marshal(strct.NamespaceName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Status" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Status\": ")
	if tmp, err := json.Marshal(strct.Status); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Namespace) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AdminUsername":
            if err := json.Unmarshal([]byte(v), &strct.AdminUsername); err != nil {
                return err
             }
        case "CreationDate":
            if err := json.Unmarshal([]byte(v), &strct.CreationDate); err != nil {
                return err
             }
        case "DbName":
            if err := json.Unmarshal([]byte(v), &strct.DbName); err != nil {
                return err
             }
        case "DefaultIamRoleArn":
            if err := json.Unmarshal([]byte(v), &strct.DefaultIamRoleArn); err != nil {
                return err
             }
        case "IamRoles":
            if err := json.Unmarshal([]byte(v), &strct.IamRoles); err != nil {
                return err
             }
        case "KmsKeyId":
            if err := json.Unmarshal([]byte(v), &strct.KmsKeyId); err != nil {
                return err
             }
        case "LogExports":
            if err := json.Unmarshal([]byte(v), &strct.LogExports); err != nil {
                return err
             }
        case "NamespaceArn":
            if err := json.Unmarshal([]byte(v), &strct.NamespaceArn); err != nil {
                return err
             }
        case "NamespaceId":
            if err := json.Unmarshal([]byte(v), &strct.NamespaceId); err != nil {
                return err
             }
        case "NamespaceName":
            if err := json.Unmarshal([]byte(v), &strct.NamespaceName); err != nil {
                return err
             }
        case "Status":
            if err := json.Unmarshal([]byte(v), &strct.Status); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AdminUserPassword" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AdminUserPassword\": ")
	if tmp, err := json.Marshal(strct.AdminUserPassword); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AdminUsername" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AdminUsername\": ")
	if tmp, err := json.Marshal(strct.AdminUsername); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DbName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DbName\": ")
	if tmp, err := json.Marshal(strct.DbName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DefaultIamRoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DefaultIamRoleArn\": ")
	if tmp, err := json.Marshal(strct.DefaultIamRoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FinalSnapshotName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FinalSnapshotName\": ")
	if tmp, err := json.Marshal(strct.FinalSnapshotName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FinalSnapshotRetentionPeriod" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FinalSnapshotRetentionPeriod\": ")
	if tmp, err := json.Marshal(strct.FinalSnapshotRetentionPeriod); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IamRoles" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IamRoles\": ")
	if tmp, err := json.Marshal(strct.IamRoles); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "KmsKeyId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KmsKeyId\": ")
	if tmp, err := json.Marshal(strct.KmsKeyId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LogExports" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LogExports\": ")
	if tmp, err := json.Marshal(strct.LogExports); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Namespace" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Namespace\": ")
	if tmp, err := json.Marshal(strct.Namespace); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "NamespaceName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "NamespaceName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NamespaceName\": ")
	if tmp, err := json.Marshal(strct.NamespaceName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    NamespaceNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AdminUserPassword":
            if err := json.Unmarshal([]byte(v), &strct.AdminUserPassword); err != nil {
                return err
             }
        case "AdminUsername":
            if err := json.Unmarshal([]byte(v), &strct.AdminUsername); err != nil {
                return err
             }
        case "DbName":
            if err := json.Unmarshal([]byte(v), &strct.DbName); err != nil {
                return err
             }
        case "DefaultIamRoleArn":
            if err := json.Unmarshal([]byte(v), &strct.DefaultIamRoleArn); err != nil {
                return err
             }
        case "FinalSnapshotName":
            if err := json.Unmarshal([]byte(v), &strct.FinalSnapshotName); err != nil {
                return err
             }
        case "FinalSnapshotRetentionPeriod":
            if err := json.Unmarshal([]byte(v), &strct.FinalSnapshotRetentionPeriod); err != nil {
                return err
             }
        case "IamRoles":
            if err := json.Unmarshal([]byte(v), &strct.IamRoles); err != nil {
                return err
             }
        case "KmsKeyId":
            if err := json.Unmarshal([]byte(v), &strct.KmsKeyId); err != nil {
                return err
             }
        case "LogExports":
            if err := json.Unmarshal([]byte(v), &strct.LogExports); err != nil {
                return err
             }
        case "Namespace":
            if err := json.Unmarshal([]byte(v), &strct.Namespace); err != nil {
                return err
             }
        case "NamespaceName":
            if err := json.Unmarshal([]byte(v), &strct.NamespaceName); err != nil {
                return err
             }
            NamespaceNameReceived = true
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if NamespaceName (a required property) was received
    if !NamespaceNameReceived {
        return errors.New("\"NamespaceName\" is required but was not present")
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}
