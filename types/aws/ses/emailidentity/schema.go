// Code generated by schema-generate. DO NOT EDIT.

package emailidentity

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// ConfigurationSetAttributes Used to associate a configuration set with an email identity.
type ConfigurationSetAttributes struct {

  // The configuration set to use by default when sending from this identity. Note that any configuration set defined in the email sending request takes precedence.
  ConfigurationSetName string `json:"ConfigurationSetName,omitempty"`
}

// DkimAttributes Used to enable or disable DKIM authentication for an email identity.
type DkimAttributes struct {

  // Sets the DKIM signing configuration for the identity. When you set this value true, then the messages that are sent from the identity are signed using DKIM. If you set this value to false, your messages are sent without DKIM signing.
  SigningEnabled bool `json:"SigningEnabled,omitempty"`
}

// DkimSigningAttributes If your request includes this object, Amazon SES configures the identity to use Bring Your Own DKIM (BYODKIM) for DKIM authentication purposes, or, configures the key length to be used for Easy DKIM.
type DkimSigningAttributes struct {

  // [Bring Your Own DKIM] A private key that's used to generate a DKIM signature. The private key must use 1024 or 2048-bit RSA encryption, and must be encoded using base64 encoding.
  DomainSigningPrivateKey string `json:"DomainSigningPrivateKey,omitempty"`

  // [Bring Your Own DKIM] A string that's used to identify a public key in the DNS configuration for a domain.
  DomainSigningSelector string `json:"DomainSigningSelector,omitempty"`

  // [Easy DKIM] The key length of the future DKIM key pair to be generated. This can be changed at most once per day.
  NextSigningKeyLength string `json:"NextSigningKeyLength,omitempty"`
}

// FeedbackAttributes Used to enable or disable feedback forwarding for an identity.
type FeedbackAttributes struct {

  // If the value is true, you receive email notifications when bounce or complaint events occur
  EmailForwardingEnabled bool `json:"EmailForwardingEnabled,omitempty"`
}

// MailFromAttributes Used to enable or disable the custom Mail-From domain configuration for an email identity.
type MailFromAttributes struct {

  // The action to take if the required MX record isn't found when you send an email. When you set this value to UseDefaultValue , the mail is sent using amazonses.com as the MAIL FROM domain. When you set this value to RejectMessage , the Amazon SES API v2 returns a MailFromDomainNotVerified error, and doesn't attempt to deliver the email.
  BehaviorOnMxFailure string `json:"BehaviorOnMxFailure,omitempty"`

  // The custom MAIL FROM domain that you want the verified identity to use
  MailFromDomain string `json:"MailFromDomain,omitempty"`
}

// Resource Resource Type definition for AWS::SES::EmailIdentity
type Resource struct {
  ConfigurationSetAttributes *ConfigurationSetAttributes `json:"ConfigurationSetAttributes,omitempty"`
  DkimAttributes *DkimAttributes `json:"DkimAttributes,omitempty"`
  DkimDNSTokenName1 string `json:"DkimDNSTokenName1,omitempty"`
  DkimDNSTokenName2 string `json:"DkimDNSTokenName2,omitempty"`
  DkimDNSTokenName3 string `json:"DkimDNSTokenName3,omitempty"`
  DkimDNSTokenValue1 string `json:"DkimDNSTokenValue1,omitempty"`
  DkimDNSTokenValue2 string `json:"DkimDNSTokenValue2,omitempty"`
  DkimDNSTokenValue3 string `json:"DkimDNSTokenValue3,omitempty"`
  DkimSigningAttributes *DkimSigningAttributes `json:"DkimSigningAttributes,omitempty"`

  // The email address or domain to verify.
  EmailIdentity string `json:"EmailIdentity"`
  FeedbackAttributes *FeedbackAttributes `json:"FeedbackAttributes,omitempty"`
  MailFromAttributes *MailFromAttributes `json:"MailFromAttributes,omitempty"`
}

func (strct *ConfigurationSetAttributes) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ConfigurationSetName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConfigurationSetName\": ")
	if tmp, err := json.Marshal(strct.ConfigurationSetName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ConfigurationSetAttributes) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ConfigurationSetName":
            if err := json.Unmarshal([]byte(v), &strct.ConfigurationSetName); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *DkimAttributes) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "SigningEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SigningEnabled\": ")
	if tmp, err := json.Marshal(strct.SigningEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DkimAttributes) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "SigningEnabled":
            if err := json.Unmarshal([]byte(v), &strct.SigningEnabled); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *DkimSigningAttributes) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DomainSigningPrivateKey" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DomainSigningPrivateKey\": ")
	if tmp, err := json.Marshal(strct.DomainSigningPrivateKey); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DomainSigningSelector" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DomainSigningSelector\": ")
	if tmp, err := json.Marshal(strct.DomainSigningSelector); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "NextSigningKeyLength" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NextSigningKeyLength\": ")
	if tmp, err := json.Marshal(strct.NextSigningKeyLength); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DkimSigningAttributes) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DomainSigningPrivateKey":
            if err := json.Unmarshal([]byte(v), &strct.DomainSigningPrivateKey); err != nil {
                return err
             }
        case "DomainSigningSelector":
            if err := json.Unmarshal([]byte(v), &strct.DomainSigningSelector); err != nil {
                return err
             }
        case "NextSigningKeyLength":
            if err := json.Unmarshal([]byte(v), &strct.NextSigningKeyLength); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *FeedbackAttributes) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "EmailForwardingEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EmailForwardingEnabled\": ")
	if tmp, err := json.Marshal(strct.EmailForwardingEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FeedbackAttributes) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "EmailForwardingEnabled":
            if err := json.Unmarshal([]byte(v), &strct.EmailForwardingEnabled); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *MailFromAttributes) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "BehaviorOnMxFailure" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BehaviorOnMxFailure\": ")
	if tmp, err := json.Marshal(strct.BehaviorOnMxFailure); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MailFromDomain" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MailFromDomain\": ")
	if tmp, err := json.Marshal(strct.MailFromDomain); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MailFromAttributes) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BehaviorOnMxFailure":
            if err := json.Unmarshal([]byte(v), &strct.BehaviorOnMxFailure); err != nil {
                return err
             }
        case "MailFromDomain":
            if err := json.Unmarshal([]byte(v), &strct.MailFromDomain); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ConfigurationSetAttributes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConfigurationSetAttributes\": ")
	if tmp, err := json.Marshal(strct.ConfigurationSetAttributes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DkimAttributes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DkimAttributes\": ")
	if tmp, err := json.Marshal(strct.DkimAttributes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DkimDNSTokenName1" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DkimDNSTokenName1\": ")
	if tmp, err := json.Marshal(strct.DkimDNSTokenName1); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DkimDNSTokenName2" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DkimDNSTokenName2\": ")
	if tmp, err := json.Marshal(strct.DkimDNSTokenName2); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DkimDNSTokenName3" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DkimDNSTokenName3\": ")
	if tmp, err := json.Marshal(strct.DkimDNSTokenName3); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DkimDNSTokenValue1" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DkimDNSTokenValue1\": ")
	if tmp, err := json.Marshal(strct.DkimDNSTokenValue1); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DkimDNSTokenValue2" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DkimDNSTokenValue2\": ")
	if tmp, err := json.Marshal(strct.DkimDNSTokenValue2); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DkimDNSTokenValue3" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DkimDNSTokenValue3\": ")
	if tmp, err := json.Marshal(strct.DkimDNSTokenValue3); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DkimSigningAttributes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DkimSigningAttributes\": ")
	if tmp, err := json.Marshal(strct.DkimSigningAttributes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "EmailIdentity" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "EmailIdentity" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EmailIdentity\": ")
	if tmp, err := json.Marshal(strct.EmailIdentity); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FeedbackAttributes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FeedbackAttributes\": ")
	if tmp, err := json.Marshal(strct.FeedbackAttributes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MailFromAttributes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MailFromAttributes\": ")
	if tmp, err := json.Marshal(strct.MailFromAttributes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    EmailIdentityReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ConfigurationSetAttributes":
            if err := json.Unmarshal([]byte(v), &strct.ConfigurationSetAttributes); err != nil {
                return err
             }
        case "DkimAttributes":
            if err := json.Unmarshal([]byte(v), &strct.DkimAttributes); err != nil {
                return err
             }
        case "DkimDNSTokenName1":
            if err := json.Unmarshal([]byte(v), &strct.DkimDNSTokenName1); err != nil {
                return err
             }
        case "DkimDNSTokenName2":
            if err := json.Unmarshal([]byte(v), &strct.DkimDNSTokenName2); err != nil {
                return err
             }
        case "DkimDNSTokenName3":
            if err := json.Unmarshal([]byte(v), &strct.DkimDNSTokenName3); err != nil {
                return err
             }
        case "DkimDNSTokenValue1":
            if err := json.Unmarshal([]byte(v), &strct.DkimDNSTokenValue1); err != nil {
                return err
             }
        case "DkimDNSTokenValue2":
            if err := json.Unmarshal([]byte(v), &strct.DkimDNSTokenValue2); err != nil {
                return err
             }
        case "DkimDNSTokenValue3":
            if err := json.Unmarshal([]byte(v), &strct.DkimDNSTokenValue3); err != nil {
                return err
             }
        case "DkimSigningAttributes":
            if err := json.Unmarshal([]byte(v), &strct.DkimSigningAttributes); err != nil {
                return err
             }
        case "EmailIdentity":
            if err := json.Unmarshal([]byte(v), &strct.EmailIdentity); err != nil {
                return err
             }
            EmailIdentityReceived = true
        case "FeedbackAttributes":
            if err := json.Unmarshal([]byte(v), &strct.FeedbackAttributes); err != nil {
                return err
             }
        case "MailFromAttributes":
            if err := json.Unmarshal([]byte(v), &strct.MailFromAttributes); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if EmailIdentity (a required property) was received
    if !EmailIdentityReceived {
        return errors.New("\"EmailIdentity\" is required but was not present")
    }
    return nil
}
