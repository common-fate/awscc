// Code generated by schema-generate. DO NOT EDIT.

package configurationset

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// DashboardOptions Preferences regarding the Dashboard feature.
type DashboardOptions struct {

  // Whether emails sent with this configuration set have engagement tracking enabled.
  EngagementMetrics string `json:"EngagementMetrics"`
}

// DeliveryOptions An object that defines the dedicated IP pool that is used to send emails that you send using the configuration set.
type DeliveryOptions struct {

  // The name of the dedicated IP pool to associate with the configuration set.
  SendingPoolName string `json:"SendingPoolName,omitempty"`

  // Specifies whether messages that use the configuration set are required to use Transport Layer Security (TLS). If the value is Require , messages are only delivered if a TLS connection can be established. If the value is Optional , messages can be delivered in plain text if a TLS connection can't be established.
  TlsPolicy string `json:"TlsPolicy,omitempty"`
}

// GuardianOptions Preferences regarding the Guardian feature.
type GuardianOptions struct {

  // Whether emails sent with this configuration set have optimized delivery algorithm enabled.
  OptimizedSharedDelivery string `json:"OptimizedSharedDelivery"`
}

// ReputationOptions An object that defines whether or not Amazon SES collects reputation metrics for the emails that you send that use the configuration set.
type ReputationOptions struct {

  // If true , tracking of reputation metrics is enabled for the configuration set. If false , tracking of reputation metrics is disabled for the configuration set.
  ReputationMetricsEnabled bool `json:"ReputationMetricsEnabled,omitempty"`
}

// Resource Resource schema for AWS::SES::ConfigurationSet.
type Resource struct {
  DeliveryOptions *DeliveryOptions `json:"DeliveryOptions,omitempty"`

  // The name of the configuration set.
  Name string `json:"Name,omitempty"`
  ReputationOptions *ReputationOptions `json:"ReputationOptions,omitempty"`
  SendingOptions *SendingOptions `json:"SendingOptions,omitempty"`
  SuppressionOptions *SuppressionOptions `json:"SuppressionOptions,omitempty"`
  TrackingOptions *TrackingOptions `json:"TrackingOptions,omitempty"`
  VdmOptions *VdmOptions `json:"VdmOptions,omitempty"`
}

// SendingOptions An object that defines whether or not Amazon SES can send email that you send using the configuration set.
type SendingOptions struct {
  SendingEnabled bool `json:"SendingEnabled,omitempty"`
}

// SuppressionOptions An object that contains information about the suppression list preferences for your account.
type SuppressionOptions struct {

  // A list that contains the reasons that email addresses are automatically added to the suppression list for your account.
  SuppressedReasons []string `json:"SuppressedReasons,omitempty"`
}

// TrackingOptions An object that defines the open and click tracking options for emails that you send using the configuration set.
type TrackingOptions struct {

  // The domain to use for tracking open and click events.
  CustomRedirectDomain string `json:"CustomRedirectDomain,omitempty"`
}

// VdmOptions An object that contains Virtual Deliverability Manager (VDM) settings for this configuration set.
type VdmOptions struct {
  DashboardOptions *DashboardOptions `json:"DashboardOptions,omitempty"`
  GuardianOptions *GuardianOptions `json:"GuardianOptions,omitempty"`
}

func (strct *DashboardOptions) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "EngagementMetrics" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "EngagementMetrics" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EngagementMetrics\": ")
	if tmp, err := json.Marshal(strct.EngagementMetrics); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DashboardOptions) UnmarshalJSON(b []byte) error {
    EngagementMetricsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "EngagementMetrics":
            if err := json.Unmarshal([]byte(v), &strct.EngagementMetrics); err != nil {
                return err
             }
            EngagementMetricsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if EngagementMetrics (a required property) was received
    if !EngagementMetricsReceived {
        return errors.New("\"EngagementMetrics\" is required but was not present")
    }
    return nil
}

func (strct *DeliveryOptions) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "SendingPoolName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SendingPoolName\": ")
	if tmp, err := json.Marshal(strct.SendingPoolName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TlsPolicy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TlsPolicy\": ")
	if tmp, err := json.Marshal(strct.TlsPolicy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DeliveryOptions) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "SendingPoolName":
            if err := json.Unmarshal([]byte(v), &strct.SendingPoolName); err != nil {
                return err
             }
        case "TlsPolicy":
            if err := json.Unmarshal([]byte(v), &strct.TlsPolicy); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *GuardianOptions) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "OptimizedSharedDelivery" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "OptimizedSharedDelivery" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OptimizedSharedDelivery\": ")
	if tmp, err := json.Marshal(strct.OptimizedSharedDelivery); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *GuardianOptions) UnmarshalJSON(b []byte) error {
    OptimizedSharedDeliveryReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "OptimizedSharedDelivery":
            if err := json.Unmarshal([]byte(v), &strct.OptimizedSharedDelivery); err != nil {
                return err
             }
            OptimizedSharedDeliveryReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if OptimizedSharedDelivery (a required property) was received
    if !OptimizedSharedDeliveryReceived {
        return errors.New("\"OptimizedSharedDelivery\" is required but was not present")
    }
    return nil
}

func (strct *ReputationOptions) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ReputationMetricsEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ReputationMetricsEnabled\": ")
	if tmp, err := json.Marshal(strct.ReputationMetricsEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ReputationOptions) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ReputationMetricsEnabled":
            if err := json.Unmarshal([]byte(v), &strct.ReputationMetricsEnabled); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DeliveryOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DeliveryOptions\": ")
	if tmp, err := json.Marshal(strct.DeliveryOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ReputationOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ReputationOptions\": ")
	if tmp, err := json.Marshal(strct.ReputationOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SendingOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SendingOptions\": ")
	if tmp, err := json.Marshal(strct.SendingOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SuppressionOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SuppressionOptions\": ")
	if tmp, err := json.Marshal(strct.SuppressionOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TrackingOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TrackingOptions\": ")
	if tmp, err := json.Marshal(strct.TrackingOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VdmOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VdmOptions\": ")
	if tmp, err := json.Marshal(strct.VdmOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DeliveryOptions":
            if err := json.Unmarshal([]byte(v), &strct.DeliveryOptions); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "ReputationOptions":
            if err := json.Unmarshal([]byte(v), &strct.ReputationOptions); err != nil {
                return err
             }
        case "SendingOptions":
            if err := json.Unmarshal([]byte(v), &strct.SendingOptions); err != nil {
                return err
             }
        case "SuppressionOptions":
            if err := json.Unmarshal([]byte(v), &strct.SuppressionOptions); err != nil {
                return err
             }
        case "TrackingOptions":
            if err := json.Unmarshal([]byte(v), &strct.TrackingOptions); err != nil {
                return err
             }
        case "VdmOptions":
            if err := json.Unmarshal([]byte(v), &strct.VdmOptions); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *SendingOptions) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "SendingEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SendingEnabled\": ")
	if tmp, err := json.Marshal(strct.SendingEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SendingOptions) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "SendingEnabled":
            if err := json.Unmarshal([]byte(v), &strct.SendingEnabled); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *SuppressionOptions) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "SuppressedReasons" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SuppressedReasons\": ")
	if tmp, err := json.Marshal(strct.SuppressedReasons); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SuppressionOptions) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "SuppressedReasons":
            if err := json.Unmarshal([]byte(v), &strct.SuppressedReasons); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *TrackingOptions) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CustomRedirectDomain" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CustomRedirectDomain\": ")
	if tmp, err := json.Marshal(strct.CustomRedirectDomain); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TrackingOptions) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CustomRedirectDomain":
            if err := json.Unmarshal([]byte(v), &strct.CustomRedirectDomain); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *VdmOptions) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DashboardOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DashboardOptions\": ")
	if tmp, err := json.Marshal(strct.DashboardOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "GuardianOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"GuardianOptions\": ")
	if tmp, err := json.Marshal(strct.GuardianOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *VdmOptions) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DashboardOptions":
            if err := json.Unmarshal([]byte(v), &strct.DashboardOptions); err != nil {
                return err
             }
        case "GuardianOptions":
            if err := json.Unmarshal([]byte(v), &strct.GuardianOptions); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}
