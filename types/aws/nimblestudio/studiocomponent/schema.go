// Code generated by schema-generate. DO NOT EDIT.

package studiocomponent

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// ActiveDirectoryComputerAttribute <p>An LDAP attribute of an Active Directory computer account, in the form of a name:value
//             pair.</p>
type ActiveDirectoryComputerAttribute struct {

  // <p>The name for the LDAP attribute.</p>
  Name string `json:"Name,omitempty"`

  // <p>The value for the LDAP attribute.</p>
  Value string `json:"Value,omitempty"`
}

// ActiveDirectoryConfiguration <p>The configuration for a Microsoft Active Directory (Microsoft AD) studio
//             resource.</p>
type ActiveDirectoryConfiguration struct {

  // <p>A collection of custom attributes for an Active Directory computer.</p>
  ComputerAttributes []*ActiveDirectoryComputerAttribute `json:"ComputerAttributes,omitempty"`

  // <p>The directory ID of the Directory Service for Microsoft Active Directory to access
  //             using this studio component.</p>
  DirectoryId string `json:"DirectoryId,omitempty"`

  // <p>The distinguished name (DN) and organizational unit (OU) of an Active Directory
  //             computer.</p>
  OrganizationalUnitDistinguishedName string `json:"OrganizationalUnitDistinguishedName,omitempty"`
}

// ComputeFarmConfiguration <p>The configuration for a render farm that is associated with a studio resource.</p>
type ComputeFarmConfiguration struct {

  // <p>The name of an Active Directory user that is used on ComputeFarm worker
  //             instances.</p>
  ActiveDirectoryUser string `json:"ActiveDirectoryUser,omitempty"`

  // <p>The endpoint of the ComputeFarm that is accessed by the studio component
  //             resource.</p>
  Endpoint string `json:"Endpoint,omitempty"`
}

// LicenseServiceConfiguration <p>The configuration for a license service that is associated with a studio
//             resource.</p>
type LicenseServiceConfiguration struct {

  // <p>The endpoint of the license service that is accessed by the studio component
  //             resource.</p>
  Endpoint string `json:"Endpoint,omitempty"`
}

// Resource Represents a studio component that connects a non-Nimble Studio resource in your account to your studio
type Resource struct {
  Configuration interface{} `json:"Configuration,omitempty"`

  // <p>The description.</p>
  Description string `json:"Description,omitempty"`

  // <p>The EC2 security groups that control access to the studio component.</p>
  Ec2SecurityGroupIds []string `json:"Ec2SecurityGroupIds,omitempty"`

  // <p>Initialization scripts for studio components.</p>
  InitializationScripts []*StudioComponentInitializationScript `json:"InitializationScripts,omitempty"`

  // <p>The name for the studio component.</p>
  Name string `json:"Name"`
  RuntimeRoleArn string `json:"RuntimeRoleArn,omitempty"`

  // <p>Parameters for the studio component scripts.</p>
  ScriptParameters []*ScriptParameterKeyValue `json:"ScriptParameters,omitempty"`
  SecureInitializationRoleArn string `json:"SecureInitializationRoleArn,omitempty"`
  StudioComponentId string `json:"StudioComponentId,omitempty"`

  // <p>The studio ID. </p>
  StudioId string `json:"StudioId"`
  Subtype string `json:"Subtype,omitempty"`
  Tags *Tags `json:"Tags,omitempty"`
  Type string `json:"Type"`
}

// ScriptParameterKeyValue <p>A parameter for a studio component script, in the form of a key:value pair.</p>
type ScriptParameterKeyValue struct {

  // <p>A script parameter key.</p>
  Key string `json:"Key,omitempty"`

  // <p>A script parameter value.</p>
  Value string `json:"Value,omitempty"`
}

// SharedFileSystemConfiguration <p>The configuration for a shared file storage system that is associated with a studio
//             resource.</p>
type SharedFileSystemConfiguration struct {

  // <p>The endpoint of the shared file system that is accessed by the studio component
  //             resource.</p>
  Endpoint string `json:"Endpoint,omitempty"`

  // <p>The unique identifier for a file system.</p>
  FileSystemId string `json:"FileSystemId,omitempty"`

  // <p>The mount location for a shared file system on a Linux virtual workstation.</p>
  LinuxMountPoint string `json:"LinuxMountPoint,omitempty"`

  // <p>The name of the file share.</p>
  ShareName string `json:"ShareName,omitempty"`

  // <p>The mount location for a shared file system on a Windows virtual workstation.</p>
  WindowsMountDrive string `json:"WindowsMountDrive,omitempty"`
}

// StudioComponentInitializationScript <p>Initialization scripts for studio components.</p>
type StudioComponentInitializationScript struct {

  // <p>The version number of the protocol that is used by the launch profile. The only valid
  //             version is "2021-03-31".</p>
  LaunchProfileProtocolVersion string `json:"LaunchProfileProtocolVersion,omitempty"`
  Platform string `json:"Platform,omitempty"`
  RunContext string `json:"RunContext,omitempty"`

  // <p>The initialization script.</p>
  Script string `json:"Script,omitempty"`
}

// Tags 
type Tags struct {
}

func (strct *ActiveDirectoryComputerAttribute) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ActiveDirectoryComputerAttribute) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ActiveDirectoryConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ComputerAttributes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ComputerAttributes\": ")
	if tmp, err := json.Marshal(strct.ComputerAttributes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DirectoryId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DirectoryId\": ")
	if tmp, err := json.Marshal(strct.DirectoryId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OrganizationalUnitDistinguishedName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OrganizationalUnitDistinguishedName\": ")
	if tmp, err := json.Marshal(strct.OrganizationalUnitDistinguishedName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ActiveDirectoryConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ComputerAttributes":
            if err := json.Unmarshal([]byte(v), &strct.ComputerAttributes); err != nil {
                return err
             }
        case "DirectoryId":
            if err := json.Unmarshal([]byte(v), &strct.DirectoryId); err != nil {
                return err
             }
        case "OrganizationalUnitDistinguishedName":
            if err := json.Unmarshal([]byte(v), &strct.OrganizationalUnitDistinguishedName); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ComputeFarmConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ActiveDirectoryUser" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ActiveDirectoryUser\": ")
	if tmp, err := json.Marshal(strct.ActiveDirectoryUser); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Endpoint" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Endpoint\": ")
	if tmp, err := json.Marshal(strct.Endpoint); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ComputeFarmConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ActiveDirectoryUser":
            if err := json.Unmarshal([]byte(v), &strct.ActiveDirectoryUser); err != nil {
                return err
             }
        case "Endpoint":
            if err := json.Unmarshal([]byte(v), &strct.Endpoint); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *LicenseServiceConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Endpoint" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Endpoint\": ")
	if tmp, err := json.Marshal(strct.Endpoint); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LicenseServiceConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Endpoint":
            if err := json.Unmarshal([]byte(v), &strct.Endpoint); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Configuration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Configuration\": ")
	if tmp, err := json.Marshal(strct.Configuration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Ec2SecurityGroupIds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Ec2SecurityGroupIds\": ")
	if tmp, err := json.Marshal(strct.Ec2SecurityGroupIds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "InitializationScripts" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InitializationScripts\": ")
	if tmp, err := json.Marshal(strct.InitializationScripts); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RuntimeRoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RuntimeRoleArn\": ")
	if tmp, err := json.Marshal(strct.RuntimeRoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ScriptParameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ScriptParameters\": ")
	if tmp, err := json.Marshal(strct.ScriptParameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SecureInitializationRoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SecureInitializationRoleArn\": ")
	if tmp, err := json.Marshal(strct.SecureInitializationRoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StudioComponentId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StudioComponentId\": ")
	if tmp, err := json.Marshal(strct.StudioComponentId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "StudioId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "StudioId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StudioId\": ")
	if tmp, err := json.Marshal(strct.StudioId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Subtype" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Subtype\": ")
	if tmp, err := json.Marshal(strct.Subtype); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    NameReceived := false
    StudioIdReceived := false
    TypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Configuration":
            if err := json.Unmarshal([]byte(v), &strct.Configuration); err != nil {
                return err
             }
        case "Description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "Ec2SecurityGroupIds":
            if err := json.Unmarshal([]byte(v), &strct.Ec2SecurityGroupIds); err != nil {
                return err
             }
        case "InitializationScripts":
            if err := json.Unmarshal([]byte(v), &strct.InitializationScripts); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        case "RuntimeRoleArn":
            if err := json.Unmarshal([]byte(v), &strct.RuntimeRoleArn); err != nil {
                return err
             }
        case "ScriptParameters":
            if err := json.Unmarshal([]byte(v), &strct.ScriptParameters); err != nil {
                return err
             }
        case "SecureInitializationRoleArn":
            if err := json.Unmarshal([]byte(v), &strct.SecureInitializationRoleArn); err != nil {
                return err
             }
        case "StudioComponentId":
            if err := json.Unmarshal([]byte(v), &strct.StudioComponentId); err != nil {
                return err
             }
        case "StudioId":
            if err := json.Unmarshal([]byte(v), &strct.StudioId); err != nil {
                return err
             }
            StudioIdReceived = true
        case "Subtype":
            if err := json.Unmarshal([]byte(v), &strct.Subtype); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            TypeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    // check if StudioId (a required property) was received
    if !StudioIdReceived {
        return errors.New("\"StudioId\" is required but was not present")
    }
    // check if Type (a required property) was received
    if !TypeReceived {
        return errors.New("\"Type\" is required but was not present")
    }
    return nil
}

func (strct *ScriptParameterKeyValue) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ScriptParameterKeyValue) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *SharedFileSystemConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Endpoint" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Endpoint\": ")
	if tmp, err := json.Marshal(strct.Endpoint); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FileSystemId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FileSystemId\": ")
	if tmp, err := json.Marshal(strct.FileSystemId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LinuxMountPoint" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LinuxMountPoint\": ")
	if tmp, err := json.Marshal(strct.LinuxMountPoint); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ShareName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ShareName\": ")
	if tmp, err := json.Marshal(strct.ShareName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "WindowsMountDrive" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"WindowsMountDrive\": ")
	if tmp, err := json.Marshal(strct.WindowsMountDrive); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SharedFileSystemConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Endpoint":
            if err := json.Unmarshal([]byte(v), &strct.Endpoint); err != nil {
                return err
             }
        case "FileSystemId":
            if err := json.Unmarshal([]byte(v), &strct.FileSystemId); err != nil {
                return err
             }
        case "LinuxMountPoint":
            if err := json.Unmarshal([]byte(v), &strct.LinuxMountPoint); err != nil {
                return err
             }
        case "ShareName":
            if err := json.Unmarshal([]byte(v), &strct.ShareName); err != nil {
                return err
             }
        case "WindowsMountDrive":
            if err := json.Unmarshal([]byte(v), &strct.WindowsMountDrive); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *StudioComponentInitializationScript) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "LaunchProfileProtocolVersion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LaunchProfileProtocolVersion\": ")
	if tmp, err := json.Marshal(strct.LaunchProfileProtocolVersion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Platform" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Platform\": ")
	if tmp, err := json.Marshal(strct.Platform); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RunContext" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RunContext\": ")
	if tmp, err := json.Marshal(strct.RunContext); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Script" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Script\": ")
	if tmp, err := json.Marshal(strct.Script); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *StudioComponentInitializationScript) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "LaunchProfileProtocolVersion":
            if err := json.Unmarshal([]byte(v), &strct.LaunchProfileProtocolVersion); err != nil {
                return err
             }
        case "Platform":
            if err := json.Unmarshal([]byte(v), &strct.Platform); err != nil {
                return err
             }
        case "RunContext":
            if err := json.Unmarshal([]byte(v), &strct.RunContext); err != nil {
                return err
             }
        case "Script":
            if err := json.Unmarshal([]byte(v), &strct.Script); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Tags) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tags) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}
