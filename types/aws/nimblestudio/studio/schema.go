// Code generated by schema-generate. DO NOT EDIT.

package studio

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// Resource Represents a studio that contains other Nimble Studio resources
type Resource struct {

  // <p>The IAM role that Studio Admins will assume when logging in to the Nimble Studio portal.</p>
  AdminRoleArn string `json:"AdminRoleArn"`

  // <p>A friendly name for the studio.</p>
  DisplayName string `json:"DisplayName"`

  // <p>The Amazon Web Services Region where the studio resource is located.</p>
  HomeRegion string `json:"HomeRegion,omitempty"`

  // <p>The Amazon Web Services SSO application client ID used to integrate with Amazon Web Services SSO to enable Amazon Web Services SSO users to log in to Nimble Studio portal.</p>
  SsoClientId string `json:"SsoClientId,omitempty"`
  StudioEncryptionConfiguration *StudioEncryptionConfiguration `json:"StudioEncryptionConfiguration,omitempty"`
  StudioId string `json:"StudioId,omitempty"`

  // <p>The studio name that is used in the URL of the Nimble Studio portal when accessed by Nimble Studio users.</p>
  StudioName string `json:"StudioName"`

  // <p>The address of the web page for the studio.</p>
  StudioUrl string `json:"StudioUrl,omitempty"`
  Tags *Tags `json:"Tags,omitempty"`

  // <p>The IAM role that Studio Users will assume when logging in to the Nimble Studio portal.</p>
  UserRoleArn string `json:"UserRoleArn"`
}

// StudioEncryptionConfiguration <p>Configuration of the encryption method that is used for the studio.</p>
type StudioEncryptionConfiguration struct {

  // <p>The ARN for a KMS key that is used to encrypt studio data.</p>
  KeyArn string `json:"KeyArn,omitempty"`
  KeyType string `json:"KeyType"`
}

// Tags 
type Tags struct {
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AdminRoleArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AdminRoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AdminRoleArn\": ")
	if tmp, err := json.Marshal(strct.AdminRoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "DisplayName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "DisplayName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DisplayName\": ")
	if tmp, err := json.Marshal(strct.DisplayName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "HomeRegion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HomeRegion\": ")
	if tmp, err := json.Marshal(strct.HomeRegion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SsoClientId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SsoClientId\": ")
	if tmp, err := json.Marshal(strct.SsoClientId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StudioEncryptionConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StudioEncryptionConfiguration\": ")
	if tmp, err := json.Marshal(strct.StudioEncryptionConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StudioId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StudioId\": ")
	if tmp, err := json.Marshal(strct.StudioId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "StudioName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "StudioName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StudioName\": ")
	if tmp, err := json.Marshal(strct.StudioName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StudioUrl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StudioUrl\": ")
	if tmp, err := json.Marshal(strct.StudioUrl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "UserRoleArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "UserRoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UserRoleArn\": ")
	if tmp, err := json.Marshal(strct.UserRoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    AdminRoleArnReceived := false
    DisplayNameReceived := false
    StudioNameReceived := false
    UserRoleArnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AdminRoleArn":
            if err := json.Unmarshal([]byte(v), &strct.AdminRoleArn); err != nil {
                return err
             }
            AdminRoleArnReceived = true
        case "DisplayName":
            if err := json.Unmarshal([]byte(v), &strct.DisplayName); err != nil {
                return err
             }
            DisplayNameReceived = true
        case "HomeRegion":
            if err := json.Unmarshal([]byte(v), &strct.HomeRegion); err != nil {
                return err
             }
        case "SsoClientId":
            if err := json.Unmarshal([]byte(v), &strct.SsoClientId); err != nil {
                return err
             }
        case "StudioEncryptionConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.StudioEncryptionConfiguration); err != nil {
                return err
             }
        case "StudioId":
            if err := json.Unmarshal([]byte(v), &strct.StudioId); err != nil {
                return err
             }
        case "StudioName":
            if err := json.Unmarshal([]byte(v), &strct.StudioName); err != nil {
                return err
             }
            StudioNameReceived = true
        case "StudioUrl":
            if err := json.Unmarshal([]byte(v), &strct.StudioUrl); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        case "UserRoleArn":
            if err := json.Unmarshal([]byte(v), &strct.UserRoleArn); err != nil {
                return err
             }
            UserRoleArnReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if AdminRoleArn (a required property) was received
    if !AdminRoleArnReceived {
        return errors.New("\"AdminRoleArn\" is required but was not present")
    }
    // check if DisplayName (a required property) was received
    if !DisplayNameReceived {
        return errors.New("\"DisplayName\" is required but was not present")
    }
    // check if StudioName (a required property) was received
    if !StudioNameReceived {
        return errors.New("\"StudioName\" is required but was not present")
    }
    // check if UserRoleArn (a required property) was received
    if !UserRoleArnReceived {
        return errors.New("\"UserRoleArn\" is required but was not present")
    }
    return nil
}

func (strct *StudioEncryptionConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "KeyArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KeyArn\": ")
	if tmp, err := json.Marshal(strct.KeyArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "KeyType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "KeyType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KeyType\": ")
	if tmp, err := json.Marshal(strct.KeyType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *StudioEncryptionConfiguration) UnmarshalJSON(b []byte) error {
    KeyTypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "KeyArn":
            if err := json.Unmarshal([]byte(v), &strct.KeyArn); err != nil {
                return err
             }
        case "KeyType":
            if err := json.Unmarshal([]byte(v), &strct.KeyType); err != nil {
                return err
             }
            KeyTypeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if KeyType (a required property) was received
    if !KeyTypeReceived {
        return errors.New("\"KeyType\" is required but was not present")
    }
    return nil
}

func (strct *Tags) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tags) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}
