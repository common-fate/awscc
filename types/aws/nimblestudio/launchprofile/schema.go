// Code generated by schema-generate. DO NOT EDIT.

package launchprofile

import (
    "bytes"
    "errors"
    "encoding/json"
    "fmt"
)

// Resource Represents a launch profile which delegates access to a collection of studio components to studio users
type Resource struct {

  // <p>The description.</p>
  Description string `json:"Description,omitempty"`

  // <p>Specifies the IDs of the EC2 subnets where streaming sessions will be accessible from.
  //             These subnets must support the specified instance types. </p>
  Ec2SubnetIds []string `json:"Ec2SubnetIds"`
  LaunchProfileId string `json:"LaunchProfileId,omitempty"`

  // <p>The version number of the protocol that is used by the launch profile. The only valid
  //             version is "2021-03-31".</p>
  LaunchProfileProtocolVersions []string `json:"LaunchProfileProtocolVersions"`

  // <p>The name for the launch profile.</p>
  Name string `json:"Name"`
  StreamConfiguration *StreamConfiguration `json:"StreamConfiguration"`

  // <p>Unique identifiers for a collection of studio components that can be used with this
  //             launch profile.</p>
  StudioComponentIds []string `json:"StudioComponentIds"`

  // <p>The studio ID. </p>
  StudioId string `json:"StudioId"`
  Tags *Tags `json:"Tags,omitempty"`
}

// StreamConfiguration <p>A configuration for a streaming session.</p>
type StreamConfiguration struct {
  AutomaticTerminationMode string `json:"AutomaticTerminationMode,omitempty"`
  ClipboardMode string `json:"ClipboardMode"`

  // <p>The EC2 instance types that users can select from when launching a streaming session
  //             with this launch profile.</p>
  Ec2InstanceTypes []string `json:"Ec2InstanceTypes"`

  // <p>The length of time, in minutes, that a streaming session can be active before it is
  //             stopped or terminated. After this point, Nimble Studio automatically terminates or
  //             stops the session. The default length of time is 690 minutes, and the maximum length of
  //             time is 30 days.</p>
  MaxSessionLengthInMinutes float64 `json:"MaxSessionLengthInMinutes,omitempty"`

  // <p>Integer that determines if you can start and stop your sessions and how long a session
  //             can stay in the <code>STOPPED</code> state. The default value is 0. The maximum value is
  //             5760.</p>
  //          <p>This field is allowed only when <code>sessionPersistenceMode</code> is
  //                 <code>ACTIVATED</code> and <code>automaticTerminationMode</code> is
  //                 <code>ACTIVATED</code>.</p>
  //          <p>If the value is set to 0, your sessions can?t be <code>STOPPED</code>. If you then
  //             call <code>StopStreamingSession</code>, the session fails. If the time that a session
  //             stays in the <code>READY</code> state exceeds the <code>maxSessionLengthInMinutes</code>
  //             value, the session will automatically be terminated (instead of
  //             <code>STOPPED</code>).</p>
  //          <p>If the value is set to a positive number, the session can be stopped. You can call
  //                 <code>StopStreamingSession</code> to stop sessions in the <code>READY</code> state.
  //             If the time that a session stays in the <code>READY</code> state exceeds the
  //                 <code>maxSessionLengthInMinutes</code> value, the session will automatically be
  //             stopped (instead of terminated).</p>
  MaxStoppedSessionLengthInMinutes float64 `json:"MaxStoppedSessionLengthInMinutes,omitempty"`
  SessionBackup *StreamConfigurationSessionBackup `json:"SessionBackup,omitempty"`
  SessionPersistenceMode string `json:"SessionPersistenceMode,omitempty"`
  SessionStorage *StreamConfigurationSessionStorage `json:"SessionStorage,omitempty"`

  // <p>The streaming images that users can select from when launching a streaming session
  //             with this launch profile.</p>
  StreamingImageIds []string `json:"StreamingImageIds"`
  VolumeConfiguration *VolumeConfiguration `json:"VolumeConfiguration,omitempty"`
}

// StreamConfigurationSessionBackup <p>Configures how streaming sessions are backed up when launched from this launch
//             profile.</p>
type StreamConfigurationSessionBackup struct {

  // <p>The maximum number of backups that each streaming session created from this launch
  //             profile can have.</p>
  MaxBackupsToRetain float64 `json:"MaxBackupsToRetain,omitempty"`
  Mode string `json:"Mode,omitempty"`
}

// StreamConfigurationSessionStorage <p>The configuration for a streaming session?s upload storage.</p>
type StreamConfigurationSessionStorage struct {

  // <p>Allows artists to upload files to their workstations. The only valid option is
  //                 <code>UPLOAD</code>.</p>
  Mode []string `json:"Mode"`
  Root *StreamingSessionStorageRoot `json:"Root,omitempty"`
}

// StreamingSessionStorageRoot <p>The upload storage root location (folder) on streaming workstations where files are
//             uploaded.</p>
type StreamingSessionStorageRoot struct {

  // <p>The folder path in Linux workstations where files are uploaded.</p>
  Linux string `json:"Linux,omitempty"`

  // <p>The folder path in Windows workstations where files are uploaded.</p>
  Windows string `json:"Windows,omitempty"`
}

// Tags 
type Tags struct {
}

// VolumeConfiguration <p>Custom volume configuration for the root volumes that are attached to streaming
//             sessions.</p>
//          <p>This parameter is only allowed when <code>sessionPersistenceMode</code> is
//                 <code>ACTIVATED</code>.</p>
type VolumeConfiguration struct {

  // <p>The number of I/O operations per second for the root volume that is attached to
  //             streaming session.</p>
  Iops float64 `json:"Iops,omitempty"`

  // <p>The size of the root volume that is attached to the streaming session. The root volume
  //             size is measured in GiBs.</p>
  Size float64 `json:"Size,omitempty"`

  // <p>The throughput to provision for the root volume that is attached to the streaming
  //             session. The throughput is measured in MiB/s.</p>
  Throughput float64 `json:"Throughput,omitempty"`
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Ec2SubnetIds" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Ec2SubnetIds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Ec2SubnetIds\": ")
	if tmp, err := json.Marshal(strct.Ec2SubnetIds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LaunchProfileId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LaunchProfileId\": ")
	if tmp, err := json.Marshal(strct.LaunchProfileId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "LaunchProfileProtocolVersions" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "LaunchProfileProtocolVersions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LaunchProfileProtocolVersions\": ")
	if tmp, err := json.Marshal(strct.LaunchProfileProtocolVersions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "StreamConfiguration" field is required
    if strct.StreamConfiguration == nil {
        return nil, errors.New("StreamConfiguration is a required field")
    }
    // Marshal the "StreamConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StreamConfiguration\": ")
	if tmp, err := json.Marshal(strct.StreamConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "StudioComponentIds" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "StudioComponentIds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StudioComponentIds\": ")
	if tmp, err := json.Marshal(strct.StudioComponentIds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "StudioId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "StudioId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StudioId\": ")
	if tmp, err := json.Marshal(strct.StudioId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    Ec2SubnetIdsReceived := false
    LaunchProfileProtocolVersionsReceived := false
    NameReceived := false
    StreamConfigurationReceived := false
    StudioComponentIdsReceived := false
    StudioIdReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "Ec2SubnetIds":
            if err := json.Unmarshal([]byte(v), &strct.Ec2SubnetIds); err != nil {
                return err
             }
            Ec2SubnetIdsReceived = true
        case "LaunchProfileId":
            if err := json.Unmarshal([]byte(v), &strct.LaunchProfileId); err != nil {
                return err
             }
        case "LaunchProfileProtocolVersions":
            if err := json.Unmarshal([]byte(v), &strct.LaunchProfileProtocolVersions); err != nil {
                return err
             }
            LaunchProfileProtocolVersionsReceived = true
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        case "StreamConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.StreamConfiguration); err != nil {
                return err
             }
            StreamConfigurationReceived = true
        case "StudioComponentIds":
            if err := json.Unmarshal([]byte(v), &strct.StudioComponentIds); err != nil {
                return err
             }
            StudioComponentIdsReceived = true
        case "StudioId":
            if err := json.Unmarshal([]byte(v), &strct.StudioId); err != nil {
                return err
             }
            StudioIdReceived = true
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Ec2SubnetIds (a required property) was received
    if !Ec2SubnetIdsReceived {
        return errors.New("\"Ec2SubnetIds\" is required but was not present")
    }
    // check if LaunchProfileProtocolVersions (a required property) was received
    if !LaunchProfileProtocolVersionsReceived {
        return errors.New("\"LaunchProfileProtocolVersions\" is required but was not present")
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    // check if StreamConfiguration (a required property) was received
    if !StreamConfigurationReceived {
        return errors.New("\"StreamConfiguration\" is required but was not present")
    }
    // check if StudioComponentIds (a required property) was received
    if !StudioComponentIdsReceived {
        return errors.New("\"StudioComponentIds\" is required but was not present")
    }
    // check if StudioId (a required property) was received
    if !StudioIdReceived {
        return errors.New("\"StudioId\" is required but was not present")
    }
    return nil
}

func (strct *StreamConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AutomaticTerminationMode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AutomaticTerminationMode\": ")
	if tmp, err := json.Marshal(strct.AutomaticTerminationMode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ClipboardMode" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ClipboardMode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ClipboardMode\": ")
	if tmp, err := json.Marshal(strct.ClipboardMode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Ec2InstanceTypes" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Ec2InstanceTypes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Ec2InstanceTypes\": ")
	if tmp, err := json.Marshal(strct.Ec2InstanceTypes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MaxSessionLengthInMinutes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaxSessionLengthInMinutes\": ")
	if tmp, err := json.Marshal(strct.MaxSessionLengthInMinutes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MaxStoppedSessionLengthInMinutes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaxStoppedSessionLengthInMinutes\": ")
	if tmp, err := json.Marshal(strct.MaxStoppedSessionLengthInMinutes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SessionBackup" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SessionBackup\": ")
	if tmp, err := json.Marshal(strct.SessionBackup); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SessionPersistenceMode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SessionPersistenceMode\": ")
	if tmp, err := json.Marshal(strct.SessionPersistenceMode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SessionStorage" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SessionStorage\": ")
	if tmp, err := json.Marshal(strct.SessionStorage); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "StreamingImageIds" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "StreamingImageIds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StreamingImageIds\": ")
	if tmp, err := json.Marshal(strct.StreamingImageIds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VolumeConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VolumeConfiguration\": ")
	if tmp, err := json.Marshal(strct.VolumeConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *StreamConfiguration) UnmarshalJSON(b []byte) error {
    ClipboardModeReceived := false
    Ec2InstanceTypesReceived := false
    StreamingImageIdsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AutomaticTerminationMode":
            if err := json.Unmarshal([]byte(v), &strct.AutomaticTerminationMode); err != nil {
                return err
             }
        case "ClipboardMode":
            if err := json.Unmarshal([]byte(v), &strct.ClipboardMode); err != nil {
                return err
             }
            ClipboardModeReceived = true
        case "Ec2InstanceTypes":
            if err := json.Unmarshal([]byte(v), &strct.Ec2InstanceTypes); err != nil {
                return err
             }
            Ec2InstanceTypesReceived = true
        case "MaxSessionLengthInMinutes":
            if err := json.Unmarshal([]byte(v), &strct.MaxSessionLengthInMinutes); err != nil {
                return err
             }
        case "MaxStoppedSessionLengthInMinutes":
            if err := json.Unmarshal([]byte(v), &strct.MaxStoppedSessionLengthInMinutes); err != nil {
                return err
             }
        case "SessionBackup":
            if err := json.Unmarshal([]byte(v), &strct.SessionBackup); err != nil {
                return err
             }
        case "SessionPersistenceMode":
            if err := json.Unmarshal([]byte(v), &strct.SessionPersistenceMode); err != nil {
                return err
             }
        case "SessionStorage":
            if err := json.Unmarshal([]byte(v), &strct.SessionStorage); err != nil {
                return err
             }
        case "StreamingImageIds":
            if err := json.Unmarshal([]byte(v), &strct.StreamingImageIds); err != nil {
                return err
             }
            StreamingImageIdsReceived = true
        case "VolumeConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.VolumeConfiguration); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ClipboardMode (a required property) was received
    if !ClipboardModeReceived {
        return errors.New("\"ClipboardMode\" is required but was not present")
    }
    // check if Ec2InstanceTypes (a required property) was received
    if !Ec2InstanceTypesReceived {
        return errors.New("\"Ec2InstanceTypes\" is required but was not present")
    }
    // check if StreamingImageIds (a required property) was received
    if !StreamingImageIdsReceived {
        return errors.New("\"StreamingImageIds\" is required but was not present")
    }
    return nil
}

func (strct *StreamConfigurationSessionBackup) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "MaxBackupsToRetain" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaxBackupsToRetain\": ")
	if tmp, err := json.Marshal(strct.MaxBackupsToRetain); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Mode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Mode\": ")
	if tmp, err := json.Marshal(strct.Mode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *StreamConfigurationSessionBackup) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "MaxBackupsToRetain":
            if err := json.Unmarshal([]byte(v), &strct.MaxBackupsToRetain); err != nil {
                return err
             }
        case "Mode":
            if err := json.Unmarshal([]byte(v), &strct.Mode); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *StreamConfigurationSessionStorage) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Mode" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Mode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Mode\": ")
	if tmp, err := json.Marshal(strct.Mode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Root" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Root\": ")
	if tmp, err := json.Marshal(strct.Root); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *StreamConfigurationSessionStorage) UnmarshalJSON(b []byte) error {
    ModeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Mode":
            if err := json.Unmarshal([]byte(v), &strct.Mode); err != nil {
                return err
             }
            ModeReceived = true
        case "Root":
            if err := json.Unmarshal([]byte(v), &strct.Root); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Mode (a required property) was received
    if !ModeReceived {
        return errors.New("\"Mode\" is required but was not present")
    }
    return nil
}

func (strct *StreamingSessionStorageRoot) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Linux" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Linux\": ")
	if tmp, err := json.Marshal(strct.Linux); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Windows" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Windows\": ")
	if tmp, err := json.Marshal(strct.Windows); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *StreamingSessionStorageRoot) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Linux":
            if err := json.Unmarshal([]byte(v), &strct.Linux); err != nil {
                return err
             }
        case "Windows":
            if err := json.Unmarshal([]byte(v), &strct.Windows); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Tags) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tags) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *VolumeConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Iops" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Iops\": ")
	if tmp, err := json.Marshal(strct.Iops); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Size" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Size\": ")
	if tmp, err := json.Marshal(strct.Size); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Throughput" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Throughput\": ")
	if tmp, err := json.Marshal(strct.Throughput); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *VolumeConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Iops":
            if err := json.Unmarshal([]byte(v), &strct.Iops); err != nil {
                return err
             }
        case "Size":
            if err := json.Unmarshal([]byte(v), &strct.Size); err != nil {
                return err
             }
        case "Throughput":
            if err := json.Unmarshal([]byte(v), &strct.Throughput); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}
