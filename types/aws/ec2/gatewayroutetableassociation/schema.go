// Code generated by schema-generate. DO NOT EDIT.

package gatewayroutetableassociation

import (
    "encoding/json"
    "fmt"
    "errors"
    "bytes"
)

// Resource Associates a gateway with a route table. The gateway and route table must be in the same VPC. This association causes the incoming traffic to the gateway to be routed according to the routes in the route table.
type Resource struct {

  // The route table association ID.
  AssociationId string `json:"AssociationId,omitempty"`

  // The ID of the gateway.
  GatewayId string `json:"GatewayId"`

  // The ID of the route table.
  RouteTableId string `json:"RouteTableId"`
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AssociationId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AssociationId\": ")
	if tmp, err := json.Marshal(strct.AssociationId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "GatewayId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "GatewayId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"GatewayId\": ")
	if tmp, err := json.Marshal(strct.GatewayId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RouteTableId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RouteTableId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RouteTableId\": ")
	if tmp, err := json.Marshal(strct.RouteTableId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    GatewayIdReceived := false
    RouteTableIdReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AssociationId":
            if err := json.Unmarshal([]byte(v), &strct.AssociationId); err != nil {
                return err
             }
        case "GatewayId":
            if err := json.Unmarshal([]byte(v), &strct.GatewayId); err != nil {
                return err
             }
            GatewayIdReceived = true
        case "RouteTableId":
            if err := json.Unmarshal([]byte(v), &strct.RouteTableId); err != nil {
                return err
             }
            RouteTableIdReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if GatewayId (a required property) was received
    if !GatewayIdReceived {
        return errors.New("\"GatewayId\" is required but was not present")
    }
    // check if RouteTableId (a required property) was received
    if !RouteTableIdReceived {
        return errors.New("\"RouteTableId\" is required but was not present")
    }
    return nil
}
