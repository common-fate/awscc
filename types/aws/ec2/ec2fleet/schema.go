// Code generated by schema-generate. DO NOT EDIT.

package ec2fleet

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// AcceleratorCountRequest 
type AcceleratorCountRequest struct {
  Max int `json:"Max,omitempty"`
  Min int `json:"Min,omitempty"`
}

// AcceleratorTotalMemoryMiBRequest 
type AcceleratorTotalMemoryMiBRequest struct {
  Max int `json:"Max,omitempty"`
  Min int `json:"Min,omitempty"`
}

// BaselineEbsBandwidthMbpsRequest 
type BaselineEbsBandwidthMbpsRequest struct {
  Max int `json:"Max,omitempty"`
  Min int `json:"Min,omitempty"`
}

// CapacityRebalance 
type CapacityRebalance struct {
  ReplacementStrategy string `json:"ReplacementStrategy,omitempty"`
  TerminationDelay int `json:"TerminationDelay,omitempty"`
}

// CapacityReservationOptionsRequest 
type CapacityReservationOptionsRequest struct {
  UsageStrategy string `json:"UsageStrategy,omitempty"`
}

// FleetLaunchTemplateConfigRequest 
type FleetLaunchTemplateConfigRequest struct {
  LaunchTemplateSpecification *FleetLaunchTemplateSpecificationRequest `json:"LaunchTemplateSpecification,omitempty"`
  Overrides []*FleetLaunchTemplateOverridesRequest `json:"Overrides,omitempty"`
}

// FleetLaunchTemplateOverridesRequest 
type FleetLaunchTemplateOverridesRequest struct {
  AvailabilityZone string `json:"AvailabilityZone,omitempty"`
  InstanceRequirements *InstanceRequirementsRequest `json:"InstanceRequirements,omitempty"`
  InstanceType string `json:"InstanceType,omitempty"`
  MaxPrice string `json:"MaxPrice,omitempty"`
  Placement *Placement `json:"Placement,omitempty"`
  Priority float64 `json:"Priority,omitempty"`
  SubnetId string `json:"SubnetId,omitempty"`
  WeightedCapacity float64 `json:"WeightedCapacity,omitempty"`
}

// FleetLaunchTemplateSpecificationRequest 
type FleetLaunchTemplateSpecificationRequest struct {
  LaunchTemplateId string `json:"LaunchTemplateId,omitempty"`
  LaunchTemplateName string `json:"LaunchTemplateName,omitempty"`
  Version string `json:"Version"`
}

// InstanceRequirementsRequest 
type InstanceRequirementsRequest struct {
  AcceleratorCount *AcceleratorCountRequest `json:"AcceleratorCount,omitempty"`
  AcceleratorManufacturers []string `json:"AcceleratorManufacturers,omitempty"`
  AcceleratorNames []string `json:"AcceleratorNames,omitempty"`
  AcceleratorTotalMemoryMiB *AcceleratorTotalMemoryMiBRequest `json:"AcceleratorTotalMemoryMiB,omitempty"`
  AcceleratorTypes []string `json:"AcceleratorTypes,omitempty"`
  AllowedInstanceTypes []string `json:"AllowedInstanceTypes,omitempty"`
  BareMetal string `json:"BareMetal,omitempty"`
  BaselineEbsBandwidthMbps *BaselineEbsBandwidthMbpsRequest `json:"BaselineEbsBandwidthMbps,omitempty"`
  BurstablePerformance string `json:"BurstablePerformance,omitempty"`
  CpuManufacturers []string `json:"CpuManufacturers,omitempty"`
  ExcludedInstanceTypes []string `json:"ExcludedInstanceTypes,omitempty"`
  InstanceGenerations []string `json:"InstanceGenerations,omitempty"`
  LocalStorage string `json:"LocalStorage,omitempty"`
  LocalStorageTypes []string `json:"LocalStorageTypes,omitempty"`
  MemoryGiBPerVCpu *MemoryGiBPerVCpuRequest `json:"MemoryGiBPerVCpu,omitempty"`
  MemoryMiB *MemoryMiBRequest `json:"MemoryMiB,omitempty"`
  NetworkBandwidthGbps *NetworkBandwidthGbpsRequest `json:"NetworkBandwidthGbps,omitempty"`
  NetworkInterfaceCount *NetworkInterfaceCountRequest `json:"NetworkInterfaceCount,omitempty"`
  OnDemandMaxPricePercentageOverLowestPrice int `json:"OnDemandMaxPricePercentageOverLowestPrice,omitempty"`
  RequireHibernateSupport bool `json:"RequireHibernateSupport,omitempty"`
  SpotMaxPricePercentageOverLowestPrice int `json:"SpotMaxPricePercentageOverLowestPrice,omitempty"`
  TotalLocalStorageGB *TotalLocalStorageGBRequest `json:"TotalLocalStorageGB,omitempty"`
  VCpuCount *VCpuCountRangeRequest `json:"VCpuCount,omitempty"`
}

// MaintenanceStrategies 
type MaintenanceStrategies struct {
  CapacityRebalance *CapacityRebalance `json:"CapacityRebalance,omitempty"`
}

// MemoryGiBPerVCpuRequest 
type MemoryGiBPerVCpuRequest struct {
  Max float64 `json:"Max,omitempty"`
  Min float64 `json:"Min,omitempty"`
}

// MemoryMiBRequest 
type MemoryMiBRequest struct {
  Max int `json:"Max,omitempty"`
  Min int `json:"Min,omitempty"`
}

// NetworkBandwidthGbpsRequest 
type NetworkBandwidthGbpsRequest struct {
  Max float64 `json:"Max,omitempty"`
  Min float64 `json:"Min,omitempty"`
}

// NetworkInterfaceCountRequest 
type NetworkInterfaceCountRequest struct {
  Max int `json:"Max,omitempty"`
  Min int `json:"Min,omitempty"`
}

// OnDemandOptionsRequest 
type OnDemandOptionsRequest struct {
  AllocationStrategy string `json:"AllocationStrategy,omitempty"`
  CapacityReservationOptions *CapacityReservationOptionsRequest `json:"CapacityReservationOptions,omitempty"`
  MaxTotalPrice string `json:"MaxTotalPrice,omitempty"`
  MinTargetCapacity int `json:"MinTargetCapacity,omitempty"`
  SingleAvailabilityZone bool `json:"SingleAvailabilityZone,omitempty"`
  SingleInstanceType bool `json:"SingleInstanceType,omitempty"`
}

// Placement 
type Placement struct {
  Affinity string `json:"Affinity,omitempty"`
  AvailabilityZone string `json:"AvailabilityZone,omitempty"`
  GroupName string `json:"GroupName,omitempty"`
  HostId string `json:"HostId,omitempty"`
  HostResourceGroupArn string `json:"HostResourceGroupArn,omitempty"`
  PartitionNumber int `json:"PartitionNumber,omitempty"`
  SpreadDomain string `json:"SpreadDomain,omitempty"`
  Tenancy string `json:"Tenancy,omitempty"`
}

// Resource Resource Type definition for AWS::EC2::EC2Fleet
type Resource struct {
  Context string `json:"Context,omitempty"`
  ExcessCapacityTerminationPolicy string `json:"ExcessCapacityTerminationPolicy,omitempty"`
  FleetId string `json:"FleetId,omitempty"`
  LaunchTemplateConfigs []*FleetLaunchTemplateConfigRequest `json:"LaunchTemplateConfigs"`
  OnDemandOptions *OnDemandOptionsRequest `json:"OnDemandOptions,omitempty"`
  ReplaceUnhealthyInstances bool `json:"ReplaceUnhealthyInstances,omitempty"`
  SpotOptions *SpotOptionsRequest `json:"SpotOptions,omitempty"`
  TagSpecifications []*TagSpecification `json:"TagSpecifications,omitempty"`
  TargetCapacitySpecification *TargetCapacitySpecificationRequest `json:"TargetCapacitySpecification"`
  TerminateInstancesWithExpiration bool `json:"TerminateInstancesWithExpiration,omitempty"`
  Type string `json:"Type,omitempty"`
  ValidFrom string `json:"ValidFrom,omitempty"`
  ValidUntil string `json:"ValidUntil,omitempty"`
}

// SpotOptionsRequest 
type SpotOptionsRequest struct {
  AllocationStrategy string `json:"AllocationStrategy,omitempty"`
  InstanceInterruptionBehavior string `json:"InstanceInterruptionBehavior,omitempty"`
  InstancePoolsToUseCount int `json:"InstancePoolsToUseCount,omitempty"`
  MaintenanceStrategies *MaintenanceStrategies `json:"MaintenanceStrategies,omitempty"`
  MaxTotalPrice string `json:"MaxTotalPrice,omitempty"`
  MinTargetCapacity int `json:"MinTargetCapacity,omitempty"`
  SingleAvailabilityZone bool `json:"SingleAvailabilityZone,omitempty"`
  SingleInstanceType bool `json:"SingleInstanceType,omitempty"`
}

// Tag 
type Tag struct {
  Key string `json:"Key"`
  Value string `json:"Value"`
}

// TagSpecification 
type TagSpecification struct {
  ResourceType string `json:"ResourceType,omitempty"`
  Tags []*Tag `json:"Tags,omitempty"`
}

// TargetCapacitySpecificationRequest 
type TargetCapacitySpecificationRequest struct {
  DefaultTargetCapacityType string `json:"DefaultTargetCapacityType,omitempty"`
  OnDemandTargetCapacity int `json:"OnDemandTargetCapacity,omitempty"`
  SpotTargetCapacity int `json:"SpotTargetCapacity,omitempty"`
  TargetCapacityUnitType string `json:"TargetCapacityUnitType,omitempty"`
  TotalTargetCapacity int `json:"TotalTargetCapacity"`
}

// TotalLocalStorageGBRequest 
type TotalLocalStorageGBRequest struct {
  Max float64 `json:"Max,omitempty"`
  Min float64 `json:"Min,omitempty"`
}

// VCpuCountRangeRequest 
type VCpuCountRangeRequest struct {
  Max int `json:"Max,omitempty"`
  Min int `json:"Min,omitempty"`
}

func (strct *AcceleratorCountRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Max" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Max\": ")
	if tmp, err := json.Marshal(strct.Max); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Min" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Min\": ")
	if tmp, err := json.Marshal(strct.Min); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AcceleratorCountRequest) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Max":
            if err := json.Unmarshal([]byte(v), &strct.Max); err != nil {
                return err
             }
        case "Min":
            if err := json.Unmarshal([]byte(v), &strct.Min); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *AcceleratorTotalMemoryMiBRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Max" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Max\": ")
	if tmp, err := json.Marshal(strct.Max); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Min" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Min\": ")
	if tmp, err := json.Marshal(strct.Min); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AcceleratorTotalMemoryMiBRequest) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Max":
            if err := json.Unmarshal([]byte(v), &strct.Max); err != nil {
                return err
             }
        case "Min":
            if err := json.Unmarshal([]byte(v), &strct.Min); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *BaselineEbsBandwidthMbpsRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Max" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Max\": ")
	if tmp, err := json.Marshal(strct.Max); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Min" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Min\": ")
	if tmp, err := json.Marshal(strct.Min); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BaselineEbsBandwidthMbpsRequest) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Max":
            if err := json.Unmarshal([]byte(v), &strct.Max); err != nil {
                return err
             }
        case "Min":
            if err := json.Unmarshal([]byte(v), &strct.Min); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *CapacityRebalance) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ReplacementStrategy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ReplacementStrategy\": ")
	if tmp, err := json.Marshal(strct.ReplacementStrategy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TerminationDelay" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TerminationDelay\": ")
	if tmp, err := json.Marshal(strct.TerminationDelay); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CapacityRebalance) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ReplacementStrategy":
            if err := json.Unmarshal([]byte(v), &strct.ReplacementStrategy); err != nil {
                return err
             }
        case "TerminationDelay":
            if err := json.Unmarshal([]byte(v), &strct.TerminationDelay); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *CapacityReservationOptionsRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "UsageStrategy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UsageStrategy\": ")
	if tmp, err := json.Marshal(strct.UsageStrategy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CapacityReservationOptionsRequest) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "UsageStrategy":
            if err := json.Unmarshal([]byte(v), &strct.UsageStrategy); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *FleetLaunchTemplateConfigRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "LaunchTemplateSpecification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LaunchTemplateSpecification\": ")
	if tmp, err := json.Marshal(strct.LaunchTemplateSpecification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Overrides" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Overrides\": ")
	if tmp, err := json.Marshal(strct.Overrides); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FleetLaunchTemplateConfigRequest) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "LaunchTemplateSpecification":
            if err := json.Unmarshal([]byte(v), &strct.LaunchTemplateSpecification); err != nil {
                return err
             }
        case "Overrides":
            if err := json.Unmarshal([]byte(v), &strct.Overrides); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *FleetLaunchTemplateOverridesRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AvailabilityZone" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AvailabilityZone\": ")
	if tmp, err := json.Marshal(strct.AvailabilityZone); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "InstanceRequirements" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InstanceRequirements\": ")
	if tmp, err := json.Marshal(strct.InstanceRequirements); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "InstanceType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InstanceType\": ")
	if tmp, err := json.Marshal(strct.InstanceType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MaxPrice" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaxPrice\": ")
	if tmp, err := json.Marshal(strct.MaxPrice); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Placement" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Placement\": ")
	if tmp, err := json.Marshal(strct.Placement); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Priority" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Priority\": ")
	if tmp, err := json.Marshal(strct.Priority); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SubnetId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SubnetId\": ")
	if tmp, err := json.Marshal(strct.SubnetId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "WeightedCapacity" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"WeightedCapacity\": ")
	if tmp, err := json.Marshal(strct.WeightedCapacity); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FleetLaunchTemplateOverridesRequest) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AvailabilityZone":
            if err := json.Unmarshal([]byte(v), &strct.AvailabilityZone); err != nil {
                return err
             }
        case "InstanceRequirements":
            if err := json.Unmarshal([]byte(v), &strct.InstanceRequirements); err != nil {
                return err
             }
        case "InstanceType":
            if err := json.Unmarshal([]byte(v), &strct.InstanceType); err != nil {
                return err
             }
        case "MaxPrice":
            if err := json.Unmarshal([]byte(v), &strct.MaxPrice); err != nil {
                return err
             }
        case "Placement":
            if err := json.Unmarshal([]byte(v), &strct.Placement); err != nil {
                return err
             }
        case "Priority":
            if err := json.Unmarshal([]byte(v), &strct.Priority); err != nil {
                return err
             }
        case "SubnetId":
            if err := json.Unmarshal([]byte(v), &strct.SubnetId); err != nil {
                return err
             }
        case "WeightedCapacity":
            if err := json.Unmarshal([]byte(v), &strct.WeightedCapacity); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *FleetLaunchTemplateSpecificationRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "LaunchTemplateId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LaunchTemplateId\": ")
	if tmp, err := json.Marshal(strct.LaunchTemplateId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LaunchTemplateName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LaunchTemplateName\": ")
	if tmp, err := json.Marshal(strct.LaunchTemplateName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Version" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Version" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Version\": ")
	if tmp, err := json.Marshal(strct.Version); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FleetLaunchTemplateSpecificationRequest) UnmarshalJSON(b []byte) error {
    VersionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "LaunchTemplateId":
            if err := json.Unmarshal([]byte(v), &strct.LaunchTemplateId); err != nil {
                return err
             }
        case "LaunchTemplateName":
            if err := json.Unmarshal([]byte(v), &strct.LaunchTemplateName); err != nil {
                return err
             }
        case "Version":
            if err := json.Unmarshal([]byte(v), &strct.Version); err != nil {
                return err
             }
            VersionReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Version (a required property) was received
    if !VersionReceived {
        return errors.New("\"Version\" is required but was not present")
    }
    return nil
}

func (strct *InstanceRequirementsRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AcceleratorCount" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AcceleratorCount\": ")
	if tmp, err := json.Marshal(strct.AcceleratorCount); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AcceleratorManufacturers" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AcceleratorManufacturers\": ")
	if tmp, err := json.Marshal(strct.AcceleratorManufacturers); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AcceleratorNames" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AcceleratorNames\": ")
	if tmp, err := json.Marshal(strct.AcceleratorNames); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AcceleratorTotalMemoryMiB" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AcceleratorTotalMemoryMiB\": ")
	if tmp, err := json.Marshal(strct.AcceleratorTotalMemoryMiB); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AcceleratorTypes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AcceleratorTypes\": ")
	if tmp, err := json.Marshal(strct.AcceleratorTypes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AllowedInstanceTypes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AllowedInstanceTypes\": ")
	if tmp, err := json.Marshal(strct.AllowedInstanceTypes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BareMetal" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BareMetal\": ")
	if tmp, err := json.Marshal(strct.BareMetal); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BaselineEbsBandwidthMbps" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BaselineEbsBandwidthMbps\": ")
	if tmp, err := json.Marshal(strct.BaselineEbsBandwidthMbps); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BurstablePerformance" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BurstablePerformance\": ")
	if tmp, err := json.Marshal(strct.BurstablePerformance); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CpuManufacturers" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CpuManufacturers\": ")
	if tmp, err := json.Marshal(strct.CpuManufacturers); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ExcludedInstanceTypes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ExcludedInstanceTypes\": ")
	if tmp, err := json.Marshal(strct.ExcludedInstanceTypes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "InstanceGenerations" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InstanceGenerations\": ")
	if tmp, err := json.Marshal(strct.InstanceGenerations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LocalStorage" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LocalStorage\": ")
	if tmp, err := json.Marshal(strct.LocalStorage); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LocalStorageTypes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LocalStorageTypes\": ")
	if tmp, err := json.Marshal(strct.LocalStorageTypes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MemoryGiBPerVCpu" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MemoryGiBPerVCpu\": ")
	if tmp, err := json.Marshal(strct.MemoryGiBPerVCpu); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MemoryMiB" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MemoryMiB\": ")
	if tmp, err := json.Marshal(strct.MemoryMiB); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "NetworkBandwidthGbps" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NetworkBandwidthGbps\": ")
	if tmp, err := json.Marshal(strct.NetworkBandwidthGbps); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "NetworkInterfaceCount" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NetworkInterfaceCount\": ")
	if tmp, err := json.Marshal(strct.NetworkInterfaceCount); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OnDemandMaxPricePercentageOverLowestPrice" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OnDemandMaxPricePercentageOverLowestPrice\": ")
	if tmp, err := json.Marshal(strct.OnDemandMaxPricePercentageOverLowestPrice); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RequireHibernateSupport" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RequireHibernateSupport\": ")
	if tmp, err := json.Marshal(strct.RequireHibernateSupport); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SpotMaxPricePercentageOverLowestPrice" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SpotMaxPricePercentageOverLowestPrice\": ")
	if tmp, err := json.Marshal(strct.SpotMaxPricePercentageOverLowestPrice); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TotalLocalStorageGB" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TotalLocalStorageGB\": ")
	if tmp, err := json.Marshal(strct.TotalLocalStorageGB); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VCpuCount" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VCpuCount\": ")
	if tmp, err := json.Marshal(strct.VCpuCount); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *InstanceRequirementsRequest) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AcceleratorCount":
            if err := json.Unmarshal([]byte(v), &strct.AcceleratorCount); err != nil {
                return err
             }
        case "AcceleratorManufacturers":
            if err := json.Unmarshal([]byte(v), &strct.AcceleratorManufacturers); err != nil {
                return err
             }
        case "AcceleratorNames":
            if err := json.Unmarshal([]byte(v), &strct.AcceleratorNames); err != nil {
                return err
             }
        case "AcceleratorTotalMemoryMiB":
            if err := json.Unmarshal([]byte(v), &strct.AcceleratorTotalMemoryMiB); err != nil {
                return err
             }
        case "AcceleratorTypes":
            if err := json.Unmarshal([]byte(v), &strct.AcceleratorTypes); err != nil {
                return err
             }
        case "AllowedInstanceTypes":
            if err := json.Unmarshal([]byte(v), &strct.AllowedInstanceTypes); err != nil {
                return err
             }
        case "BareMetal":
            if err := json.Unmarshal([]byte(v), &strct.BareMetal); err != nil {
                return err
             }
        case "BaselineEbsBandwidthMbps":
            if err := json.Unmarshal([]byte(v), &strct.BaselineEbsBandwidthMbps); err != nil {
                return err
             }
        case "BurstablePerformance":
            if err := json.Unmarshal([]byte(v), &strct.BurstablePerformance); err != nil {
                return err
             }
        case "CpuManufacturers":
            if err := json.Unmarshal([]byte(v), &strct.CpuManufacturers); err != nil {
                return err
             }
        case "ExcludedInstanceTypes":
            if err := json.Unmarshal([]byte(v), &strct.ExcludedInstanceTypes); err != nil {
                return err
             }
        case "InstanceGenerations":
            if err := json.Unmarshal([]byte(v), &strct.InstanceGenerations); err != nil {
                return err
             }
        case "LocalStorage":
            if err := json.Unmarshal([]byte(v), &strct.LocalStorage); err != nil {
                return err
             }
        case "LocalStorageTypes":
            if err := json.Unmarshal([]byte(v), &strct.LocalStorageTypes); err != nil {
                return err
             }
        case "MemoryGiBPerVCpu":
            if err := json.Unmarshal([]byte(v), &strct.MemoryGiBPerVCpu); err != nil {
                return err
             }
        case "MemoryMiB":
            if err := json.Unmarshal([]byte(v), &strct.MemoryMiB); err != nil {
                return err
             }
        case "NetworkBandwidthGbps":
            if err := json.Unmarshal([]byte(v), &strct.NetworkBandwidthGbps); err != nil {
                return err
             }
        case "NetworkInterfaceCount":
            if err := json.Unmarshal([]byte(v), &strct.NetworkInterfaceCount); err != nil {
                return err
             }
        case "OnDemandMaxPricePercentageOverLowestPrice":
            if err := json.Unmarshal([]byte(v), &strct.OnDemandMaxPricePercentageOverLowestPrice); err != nil {
                return err
             }
        case "RequireHibernateSupport":
            if err := json.Unmarshal([]byte(v), &strct.RequireHibernateSupport); err != nil {
                return err
             }
        case "SpotMaxPricePercentageOverLowestPrice":
            if err := json.Unmarshal([]byte(v), &strct.SpotMaxPricePercentageOverLowestPrice); err != nil {
                return err
             }
        case "TotalLocalStorageGB":
            if err := json.Unmarshal([]byte(v), &strct.TotalLocalStorageGB); err != nil {
                return err
             }
        case "VCpuCount":
            if err := json.Unmarshal([]byte(v), &strct.VCpuCount); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *MaintenanceStrategies) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CapacityRebalance" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CapacityRebalance\": ")
	if tmp, err := json.Marshal(strct.CapacityRebalance); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MaintenanceStrategies) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CapacityRebalance":
            if err := json.Unmarshal([]byte(v), &strct.CapacityRebalance); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *MemoryGiBPerVCpuRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Max" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Max\": ")
	if tmp, err := json.Marshal(strct.Max); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Min" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Min\": ")
	if tmp, err := json.Marshal(strct.Min); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MemoryGiBPerVCpuRequest) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Max":
            if err := json.Unmarshal([]byte(v), &strct.Max); err != nil {
                return err
             }
        case "Min":
            if err := json.Unmarshal([]byte(v), &strct.Min); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *MemoryMiBRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Max" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Max\": ")
	if tmp, err := json.Marshal(strct.Max); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Min" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Min\": ")
	if tmp, err := json.Marshal(strct.Min); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MemoryMiBRequest) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Max":
            if err := json.Unmarshal([]byte(v), &strct.Max); err != nil {
                return err
             }
        case "Min":
            if err := json.Unmarshal([]byte(v), &strct.Min); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *NetworkBandwidthGbpsRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Max" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Max\": ")
	if tmp, err := json.Marshal(strct.Max); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Min" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Min\": ")
	if tmp, err := json.Marshal(strct.Min); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *NetworkBandwidthGbpsRequest) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Max":
            if err := json.Unmarshal([]byte(v), &strct.Max); err != nil {
                return err
             }
        case "Min":
            if err := json.Unmarshal([]byte(v), &strct.Min); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *NetworkInterfaceCountRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Max" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Max\": ")
	if tmp, err := json.Marshal(strct.Max); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Min" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Min\": ")
	if tmp, err := json.Marshal(strct.Min); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *NetworkInterfaceCountRequest) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Max":
            if err := json.Unmarshal([]byte(v), &strct.Max); err != nil {
                return err
             }
        case "Min":
            if err := json.Unmarshal([]byte(v), &strct.Min); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *OnDemandOptionsRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AllocationStrategy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AllocationStrategy\": ")
	if tmp, err := json.Marshal(strct.AllocationStrategy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CapacityReservationOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CapacityReservationOptions\": ")
	if tmp, err := json.Marshal(strct.CapacityReservationOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MaxTotalPrice" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaxTotalPrice\": ")
	if tmp, err := json.Marshal(strct.MaxTotalPrice); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MinTargetCapacity" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MinTargetCapacity\": ")
	if tmp, err := json.Marshal(strct.MinTargetCapacity); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SingleAvailabilityZone" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SingleAvailabilityZone\": ")
	if tmp, err := json.Marshal(strct.SingleAvailabilityZone); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SingleInstanceType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SingleInstanceType\": ")
	if tmp, err := json.Marshal(strct.SingleInstanceType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *OnDemandOptionsRequest) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AllocationStrategy":
            if err := json.Unmarshal([]byte(v), &strct.AllocationStrategy); err != nil {
                return err
             }
        case "CapacityReservationOptions":
            if err := json.Unmarshal([]byte(v), &strct.CapacityReservationOptions); err != nil {
                return err
             }
        case "MaxTotalPrice":
            if err := json.Unmarshal([]byte(v), &strct.MaxTotalPrice); err != nil {
                return err
             }
        case "MinTargetCapacity":
            if err := json.Unmarshal([]byte(v), &strct.MinTargetCapacity); err != nil {
                return err
             }
        case "SingleAvailabilityZone":
            if err := json.Unmarshal([]byte(v), &strct.SingleAvailabilityZone); err != nil {
                return err
             }
        case "SingleInstanceType":
            if err := json.Unmarshal([]byte(v), &strct.SingleInstanceType); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Placement) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Affinity" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Affinity\": ")
	if tmp, err := json.Marshal(strct.Affinity); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AvailabilityZone" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AvailabilityZone\": ")
	if tmp, err := json.Marshal(strct.AvailabilityZone); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "GroupName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"GroupName\": ")
	if tmp, err := json.Marshal(strct.GroupName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "HostId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HostId\": ")
	if tmp, err := json.Marshal(strct.HostId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "HostResourceGroupArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HostResourceGroupArn\": ")
	if tmp, err := json.Marshal(strct.HostResourceGroupArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PartitionNumber" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PartitionNumber\": ")
	if tmp, err := json.Marshal(strct.PartitionNumber); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SpreadDomain" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SpreadDomain\": ")
	if tmp, err := json.Marshal(strct.SpreadDomain); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tenancy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tenancy\": ")
	if tmp, err := json.Marshal(strct.Tenancy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Placement) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Affinity":
            if err := json.Unmarshal([]byte(v), &strct.Affinity); err != nil {
                return err
             }
        case "AvailabilityZone":
            if err := json.Unmarshal([]byte(v), &strct.AvailabilityZone); err != nil {
                return err
             }
        case "GroupName":
            if err := json.Unmarshal([]byte(v), &strct.GroupName); err != nil {
                return err
             }
        case "HostId":
            if err := json.Unmarshal([]byte(v), &strct.HostId); err != nil {
                return err
             }
        case "HostResourceGroupArn":
            if err := json.Unmarshal([]byte(v), &strct.HostResourceGroupArn); err != nil {
                return err
             }
        case "PartitionNumber":
            if err := json.Unmarshal([]byte(v), &strct.PartitionNumber); err != nil {
                return err
             }
        case "SpreadDomain":
            if err := json.Unmarshal([]byte(v), &strct.SpreadDomain); err != nil {
                return err
             }
        case "Tenancy":
            if err := json.Unmarshal([]byte(v), &strct.Tenancy); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Context" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Context\": ")
	if tmp, err := json.Marshal(strct.Context); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ExcessCapacityTerminationPolicy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ExcessCapacityTerminationPolicy\": ")
	if tmp, err := json.Marshal(strct.ExcessCapacityTerminationPolicy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FleetId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FleetId\": ")
	if tmp, err := json.Marshal(strct.FleetId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "LaunchTemplateConfigs" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "LaunchTemplateConfigs" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LaunchTemplateConfigs\": ")
	if tmp, err := json.Marshal(strct.LaunchTemplateConfigs); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OnDemandOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OnDemandOptions\": ")
	if tmp, err := json.Marshal(strct.OnDemandOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ReplaceUnhealthyInstances" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ReplaceUnhealthyInstances\": ")
	if tmp, err := json.Marshal(strct.ReplaceUnhealthyInstances); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SpotOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SpotOptions\": ")
	if tmp, err := json.Marshal(strct.SpotOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TagSpecifications" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TagSpecifications\": ")
	if tmp, err := json.Marshal(strct.TagSpecifications); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TargetCapacitySpecification" field is required
    if strct.TargetCapacitySpecification == nil {
        return nil, errors.New("TargetCapacitySpecification is a required field")
    }
    // Marshal the "TargetCapacitySpecification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TargetCapacitySpecification\": ")
	if tmp, err := json.Marshal(strct.TargetCapacitySpecification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TerminateInstancesWithExpiration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TerminateInstancesWithExpiration\": ")
	if tmp, err := json.Marshal(strct.TerminateInstancesWithExpiration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ValidFrom" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ValidFrom\": ")
	if tmp, err := json.Marshal(strct.ValidFrom); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ValidUntil" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ValidUntil\": ")
	if tmp, err := json.Marshal(strct.ValidUntil); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    LaunchTemplateConfigsReceived := false
    TargetCapacitySpecificationReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Context":
            if err := json.Unmarshal([]byte(v), &strct.Context); err != nil {
                return err
             }
        case "ExcessCapacityTerminationPolicy":
            if err := json.Unmarshal([]byte(v), &strct.ExcessCapacityTerminationPolicy); err != nil {
                return err
             }
        case "FleetId":
            if err := json.Unmarshal([]byte(v), &strct.FleetId); err != nil {
                return err
             }
        case "LaunchTemplateConfigs":
            if err := json.Unmarshal([]byte(v), &strct.LaunchTemplateConfigs); err != nil {
                return err
             }
            LaunchTemplateConfigsReceived = true
        case "OnDemandOptions":
            if err := json.Unmarshal([]byte(v), &strct.OnDemandOptions); err != nil {
                return err
             }
        case "ReplaceUnhealthyInstances":
            if err := json.Unmarshal([]byte(v), &strct.ReplaceUnhealthyInstances); err != nil {
                return err
             }
        case "SpotOptions":
            if err := json.Unmarshal([]byte(v), &strct.SpotOptions); err != nil {
                return err
             }
        case "TagSpecifications":
            if err := json.Unmarshal([]byte(v), &strct.TagSpecifications); err != nil {
                return err
             }
        case "TargetCapacitySpecification":
            if err := json.Unmarshal([]byte(v), &strct.TargetCapacitySpecification); err != nil {
                return err
             }
            TargetCapacitySpecificationReceived = true
        case "TerminateInstancesWithExpiration":
            if err := json.Unmarshal([]byte(v), &strct.TerminateInstancesWithExpiration); err != nil {
                return err
             }
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
        case "ValidFrom":
            if err := json.Unmarshal([]byte(v), &strct.ValidFrom); err != nil {
                return err
             }
        case "ValidUntil":
            if err := json.Unmarshal([]byte(v), &strct.ValidUntil); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if LaunchTemplateConfigs (a required property) was received
    if !LaunchTemplateConfigsReceived {
        return errors.New("\"LaunchTemplateConfigs\" is required but was not present")
    }
    // check if TargetCapacitySpecification (a required property) was received
    if !TargetCapacitySpecificationReceived {
        return errors.New("\"TargetCapacitySpecification\" is required but was not present")
    }
    return nil
}

func (strct *SpotOptionsRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AllocationStrategy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AllocationStrategy\": ")
	if tmp, err := json.Marshal(strct.AllocationStrategy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "InstanceInterruptionBehavior" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InstanceInterruptionBehavior\": ")
	if tmp, err := json.Marshal(strct.InstanceInterruptionBehavior); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "InstancePoolsToUseCount" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InstancePoolsToUseCount\": ")
	if tmp, err := json.Marshal(strct.InstancePoolsToUseCount); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MaintenanceStrategies" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaintenanceStrategies\": ")
	if tmp, err := json.Marshal(strct.MaintenanceStrategies); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MaxTotalPrice" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaxTotalPrice\": ")
	if tmp, err := json.Marshal(strct.MaxTotalPrice); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MinTargetCapacity" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MinTargetCapacity\": ")
	if tmp, err := json.Marshal(strct.MinTargetCapacity); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SingleAvailabilityZone" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SingleAvailabilityZone\": ")
	if tmp, err := json.Marshal(strct.SingleAvailabilityZone); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SingleInstanceType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SingleInstanceType\": ")
	if tmp, err := json.Marshal(strct.SingleInstanceType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SpotOptionsRequest) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AllocationStrategy":
            if err := json.Unmarshal([]byte(v), &strct.AllocationStrategy); err != nil {
                return err
             }
        case "InstanceInterruptionBehavior":
            if err := json.Unmarshal([]byte(v), &strct.InstanceInterruptionBehavior); err != nil {
                return err
             }
        case "InstancePoolsToUseCount":
            if err := json.Unmarshal([]byte(v), &strct.InstancePoolsToUseCount); err != nil {
                return err
             }
        case "MaintenanceStrategies":
            if err := json.Unmarshal([]byte(v), &strct.MaintenanceStrategies); err != nil {
                return err
             }
        case "MaxTotalPrice":
            if err := json.Unmarshal([]byte(v), &strct.MaxTotalPrice); err != nil {
                return err
             }
        case "MinTargetCapacity":
            if err := json.Unmarshal([]byte(v), &strct.MinTargetCapacity); err != nil {
                return err
             }
        case "SingleAvailabilityZone":
            if err := json.Unmarshal([]byte(v), &strct.SingleAvailabilityZone); err != nil {
                return err
             }
        case "SingleInstanceType":
            if err := json.Unmarshal([]byte(v), &strct.SingleInstanceType); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *TagSpecification) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ResourceType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ResourceType\": ")
	if tmp, err := json.Marshal(strct.ResourceType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TagSpecification) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ResourceType":
            if err := json.Unmarshal([]byte(v), &strct.ResourceType); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *TargetCapacitySpecificationRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DefaultTargetCapacityType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DefaultTargetCapacityType\": ")
	if tmp, err := json.Marshal(strct.DefaultTargetCapacityType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OnDemandTargetCapacity" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OnDemandTargetCapacity\": ")
	if tmp, err := json.Marshal(strct.OnDemandTargetCapacity); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SpotTargetCapacity" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SpotTargetCapacity\": ")
	if tmp, err := json.Marshal(strct.SpotTargetCapacity); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TargetCapacityUnitType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TargetCapacityUnitType\": ")
	if tmp, err := json.Marshal(strct.TargetCapacityUnitType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TotalTargetCapacity" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TotalTargetCapacity" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TotalTargetCapacity\": ")
	if tmp, err := json.Marshal(strct.TotalTargetCapacity); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TargetCapacitySpecificationRequest) UnmarshalJSON(b []byte) error {
    TotalTargetCapacityReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DefaultTargetCapacityType":
            if err := json.Unmarshal([]byte(v), &strct.DefaultTargetCapacityType); err != nil {
                return err
             }
        case "OnDemandTargetCapacity":
            if err := json.Unmarshal([]byte(v), &strct.OnDemandTargetCapacity); err != nil {
                return err
             }
        case "SpotTargetCapacity":
            if err := json.Unmarshal([]byte(v), &strct.SpotTargetCapacity); err != nil {
                return err
             }
        case "TargetCapacityUnitType":
            if err := json.Unmarshal([]byte(v), &strct.TargetCapacityUnitType); err != nil {
                return err
             }
        case "TotalTargetCapacity":
            if err := json.Unmarshal([]byte(v), &strct.TotalTargetCapacity); err != nil {
                return err
             }
            TotalTargetCapacityReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if TotalTargetCapacity (a required property) was received
    if !TotalTargetCapacityReceived {
        return errors.New("\"TotalTargetCapacity\" is required but was not present")
    }
    return nil
}

func (strct *TotalLocalStorageGBRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Max" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Max\": ")
	if tmp, err := json.Marshal(strct.Max); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Min" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Min\": ")
	if tmp, err := json.Marshal(strct.Min); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TotalLocalStorageGBRequest) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Max":
            if err := json.Unmarshal([]byte(v), &strct.Max); err != nil {
                return err
             }
        case "Min":
            if err := json.Unmarshal([]byte(v), &strct.Min); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *VCpuCountRangeRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Max" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Max\": ")
	if tmp, err := json.Marshal(strct.Max); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Min" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Min\": ")
	if tmp, err := json.Marshal(strct.Min); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *VCpuCountRangeRequest) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Max":
            if err := json.Unmarshal([]byte(v), &strct.Max); err != nil {
                return err
             }
        case "Min":
            if err := json.Unmarshal([]byte(v), &strct.Min); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}
