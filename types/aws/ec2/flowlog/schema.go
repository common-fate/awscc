// Code generated by schema-generate. DO NOT EDIT.

package flowlog

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// DestinationOptions 
type DestinationOptions struct {
  FileFormat string `json:"FileFormat"`
  HiveCompatiblePartitions bool `json:"HiveCompatiblePartitions"`
  PerHourPartition bool `json:"PerHourPartition"`
}

// Resource Specifies a VPC flow log, which enables you to capture IP traffic for a specific network interface, subnet, or VPC.
type Resource struct {

  // The ARN for the IAM role that permits Amazon EC2 to publish flow logs to a CloudWatch Logs log group in your account. If you specify LogDestinationType as s3 or kinesis-data-firehose, do not specify DeliverLogsPermissionArn or LogGroupName.
  DeliverLogsPermissionArn string `json:"DeliverLogsPermissionArn,omitempty"`
  DestinationOptions *DestinationOptions `json:"DestinationOptions,omitempty"`

  // The Flow Log ID
  Id string `json:"Id,omitempty"`

  // Specifies the destination to which the flow log data is to be published. Flow log data can be published to a CloudWatch Logs log group, an Amazon S3 bucket, or a Kinesis Firehose stream. The value specified for this parameter depends on the value specified for LogDestinationType.
  LogDestination string `json:"LogDestination,omitempty"`

  // Specifies the type of destination to which the flow log data is to be published. Flow log data can be published to CloudWatch Logs or Amazon S3.
  LogDestinationType string `json:"LogDestinationType,omitempty"`

  // The fields to include in the flow log record, in the order in which they should appear.
  LogFormat string `json:"LogFormat,omitempty"`

  // The name of a new or existing CloudWatch Logs log group where Amazon EC2 publishes your flow logs. If you specify LogDestinationType as s3 or kinesis-data-firehose, do not specify DeliverLogsPermissionArn or LogGroupName.
  LogGroupName string `json:"LogGroupName,omitempty"`

  // The maximum interval of time during which a flow of packets is captured and aggregated into a flow log record. You can specify 60 seconds (1 minute) or 600 seconds (10 minutes).
  MaxAggregationInterval int `json:"MaxAggregationInterval,omitempty"`

  // The ID of the subnet, network interface, or VPC for which you want to create a flow log.
  ResourceId string `json:"ResourceId"`

  // The type of resource for which to create the flow log. For example, if you specified a VPC ID for the ResourceId property, specify VPC for this property.
  ResourceType string `json:"ResourceType"`

  // The tags to apply to the flow logs.
  Tags []*Tag `json:"Tags,omitempty"`

  // The type of traffic to log. You can log traffic that the resource accepts or rejects, or all traffic.
  TrafficType string `json:"TrafficType,omitempty"`
}

// Tag 
type Tag struct {
  Key string `json:"Key"`
  Value string `json:"Value"`
}

func (strct *DestinationOptions) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "FileFormat" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "FileFormat" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FileFormat\": ")
	if tmp, err := json.Marshal(strct.FileFormat); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "HiveCompatiblePartitions" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "HiveCompatiblePartitions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HiveCompatiblePartitions\": ")
	if tmp, err := json.Marshal(strct.HiveCompatiblePartitions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "PerHourPartition" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "PerHourPartition" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PerHourPartition\": ")
	if tmp, err := json.Marshal(strct.PerHourPartition); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DestinationOptions) UnmarshalJSON(b []byte) error {
    FileFormatReceived := false
    HiveCompatiblePartitionsReceived := false
    PerHourPartitionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "FileFormat":
            if err := json.Unmarshal([]byte(v), &strct.FileFormat); err != nil {
                return err
             }
            FileFormatReceived = true
        case "HiveCompatiblePartitions":
            if err := json.Unmarshal([]byte(v), &strct.HiveCompatiblePartitions); err != nil {
                return err
             }
            HiveCompatiblePartitionsReceived = true
        case "PerHourPartition":
            if err := json.Unmarshal([]byte(v), &strct.PerHourPartition); err != nil {
                return err
             }
            PerHourPartitionReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if FileFormat (a required property) was received
    if !FileFormatReceived {
        return errors.New("\"FileFormat\" is required but was not present")
    }
    // check if HiveCompatiblePartitions (a required property) was received
    if !HiveCompatiblePartitionsReceived {
        return errors.New("\"HiveCompatiblePartitions\" is required but was not present")
    }
    // check if PerHourPartition (a required property) was received
    if !PerHourPartitionReceived {
        return errors.New("\"PerHourPartition\" is required but was not present")
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DeliverLogsPermissionArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DeliverLogsPermissionArn\": ")
	if tmp, err := json.Marshal(strct.DeliverLogsPermissionArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DestinationOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DestinationOptions\": ")
	if tmp, err := json.Marshal(strct.DestinationOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Id" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LogDestination" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LogDestination\": ")
	if tmp, err := json.Marshal(strct.LogDestination); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LogDestinationType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LogDestinationType\": ")
	if tmp, err := json.Marshal(strct.LogDestinationType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LogFormat" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LogFormat\": ")
	if tmp, err := json.Marshal(strct.LogFormat); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LogGroupName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LogGroupName\": ")
	if tmp, err := json.Marshal(strct.LogGroupName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MaxAggregationInterval" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaxAggregationInterval\": ")
	if tmp, err := json.Marshal(strct.MaxAggregationInterval); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ResourceId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ResourceId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ResourceId\": ")
	if tmp, err := json.Marshal(strct.ResourceId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ResourceType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ResourceType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ResourceType\": ")
	if tmp, err := json.Marshal(strct.ResourceType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TrafficType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TrafficType\": ")
	if tmp, err := json.Marshal(strct.TrafficType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    ResourceIdReceived := false
    ResourceTypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DeliverLogsPermissionArn":
            if err := json.Unmarshal([]byte(v), &strct.DeliverLogsPermissionArn); err != nil {
                return err
             }
        case "DestinationOptions":
            if err := json.Unmarshal([]byte(v), &strct.DestinationOptions); err != nil {
                return err
             }
        case "Id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
        case "LogDestination":
            if err := json.Unmarshal([]byte(v), &strct.LogDestination); err != nil {
                return err
             }
        case "LogDestinationType":
            if err := json.Unmarshal([]byte(v), &strct.LogDestinationType); err != nil {
                return err
             }
        case "LogFormat":
            if err := json.Unmarshal([]byte(v), &strct.LogFormat); err != nil {
                return err
             }
        case "LogGroupName":
            if err := json.Unmarshal([]byte(v), &strct.LogGroupName); err != nil {
                return err
             }
        case "MaxAggregationInterval":
            if err := json.Unmarshal([]byte(v), &strct.MaxAggregationInterval); err != nil {
                return err
             }
        case "ResourceId":
            if err := json.Unmarshal([]byte(v), &strct.ResourceId); err != nil {
                return err
             }
            ResourceIdReceived = true
        case "ResourceType":
            if err := json.Unmarshal([]byte(v), &strct.ResourceType); err != nil {
                return err
             }
            ResourceTypeReceived = true
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        case "TrafficType":
            if err := json.Unmarshal([]byte(v), &strct.TrafficType); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ResourceId (a required property) was received
    if !ResourceIdReceived {
        return errors.New("\"ResourceId\" is required but was not present")
    }
    // check if ResourceType (a required property) was received
    if !ResourceTypeReceived {
        return errors.New("\"ResourceType\" is required but was not present")
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}
