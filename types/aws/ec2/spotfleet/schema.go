// Code generated by schema-generate. DO NOT EDIT.

package spotfleet

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// AcceleratorCountRequest 
type AcceleratorCountRequest struct {
  Max int `json:"Max,omitempty"`
  Min int `json:"Min,omitempty"`
}

// AcceleratorTotalMemoryMiBRequest 
type AcceleratorTotalMemoryMiBRequest struct {
  Max int `json:"Max,omitempty"`
  Min int `json:"Min,omitempty"`
}

// BaselineEbsBandwidthMbpsRequest 
type BaselineEbsBandwidthMbpsRequest struct {
  Max int `json:"Max,omitempty"`
  Min int `json:"Min,omitempty"`
}

// BlockDeviceMapping 
type BlockDeviceMapping struct {
  DeviceName string `json:"DeviceName"`
  Ebs *EbsBlockDevice `json:"Ebs,omitempty"`
  NoDevice string `json:"NoDevice,omitempty"`
  VirtualName string `json:"VirtualName,omitempty"`
}

// ClassicLoadBalancer 
type ClassicLoadBalancer struct {
  Name string `json:"Name"`
}

// ClassicLoadBalancersConfig 
type ClassicLoadBalancersConfig struct {
  ClassicLoadBalancers []*ClassicLoadBalancer `json:"ClassicLoadBalancers"`
}

// EbsBlockDevice 
type EbsBlockDevice struct {
  DeleteOnTermination bool `json:"DeleteOnTermination,omitempty"`
  Encrypted bool `json:"Encrypted,omitempty"`
  Iops int `json:"Iops,omitempty"`
  SnapshotId string `json:"SnapshotId,omitempty"`
  VolumeSize int `json:"VolumeSize,omitempty"`
  VolumeType string `json:"VolumeType,omitempty"`
}

// FleetLaunchTemplateSpecification 
type FleetLaunchTemplateSpecification struct {
  LaunchTemplateId string `json:"LaunchTemplateId,omitempty"`
  LaunchTemplateName string `json:"LaunchTemplateName,omitempty"`
  Version string `json:"Version"`
}

// GroupIdentifier 
type GroupIdentifier struct {
  GroupId string `json:"GroupId"`
}

// IamInstanceProfileSpecification 
type IamInstanceProfileSpecification struct {
  Arn string `json:"Arn,omitempty"`
}

// InstanceIpv6Address 
type InstanceIpv6Address struct {
  Ipv6Address string `json:"Ipv6Address"`
}

// InstanceNetworkInterfaceSpecification 
type InstanceNetworkInterfaceSpecification struct {
  AssociatePublicIpAddress bool `json:"AssociatePublicIpAddress,omitempty"`
  DeleteOnTermination bool `json:"DeleteOnTermination,omitempty"`
  Description string `json:"Description,omitempty"`
  DeviceIndex int `json:"DeviceIndex,omitempty"`
  Groups []string `json:"Groups,omitempty"`
  Ipv6AddressCount int `json:"Ipv6AddressCount,omitempty"`
  Ipv6Addresses []*InstanceIpv6Address `json:"Ipv6Addresses,omitempty"`
  NetworkInterfaceId string `json:"NetworkInterfaceId,omitempty"`
  PrivateIpAddresses []*PrivateIpAddressSpecification `json:"PrivateIpAddresses,omitempty"`
  SecondaryPrivateIpAddressCount int `json:"SecondaryPrivateIpAddressCount,omitempty"`
  SubnetId string `json:"SubnetId,omitempty"`
}

// InstanceRequirementsRequest 
type InstanceRequirementsRequest struct {
  AcceleratorCount *AcceleratorCountRequest `json:"AcceleratorCount,omitempty"`
  AcceleratorManufacturers []string `json:"AcceleratorManufacturers,omitempty"`
  AcceleratorNames []string `json:"AcceleratorNames,omitempty"`
  AcceleratorTotalMemoryMiB *AcceleratorTotalMemoryMiBRequest `json:"AcceleratorTotalMemoryMiB,omitempty"`
  AcceleratorTypes []string `json:"AcceleratorTypes,omitempty"`
  AllowedInstanceTypes []string `json:"AllowedInstanceTypes,omitempty"`
  BareMetal string `json:"BareMetal,omitempty"`
  BaselineEbsBandwidthMbps *BaselineEbsBandwidthMbpsRequest `json:"BaselineEbsBandwidthMbps,omitempty"`
  BurstablePerformance string `json:"BurstablePerformance,omitempty"`
  CpuManufacturers []string `json:"CpuManufacturers,omitempty"`
  ExcludedInstanceTypes []string `json:"ExcludedInstanceTypes,omitempty"`
  InstanceGenerations []string `json:"InstanceGenerations,omitempty"`
  LocalStorage string `json:"LocalStorage,omitempty"`
  LocalStorageTypes []string `json:"LocalStorageTypes,omitempty"`
  MemoryGiBPerVCpu *MemoryGiBPerVCpuRequest `json:"MemoryGiBPerVCpu,omitempty"`
  MemoryMiB *MemoryMiBRequest `json:"MemoryMiB,omitempty"`
  NetworkBandwidthGbps *NetworkBandwidthGbpsRequest `json:"NetworkBandwidthGbps,omitempty"`
  NetworkInterfaceCount *NetworkInterfaceCountRequest `json:"NetworkInterfaceCount,omitempty"`
  OnDemandMaxPricePercentageOverLowestPrice int `json:"OnDemandMaxPricePercentageOverLowestPrice,omitempty"`
  RequireHibernateSupport bool `json:"RequireHibernateSupport,omitempty"`
  SpotMaxPricePercentageOverLowestPrice int `json:"SpotMaxPricePercentageOverLowestPrice,omitempty"`
  TotalLocalStorageGB *TotalLocalStorageGBRequest `json:"TotalLocalStorageGB,omitempty"`
  VCpuCount *VCpuCountRangeRequest `json:"VCpuCount,omitempty"`
}

// LaunchTemplateConfig 
type LaunchTemplateConfig struct {
  LaunchTemplateSpecification *FleetLaunchTemplateSpecification `json:"LaunchTemplateSpecification,omitempty"`
  Overrides []*LaunchTemplateOverrides `json:"Overrides,omitempty"`
}

// LaunchTemplateOverrides 
type LaunchTemplateOverrides struct {
  AvailabilityZone string `json:"AvailabilityZone,omitempty"`
  InstanceRequirements *InstanceRequirementsRequest `json:"InstanceRequirements,omitempty"`
  InstanceType string `json:"InstanceType,omitempty"`
  Priority float64 `json:"Priority,omitempty"`
  SpotPrice string `json:"SpotPrice,omitempty"`
  SubnetId string `json:"SubnetId,omitempty"`
  WeightedCapacity float64 `json:"WeightedCapacity,omitempty"`
}

// LoadBalancersConfig 
type LoadBalancersConfig struct {
  ClassicLoadBalancersConfig *ClassicLoadBalancersConfig `json:"ClassicLoadBalancersConfig,omitempty"`
  TargetGroupsConfig *TargetGroupsConfig `json:"TargetGroupsConfig,omitempty"`
}

// MemoryGiBPerVCpuRequest 
type MemoryGiBPerVCpuRequest struct {
  Max float64 `json:"Max,omitempty"`
  Min float64 `json:"Min,omitempty"`
}

// MemoryMiBRequest 
type MemoryMiBRequest struct {
  Max int `json:"Max,omitempty"`
  Min int `json:"Min,omitempty"`
}

// NetworkBandwidthGbpsRequest 
type NetworkBandwidthGbpsRequest struct {
  Max float64 `json:"Max,omitempty"`
  Min float64 `json:"Min,omitempty"`
}

// NetworkInterfaceCountRequest 
type NetworkInterfaceCountRequest struct {
  Max int `json:"Max,omitempty"`
  Min int `json:"Min,omitempty"`
}

// PrivateIpAddressSpecification 
type PrivateIpAddressSpecification struct {
  Primary bool `json:"Primary,omitempty"`
  PrivateIpAddress string `json:"PrivateIpAddress"`
}

// Resource Resource Type definition for AWS::EC2::SpotFleet
type Resource struct {
  Id string `json:"Id,omitempty"`
  SpotFleetRequestConfigData *SpotFleetRequestConfigData `json:"SpotFleetRequestConfigData"`
}

// SpotCapacityRebalance 
type SpotCapacityRebalance struct {
  ReplacementStrategy string `json:"ReplacementStrategy,omitempty"`
  TerminationDelay int `json:"TerminationDelay,omitempty"`
}

// SpotFleetLaunchSpecification 
type SpotFleetLaunchSpecification struct {
  BlockDeviceMappings []*BlockDeviceMapping `json:"BlockDeviceMappings,omitempty"`
  EbsOptimized bool `json:"EbsOptimized,omitempty"`
  IamInstanceProfile *IamInstanceProfileSpecification `json:"IamInstanceProfile,omitempty"`
  ImageId string `json:"ImageId"`
  InstanceRequirements *InstanceRequirementsRequest `json:"InstanceRequirements,omitempty"`
  InstanceType string `json:"InstanceType,omitempty"`
  KernelId string `json:"KernelId,omitempty"`
  KeyName string `json:"KeyName,omitempty"`
  Monitoring *SpotFleetMonitoring `json:"Monitoring,omitempty"`
  NetworkInterfaces []*InstanceNetworkInterfaceSpecification `json:"NetworkInterfaces,omitempty"`
  Placement *SpotPlacement `json:"Placement,omitempty"`
  RamdiskId string `json:"RamdiskId,omitempty"`
  SecurityGroups []*GroupIdentifier `json:"SecurityGroups,omitempty"`
  SpotPrice string `json:"SpotPrice,omitempty"`
  SubnetId string `json:"SubnetId,omitempty"`
  TagSpecifications []*SpotFleetTagSpecification `json:"TagSpecifications,omitempty"`
  UserData string `json:"UserData,omitempty"`
  WeightedCapacity float64 `json:"WeightedCapacity,omitempty"`
}

// SpotFleetMonitoring 
type SpotFleetMonitoring struct {
  Enabled bool `json:"Enabled,omitempty"`
}

// SpotFleetRequestConfigData 
type SpotFleetRequestConfigData struct {
  AllocationStrategy string `json:"AllocationStrategy,omitempty"`
  Context string `json:"Context,omitempty"`
  ExcessCapacityTerminationPolicy string `json:"ExcessCapacityTerminationPolicy,omitempty"`
  IamFleetRole string `json:"IamFleetRole"`
  InstanceInterruptionBehavior string `json:"InstanceInterruptionBehavior,omitempty"`
  InstancePoolsToUseCount int `json:"InstancePoolsToUseCount,omitempty"`
  LaunchSpecifications []*SpotFleetLaunchSpecification `json:"LaunchSpecifications,omitempty"`
  LaunchTemplateConfigs []*LaunchTemplateConfig `json:"LaunchTemplateConfigs,omitempty"`
  LoadBalancersConfig *LoadBalancersConfig `json:"LoadBalancersConfig,omitempty"`
  OnDemandAllocationStrategy string `json:"OnDemandAllocationStrategy,omitempty"`
  OnDemandMaxTotalPrice string `json:"OnDemandMaxTotalPrice,omitempty"`
  OnDemandTargetCapacity int `json:"OnDemandTargetCapacity,omitempty"`
  ReplaceUnhealthyInstances bool `json:"ReplaceUnhealthyInstances,omitempty"`
  SpotMaintenanceStrategies *SpotMaintenanceStrategies `json:"SpotMaintenanceStrategies,omitempty"`
  SpotMaxTotalPrice string `json:"SpotMaxTotalPrice,omitempty"`
  SpotPrice string `json:"SpotPrice,omitempty"`
  TagSpecifications []*SpotFleetTagSpecification `json:"TagSpecifications,omitempty"`
  TargetCapacity int `json:"TargetCapacity"`
  TargetCapacityUnitType string `json:"TargetCapacityUnitType,omitempty"`
  TerminateInstancesWithExpiration bool `json:"TerminateInstancesWithExpiration,omitempty"`
  Type string `json:"Type,omitempty"`
  ValidFrom string `json:"ValidFrom,omitempty"`
  ValidUntil string `json:"ValidUntil,omitempty"`
}

// SpotFleetTagSpecification 
type SpotFleetTagSpecification struct {
  ResourceType string `json:"ResourceType,omitempty"`
  Tags []*Tag `json:"Tags,omitempty"`
}

// SpotMaintenanceStrategies 
type SpotMaintenanceStrategies struct {
  CapacityRebalance *SpotCapacityRebalance `json:"CapacityRebalance,omitempty"`
}

// SpotPlacement 
type SpotPlacement struct {
  AvailabilityZone string `json:"AvailabilityZone,omitempty"`
  GroupName string `json:"GroupName,omitempty"`
  Tenancy string `json:"Tenancy,omitempty"`
}

// Tag 
type Tag struct {
  Key string `json:"Key"`
  Value string `json:"Value"`
}

// TargetGroup 
type TargetGroup struct {
  Arn string `json:"Arn"`
}

// TargetGroupsConfig 
type TargetGroupsConfig struct {
  TargetGroups []*TargetGroup `json:"TargetGroups"`
}

// TotalLocalStorageGBRequest 
type TotalLocalStorageGBRequest struct {
  Max float64 `json:"Max,omitempty"`
  Min float64 `json:"Min,omitempty"`
}

// VCpuCountRangeRequest 
type VCpuCountRangeRequest struct {
  Max int `json:"Max,omitempty"`
  Min int `json:"Min,omitempty"`
}

func (strct *AcceleratorCountRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Max" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Max\": ")
	if tmp, err := json.Marshal(strct.Max); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Min" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Min\": ")
	if tmp, err := json.Marshal(strct.Min); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AcceleratorCountRequest) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Max":
            if err := json.Unmarshal([]byte(v), &strct.Max); err != nil {
                return err
             }
        case "Min":
            if err := json.Unmarshal([]byte(v), &strct.Min); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *AcceleratorTotalMemoryMiBRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Max" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Max\": ")
	if tmp, err := json.Marshal(strct.Max); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Min" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Min\": ")
	if tmp, err := json.Marshal(strct.Min); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AcceleratorTotalMemoryMiBRequest) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Max":
            if err := json.Unmarshal([]byte(v), &strct.Max); err != nil {
                return err
             }
        case "Min":
            if err := json.Unmarshal([]byte(v), &strct.Min); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *BaselineEbsBandwidthMbpsRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Max" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Max\": ")
	if tmp, err := json.Marshal(strct.Max); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Min" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Min\": ")
	if tmp, err := json.Marshal(strct.Min); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BaselineEbsBandwidthMbpsRequest) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Max":
            if err := json.Unmarshal([]byte(v), &strct.Max); err != nil {
                return err
             }
        case "Min":
            if err := json.Unmarshal([]byte(v), &strct.Min); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *BlockDeviceMapping) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "DeviceName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "DeviceName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DeviceName\": ")
	if tmp, err := json.Marshal(strct.DeviceName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Ebs" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Ebs\": ")
	if tmp, err := json.Marshal(strct.Ebs); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "NoDevice" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NoDevice\": ")
	if tmp, err := json.Marshal(strct.NoDevice); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VirtualName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VirtualName\": ")
	if tmp, err := json.Marshal(strct.VirtualName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BlockDeviceMapping) UnmarshalJSON(b []byte) error {
    DeviceNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DeviceName":
            if err := json.Unmarshal([]byte(v), &strct.DeviceName); err != nil {
                return err
             }
            DeviceNameReceived = true
        case "Ebs":
            if err := json.Unmarshal([]byte(v), &strct.Ebs); err != nil {
                return err
             }
        case "NoDevice":
            if err := json.Unmarshal([]byte(v), &strct.NoDevice); err != nil {
                return err
             }
        case "VirtualName":
            if err := json.Unmarshal([]byte(v), &strct.VirtualName); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if DeviceName (a required property) was received
    if !DeviceNameReceived {
        return errors.New("\"DeviceName\" is required but was not present")
    }
    return nil
}

func (strct *ClassicLoadBalancer) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ClassicLoadBalancer) UnmarshalJSON(b []byte) error {
    NameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    return nil
}

func (strct *ClassicLoadBalancersConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ClassicLoadBalancers" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ClassicLoadBalancers" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ClassicLoadBalancers\": ")
	if tmp, err := json.Marshal(strct.ClassicLoadBalancers); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ClassicLoadBalancersConfig) UnmarshalJSON(b []byte) error {
    ClassicLoadBalancersReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ClassicLoadBalancers":
            if err := json.Unmarshal([]byte(v), &strct.ClassicLoadBalancers); err != nil {
                return err
             }
            ClassicLoadBalancersReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ClassicLoadBalancers (a required property) was received
    if !ClassicLoadBalancersReceived {
        return errors.New("\"ClassicLoadBalancers\" is required but was not present")
    }
    return nil
}

func (strct *EbsBlockDevice) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DeleteOnTermination" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DeleteOnTermination\": ")
	if tmp, err := json.Marshal(strct.DeleteOnTermination); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Encrypted" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Encrypted\": ")
	if tmp, err := json.Marshal(strct.Encrypted); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Iops" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Iops\": ")
	if tmp, err := json.Marshal(strct.Iops); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SnapshotId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SnapshotId\": ")
	if tmp, err := json.Marshal(strct.SnapshotId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VolumeSize" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VolumeSize\": ")
	if tmp, err := json.Marshal(strct.VolumeSize); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VolumeType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VolumeType\": ")
	if tmp, err := json.Marshal(strct.VolumeType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *EbsBlockDevice) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DeleteOnTermination":
            if err := json.Unmarshal([]byte(v), &strct.DeleteOnTermination); err != nil {
                return err
             }
        case "Encrypted":
            if err := json.Unmarshal([]byte(v), &strct.Encrypted); err != nil {
                return err
             }
        case "Iops":
            if err := json.Unmarshal([]byte(v), &strct.Iops); err != nil {
                return err
             }
        case "SnapshotId":
            if err := json.Unmarshal([]byte(v), &strct.SnapshotId); err != nil {
                return err
             }
        case "VolumeSize":
            if err := json.Unmarshal([]byte(v), &strct.VolumeSize); err != nil {
                return err
             }
        case "VolumeType":
            if err := json.Unmarshal([]byte(v), &strct.VolumeType); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *FleetLaunchTemplateSpecification) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "LaunchTemplateId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LaunchTemplateId\": ")
	if tmp, err := json.Marshal(strct.LaunchTemplateId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LaunchTemplateName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LaunchTemplateName\": ")
	if tmp, err := json.Marshal(strct.LaunchTemplateName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Version" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Version" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Version\": ")
	if tmp, err := json.Marshal(strct.Version); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FleetLaunchTemplateSpecification) UnmarshalJSON(b []byte) error {
    VersionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "LaunchTemplateId":
            if err := json.Unmarshal([]byte(v), &strct.LaunchTemplateId); err != nil {
                return err
             }
        case "LaunchTemplateName":
            if err := json.Unmarshal([]byte(v), &strct.LaunchTemplateName); err != nil {
                return err
             }
        case "Version":
            if err := json.Unmarshal([]byte(v), &strct.Version); err != nil {
                return err
             }
            VersionReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Version (a required property) was received
    if !VersionReceived {
        return errors.New("\"Version\" is required but was not present")
    }
    return nil
}

func (strct *GroupIdentifier) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "GroupId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "GroupId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"GroupId\": ")
	if tmp, err := json.Marshal(strct.GroupId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *GroupIdentifier) UnmarshalJSON(b []byte) error {
    GroupIdReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "GroupId":
            if err := json.Unmarshal([]byte(v), &strct.GroupId); err != nil {
                return err
             }
            GroupIdReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if GroupId (a required property) was received
    if !GroupIdReceived {
        return errors.New("\"GroupId\" is required but was not present")
    }
    return nil
}

func (strct *IamInstanceProfileSpecification) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Arn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Arn\": ")
	if tmp, err := json.Marshal(strct.Arn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *IamInstanceProfileSpecification) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Arn":
            if err := json.Unmarshal([]byte(v), &strct.Arn); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *InstanceIpv6Address) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Ipv6Address" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Ipv6Address" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Ipv6Address\": ")
	if tmp, err := json.Marshal(strct.Ipv6Address); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *InstanceIpv6Address) UnmarshalJSON(b []byte) error {
    Ipv6AddressReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Ipv6Address":
            if err := json.Unmarshal([]byte(v), &strct.Ipv6Address); err != nil {
                return err
             }
            Ipv6AddressReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Ipv6Address (a required property) was received
    if !Ipv6AddressReceived {
        return errors.New("\"Ipv6Address\" is required but was not present")
    }
    return nil
}

func (strct *InstanceNetworkInterfaceSpecification) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AssociatePublicIpAddress" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AssociatePublicIpAddress\": ")
	if tmp, err := json.Marshal(strct.AssociatePublicIpAddress); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DeleteOnTermination" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DeleteOnTermination\": ")
	if tmp, err := json.Marshal(strct.DeleteOnTermination); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DeviceIndex" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DeviceIndex\": ")
	if tmp, err := json.Marshal(strct.DeviceIndex); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Groups" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Groups\": ")
	if tmp, err := json.Marshal(strct.Groups); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Ipv6AddressCount" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Ipv6AddressCount\": ")
	if tmp, err := json.Marshal(strct.Ipv6AddressCount); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Ipv6Addresses" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Ipv6Addresses\": ")
	if tmp, err := json.Marshal(strct.Ipv6Addresses); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "NetworkInterfaceId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NetworkInterfaceId\": ")
	if tmp, err := json.Marshal(strct.NetworkInterfaceId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PrivateIpAddresses" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PrivateIpAddresses\": ")
	if tmp, err := json.Marshal(strct.PrivateIpAddresses); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SecondaryPrivateIpAddressCount" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SecondaryPrivateIpAddressCount\": ")
	if tmp, err := json.Marshal(strct.SecondaryPrivateIpAddressCount); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SubnetId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SubnetId\": ")
	if tmp, err := json.Marshal(strct.SubnetId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *InstanceNetworkInterfaceSpecification) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AssociatePublicIpAddress":
            if err := json.Unmarshal([]byte(v), &strct.AssociatePublicIpAddress); err != nil {
                return err
             }
        case "DeleteOnTermination":
            if err := json.Unmarshal([]byte(v), &strct.DeleteOnTermination); err != nil {
                return err
             }
        case "Description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "DeviceIndex":
            if err := json.Unmarshal([]byte(v), &strct.DeviceIndex); err != nil {
                return err
             }
        case "Groups":
            if err := json.Unmarshal([]byte(v), &strct.Groups); err != nil {
                return err
             }
        case "Ipv6AddressCount":
            if err := json.Unmarshal([]byte(v), &strct.Ipv6AddressCount); err != nil {
                return err
             }
        case "Ipv6Addresses":
            if err := json.Unmarshal([]byte(v), &strct.Ipv6Addresses); err != nil {
                return err
             }
        case "NetworkInterfaceId":
            if err := json.Unmarshal([]byte(v), &strct.NetworkInterfaceId); err != nil {
                return err
             }
        case "PrivateIpAddresses":
            if err := json.Unmarshal([]byte(v), &strct.PrivateIpAddresses); err != nil {
                return err
             }
        case "SecondaryPrivateIpAddressCount":
            if err := json.Unmarshal([]byte(v), &strct.SecondaryPrivateIpAddressCount); err != nil {
                return err
             }
        case "SubnetId":
            if err := json.Unmarshal([]byte(v), &strct.SubnetId); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *InstanceRequirementsRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AcceleratorCount" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AcceleratorCount\": ")
	if tmp, err := json.Marshal(strct.AcceleratorCount); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AcceleratorManufacturers" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AcceleratorManufacturers\": ")
	if tmp, err := json.Marshal(strct.AcceleratorManufacturers); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AcceleratorNames" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AcceleratorNames\": ")
	if tmp, err := json.Marshal(strct.AcceleratorNames); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AcceleratorTotalMemoryMiB" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AcceleratorTotalMemoryMiB\": ")
	if tmp, err := json.Marshal(strct.AcceleratorTotalMemoryMiB); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AcceleratorTypes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AcceleratorTypes\": ")
	if tmp, err := json.Marshal(strct.AcceleratorTypes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AllowedInstanceTypes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AllowedInstanceTypes\": ")
	if tmp, err := json.Marshal(strct.AllowedInstanceTypes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BareMetal" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BareMetal\": ")
	if tmp, err := json.Marshal(strct.BareMetal); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BaselineEbsBandwidthMbps" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BaselineEbsBandwidthMbps\": ")
	if tmp, err := json.Marshal(strct.BaselineEbsBandwidthMbps); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BurstablePerformance" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BurstablePerformance\": ")
	if tmp, err := json.Marshal(strct.BurstablePerformance); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CpuManufacturers" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CpuManufacturers\": ")
	if tmp, err := json.Marshal(strct.CpuManufacturers); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ExcludedInstanceTypes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ExcludedInstanceTypes\": ")
	if tmp, err := json.Marshal(strct.ExcludedInstanceTypes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "InstanceGenerations" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InstanceGenerations\": ")
	if tmp, err := json.Marshal(strct.InstanceGenerations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LocalStorage" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LocalStorage\": ")
	if tmp, err := json.Marshal(strct.LocalStorage); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LocalStorageTypes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LocalStorageTypes\": ")
	if tmp, err := json.Marshal(strct.LocalStorageTypes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MemoryGiBPerVCpu" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MemoryGiBPerVCpu\": ")
	if tmp, err := json.Marshal(strct.MemoryGiBPerVCpu); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MemoryMiB" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MemoryMiB\": ")
	if tmp, err := json.Marshal(strct.MemoryMiB); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "NetworkBandwidthGbps" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NetworkBandwidthGbps\": ")
	if tmp, err := json.Marshal(strct.NetworkBandwidthGbps); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "NetworkInterfaceCount" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NetworkInterfaceCount\": ")
	if tmp, err := json.Marshal(strct.NetworkInterfaceCount); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OnDemandMaxPricePercentageOverLowestPrice" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OnDemandMaxPricePercentageOverLowestPrice\": ")
	if tmp, err := json.Marshal(strct.OnDemandMaxPricePercentageOverLowestPrice); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RequireHibernateSupport" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RequireHibernateSupport\": ")
	if tmp, err := json.Marshal(strct.RequireHibernateSupport); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SpotMaxPricePercentageOverLowestPrice" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SpotMaxPricePercentageOverLowestPrice\": ")
	if tmp, err := json.Marshal(strct.SpotMaxPricePercentageOverLowestPrice); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TotalLocalStorageGB" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TotalLocalStorageGB\": ")
	if tmp, err := json.Marshal(strct.TotalLocalStorageGB); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VCpuCount" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VCpuCount\": ")
	if tmp, err := json.Marshal(strct.VCpuCount); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *InstanceRequirementsRequest) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AcceleratorCount":
            if err := json.Unmarshal([]byte(v), &strct.AcceleratorCount); err != nil {
                return err
             }
        case "AcceleratorManufacturers":
            if err := json.Unmarshal([]byte(v), &strct.AcceleratorManufacturers); err != nil {
                return err
             }
        case "AcceleratorNames":
            if err := json.Unmarshal([]byte(v), &strct.AcceleratorNames); err != nil {
                return err
             }
        case "AcceleratorTotalMemoryMiB":
            if err := json.Unmarshal([]byte(v), &strct.AcceleratorTotalMemoryMiB); err != nil {
                return err
             }
        case "AcceleratorTypes":
            if err := json.Unmarshal([]byte(v), &strct.AcceleratorTypes); err != nil {
                return err
             }
        case "AllowedInstanceTypes":
            if err := json.Unmarshal([]byte(v), &strct.AllowedInstanceTypes); err != nil {
                return err
             }
        case "BareMetal":
            if err := json.Unmarshal([]byte(v), &strct.BareMetal); err != nil {
                return err
             }
        case "BaselineEbsBandwidthMbps":
            if err := json.Unmarshal([]byte(v), &strct.BaselineEbsBandwidthMbps); err != nil {
                return err
             }
        case "BurstablePerformance":
            if err := json.Unmarshal([]byte(v), &strct.BurstablePerformance); err != nil {
                return err
             }
        case "CpuManufacturers":
            if err := json.Unmarshal([]byte(v), &strct.CpuManufacturers); err != nil {
                return err
             }
        case "ExcludedInstanceTypes":
            if err := json.Unmarshal([]byte(v), &strct.ExcludedInstanceTypes); err != nil {
                return err
             }
        case "InstanceGenerations":
            if err := json.Unmarshal([]byte(v), &strct.InstanceGenerations); err != nil {
                return err
             }
        case "LocalStorage":
            if err := json.Unmarshal([]byte(v), &strct.LocalStorage); err != nil {
                return err
             }
        case "LocalStorageTypes":
            if err := json.Unmarshal([]byte(v), &strct.LocalStorageTypes); err != nil {
                return err
             }
        case "MemoryGiBPerVCpu":
            if err := json.Unmarshal([]byte(v), &strct.MemoryGiBPerVCpu); err != nil {
                return err
             }
        case "MemoryMiB":
            if err := json.Unmarshal([]byte(v), &strct.MemoryMiB); err != nil {
                return err
             }
        case "NetworkBandwidthGbps":
            if err := json.Unmarshal([]byte(v), &strct.NetworkBandwidthGbps); err != nil {
                return err
             }
        case "NetworkInterfaceCount":
            if err := json.Unmarshal([]byte(v), &strct.NetworkInterfaceCount); err != nil {
                return err
             }
        case "OnDemandMaxPricePercentageOverLowestPrice":
            if err := json.Unmarshal([]byte(v), &strct.OnDemandMaxPricePercentageOverLowestPrice); err != nil {
                return err
             }
        case "RequireHibernateSupport":
            if err := json.Unmarshal([]byte(v), &strct.RequireHibernateSupport); err != nil {
                return err
             }
        case "SpotMaxPricePercentageOverLowestPrice":
            if err := json.Unmarshal([]byte(v), &strct.SpotMaxPricePercentageOverLowestPrice); err != nil {
                return err
             }
        case "TotalLocalStorageGB":
            if err := json.Unmarshal([]byte(v), &strct.TotalLocalStorageGB); err != nil {
                return err
             }
        case "VCpuCount":
            if err := json.Unmarshal([]byte(v), &strct.VCpuCount); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *LaunchTemplateConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "LaunchTemplateSpecification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LaunchTemplateSpecification\": ")
	if tmp, err := json.Marshal(strct.LaunchTemplateSpecification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Overrides" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Overrides\": ")
	if tmp, err := json.Marshal(strct.Overrides); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LaunchTemplateConfig) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "LaunchTemplateSpecification":
            if err := json.Unmarshal([]byte(v), &strct.LaunchTemplateSpecification); err != nil {
                return err
             }
        case "Overrides":
            if err := json.Unmarshal([]byte(v), &strct.Overrides); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *LaunchTemplateOverrides) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AvailabilityZone" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AvailabilityZone\": ")
	if tmp, err := json.Marshal(strct.AvailabilityZone); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "InstanceRequirements" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InstanceRequirements\": ")
	if tmp, err := json.Marshal(strct.InstanceRequirements); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "InstanceType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InstanceType\": ")
	if tmp, err := json.Marshal(strct.InstanceType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Priority" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Priority\": ")
	if tmp, err := json.Marshal(strct.Priority); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SpotPrice" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SpotPrice\": ")
	if tmp, err := json.Marshal(strct.SpotPrice); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SubnetId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SubnetId\": ")
	if tmp, err := json.Marshal(strct.SubnetId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "WeightedCapacity" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"WeightedCapacity\": ")
	if tmp, err := json.Marshal(strct.WeightedCapacity); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LaunchTemplateOverrides) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AvailabilityZone":
            if err := json.Unmarshal([]byte(v), &strct.AvailabilityZone); err != nil {
                return err
             }
        case "InstanceRequirements":
            if err := json.Unmarshal([]byte(v), &strct.InstanceRequirements); err != nil {
                return err
             }
        case "InstanceType":
            if err := json.Unmarshal([]byte(v), &strct.InstanceType); err != nil {
                return err
             }
        case "Priority":
            if err := json.Unmarshal([]byte(v), &strct.Priority); err != nil {
                return err
             }
        case "SpotPrice":
            if err := json.Unmarshal([]byte(v), &strct.SpotPrice); err != nil {
                return err
             }
        case "SubnetId":
            if err := json.Unmarshal([]byte(v), &strct.SubnetId); err != nil {
                return err
             }
        case "WeightedCapacity":
            if err := json.Unmarshal([]byte(v), &strct.WeightedCapacity); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *LoadBalancersConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ClassicLoadBalancersConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ClassicLoadBalancersConfig\": ")
	if tmp, err := json.Marshal(strct.ClassicLoadBalancersConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TargetGroupsConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TargetGroupsConfig\": ")
	if tmp, err := json.Marshal(strct.TargetGroupsConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LoadBalancersConfig) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ClassicLoadBalancersConfig":
            if err := json.Unmarshal([]byte(v), &strct.ClassicLoadBalancersConfig); err != nil {
                return err
             }
        case "TargetGroupsConfig":
            if err := json.Unmarshal([]byte(v), &strct.TargetGroupsConfig); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *MemoryGiBPerVCpuRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Max" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Max\": ")
	if tmp, err := json.Marshal(strct.Max); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Min" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Min\": ")
	if tmp, err := json.Marshal(strct.Min); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MemoryGiBPerVCpuRequest) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Max":
            if err := json.Unmarshal([]byte(v), &strct.Max); err != nil {
                return err
             }
        case "Min":
            if err := json.Unmarshal([]byte(v), &strct.Min); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *MemoryMiBRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Max" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Max\": ")
	if tmp, err := json.Marshal(strct.Max); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Min" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Min\": ")
	if tmp, err := json.Marshal(strct.Min); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MemoryMiBRequest) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Max":
            if err := json.Unmarshal([]byte(v), &strct.Max); err != nil {
                return err
             }
        case "Min":
            if err := json.Unmarshal([]byte(v), &strct.Min); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *NetworkBandwidthGbpsRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Max" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Max\": ")
	if tmp, err := json.Marshal(strct.Max); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Min" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Min\": ")
	if tmp, err := json.Marshal(strct.Min); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *NetworkBandwidthGbpsRequest) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Max":
            if err := json.Unmarshal([]byte(v), &strct.Max); err != nil {
                return err
             }
        case "Min":
            if err := json.Unmarshal([]byte(v), &strct.Min); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *NetworkInterfaceCountRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Max" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Max\": ")
	if tmp, err := json.Marshal(strct.Max); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Min" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Min\": ")
	if tmp, err := json.Marshal(strct.Min); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *NetworkInterfaceCountRequest) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Max":
            if err := json.Unmarshal([]byte(v), &strct.Max); err != nil {
                return err
             }
        case "Min":
            if err := json.Unmarshal([]byte(v), &strct.Min); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *PrivateIpAddressSpecification) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Primary" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Primary\": ")
	if tmp, err := json.Marshal(strct.Primary); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "PrivateIpAddress" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "PrivateIpAddress" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PrivateIpAddress\": ")
	if tmp, err := json.Marshal(strct.PrivateIpAddress); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PrivateIpAddressSpecification) UnmarshalJSON(b []byte) error {
    PrivateIpAddressReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Primary":
            if err := json.Unmarshal([]byte(v), &strct.Primary); err != nil {
                return err
             }
        case "PrivateIpAddress":
            if err := json.Unmarshal([]byte(v), &strct.PrivateIpAddress); err != nil {
                return err
             }
            PrivateIpAddressReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if PrivateIpAddress (a required property) was received
    if !PrivateIpAddressReceived {
        return errors.New("\"PrivateIpAddress\" is required but was not present")
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Id" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "SpotFleetRequestConfigData" field is required
    if strct.SpotFleetRequestConfigData == nil {
        return nil, errors.New("SpotFleetRequestConfigData is a required field")
    }
    // Marshal the "SpotFleetRequestConfigData" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SpotFleetRequestConfigData\": ")
	if tmp, err := json.Marshal(strct.SpotFleetRequestConfigData); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    SpotFleetRequestConfigDataReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
        case "SpotFleetRequestConfigData":
            if err := json.Unmarshal([]byte(v), &strct.SpotFleetRequestConfigData); err != nil {
                return err
             }
            SpotFleetRequestConfigDataReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if SpotFleetRequestConfigData (a required property) was received
    if !SpotFleetRequestConfigDataReceived {
        return errors.New("\"SpotFleetRequestConfigData\" is required but was not present")
    }
    return nil
}

func (strct *SpotCapacityRebalance) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ReplacementStrategy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ReplacementStrategy\": ")
	if tmp, err := json.Marshal(strct.ReplacementStrategy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TerminationDelay" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TerminationDelay\": ")
	if tmp, err := json.Marshal(strct.TerminationDelay); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SpotCapacityRebalance) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ReplacementStrategy":
            if err := json.Unmarshal([]byte(v), &strct.ReplacementStrategy); err != nil {
                return err
             }
        case "TerminationDelay":
            if err := json.Unmarshal([]byte(v), &strct.TerminationDelay); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *SpotFleetLaunchSpecification) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "BlockDeviceMappings" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BlockDeviceMappings\": ")
	if tmp, err := json.Marshal(strct.BlockDeviceMappings); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EbsOptimized" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EbsOptimized\": ")
	if tmp, err := json.Marshal(strct.EbsOptimized); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IamInstanceProfile" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IamInstanceProfile\": ")
	if tmp, err := json.Marshal(strct.IamInstanceProfile); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ImageId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ImageId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ImageId\": ")
	if tmp, err := json.Marshal(strct.ImageId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "InstanceRequirements" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InstanceRequirements\": ")
	if tmp, err := json.Marshal(strct.InstanceRequirements); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "InstanceType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InstanceType\": ")
	if tmp, err := json.Marshal(strct.InstanceType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "KernelId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KernelId\": ")
	if tmp, err := json.Marshal(strct.KernelId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "KeyName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KeyName\": ")
	if tmp, err := json.Marshal(strct.KeyName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Monitoring" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Monitoring\": ")
	if tmp, err := json.Marshal(strct.Monitoring); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "NetworkInterfaces" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NetworkInterfaces\": ")
	if tmp, err := json.Marshal(strct.NetworkInterfaces); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Placement" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Placement\": ")
	if tmp, err := json.Marshal(strct.Placement); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RamdiskId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RamdiskId\": ")
	if tmp, err := json.Marshal(strct.RamdiskId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SecurityGroups" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SecurityGroups\": ")
	if tmp, err := json.Marshal(strct.SecurityGroups); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SpotPrice" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SpotPrice\": ")
	if tmp, err := json.Marshal(strct.SpotPrice); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SubnetId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SubnetId\": ")
	if tmp, err := json.Marshal(strct.SubnetId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TagSpecifications" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TagSpecifications\": ")
	if tmp, err := json.Marshal(strct.TagSpecifications); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "UserData" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UserData\": ")
	if tmp, err := json.Marshal(strct.UserData); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "WeightedCapacity" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"WeightedCapacity\": ")
	if tmp, err := json.Marshal(strct.WeightedCapacity); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SpotFleetLaunchSpecification) UnmarshalJSON(b []byte) error {
    ImageIdReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BlockDeviceMappings":
            if err := json.Unmarshal([]byte(v), &strct.BlockDeviceMappings); err != nil {
                return err
             }
        case "EbsOptimized":
            if err := json.Unmarshal([]byte(v), &strct.EbsOptimized); err != nil {
                return err
             }
        case "IamInstanceProfile":
            if err := json.Unmarshal([]byte(v), &strct.IamInstanceProfile); err != nil {
                return err
             }
        case "ImageId":
            if err := json.Unmarshal([]byte(v), &strct.ImageId); err != nil {
                return err
             }
            ImageIdReceived = true
        case "InstanceRequirements":
            if err := json.Unmarshal([]byte(v), &strct.InstanceRequirements); err != nil {
                return err
             }
        case "InstanceType":
            if err := json.Unmarshal([]byte(v), &strct.InstanceType); err != nil {
                return err
             }
        case "KernelId":
            if err := json.Unmarshal([]byte(v), &strct.KernelId); err != nil {
                return err
             }
        case "KeyName":
            if err := json.Unmarshal([]byte(v), &strct.KeyName); err != nil {
                return err
             }
        case "Monitoring":
            if err := json.Unmarshal([]byte(v), &strct.Monitoring); err != nil {
                return err
             }
        case "NetworkInterfaces":
            if err := json.Unmarshal([]byte(v), &strct.NetworkInterfaces); err != nil {
                return err
             }
        case "Placement":
            if err := json.Unmarshal([]byte(v), &strct.Placement); err != nil {
                return err
             }
        case "RamdiskId":
            if err := json.Unmarshal([]byte(v), &strct.RamdiskId); err != nil {
                return err
             }
        case "SecurityGroups":
            if err := json.Unmarshal([]byte(v), &strct.SecurityGroups); err != nil {
                return err
             }
        case "SpotPrice":
            if err := json.Unmarshal([]byte(v), &strct.SpotPrice); err != nil {
                return err
             }
        case "SubnetId":
            if err := json.Unmarshal([]byte(v), &strct.SubnetId); err != nil {
                return err
             }
        case "TagSpecifications":
            if err := json.Unmarshal([]byte(v), &strct.TagSpecifications); err != nil {
                return err
             }
        case "UserData":
            if err := json.Unmarshal([]byte(v), &strct.UserData); err != nil {
                return err
             }
        case "WeightedCapacity":
            if err := json.Unmarshal([]byte(v), &strct.WeightedCapacity); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ImageId (a required property) was received
    if !ImageIdReceived {
        return errors.New("\"ImageId\" is required but was not present")
    }
    return nil
}

func (strct *SpotFleetMonitoring) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Enabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SpotFleetMonitoring) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Enabled":
            if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *SpotFleetRequestConfigData) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AllocationStrategy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AllocationStrategy\": ")
	if tmp, err := json.Marshal(strct.AllocationStrategy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Context" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Context\": ")
	if tmp, err := json.Marshal(strct.Context); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ExcessCapacityTerminationPolicy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ExcessCapacityTerminationPolicy\": ")
	if tmp, err := json.Marshal(strct.ExcessCapacityTerminationPolicy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "IamFleetRole" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "IamFleetRole" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IamFleetRole\": ")
	if tmp, err := json.Marshal(strct.IamFleetRole); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "InstanceInterruptionBehavior" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InstanceInterruptionBehavior\": ")
	if tmp, err := json.Marshal(strct.InstanceInterruptionBehavior); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "InstancePoolsToUseCount" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InstancePoolsToUseCount\": ")
	if tmp, err := json.Marshal(strct.InstancePoolsToUseCount); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LaunchSpecifications" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LaunchSpecifications\": ")
	if tmp, err := json.Marshal(strct.LaunchSpecifications); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LaunchTemplateConfigs" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LaunchTemplateConfigs\": ")
	if tmp, err := json.Marshal(strct.LaunchTemplateConfigs); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LoadBalancersConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LoadBalancersConfig\": ")
	if tmp, err := json.Marshal(strct.LoadBalancersConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OnDemandAllocationStrategy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OnDemandAllocationStrategy\": ")
	if tmp, err := json.Marshal(strct.OnDemandAllocationStrategy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OnDemandMaxTotalPrice" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OnDemandMaxTotalPrice\": ")
	if tmp, err := json.Marshal(strct.OnDemandMaxTotalPrice); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OnDemandTargetCapacity" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OnDemandTargetCapacity\": ")
	if tmp, err := json.Marshal(strct.OnDemandTargetCapacity); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ReplaceUnhealthyInstances" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ReplaceUnhealthyInstances\": ")
	if tmp, err := json.Marshal(strct.ReplaceUnhealthyInstances); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SpotMaintenanceStrategies" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SpotMaintenanceStrategies\": ")
	if tmp, err := json.Marshal(strct.SpotMaintenanceStrategies); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SpotMaxTotalPrice" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SpotMaxTotalPrice\": ")
	if tmp, err := json.Marshal(strct.SpotMaxTotalPrice); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SpotPrice" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SpotPrice\": ")
	if tmp, err := json.Marshal(strct.SpotPrice); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TagSpecifications" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TagSpecifications\": ")
	if tmp, err := json.Marshal(strct.TagSpecifications); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TargetCapacity" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TargetCapacity" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TargetCapacity\": ")
	if tmp, err := json.Marshal(strct.TargetCapacity); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TargetCapacityUnitType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TargetCapacityUnitType\": ")
	if tmp, err := json.Marshal(strct.TargetCapacityUnitType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TerminateInstancesWithExpiration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TerminateInstancesWithExpiration\": ")
	if tmp, err := json.Marshal(strct.TerminateInstancesWithExpiration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ValidFrom" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ValidFrom\": ")
	if tmp, err := json.Marshal(strct.ValidFrom); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ValidUntil" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ValidUntil\": ")
	if tmp, err := json.Marshal(strct.ValidUntil); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SpotFleetRequestConfigData) UnmarshalJSON(b []byte) error {
    IamFleetRoleReceived := false
    TargetCapacityReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AllocationStrategy":
            if err := json.Unmarshal([]byte(v), &strct.AllocationStrategy); err != nil {
                return err
             }
        case "Context":
            if err := json.Unmarshal([]byte(v), &strct.Context); err != nil {
                return err
             }
        case "ExcessCapacityTerminationPolicy":
            if err := json.Unmarshal([]byte(v), &strct.ExcessCapacityTerminationPolicy); err != nil {
                return err
             }
        case "IamFleetRole":
            if err := json.Unmarshal([]byte(v), &strct.IamFleetRole); err != nil {
                return err
             }
            IamFleetRoleReceived = true
        case "InstanceInterruptionBehavior":
            if err := json.Unmarshal([]byte(v), &strct.InstanceInterruptionBehavior); err != nil {
                return err
             }
        case "InstancePoolsToUseCount":
            if err := json.Unmarshal([]byte(v), &strct.InstancePoolsToUseCount); err != nil {
                return err
             }
        case "LaunchSpecifications":
            if err := json.Unmarshal([]byte(v), &strct.LaunchSpecifications); err != nil {
                return err
             }
        case "LaunchTemplateConfigs":
            if err := json.Unmarshal([]byte(v), &strct.LaunchTemplateConfigs); err != nil {
                return err
             }
        case "LoadBalancersConfig":
            if err := json.Unmarshal([]byte(v), &strct.LoadBalancersConfig); err != nil {
                return err
             }
        case "OnDemandAllocationStrategy":
            if err := json.Unmarshal([]byte(v), &strct.OnDemandAllocationStrategy); err != nil {
                return err
             }
        case "OnDemandMaxTotalPrice":
            if err := json.Unmarshal([]byte(v), &strct.OnDemandMaxTotalPrice); err != nil {
                return err
             }
        case "OnDemandTargetCapacity":
            if err := json.Unmarshal([]byte(v), &strct.OnDemandTargetCapacity); err != nil {
                return err
             }
        case "ReplaceUnhealthyInstances":
            if err := json.Unmarshal([]byte(v), &strct.ReplaceUnhealthyInstances); err != nil {
                return err
             }
        case "SpotMaintenanceStrategies":
            if err := json.Unmarshal([]byte(v), &strct.SpotMaintenanceStrategies); err != nil {
                return err
             }
        case "SpotMaxTotalPrice":
            if err := json.Unmarshal([]byte(v), &strct.SpotMaxTotalPrice); err != nil {
                return err
             }
        case "SpotPrice":
            if err := json.Unmarshal([]byte(v), &strct.SpotPrice); err != nil {
                return err
             }
        case "TagSpecifications":
            if err := json.Unmarshal([]byte(v), &strct.TagSpecifications); err != nil {
                return err
             }
        case "TargetCapacity":
            if err := json.Unmarshal([]byte(v), &strct.TargetCapacity); err != nil {
                return err
             }
            TargetCapacityReceived = true
        case "TargetCapacityUnitType":
            if err := json.Unmarshal([]byte(v), &strct.TargetCapacityUnitType); err != nil {
                return err
             }
        case "TerminateInstancesWithExpiration":
            if err := json.Unmarshal([]byte(v), &strct.TerminateInstancesWithExpiration); err != nil {
                return err
             }
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
        case "ValidFrom":
            if err := json.Unmarshal([]byte(v), &strct.ValidFrom); err != nil {
                return err
             }
        case "ValidUntil":
            if err := json.Unmarshal([]byte(v), &strct.ValidUntil); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if IamFleetRole (a required property) was received
    if !IamFleetRoleReceived {
        return errors.New("\"IamFleetRole\" is required but was not present")
    }
    // check if TargetCapacity (a required property) was received
    if !TargetCapacityReceived {
        return errors.New("\"TargetCapacity\" is required but was not present")
    }
    return nil
}

func (strct *SpotFleetTagSpecification) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ResourceType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ResourceType\": ")
	if tmp, err := json.Marshal(strct.ResourceType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SpotFleetTagSpecification) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ResourceType":
            if err := json.Unmarshal([]byte(v), &strct.ResourceType); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *SpotMaintenanceStrategies) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CapacityRebalance" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CapacityRebalance\": ")
	if tmp, err := json.Marshal(strct.CapacityRebalance); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SpotMaintenanceStrategies) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CapacityRebalance":
            if err := json.Unmarshal([]byte(v), &strct.CapacityRebalance); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *SpotPlacement) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AvailabilityZone" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AvailabilityZone\": ")
	if tmp, err := json.Marshal(strct.AvailabilityZone); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "GroupName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"GroupName\": ")
	if tmp, err := json.Marshal(strct.GroupName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tenancy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tenancy\": ")
	if tmp, err := json.Marshal(strct.Tenancy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SpotPlacement) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AvailabilityZone":
            if err := json.Unmarshal([]byte(v), &strct.AvailabilityZone); err != nil {
                return err
             }
        case "GroupName":
            if err := json.Unmarshal([]byte(v), &strct.GroupName); err != nil {
                return err
             }
        case "Tenancy":
            if err := json.Unmarshal([]byte(v), &strct.Tenancy); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *TargetGroup) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Arn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Arn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Arn\": ")
	if tmp, err := json.Marshal(strct.Arn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TargetGroup) UnmarshalJSON(b []byte) error {
    ArnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Arn":
            if err := json.Unmarshal([]byte(v), &strct.Arn); err != nil {
                return err
             }
            ArnReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Arn (a required property) was received
    if !ArnReceived {
        return errors.New("\"Arn\" is required but was not present")
    }
    return nil
}

func (strct *TargetGroupsConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "TargetGroups" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TargetGroups" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TargetGroups\": ")
	if tmp, err := json.Marshal(strct.TargetGroups); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TargetGroupsConfig) UnmarshalJSON(b []byte) error {
    TargetGroupsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "TargetGroups":
            if err := json.Unmarshal([]byte(v), &strct.TargetGroups); err != nil {
                return err
             }
            TargetGroupsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if TargetGroups (a required property) was received
    if !TargetGroupsReceived {
        return errors.New("\"TargetGroups\" is required but was not present")
    }
    return nil
}

func (strct *TotalLocalStorageGBRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Max" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Max\": ")
	if tmp, err := json.Marshal(strct.Max); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Min" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Min\": ")
	if tmp, err := json.Marshal(strct.Min); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TotalLocalStorageGBRequest) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Max":
            if err := json.Unmarshal([]byte(v), &strct.Max); err != nil {
                return err
             }
        case "Min":
            if err := json.Unmarshal([]byte(v), &strct.Min); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *VCpuCountRangeRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Max" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Max\": ")
	if tmp, err := json.Marshal(strct.Max); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Min" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Min\": ")
	if tmp, err := json.Marshal(strct.Min); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *VCpuCountRangeRequest) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Max":
            if err := json.Unmarshal([]byte(v), &strct.Max); err != nil {
                return err
             }
        case "Min":
            if err := json.Unmarshal([]byte(v), &strct.Min); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}
