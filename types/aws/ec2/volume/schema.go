// Code generated by schema-generate. DO NOT EDIT.

package volume

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// Resource Resource Type definition for AWS::EC2::Volume
type Resource struct {

  // The Availability Zone in which to create the volume.
  AutoEnableIO bool `json:"AutoEnableIO,omitempty"`

  // The Availability Zone in which to create the volume.
  AvailabilityZone string `json:"AvailabilityZone"`

  // Specifies whether the volume should be encrypted. The effect of setting the encryption state to true depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see Encryption by default in the Amazon Elastic Compute Cloud User Guide. Encrypted Amazon EBS volumes must be attached to instances that support Amazon EBS encryption. For more information, see Supported instance types.
  Encrypted bool `json:"Encrypted,omitempty"`

  // The number of I/O operations per second (IOPS) to provision for an io1 or io2 volume, with a maximum ratio of 50 IOPS/GiB for io1, and 500 IOPS/GiB for io2. Range is 100 to 64,000 IOPS for volumes in most Regions. Maximum IOPS of 64,000 is guaranteed only on Nitro-based instances. Other instance families guarantee performance up to 32,000 IOPS. For more information, see Amazon EBS volume types in the Amazon Elastic Compute Cloud User Guide. This parameter is valid only for Provisioned IOPS SSD (io1 and io2) volumes. 
  Iops int `json:"Iops,omitempty"`

  // The identifier of the AWS Key Management Service (AWS KMS) customer master key (CMK) to use for Amazon EBS encryption. If KmsKeyId is specified, the encrypted state must be true. If you omit this property and your account is enabled for encryption by default, or Encrypted is set to true, then the volume is encrypted using the default CMK specified for your account. If your account does not have a default CMK, then the volume is encrypted using the AWS managed CMK.  Alternatively, if you want to specify a different CMK, you can specify one of the following:  Key ID. For example, 1234abcd-12ab-34cd-56ef-1234567890ab. Key alias. Specify the alias for the CMK, prefixed with alias/. For example, for a CMK with the alias my_cmk, use alias/my_cmk. Or to specify the AWS managed CMK, use alias/aws/ebs. Key ARN. For example, arn:aws:kms:us-east-1:012345678910:key/1234abcd-12ab-34cd-56ef-1234567890ab. Alias ARN. For example, arn:aws:kms:us-east-1:012345678910:alias/ExampleAlias.
  KmsKeyId string `json:"KmsKeyId,omitempty"`

  // Indicates whether Amazon EBS Multi-Attach is enabled.
  MultiAttachEnabled bool `json:"MultiAttachEnabled,omitempty"`

  // The Amazon Resource Name (ARN) of the Outpost.
  OutpostArn string `json:"OutpostArn,omitempty"`

  // The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size.  Constraints: 1-16,384 for gp2, 4-16,384 for io1 and io2, 500-16,384 for st1, 500-16,384 for sc1, and 1-1,024 for standard. If you specify a snapshot, the volume size must be equal to or larger than the snapshot size. Default: If you're creating the volume from a snapshot and don't specify a volume size, the default is the snapshot size. 
  Size int `json:"Size,omitempty"`

  // The snapshot from which to create the volume. You must specify either a snapshot ID or a volume size. 
  SnapshotId string `json:"SnapshotId,omitempty"`

  // The tags to apply to the volume during creation.
  Tags []*Tag `json:"Tags,omitempty"`

  // The throughput that the volume supports, in MiB/s.
  Throughput int `json:"Throughput,omitempty"`
  VolumeId string `json:"VolumeId,omitempty"`

  // The volume type. This parameter can be one of the following values: General Purpose SSD: gp2 | gp3, Provisioned IOPS SSD: io1 | io2, Throughput Optimized HDD: st1, Cold HDD: sc1, Magnetic: standard
  VolumeType string `json:"VolumeType,omitempty"`
}

// Tag 
type Tag struct {

  // The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
  Key string `json:"Key"`

  // The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
  Value string `json:"Value"`
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AutoEnableIO" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AutoEnableIO\": ")
	if tmp, err := json.Marshal(strct.AutoEnableIO); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "AvailabilityZone" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AvailabilityZone" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AvailabilityZone\": ")
	if tmp, err := json.Marshal(strct.AvailabilityZone); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Encrypted" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Encrypted\": ")
	if tmp, err := json.Marshal(strct.Encrypted); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Iops" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Iops\": ")
	if tmp, err := json.Marshal(strct.Iops); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "KmsKeyId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KmsKeyId\": ")
	if tmp, err := json.Marshal(strct.KmsKeyId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MultiAttachEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MultiAttachEnabled\": ")
	if tmp, err := json.Marshal(strct.MultiAttachEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OutpostArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OutpostArn\": ")
	if tmp, err := json.Marshal(strct.OutpostArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Size" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Size\": ")
	if tmp, err := json.Marshal(strct.Size); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SnapshotId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SnapshotId\": ")
	if tmp, err := json.Marshal(strct.SnapshotId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Throughput" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Throughput\": ")
	if tmp, err := json.Marshal(strct.Throughput); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VolumeId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VolumeId\": ")
	if tmp, err := json.Marshal(strct.VolumeId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VolumeType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VolumeType\": ")
	if tmp, err := json.Marshal(strct.VolumeType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    AvailabilityZoneReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AutoEnableIO":
            if err := json.Unmarshal([]byte(v), &strct.AutoEnableIO); err != nil {
                return err
             }
        case "AvailabilityZone":
            if err := json.Unmarshal([]byte(v), &strct.AvailabilityZone); err != nil {
                return err
             }
            AvailabilityZoneReceived = true
        case "Encrypted":
            if err := json.Unmarshal([]byte(v), &strct.Encrypted); err != nil {
                return err
             }
        case "Iops":
            if err := json.Unmarshal([]byte(v), &strct.Iops); err != nil {
                return err
             }
        case "KmsKeyId":
            if err := json.Unmarshal([]byte(v), &strct.KmsKeyId); err != nil {
                return err
             }
        case "MultiAttachEnabled":
            if err := json.Unmarshal([]byte(v), &strct.MultiAttachEnabled); err != nil {
                return err
             }
        case "OutpostArn":
            if err := json.Unmarshal([]byte(v), &strct.OutpostArn); err != nil {
                return err
             }
        case "Size":
            if err := json.Unmarshal([]byte(v), &strct.Size); err != nil {
                return err
             }
        case "SnapshotId":
            if err := json.Unmarshal([]byte(v), &strct.SnapshotId); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        case "Throughput":
            if err := json.Unmarshal([]byte(v), &strct.Throughput); err != nil {
                return err
             }
        case "VolumeId":
            if err := json.Unmarshal([]byte(v), &strct.VolumeId); err != nil {
                return err
             }
        case "VolumeType":
            if err := json.Unmarshal([]byte(v), &strct.VolumeType); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if AvailabilityZone (a required property) was received
    if !AvailabilityZoneReceived {
        return errors.New("\"AvailabilityZone\" is required but was not present")
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}
