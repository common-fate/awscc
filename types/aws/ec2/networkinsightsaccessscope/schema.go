// Code generated by schema-generate. DO NOT EDIT.

package networkinsightsaccessscope

import (
    "fmt"
    "errors"
    "bytes"
    "encoding/json"
)

// AccessScopePathRequest 
type AccessScopePathRequest struct {
  Destination *PathStatementRequest `json:"Destination,omitempty"`
  Source *PathStatementRequest `json:"Source,omitempty"`
  ThroughResources []*ThroughResourcesStatementRequest `json:"ThroughResources,omitempty"`
}

// PacketHeaderStatementRequest 
type PacketHeaderStatementRequest struct {
  DestinationAddresses []string `json:"DestinationAddresses,omitempty"`
  DestinationPorts []string `json:"DestinationPorts,omitempty"`
  DestinationPrefixLists []string `json:"DestinationPrefixLists,omitempty"`
  Protocols []string `json:"Protocols,omitempty"`
  SourceAddresses []string `json:"SourceAddresses,omitempty"`
  SourcePorts []string `json:"SourcePorts,omitempty"`
  SourcePrefixLists []string `json:"SourcePrefixLists,omitempty"`
}

// PathStatementRequest 
type PathStatementRequest struct {
  PacketHeaderStatement *PacketHeaderStatementRequest `json:"PacketHeaderStatement,omitempty"`
  ResourceStatement *ResourceStatementRequest `json:"ResourceStatement,omitempty"`
}

// Resource Resource schema for AWS::EC2::NetworkInsightsAccessScope
type Resource struct {
  CreatedDate string `json:"CreatedDate,omitempty"`
  ExcludePaths []*AccessScopePathRequest `json:"ExcludePaths,omitempty"`
  MatchPaths []*AccessScopePathRequest `json:"MatchPaths,omitempty"`
  NetworkInsightsAccessScopeArn string `json:"NetworkInsightsAccessScopeArn,omitempty"`
  NetworkInsightsAccessScopeId string `json:"NetworkInsightsAccessScopeId,omitempty"`
  Tags []*Tag `json:"Tags,omitempty"`
  UpdatedDate string `json:"UpdatedDate,omitempty"`
}

// ResourceStatementRequest 
type ResourceStatementRequest struct {
  ResourceTypes []string `json:"ResourceTypes,omitempty"`
  Resources []string `json:"Resources,omitempty"`
}

// Tag 
type Tag struct {
  Key string `json:"Key"`
  Value string `json:"Value,omitempty"`
}

// ThroughResourcesStatementRequest 
type ThroughResourcesStatementRequest struct {
  ResourceStatement *ResourceStatementRequest `json:"ResourceStatement,omitempty"`
}

func (strct *AccessScopePathRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Destination" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Destination\": ")
	if tmp, err := json.Marshal(strct.Destination); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Source" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Source\": ")
	if tmp, err := json.Marshal(strct.Source); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ThroughResources" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ThroughResources\": ")
	if tmp, err := json.Marshal(strct.ThroughResources); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AccessScopePathRequest) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Destination":
            if err := json.Unmarshal([]byte(v), &strct.Destination); err != nil {
                return err
             }
        case "Source":
            if err := json.Unmarshal([]byte(v), &strct.Source); err != nil {
                return err
             }
        case "ThroughResources":
            if err := json.Unmarshal([]byte(v), &strct.ThroughResources); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *PacketHeaderStatementRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DestinationAddresses" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DestinationAddresses\": ")
	if tmp, err := json.Marshal(strct.DestinationAddresses); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DestinationPorts" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DestinationPorts\": ")
	if tmp, err := json.Marshal(strct.DestinationPorts); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DestinationPrefixLists" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DestinationPrefixLists\": ")
	if tmp, err := json.Marshal(strct.DestinationPrefixLists); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Protocols" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Protocols\": ")
	if tmp, err := json.Marshal(strct.Protocols); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SourceAddresses" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SourceAddresses\": ")
	if tmp, err := json.Marshal(strct.SourceAddresses); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SourcePorts" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SourcePorts\": ")
	if tmp, err := json.Marshal(strct.SourcePorts); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SourcePrefixLists" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SourcePrefixLists\": ")
	if tmp, err := json.Marshal(strct.SourcePrefixLists); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PacketHeaderStatementRequest) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DestinationAddresses":
            if err := json.Unmarshal([]byte(v), &strct.DestinationAddresses); err != nil {
                return err
             }
        case "DestinationPorts":
            if err := json.Unmarshal([]byte(v), &strct.DestinationPorts); err != nil {
                return err
             }
        case "DestinationPrefixLists":
            if err := json.Unmarshal([]byte(v), &strct.DestinationPrefixLists); err != nil {
                return err
             }
        case "Protocols":
            if err := json.Unmarshal([]byte(v), &strct.Protocols); err != nil {
                return err
             }
        case "SourceAddresses":
            if err := json.Unmarshal([]byte(v), &strct.SourceAddresses); err != nil {
                return err
             }
        case "SourcePorts":
            if err := json.Unmarshal([]byte(v), &strct.SourcePorts); err != nil {
                return err
             }
        case "SourcePrefixLists":
            if err := json.Unmarshal([]byte(v), &strct.SourcePrefixLists); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *PathStatementRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "PacketHeaderStatement" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PacketHeaderStatement\": ")
	if tmp, err := json.Marshal(strct.PacketHeaderStatement); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ResourceStatement" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ResourceStatement\": ")
	if tmp, err := json.Marshal(strct.ResourceStatement); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PathStatementRequest) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "PacketHeaderStatement":
            if err := json.Unmarshal([]byte(v), &strct.PacketHeaderStatement); err != nil {
                return err
             }
        case "ResourceStatement":
            if err := json.Unmarshal([]byte(v), &strct.ResourceStatement); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CreatedDate" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CreatedDate\": ")
	if tmp, err := json.Marshal(strct.CreatedDate); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ExcludePaths" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ExcludePaths\": ")
	if tmp, err := json.Marshal(strct.ExcludePaths); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MatchPaths" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MatchPaths\": ")
	if tmp, err := json.Marshal(strct.MatchPaths); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "NetworkInsightsAccessScopeArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NetworkInsightsAccessScopeArn\": ")
	if tmp, err := json.Marshal(strct.NetworkInsightsAccessScopeArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "NetworkInsightsAccessScopeId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NetworkInsightsAccessScopeId\": ")
	if tmp, err := json.Marshal(strct.NetworkInsightsAccessScopeId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "UpdatedDate" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UpdatedDate\": ")
	if tmp, err := json.Marshal(strct.UpdatedDate); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CreatedDate":
            if err := json.Unmarshal([]byte(v), &strct.CreatedDate); err != nil {
                return err
             }
        case "ExcludePaths":
            if err := json.Unmarshal([]byte(v), &strct.ExcludePaths); err != nil {
                return err
             }
        case "MatchPaths":
            if err := json.Unmarshal([]byte(v), &strct.MatchPaths); err != nil {
                return err
             }
        case "NetworkInsightsAccessScopeArn":
            if err := json.Unmarshal([]byte(v), &strct.NetworkInsightsAccessScopeArn); err != nil {
                return err
             }
        case "NetworkInsightsAccessScopeId":
            if err := json.Unmarshal([]byte(v), &strct.NetworkInsightsAccessScopeId); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        case "UpdatedDate":
            if err := json.Unmarshal([]byte(v), &strct.UpdatedDate); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ResourceStatementRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ResourceTypes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ResourceTypes\": ")
	if tmp, err := json.Marshal(strct.ResourceTypes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Resources" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Resources\": ")
	if tmp, err := json.Marshal(strct.Resources); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ResourceStatementRequest) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ResourceTypes":
            if err := json.Unmarshal([]byte(v), &strct.ResourceTypes); err != nil {
                return err
             }
        case "Resources":
            if err := json.Unmarshal([]byte(v), &strct.Resources); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    return nil
}

func (strct *ThroughResourcesStatementRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ResourceStatement" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ResourceStatement\": ")
	if tmp, err := json.Marshal(strct.ResourceStatement); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ThroughResourcesStatementRequest) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ResourceStatement":
            if err := json.Unmarshal([]byte(v), &strct.ResourceStatement); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}
