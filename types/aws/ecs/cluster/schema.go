// Code generated by schema-generate. DO NOT EDIT.

package cluster

import (
    "bytes"
    "encoding/json"
    "fmt"
)

// CapacityProviderStrategyItem A capacity provider strategy consists of one or more capacity providers along with the `base` and `weight` to assign to them. A capacity provider must be associated with the cluster to be used in a capacity provider strategy. The PutClusterCapacityProviders API is used to associate a capacity provider with a cluster. Only capacity providers with an `ACTIVE` or `UPDATING` status can be used.
type CapacityProviderStrategyItem struct {
  Base int `json:"Base,omitempty"`
  CapacityProvider string `json:"CapacityProvider,omitempty"`
  Weight int `json:"Weight,omitempty"`
}

// ClusterConfiguration The configurations to be set at cluster level.
type ClusterConfiguration struct {
  ExecuteCommandConfiguration *ExecuteCommandConfiguration `json:"ExecuteCommandConfiguration,omitempty"`
}

// ClusterSettings The setting to use when creating a cluster. This parameter is used to enable CloudWatch Container Insights for a cluster. If this value is specified, it will override the containerInsights value set with PutAccountSetting or PutAccountSettingDefault.
type ClusterSettings struct {
  Name string `json:"Name,omitempty"`
  Value string `json:"Value,omitempty"`
}

// ExecuteCommandConfiguration The configuration for ExecuteCommand.
type ExecuteCommandConfiguration struct {
  KmsKeyId string `json:"KmsKeyId,omitempty"`
  LogConfiguration *ExecuteCommandLogConfiguration `json:"LogConfiguration,omitempty"`
  Logging string `json:"Logging,omitempty"`
}

// ExecuteCommandLogConfiguration The session logging configuration for ExecuteCommand.
type ExecuteCommandLogConfiguration struct {
  CloudWatchEncryptionEnabled bool `json:"CloudWatchEncryptionEnabled,omitempty"`
  CloudWatchLogGroupName string `json:"CloudWatchLogGroupName,omitempty"`
  S3BucketName string `json:"S3BucketName,omitempty"`
  S3EncryptionEnabled bool `json:"S3EncryptionEnabled,omitempty"`
  S3KeyPrefix string `json:"S3KeyPrefix,omitempty"`
}

// Resource Create an Elastic Container Service (ECS) cluster.
type Resource struct {

  // The Amazon Resource Name (ARN) of the Amazon ECS cluster, such as arn:aws:ecs:us-east-2:123456789012:cluster/MyECSCluster.
  Arn string `json:"Arn,omitempty"`
  CapacityProviders []string `json:"CapacityProviders,omitempty"`

  // A user-generated string that you use to identify your cluster. If you don't specify a name, AWS CloudFormation generates a unique physical ID for the name.
  ClusterName string `json:"ClusterName,omitempty"`
  ClusterSettings []*ClusterSettings `json:"ClusterSettings,omitempty"`
  Configuration *ClusterConfiguration `json:"Configuration,omitempty"`
  DefaultCapacityProviderStrategy []*CapacityProviderStrategyItem `json:"DefaultCapacityProviderStrategy,omitempty"`
  ServiceConnectDefaults *ServiceConnectDefaults `json:"ServiceConnectDefaults,omitempty"`
  Tags []*Tag `json:"Tags,omitempty"`
}

// ServiceConnectDefaults Service Connect Configuration default for all services or tasks within this cluster
type ServiceConnectDefaults struct {

  // Service Connect Namespace Name or ARN default for all services or tasks within this cluster
  Namespace string `json:"Namespace,omitempty"`
}

// Tag The metadata that you apply to the cluster to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define.
type Tag struct {
  Key string `json:"Key,omitempty"`
  Value string `json:"Value,omitempty"`
}

func (strct *CapacityProviderStrategyItem) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Base" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Base\": ")
	if tmp, err := json.Marshal(strct.Base); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CapacityProvider" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CapacityProvider\": ")
	if tmp, err := json.Marshal(strct.CapacityProvider); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Weight" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Weight\": ")
	if tmp, err := json.Marshal(strct.Weight); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CapacityProviderStrategyItem) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Base":
            if err := json.Unmarshal([]byte(v), &strct.Base); err != nil {
                return err
             }
        case "CapacityProvider":
            if err := json.Unmarshal([]byte(v), &strct.CapacityProvider); err != nil {
                return err
             }
        case "Weight":
            if err := json.Unmarshal([]byte(v), &strct.Weight); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ClusterConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ExecuteCommandConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ExecuteCommandConfiguration\": ")
	if tmp, err := json.Marshal(strct.ExecuteCommandConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ClusterConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ExecuteCommandConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.ExecuteCommandConfiguration); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ClusterSettings) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ClusterSettings) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ExecuteCommandConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "KmsKeyId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KmsKeyId\": ")
	if tmp, err := json.Marshal(strct.KmsKeyId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LogConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LogConfiguration\": ")
	if tmp, err := json.Marshal(strct.LogConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Logging" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Logging\": ")
	if tmp, err := json.Marshal(strct.Logging); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ExecuteCommandConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "KmsKeyId":
            if err := json.Unmarshal([]byte(v), &strct.KmsKeyId); err != nil {
                return err
             }
        case "LogConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.LogConfiguration); err != nil {
                return err
             }
        case "Logging":
            if err := json.Unmarshal([]byte(v), &strct.Logging); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ExecuteCommandLogConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CloudWatchEncryptionEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CloudWatchEncryptionEnabled\": ")
	if tmp, err := json.Marshal(strct.CloudWatchEncryptionEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CloudWatchLogGroupName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CloudWatchLogGroupName\": ")
	if tmp, err := json.Marshal(strct.CloudWatchLogGroupName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "S3BucketName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3BucketName\": ")
	if tmp, err := json.Marshal(strct.S3BucketName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "S3EncryptionEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3EncryptionEnabled\": ")
	if tmp, err := json.Marshal(strct.S3EncryptionEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "S3KeyPrefix" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3KeyPrefix\": ")
	if tmp, err := json.Marshal(strct.S3KeyPrefix); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ExecuteCommandLogConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CloudWatchEncryptionEnabled":
            if err := json.Unmarshal([]byte(v), &strct.CloudWatchEncryptionEnabled); err != nil {
                return err
             }
        case "CloudWatchLogGroupName":
            if err := json.Unmarshal([]byte(v), &strct.CloudWatchLogGroupName); err != nil {
                return err
             }
        case "S3BucketName":
            if err := json.Unmarshal([]byte(v), &strct.S3BucketName); err != nil {
                return err
             }
        case "S3EncryptionEnabled":
            if err := json.Unmarshal([]byte(v), &strct.S3EncryptionEnabled); err != nil {
                return err
             }
        case "S3KeyPrefix":
            if err := json.Unmarshal([]byte(v), &strct.S3KeyPrefix); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Arn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Arn\": ")
	if tmp, err := json.Marshal(strct.Arn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CapacityProviders" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CapacityProviders\": ")
	if tmp, err := json.Marshal(strct.CapacityProviders); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ClusterName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ClusterName\": ")
	if tmp, err := json.Marshal(strct.ClusterName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ClusterSettings" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ClusterSettings\": ")
	if tmp, err := json.Marshal(strct.ClusterSettings); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Configuration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Configuration\": ")
	if tmp, err := json.Marshal(strct.Configuration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DefaultCapacityProviderStrategy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DefaultCapacityProviderStrategy\": ")
	if tmp, err := json.Marshal(strct.DefaultCapacityProviderStrategy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ServiceConnectDefaults" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ServiceConnectDefaults\": ")
	if tmp, err := json.Marshal(strct.ServiceConnectDefaults); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Arn":
            if err := json.Unmarshal([]byte(v), &strct.Arn); err != nil {
                return err
             }
        case "CapacityProviders":
            if err := json.Unmarshal([]byte(v), &strct.CapacityProviders); err != nil {
                return err
             }
        case "ClusterName":
            if err := json.Unmarshal([]byte(v), &strct.ClusterName); err != nil {
                return err
             }
        case "ClusterSettings":
            if err := json.Unmarshal([]byte(v), &strct.ClusterSettings); err != nil {
                return err
             }
        case "Configuration":
            if err := json.Unmarshal([]byte(v), &strct.Configuration); err != nil {
                return err
             }
        case "DefaultCapacityProviderStrategy":
            if err := json.Unmarshal([]byte(v), &strct.DefaultCapacityProviderStrategy); err != nil {
                return err
             }
        case "ServiceConnectDefaults":
            if err := json.Unmarshal([]byte(v), &strct.ServiceConnectDefaults); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ServiceConnectDefaults) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Namespace" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Namespace\": ")
	if tmp, err := json.Marshal(strct.Namespace); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ServiceConnectDefaults) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Namespace":
            if err := json.Unmarshal([]byte(v), &strct.Namespace); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}
