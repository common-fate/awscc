// Code generated by schema-generate. DO NOT EDIT.

package service

import (
    "fmt"
    "errors"
    "bytes"
    "encoding/json"
)

// AwsVpcConfiguration 
type AwsVpcConfiguration struct {
  AssignPublicIp string `json:"AssignPublicIp,omitempty"`
  SecurityGroups []string `json:"SecurityGroups,omitempty"`
  Subnets []string `json:"Subnets,omitempty"`
}

// CapacityProviderStrategyItem 
type CapacityProviderStrategyItem struct {
  Base int `json:"Base,omitempty"`
  CapacityProvider string `json:"CapacityProvider,omitempty"`
  Weight int `json:"Weight,omitempty"`
}

// DeploymentAlarms 
type DeploymentAlarms struct {
  AlarmNames []string `json:"AlarmNames"`
  Enable bool `json:"Enable"`
  Rollback bool `json:"Rollback"`
}

// DeploymentCircuitBreaker 
type DeploymentCircuitBreaker struct {
  Enable bool `json:"Enable"`
  Rollback bool `json:"Rollback"`
}

// DeploymentConfiguration 
type DeploymentConfiguration struct {
  Alarms *DeploymentAlarms `json:"Alarms,omitempty"`
  DeploymentCircuitBreaker *DeploymentCircuitBreaker `json:"DeploymentCircuitBreaker,omitempty"`
  MaximumPercent int `json:"MaximumPercent,omitempty"`
  MinimumHealthyPercent int `json:"MinimumHealthyPercent,omitempty"`
}

// DeploymentController 
type DeploymentController struct {
  Type string `json:"Type,omitempty"`
}

// LoadBalancer 
type LoadBalancer struct {
  ContainerName string `json:"ContainerName,omitempty"`
  ContainerPort int `json:"ContainerPort,omitempty"`
  LoadBalancerName string `json:"LoadBalancerName,omitempty"`
  TargetGroupArn string `json:"TargetGroupArn,omitempty"`
}

// LogConfiguration 
type LogConfiguration struct {
  LogDriver string `json:"LogDriver,omitempty"`
  Options *Options `json:"Options,omitempty"`
  SecretOptions []*Secret `json:"SecretOptions,omitempty"`
}

// NetworkConfiguration 
type NetworkConfiguration struct {
  AwsvpcConfiguration *AwsVpcConfiguration `json:"AwsvpcConfiguration,omitempty"`
}

// Options 
type Options struct {
}

// PlacementConstraint 
type PlacementConstraint struct {
  Expression string `json:"Expression,omitempty"`
  Type string `json:"Type"`
}

// PlacementStrategy 
type PlacementStrategy struct {
  Field string `json:"Field,omitempty"`
  Type string `json:"Type"`
}

// Resource Resource Type definition for AWS::ECS::Service
type Resource struct {
  CapacityProviderStrategy []*CapacityProviderStrategyItem `json:"CapacityProviderStrategy,omitempty"`
  Cluster string `json:"Cluster,omitempty"`
  DeploymentConfiguration *DeploymentConfiguration `json:"DeploymentConfiguration,omitempty"`
  DeploymentController *DeploymentController `json:"DeploymentController,omitempty"`
  DesiredCount int `json:"DesiredCount,omitempty"`
  EnableECSManagedTags bool `json:"EnableECSManagedTags,omitempty"`
  EnableExecuteCommand bool `json:"EnableExecuteCommand,omitempty"`
  HealthCheckGracePeriodSeconds int `json:"HealthCheckGracePeriodSeconds,omitempty"`
  LaunchType string `json:"LaunchType,omitempty"`
  LoadBalancers []*LoadBalancer `json:"LoadBalancers,omitempty"`
  Name string `json:"Name,omitempty"`
  NetworkConfiguration *NetworkConfiguration `json:"NetworkConfiguration,omitempty"`
  PlacementConstraints []*PlacementConstraint `json:"PlacementConstraints,omitempty"`
  PlacementStrategies []*PlacementStrategy `json:"PlacementStrategies,omitempty"`
  PlatformVersion string `json:"PlatformVersion,omitempty"`
  PropagateTags string `json:"PropagateTags,omitempty"`
  Role string `json:"Role,omitempty"`
  SchedulingStrategy string `json:"SchedulingStrategy,omitempty"`
  ServiceArn string `json:"ServiceArn,omitempty"`
  ServiceConnectConfiguration *ServiceConnectConfiguration `json:"ServiceConnectConfiguration,omitempty"`
  ServiceName string `json:"ServiceName,omitempty"`
  ServiceRegistries []*ServiceRegistry `json:"ServiceRegistries,omitempty"`
  Tags []*Tag `json:"Tags,omitempty"`
  TaskDefinition string `json:"TaskDefinition,omitempty"`
}

// Secret 
type Secret struct {
  Name string `json:"Name"`
  ValueFrom string `json:"ValueFrom"`
}

// ServiceConnectClientAlias 
type ServiceConnectClientAlias struct {
  DnsName string `json:"DnsName,omitempty"`
  Port int `json:"Port"`
}

// ServiceConnectConfiguration 
type ServiceConnectConfiguration struct {
  Enabled bool `json:"Enabled"`
  LogConfiguration *LogConfiguration `json:"LogConfiguration,omitempty"`
  Namespace string `json:"Namespace,omitempty"`
  Services []*ServiceConnectService `json:"Services,omitempty"`
}

// ServiceConnectService 
type ServiceConnectService struct {
  ClientAliases []*ServiceConnectClientAlias `json:"ClientAliases,omitempty"`
  DiscoveryName string `json:"DiscoveryName,omitempty"`
  IngressPortOverride int `json:"IngressPortOverride,omitempty"`
  PortName string `json:"PortName"`
}

// ServiceRegistry 
type ServiceRegistry struct {
  ContainerName string `json:"ContainerName,omitempty"`
  ContainerPort int `json:"ContainerPort,omitempty"`
  Port int `json:"Port,omitempty"`
  RegistryArn string `json:"RegistryArn,omitempty"`
}

// Tag 
type Tag struct {
  Key string `json:"Key,omitempty"`
  Value string `json:"Value,omitempty"`
}

func (strct *AwsVpcConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AssignPublicIp" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AssignPublicIp\": ")
	if tmp, err := json.Marshal(strct.AssignPublicIp); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SecurityGroups" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SecurityGroups\": ")
	if tmp, err := json.Marshal(strct.SecurityGroups); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Subnets" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Subnets\": ")
	if tmp, err := json.Marshal(strct.Subnets); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AwsVpcConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AssignPublicIp":
            if err := json.Unmarshal([]byte(v), &strct.AssignPublicIp); err != nil {
                return err
             }
        case "SecurityGroups":
            if err := json.Unmarshal([]byte(v), &strct.SecurityGroups); err != nil {
                return err
             }
        case "Subnets":
            if err := json.Unmarshal([]byte(v), &strct.Subnets); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *CapacityProviderStrategyItem) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Base" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Base\": ")
	if tmp, err := json.Marshal(strct.Base); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CapacityProvider" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CapacityProvider\": ")
	if tmp, err := json.Marshal(strct.CapacityProvider); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Weight" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Weight\": ")
	if tmp, err := json.Marshal(strct.Weight); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CapacityProviderStrategyItem) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Base":
            if err := json.Unmarshal([]byte(v), &strct.Base); err != nil {
                return err
             }
        case "CapacityProvider":
            if err := json.Unmarshal([]byte(v), &strct.CapacityProvider); err != nil {
                return err
             }
        case "Weight":
            if err := json.Unmarshal([]byte(v), &strct.Weight); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *DeploymentAlarms) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AlarmNames" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AlarmNames" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AlarmNames\": ")
	if tmp, err := json.Marshal(strct.AlarmNames); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Enable" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Enable" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Enable\": ")
	if tmp, err := json.Marshal(strct.Enable); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Rollback" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Rollback" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Rollback\": ")
	if tmp, err := json.Marshal(strct.Rollback); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DeploymentAlarms) UnmarshalJSON(b []byte) error {
    AlarmNamesReceived := false
    EnableReceived := false
    RollbackReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AlarmNames":
            if err := json.Unmarshal([]byte(v), &strct.AlarmNames); err != nil {
                return err
             }
            AlarmNamesReceived = true
        case "Enable":
            if err := json.Unmarshal([]byte(v), &strct.Enable); err != nil {
                return err
             }
            EnableReceived = true
        case "Rollback":
            if err := json.Unmarshal([]byte(v), &strct.Rollback); err != nil {
                return err
             }
            RollbackReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if AlarmNames (a required property) was received
    if !AlarmNamesReceived {
        return errors.New("\"AlarmNames\" is required but was not present")
    }
    // check if Enable (a required property) was received
    if !EnableReceived {
        return errors.New("\"Enable\" is required but was not present")
    }
    // check if Rollback (a required property) was received
    if !RollbackReceived {
        return errors.New("\"Rollback\" is required but was not present")
    }
    return nil
}

func (strct *DeploymentCircuitBreaker) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Enable" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Enable" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Enable\": ")
	if tmp, err := json.Marshal(strct.Enable); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Rollback" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Rollback" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Rollback\": ")
	if tmp, err := json.Marshal(strct.Rollback); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DeploymentCircuitBreaker) UnmarshalJSON(b []byte) error {
    EnableReceived := false
    RollbackReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Enable":
            if err := json.Unmarshal([]byte(v), &strct.Enable); err != nil {
                return err
             }
            EnableReceived = true
        case "Rollback":
            if err := json.Unmarshal([]byte(v), &strct.Rollback); err != nil {
                return err
             }
            RollbackReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Enable (a required property) was received
    if !EnableReceived {
        return errors.New("\"Enable\" is required but was not present")
    }
    // check if Rollback (a required property) was received
    if !RollbackReceived {
        return errors.New("\"Rollback\" is required but was not present")
    }
    return nil
}

func (strct *DeploymentConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Alarms" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Alarms\": ")
	if tmp, err := json.Marshal(strct.Alarms); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DeploymentCircuitBreaker" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DeploymentCircuitBreaker\": ")
	if tmp, err := json.Marshal(strct.DeploymentCircuitBreaker); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MaximumPercent" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaximumPercent\": ")
	if tmp, err := json.Marshal(strct.MaximumPercent); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MinimumHealthyPercent" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MinimumHealthyPercent\": ")
	if tmp, err := json.Marshal(strct.MinimumHealthyPercent); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DeploymentConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Alarms":
            if err := json.Unmarshal([]byte(v), &strct.Alarms); err != nil {
                return err
             }
        case "DeploymentCircuitBreaker":
            if err := json.Unmarshal([]byte(v), &strct.DeploymentCircuitBreaker); err != nil {
                return err
             }
        case "MaximumPercent":
            if err := json.Unmarshal([]byte(v), &strct.MaximumPercent); err != nil {
                return err
             }
        case "MinimumHealthyPercent":
            if err := json.Unmarshal([]byte(v), &strct.MinimumHealthyPercent); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *DeploymentController) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DeploymentController) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *LoadBalancer) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ContainerName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ContainerName\": ")
	if tmp, err := json.Marshal(strct.ContainerName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ContainerPort" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ContainerPort\": ")
	if tmp, err := json.Marshal(strct.ContainerPort); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LoadBalancerName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LoadBalancerName\": ")
	if tmp, err := json.Marshal(strct.LoadBalancerName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TargetGroupArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TargetGroupArn\": ")
	if tmp, err := json.Marshal(strct.TargetGroupArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LoadBalancer) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ContainerName":
            if err := json.Unmarshal([]byte(v), &strct.ContainerName); err != nil {
                return err
             }
        case "ContainerPort":
            if err := json.Unmarshal([]byte(v), &strct.ContainerPort); err != nil {
                return err
             }
        case "LoadBalancerName":
            if err := json.Unmarshal([]byte(v), &strct.LoadBalancerName); err != nil {
                return err
             }
        case "TargetGroupArn":
            if err := json.Unmarshal([]byte(v), &strct.TargetGroupArn); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *LogConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "LogDriver" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LogDriver\": ")
	if tmp, err := json.Marshal(strct.LogDriver); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Options" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Options\": ")
	if tmp, err := json.Marshal(strct.Options); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SecretOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SecretOptions\": ")
	if tmp, err := json.Marshal(strct.SecretOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LogConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "LogDriver":
            if err := json.Unmarshal([]byte(v), &strct.LogDriver); err != nil {
                return err
             }
        case "Options":
            if err := json.Unmarshal([]byte(v), &strct.Options); err != nil {
                return err
             }
        case "SecretOptions":
            if err := json.Unmarshal([]byte(v), &strct.SecretOptions); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *NetworkConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AwsvpcConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AwsvpcConfiguration\": ")
	if tmp, err := json.Marshal(strct.AwsvpcConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *NetworkConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AwsvpcConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.AwsvpcConfiguration); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Options) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Options) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *PlacementConstraint) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Expression" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Expression\": ")
	if tmp, err := json.Marshal(strct.Expression); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PlacementConstraint) UnmarshalJSON(b []byte) error {
    TypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Expression":
            if err := json.Unmarshal([]byte(v), &strct.Expression); err != nil {
                return err
             }
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            TypeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Type (a required property) was received
    if !TypeReceived {
        return errors.New("\"Type\" is required but was not present")
    }
    return nil
}

func (strct *PlacementStrategy) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Field" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Field\": ")
	if tmp, err := json.Marshal(strct.Field); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PlacementStrategy) UnmarshalJSON(b []byte) error {
    TypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Field":
            if err := json.Unmarshal([]byte(v), &strct.Field); err != nil {
                return err
             }
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            TypeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Type (a required property) was received
    if !TypeReceived {
        return errors.New("\"Type\" is required but was not present")
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CapacityProviderStrategy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CapacityProviderStrategy\": ")
	if tmp, err := json.Marshal(strct.CapacityProviderStrategy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Cluster" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Cluster\": ")
	if tmp, err := json.Marshal(strct.Cluster); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DeploymentConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DeploymentConfiguration\": ")
	if tmp, err := json.Marshal(strct.DeploymentConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DeploymentController" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DeploymentController\": ")
	if tmp, err := json.Marshal(strct.DeploymentController); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DesiredCount" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DesiredCount\": ")
	if tmp, err := json.Marshal(strct.DesiredCount); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EnableECSManagedTags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EnableECSManagedTags\": ")
	if tmp, err := json.Marshal(strct.EnableECSManagedTags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EnableExecuteCommand" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EnableExecuteCommand\": ")
	if tmp, err := json.Marshal(strct.EnableExecuteCommand); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "HealthCheckGracePeriodSeconds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HealthCheckGracePeriodSeconds\": ")
	if tmp, err := json.Marshal(strct.HealthCheckGracePeriodSeconds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LaunchType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LaunchType\": ")
	if tmp, err := json.Marshal(strct.LaunchType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LoadBalancers" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LoadBalancers\": ")
	if tmp, err := json.Marshal(strct.LoadBalancers); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "NetworkConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NetworkConfiguration\": ")
	if tmp, err := json.Marshal(strct.NetworkConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PlacementConstraints" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PlacementConstraints\": ")
	if tmp, err := json.Marshal(strct.PlacementConstraints); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PlacementStrategies" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PlacementStrategies\": ")
	if tmp, err := json.Marshal(strct.PlacementStrategies); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PlatformVersion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PlatformVersion\": ")
	if tmp, err := json.Marshal(strct.PlatformVersion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PropagateTags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PropagateTags\": ")
	if tmp, err := json.Marshal(strct.PropagateTags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Role" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Role\": ")
	if tmp, err := json.Marshal(strct.Role); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SchedulingStrategy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SchedulingStrategy\": ")
	if tmp, err := json.Marshal(strct.SchedulingStrategy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ServiceArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ServiceArn\": ")
	if tmp, err := json.Marshal(strct.ServiceArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ServiceConnectConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ServiceConnectConfiguration\": ")
	if tmp, err := json.Marshal(strct.ServiceConnectConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ServiceName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ServiceName\": ")
	if tmp, err := json.Marshal(strct.ServiceName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ServiceRegistries" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ServiceRegistries\": ")
	if tmp, err := json.Marshal(strct.ServiceRegistries); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TaskDefinition" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TaskDefinition\": ")
	if tmp, err := json.Marshal(strct.TaskDefinition); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CapacityProviderStrategy":
            if err := json.Unmarshal([]byte(v), &strct.CapacityProviderStrategy); err != nil {
                return err
             }
        case "Cluster":
            if err := json.Unmarshal([]byte(v), &strct.Cluster); err != nil {
                return err
             }
        case "DeploymentConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.DeploymentConfiguration); err != nil {
                return err
             }
        case "DeploymentController":
            if err := json.Unmarshal([]byte(v), &strct.DeploymentController); err != nil {
                return err
             }
        case "DesiredCount":
            if err := json.Unmarshal([]byte(v), &strct.DesiredCount); err != nil {
                return err
             }
        case "EnableECSManagedTags":
            if err := json.Unmarshal([]byte(v), &strct.EnableECSManagedTags); err != nil {
                return err
             }
        case "EnableExecuteCommand":
            if err := json.Unmarshal([]byte(v), &strct.EnableExecuteCommand); err != nil {
                return err
             }
        case "HealthCheckGracePeriodSeconds":
            if err := json.Unmarshal([]byte(v), &strct.HealthCheckGracePeriodSeconds); err != nil {
                return err
             }
        case "LaunchType":
            if err := json.Unmarshal([]byte(v), &strct.LaunchType); err != nil {
                return err
             }
        case "LoadBalancers":
            if err := json.Unmarshal([]byte(v), &strct.LoadBalancers); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "NetworkConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.NetworkConfiguration); err != nil {
                return err
             }
        case "PlacementConstraints":
            if err := json.Unmarshal([]byte(v), &strct.PlacementConstraints); err != nil {
                return err
             }
        case "PlacementStrategies":
            if err := json.Unmarshal([]byte(v), &strct.PlacementStrategies); err != nil {
                return err
             }
        case "PlatformVersion":
            if err := json.Unmarshal([]byte(v), &strct.PlatformVersion); err != nil {
                return err
             }
        case "PropagateTags":
            if err := json.Unmarshal([]byte(v), &strct.PropagateTags); err != nil {
                return err
             }
        case "Role":
            if err := json.Unmarshal([]byte(v), &strct.Role); err != nil {
                return err
             }
        case "SchedulingStrategy":
            if err := json.Unmarshal([]byte(v), &strct.SchedulingStrategy); err != nil {
                return err
             }
        case "ServiceArn":
            if err := json.Unmarshal([]byte(v), &strct.ServiceArn); err != nil {
                return err
             }
        case "ServiceConnectConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.ServiceConnectConfiguration); err != nil {
                return err
             }
        case "ServiceName":
            if err := json.Unmarshal([]byte(v), &strct.ServiceName); err != nil {
                return err
             }
        case "ServiceRegistries":
            if err := json.Unmarshal([]byte(v), &strct.ServiceRegistries); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        case "TaskDefinition":
            if err := json.Unmarshal([]byte(v), &strct.TaskDefinition); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Secret) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ValueFrom" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ValueFrom" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ValueFrom\": ")
	if tmp, err := json.Marshal(strct.ValueFrom); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Secret) UnmarshalJSON(b []byte) error {
    NameReceived := false
    ValueFromReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        case "ValueFrom":
            if err := json.Unmarshal([]byte(v), &strct.ValueFrom); err != nil {
                return err
             }
            ValueFromReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    // check if ValueFrom (a required property) was received
    if !ValueFromReceived {
        return errors.New("\"ValueFrom\" is required but was not present")
    }
    return nil
}

func (strct *ServiceConnectClientAlias) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DnsName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DnsName\": ")
	if tmp, err := json.Marshal(strct.DnsName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Port" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Port" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Port\": ")
	if tmp, err := json.Marshal(strct.Port); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ServiceConnectClientAlias) UnmarshalJSON(b []byte) error {
    PortReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DnsName":
            if err := json.Unmarshal([]byte(v), &strct.DnsName); err != nil {
                return err
             }
        case "Port":
            if err := json.Unmarshal([]byte(v), &strct.Port); err != nil {
                return err
             }
            PortReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Port (a required property) was received
    if !PortReceived {
        return errors.New("\"Port\" is required but was not present")
    }
    return nil
}

func (strct *ServiceConnectConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Enabled" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Enabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LogConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LogConfiguration\": ")
	if tmp, err := json.Marshal(strct.LogConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Namespace" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Namespace\": ")
	if tmp, err := json.Marshal(strct.Namespace); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Services" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Services\": ")
	if tmp, err := json.Marshal(strct.Services); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ServiceConnectConfiguration) UnmarshalJSON(b []byte) error {
    EnabledReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Enabled":
            if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
                return err
             }
            EnabledReceived = true
        case "LogConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.LogConfiguration); err != nil {
                return err
             }
        case "Namespace":
            if err := json.Unmarshal([]byte(v), &strct.Namespace); err != nil {
                return err
             }
        case "Services":
            if err := json.Unmarshal([]byte(v), &strct.Services); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Enabled (a required property) was received
    if !EnabledReceived {
        return errors.New("\"Enabled\" is required but was not present")
    }
    return nil
}

func (strct *ServiceConnectService) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ClientAliases" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ClientAliases\": ")
	if tmp, err := json.Marshal(strct.ClientAliases); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DiscoveryName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DiscoveryName\": ")
	if tmp, err := json.Marshal(strct.DiscoveryName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IngressPortOverride" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IngressPortOverride\": ")
	if tmp, err := json.Marshal(strct.IngressPortOverride); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "PortName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "PortName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PortName\": ")
	if tmp, err := json.Marshal(strct.PortName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ServiceConnectService) UnmarshalJSON(b []byte) error {
    PortNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ClientAliases":
            if err := json.Unmarshal([]byte(v), &strct.ClientAliases); err != nil {
                return err
             }
        case "DiscoveryName":
            if err := json.Unmarshal([]byte(v), &strct.DiscoveryName); err != nil {
                return err
             }
        case "IngressPortOverride":
            if err := json.Unmarshal([]byte(v), &strct.IngressPortOverride); err != nil {
                return err
             }
        case "PortName":
            if err := json.Unmarshal([]byte(v), &strct.PortName); err != nil {
                return err
             }
            PortNameReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if PortName (a required property) was received
    if !PortNameReceived {
        return errors.New("\"PortName\" is required but was not present")
    }
    return nil
}

func (strct *ServiceRegistry) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ContainerName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ContainerName\": ")
	if tmp, err := json.Marshal(strct.ContainerName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ContainerPort" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ContainerPort\": ")
	if tmp, err := json.Marshal(strct.ContainerPort); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Port" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Port\": ")
	if tmp, err := json.Marshal(strct.Port); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RegistryArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RegistryArn\": ")
	if tmp, err := json.Marshal(strct.RegistryArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ServiceRegistry) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ContainerName":
            if err := json.Unmarshal([]byte(v), &strct.ContainerName); err != nil {
                return err
             }
        case "ContainerPort":
            if err := json.Unmarshal([]byte(v), &strct.ContainerPort); err != nil {
                return err
             }
        case "Port":
            if err := json.Unmarshal([]byte(v), &strct.Port); err != nil {
                return err
             }
        case "RegistryArn":
            if err := json.Unmarshal([]byte(v), &strct.RegistryArn); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}
