// Code generated by schema-generate. DO NOT EDIT.

package taskdefinition

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// AuthorizationConfig 
type AuthorizationConfig struct {
  AccessPointId string `json:"AccessPointId,omitempty"`
  IAM string `json:"IAM,omitempty"`
}

// ContainerDefinition List of container definitions that are passed to the Docker daemon on a container instance
type ContainerDefinition struct {
  Command []string `json:"Command,omitempty"`
  Cpu int `json:"Cpu,omitempty"`
  DependsOn []*ContainerDependency `json:"DependsOn,omitempty"`
  DisableNetworking bool `json:"DisableNetworking,omitempty"`
  DnsSearchDomains []string `json:"DnsSearchDomains,omitempty"`
  DnsServers []string `json:"DnsServers,omitempty"`
  DockerLabels *DockerLabels `json:"DockerLabels,omitempty"`
  DockerSecurityOptions []string `json:"DockerSecurityOptions,omitempty"`
  EntryPoint []string `json:"EntryPoint,omitempty"`

  // The environment variables to pass to a container
  Environment []*KeyValuePair `json:"Environment,omitempty"`

  // The list of one or more files that contain the environment variables to pass to a container
  EnvironmentFiles []*EnvironmentFile `json:"EnvironmentFiles,omitempty"`
  Essential bool `json:"Essential,omitempty"`
  ExtraHosts []*HostEntry `json:"ExtraHosts,omitempty"`
  FirelensConfiguration *FirelensConfiguration `json:"FirelensConfiguration,omitempty"`
  HealthCheck *HealthCheck `json:"HealthCheck,omitempty"`
  Hostname string `json:"Hostname,omitempty"`

  // The image used to start a container. This string is passed directly to the Docker daemon.
  Image string `json:"Image"`
  Interactive bool `json:"Interactive,omitempty"`
  Links []string `json:"Links,omitempty"`
  LinuxParameters *LinuxParameters `json:"LinuxParameters,omitempty"`
  LogConfiguration *LogConfiguration `json:"LogConfiguration,omitempty"`

  // The amount (in MiB) of memory to present to the container. If your container attempts to exceed the memory specified here, the container is killed.
  Memory int `json:"Memory,omitempty"`
  MemoryReservation int `json:"MemoryReservation,omitempty"`
  MountPoints []*MountPoint `json:"MountPoints,omitempty"`

  // The name of a container. Up to 255 letters (uppercase and lowercase), numbers, hyphens, and underscores are allowed
  Name string `json:"Name"`

  // Port mappings allow containers to access ports on the host container instance to send or receive traffic.
  PortMappings []*PortMapping `json:"PortMappings,omitempty"`
  Privileged bool `json:"Privileged,omitempty"`
  PseudoTerminal bool `json:"PseudoTerminal,omitempty"`
  ReadonlyRootFilesystem bool `json:"ReadonlyRootFilesystem,omitempty"`
  RepositoryCredentials *RepositoryCredentials `json:"RepositoryCredentials,omitempty"`
  ResourceRequirements []*ResourceRequirement `json:"ResourceRequirements,omitempty"`
  Secrets []*Secret `json:"Secrets,omitempty"`
  StartTimeout int `json:"StartTimeout,omitempty"`
  StopTimeout int `json:"StopTimeout,omitempty"`
  SystemControls []*SystemControl `json:"SystemControls,omitempty"`
  Ulimits []*Ulimit `json:"Ulimits,omitempty"`
  User string `json:"User,omitempty"`
  VolumesFrom []*VolumeFrom `json:"VolumesFrom,omitempty"`
  WorkingDirectory string `json:"WorkingDirectory,omitempty"`
}

// ContainerDependency 
type ContainerDependency struct {
  Condition string `json:"Condition,omitempty"`
  ContainerName string `json:"ContainerName,omitempty"`
}

// Device 
type Device struct {
  ContainerPath string `json:"ContainerPath,omitempty"`
  HostPath string `json:"HostPath,omitempty"`
  Permissions []string `json:"Permissions,omitempty"`
}

// DockerLabels 
type DockerLabels struct {
}

// DockerVolumeConfiguration 
type DockerVolumeConfiguration struct {
  Autoprovision bool `json:"Autoprovision,omitempty"`
  Driver string `json:"Driver,omitempty"`
  DriverOpts *DriverOpts `json:"DriverOpts,omitempty"`
  Labels *Labels `json:"Labels,omitempty"`
  Scope string `json:"Scope,omitempty"`
}

// DriverOpts 
type DriverOpts struct {
}

// EFSVolumeConfiguration 
type EFSVolumeConfiguration struct {
  AuthorizationConfig *AuthorizationConfig `json:"AuthorizationConfig,omitempty"`
  FilesystemId string `json:"FilesystemId"`
  RootDirectory string `json:"RootDirectory,omitempty"`
  TransitEncryption string `json:"TransitEncryption,omitempty"`
  TransitEncryptionPort int `json:"TransitEncryptionPort,omitempty"`
}

// EnvironmentFile 
type EnvironmentFile struct {
  Type string `json:"Type,omitempty"`
  Value string `json:"Value,omitempty"`
}

// EphemeralStorage 
type EphemeralStorage struct {
  SizeInGiB int `json:"SizeInGiB,omitempty"`
}

// FirelensConfiguration 
type FirelensConfiguration struct {
  Options *Options `json:"Options,omitempty"`
  Type string `json:"Type,omitempty"`
}

// HealthCheck The health check command and associated configuration parameters for the container.
type HealthCheck struct {

  // A string array representing the command that the container runs to determine if it is healthy.
  Command []string `json:"Command,omitempty"`

  // The time period in seconds between each health check execution. You may specify between 5 and 300 seconds. The default value is 30 seconds.
  Interval int `json:"Interval,omitempty"`

  // The number of times to retry a failed health check before the container is considered unhealthy. You may specify between 1 and 10 retries. The default value is three retries.
  Retries int `json:"Retries,omitempty"`

  // The optional grace period within which to provide containers time to bootstrap before failed health checks count towards the maximum number of retries. You may specify between 0 and 300 seconds. The startPeriod is disabled by default.
  StartPeriod int `json:"StartPeriod,omitempty"`

  // The time period in seconds to wait for a health check to succeed before it is considered a failure. You may specify between 2 and 60 seconds. The default value is 5 seconds.
  Timeout int `json:"Timeout,omitempty"`
}

// HostEntry 
type HostEntry struct {
  Hostname string `json:"Hostname,omitempty"`
  IpAddress string `json:"IpAddress,omitempty"`
}

// HostVolumeProperties 
type HostVolumeProperties struct {
  SourcePath string `json:"SourcePath,omitempty"`
}

// InferenceAccelerator 
type InferenceAccelerator struct {
  DeviceName string `json:"DeviceName,omitempty"`
  DeviceType string `json:"DeviceType,omitempty"`
}

// KernelCapabilities 
type KernelCapabilities struct {
  Add []string `json:"Add,omitempty"`
  Drop []string `json:"Drop,omitempty"`
}

// KeyValuePair 
type KeyValuePair struct {
  Name string `json:"Name,omitempty"`
  Value string `json:"Value,omitempty"`
}

// Labels 
type Labels struct {
}

// LinuxParameters 
type LinuxParameters struct {
  Capabilities *KernelCapabilities `json:"Capabilities,omitempty"`
  Devices []*Device `json:"Devices,omitempty"`
  InitProcessEnabled bool `json:"InitProcessEnabled,omitempty"`
  MaxSwap int `json:"MaxSwap,omitempty"`
  SharedMemorySize int `json:"SharedMemorySize,omitempty"`
  Swappiness int `json:"Swappiness,omitempty"`
  Tmpfs []*Tmpfs `json:"Tmpfs,omitempty"`
}

// LogConfiguration 
type LogConfiguration struct {
  LogDriver string `json:"LogDriver"`
  Options *Options `json:"Options,omitempty"`
  SecretOptions []*Secret `json:"SecretOptions,omitempty"`
}

// MountPoint 
type MountPoint struct {
  ContainerPath string `json:"ContainerPath,omitempty"`
  ReadOnly bool `json:"ReadOnly,omitempty"`
  SourceVolume string `json:"SourceVolume,omitempty"`
}

// Options 
type Options struct {
}

// PortMapping 
type PortMapping struct {
  AppProtocol string `json:"AppProtocol,omitempty"`
  ContainerPort int `json:"ContainerPort,omitempty"`
  ContainerPortRange string `json:"ContainerPortRange,omitempty"`
  HostPort int `json:"HostPort,omitempty"`
  Name string `json:"Name,omitempty"`
  Protocol string `json:"Protocol,omitempty"`
}

// ProxyConfiguration 
type ProxyConfiguration struct {
  ContainerName string `json:"ContainerName"`
  ProxyConfigurationProperties []*KeyValuePair `json:"ProxyConfigurationProperties,omitempty"`
  Type string `json:"Type,omitempty"`
}

// RepositoryCredentials 
type RepositoryCredentials struct {
  CredentialsParameter string `json:"CredentialsParameter,omitempty"`
}

// Resource Resource Schema describing various properties for ECS TaskDefinition
type Resource struct {
  ContainerDefinitions []*ContainerDefinition `json:"ContainerDefinitions,omitempty"`
  Cpu string `json:"Cpu,omitempty"`
  EphemeralStorage *EphemeralStorage `json:"EphemeralStorage,omitempty"`
  ExecutionRoleArn string `json:"ExecutionRoleArn,omitempty"`
  Family string `json:"Family,omitempty"`
  InferenceAccelerators []*InferenceAccelerator `json:"InferenceAccelerators,omitempty"`
  IpcMode string `json:"IpcMode,omitempty"`
  Memory string `json:"Memory,omitempty"`
  NetworkMode string `json:"NetworkMode,omitempty"`
  PidMode string `json:"PidMode,omitempty"`
  PlacementConstraints []*TaskDefinitionPlacementConstraint `json:"PlacementConstraints,omitempty"`
  ProxyConfiguration *ProxyConfiguration `json:"ProxyConfiguration,omitempty"`
  RequiresCompatibilities []string `json:"RequiresCompatibilities,omitempty"`
  RuntimePlatform *RuntimePlatform `json:"RuntimePlatform,omitempty"`
  Tags []*Tag `json:"Tags,omitempty"`

  // The Amazon Resource Name (ARN) of the Amazon ECS task definition
  TaskDefinitionArn string `json:"TaskDefinitionArn,omitempty"`
  TaskRoleArn string `json:"TaskRoleArn,omitempty"`
  Volumes []*Volume `json:"Volumes,omitempty"`
}

// ResourceRequirement 
type ResourceRequirement struct {
  Type string `json:"Type"`
  Value string `json:"Value"`
}

// RuntimePlatform 
type RuntimePlatform struct {
  CpuArchitecture string `json:"CpuArchitecture,omitempty"`
  OperatingSystemFamily string `json:"OperatingSystemFamily,omitempty"`
}

// Secret 
type Secret struct {
  Name string `json:"Name"`
  ValueFrom string `json:"ValueFrom"`
}

// SystemControl 
type SystemControl struct {
  Namespace string `json:"Namespace,omitempty"`
  Value string `json:"Value,omitempty"`
}

// Tag 
type Tag struct {
  Key string `json:"Key,omitempty"`
  Value string `json:"Value,omitempty"`
}

// TaskDefinitionPlacementConstraint 
type TaskDefinitionPlacementConstraint struct {
  Expression string `json:"Expression,omitempty"`
  Type string `json:"Type"`
}

// Tmpfs 
type Tmpfs struct {
  ContainerPath string `json:"ContainerPath,omitempty"`
  MountOptions []string `json:"MountOptions,omitempty"`
  Size int `json:"Size"`
}

// Ulimit 
type Ulimit struct {
  HardLimit int `json:"HardLimit"`
  Name string `json:"Name"`
  SoftLimit int `json:"SoftLimit"`
}

// Volume 
type Volume struct {
  DockerVolumeConfiguration *DockerVolumeConfiguration `json:"DockerVolumeConfiguration,omitempty"`
  EFSVolumeConfiguration *EFSVolumeConfiguration `json:"EFSVolumeConfiguration,omitempty"`
  Host *HostVolumeProperties `json:"Host,omitempty"`
  Name string `json:"Name,omitempty"`
}

// VolumeFrom 
type VolumeFrom struct {
  ReadOnly bool `json:"ReadOnly,omitempty"`
  SourceContainer string `json:"SourceContainer,omitempty"`
}

func (strct *AuthorizationConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AccessPointId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AccessPointId\": ")
	if tmp, err := json.Marshal(strct.AccessPointId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IAM" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IAM\": ")
	if tmp, err := json.Marshal(strct.IAM); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AuthorizationConfig) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AccessPointId":
            if err := json.Unmarshal([]byte(v), &strct.AccessPointId); err != nil {
                return err
             }
        case "IAM":
            if err := json.Unmarshal([]byte(v), &strct.IAM); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ContainerDefinition) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Command" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Command\": ")
	if tmp, err := json.Marshal(strct.Command); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Cpu" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Cpu\": ")
	if tmp, err := json.Marshal(strct.Cpu); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DependsOn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DependsOn\": ")
	if tmp, err := json.Marshal(strct.DependsOn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DisableNetworking" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DisableNetworking\": ")
	if tmp, err := json.Marshal(strct.DisableNetworking); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DnsSearchDomains" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DnsSearchDomains\": ")
	if tmp, err := json.Marshal(strct.DnsSearchDomains); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DnsServers" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DnsServers\": ")
	if tmp, err := json.Marshal(strct.DnsServers); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DockerLabels" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DockerLabels\": ")
	if tmp, err := json.Marshal(strct.DockerLabels); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DockerSecurityOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DockerSecurityOptions\": ")
	if tmp, err := json.Marshal(strct.DockerSecurityOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EntryPoint" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EntryPoint\": ")
	if tmp, err := json.Marshal(strct.EntryPoint); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Environment" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Environment\": ")
	if tmp, err := json.Marshal(strct.Environment); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EnvironmentFiles" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EnvironmentFiles\": ")
	if tmp, err := json.Marshal(strct.EnvironmentFiles); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Essential" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Essential\": ")
	if tmp, err := json.Marshal(strct.Essential); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ExtraHosts" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ExtraHosts\": ")
	if tmp, err := json.Marshal(strct.ExtraHosts); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FirelensConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FirelensConfiguration\": ")
	if tmp, err := json.Marshal(strct.FirelensConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "HealthCheck" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HealthCheck\": ")
	if tmp, err := json.Marshal(strct.HealthCheck); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Hostname" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Hostname\": ")
	if tmp, err := json.Marshal(strct.Hostname); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Image" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Image" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Image\": ")
	if tmp, err := json.Marshal(strct.Image); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Interactive" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Interactive\": ")
	if tmp, err := json.Marshal(strct.Interactive); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Links" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Links\": ")
	if tmp, err := json.Marshal(strct.Links); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LinuxParameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LinuxParameters\": ")
	if tmp, err := json.Marshal(strct.LinuxParameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LogConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LogConfiguration\": ")
	if tmp, err := json.Marshal(strct.LogConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Memory" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Memory\": ")
	if tmp, err := json.Marshal(strct.Memory); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MemoryReservation" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MemoryReservation\": ")
	if tmp, err := json.Marshal(strct.MemoryReservation); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MountPoints" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MountPoints\": ")
	if tmp, err := json.Marshal(strct.MountPoints); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PortMappings" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PortMappings\": ")
	if tmp, err := json.Marshal(strct.PortMappings); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Privileged" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Privileged\": ")
	if tmp, err := json.Marshal(strct.Privileged); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PseudoTerminal" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PseudoTerminal\": ")
	if tmp, err := json.Marshal(strct.PseudoTerminal); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ReadonlyRootFilesystem" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ReadonlyRootFilesystem\": ")
	if tmp, err := json.Marshal(strct.ReadonlyRootFilesystem); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RepositoryCredentials" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RepositoryCredentials\": ")
	if tmp, err := json.Marshal(strct.RepositoryCredentials); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ResourceRequirements" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ResourceRequirements\": ")
	if tmp, err := json.Marshal(strct.ResourceRequirements); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Secrets" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Secrets\": ")
	if tmp, err := json.Marshal(strct.Secrets); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StartTimeout" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StartTimeout\": ")
	if tmp, err := json.Marshal(strct.StartTimeout); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StopTimeout" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StopTimeout\": ")
	if tmp, err := json.Marshal(strct.StopTimeout); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SystemControls" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SystemControls\": ")
	if tmp, err := json.Marshal(strct.SystemControls); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Ulimits" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Ulimits\": ")
	if tmp, err := json.Marshal(strct.Ulimits); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "User" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"User\": ")
	if tmp, err := json.Marshal(strct.User); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VolumesFrom" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VolumesFrom\": ")
	if tmp, err := json.Marshal(strct.VolumesFrom); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "WorkingDirectory" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"WorkingDirectory\": ")
	if tmp, err := json.Marshal(strct.WorkingDirectory); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ContainerDefinition) UnmarshalJSON(b []byte) error {
    ImageReceived := false
    NameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Command":
            if err := json.Unmarshal([]byte(v), &strct.Command); err != nil {
                return err
             }
        case "Cpu":
            if err := json.Unmarshal([]byte(v), &strct.Cpu); err != nil {
                return err
             }
        case "DependsOn":
            if err := json.Unmarshal([]byte(v), &strct.DependsOn); err != nil {
                return err
             }
        case "DisableNetworking":
            if err := json.Unmarshal([]byte(v), &strct.DisableNetworking); err != nil {
                return err
             }
        case "DnsSearchDomains":
            if err := json.Unmarshal([]byte(v), &strct.DnsSearchDomains); err != nil {
                return err
             }
        case "DnsServers":
            if err := json.Unmarshal([]byte(v), &strct.DnsServers); err != nil {
                return err
             }
        case "DockerLabels":
            if err := json.Unmarshal([]byte(v), &strct.DockerLabels); err != nil {
                return err
             }
        case "DockerSecurityOptions":
            if err := json.Unmarshal([]byte(v), &strct.DockerSecurityOptions); err != nil {
                return err
             }
        case "EntryPoint":
            if err := json.Unmarshal([]byte(v), &strct.EntryPoint); err != nil {
                return err
             }
        case "Environment":
            if err := json.Unmarshal([]byte(v), &strct.Environment); err != nil {
                return err
             }
        case "EnvironmentFiles":
            if err := json.Unmarshal([]byte(v), &strct.EnvironmentFiles); err != nil {
                return err
             }
        case "Essential":
            if err := json.Unmarshal([]byte(v), &strct.Essential); err != nil {
                return err
             }
        case "ExtraHosts":
            if err := json.Unmarshal([]byte(v), &strct.ExtraHosts); err != nil {
                return err
             }
        case "FirelensConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.FirelensConfiguration); err != nil {
                return err
             }
        case "HealthCheck":
            if err := json.Unmarshal([]byte(v), &strct.HealthCheck); err != nil {
                return err
             }
        case "Hostname":
            if err := json.Unmarshal([]byte(v), &strct.Hostname); err != nil {
                return err
             }
        case "Image":
            if err := json.Unmarshal([]byte(v), &strct.Image); err != nil {
                return err
             }
            ImageReceived = true
        case "Interactive":
            if err := json.Unmarshal([]byte(v), &strct.Interactive); err != nil {
                return err
             }
        case "Links":
            if err := json.Unmarshal([]byte(v), &strct.Links); err != nil {
                return err
             }
        case "LinuxParameters":
            if err := json.Unmarshal([]byte(v), &strct.LinuxParameters); err != nil {
                return err
             }
        case "LogConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.LogConfiguration); err != nil {
                return err
             }
        case "Memory":
            if err := json.Unmarshal([]byte(v), &strct.Memory); err != nil {
                return err
             }
        case "MemoryReservation":
            if err := json.Unmarshal([]byte(v), &strct.MemoryReservation); err != nil {
                return err
             }
        case "MountPoints":
            if err := json.Unmarshal([]byte(v), &strct.MountPoints); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        case "PortMappings":
            if err := json.Unmarshal([]byte(v), &strct.PortMappings); err != nil {
                return err
             }
        case "Privileged":
            if err := json.Unmarshal([]byte(v), &strct.Privileged); err != nil {
                return err
             }
        case "PseudoTerminal":
            if err := json.Unmarshal([]byte(v), &strct.PseudoTerminal); err != nil {
                return err
             }
        case "ReadonlyRootFilesystem":
            if err := json.Unmarshal([]byte(v), &strct.ReadonlyRootFilesystem); err != nil {
                return err
             }
        case "RepositoryCredentials":
            if err := json.Unmarshal([]byte(v), &strct.RepositoryCredentials); err != nil {
                return err
             }
        case "ResourceRequirements":
            if err := json.Unmarshal([]byte(v), &strct.ResourceRequirements); err != nil {
                return err
             }
        case "Secrets":
            if err := json.Unmarshal([]byte(v), &strct.Secrets); err != nil {
                return err
             }
        case "StartTimeout":
            if err := json.Unmarshal([]byte(v), &strct.StartTimeout); err != nil {
                return err
             }
        case "StopTimeout":
            if err := json.Unmarshal([]byte(v), &strct.StopTimeout); err != nil {
                return err
             }
        case "SystemControls":
            if err := json.Unmarshal([]byte(v), &strct.SystemControls); err != nil {
                return err
             }
        case "Ulimits":
            if err := json.Unmarshal([]byte(v), &strct.Ulimits); err != nil {
                return err
             }
        case "User":
            if err := json.Unmarshal([]byte(v), &strct.User); err != nil {
                return err
             }
        case "VolumesFrom":
            if err := json.Unmarshal([]byte(v), &strct.VolumesFrom); err != nil {
                return err
             }
        case "WorkingDirectory":
            if err := json.Unmarshal([]byte(v), &strct.WorkingDirectory); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Image (a required property) was received
    if !ImageReceived {
        return errors.New("\"Image\" is required but was not present")
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    return nil
}

func (strct *ContainerDependency) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Condition" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Condition\": ")
	if tmp, err := json.Marshal(strct.Condition); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ContainerName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ContainerName\": ")
	if tmp, err := json.Marshal(strct.ContainerName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ContainerDependency) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Condition":
            if err := json.Unmarshal([]byte(v), &strct.Condition); err != nil {
                return err
             }
        case "ContainerName":
            if err := json.Unmarshal([]byte(v), &strct.ContainerName); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Device) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ContainerPath" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ContainerPath\": ")
	if tmp, err := json.Marshal(strct.ContainerPath); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "HostPath" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HostPath\": ")
	if tmp, err := json.Marshal(strct.HostPath); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Permissions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Permissions\": ")
	if tmp, err := json.Marshal(strct.Permissions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Device) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ContainerPath":
            if err := json.Unmarshal([]byte(v), &strct.ContainerPath); err != nil {
                return err
             }
        case "HostPath":
            if err := json.Unmarshal([]byte(v), &strct.HostPath); err != nil {
                return err
             }
        case "Permissions":
            if err := json.Unmarshal([]byte(v), &strct.Permissions); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *DockerLabels) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DockerLabels) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *DockerVolumeConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Autoprovision" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Autoprovision\": ")
	if tmp, err := json.Marshal(strct.Autoprovision); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Driver" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Driver\": ")
	if tmp, err := json.Marshal(strct.Driver); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DriverOpts" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DriverOpts\": ")
	if tmp, err := json.Marshal(strct.DriverOpts); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Labels" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Labels\": ")
	if tmp, err := json.Marshal(strct.Labels); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Scope" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Scope\": ")
	if tmp, err := json.Marshal(strct.Scope); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DockerVolumeConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Autoprovision":
            if err := json.Unmarshal([]byte(v), &strct.Autoprovision); err != nil {
                return err
             }
        case "Driver":
            if err := json.Unmarshal([]byte(v), &strct.Driver); err != nil {
                return err
             }
        case "DriverOpts":
            if err := json.Unmarshal([]byte(v), &strct.DriverOpts); err != nil {
                return err
             }
        case "Labels":
            if err := json.Unmarshal([]byte(v), &strct.Labels); err != nil {
                return err
             }
        case "Scope":
            if err := json.Unmarshal([]byte(v), &strct.Scope); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *DriverOpts) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DriverOpts) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *EFSVolumeConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AuthorizationConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AuthorizationConfig\": ")
	if tmp, err := json.Marshal(strct.AuthorizationConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "FilesystemId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "FilesystemId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FilesystemId\": ")
	if tmp, err := json.Marshal(strct.FilesystemId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RootDirectory" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RootDirectory\": ")
	if tmp, err := json.Marshal(strct.RootDirectory); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TransitEncryption" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TransitEncryption\": ")
	if tmp, err := json.Marshal(strct.TransitEncryption); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TransitEncryptionPort" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TransitEncryptionPort\": ")
	if tmp, err := json.Marshal(strct.TransitEncryptionPort); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *EFSVolumeConfiguration) UnmarshalJSON(b []byte) error {
    FilesystemIdReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AuthorizationConfig":
            if err := json.Unmarshal([]byte(v), &strct.AuthorizationConfig); err != nil {
                return err
             }
        case "FilesystemId":
            if err := json.Unmarshal([]byte(v), &strct.FilesystemId); err != nil {
                return err
             }
            FilesystemIdReceived = true
        case "RootDirectory":
            if err := json.Unmarshal([]byte(v), &strct.RootDirectory); err != nil {
                return err
             }
        case "TransitEncryption":
            if err := json.Unmarshal([]byte(v), &strct.TransitEncryption); err != nil {
                return err
             }
        case "TransitEncryptionPort":
            if err := json.Unmarshal([]byte(v), &strct.TransitEncryptionPort); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if FilesystemId (a required property) was received
    if !FilesystemIdReceived {
        return errors.New("\"FilesystemId\" is required but was not present")
    }
    return nil
}

func (strct *EnvironmentFile) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *EnvironmentFile) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *EphemeralStorage) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "SizeInGiB" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SizeInGiB\": ")
	if tmp, err := json.Marshal(strct.SizeInGiB); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *EphemeralStorage) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "SizeInGiB":
            if err := json.Unmarshal([]byte(v), &strct.SizeInGiB); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *FirelensConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Options" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Options\": ")
	if tmp, err := json.Marshal(strct.Options); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FirelensConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Options":
            if err := json.Unmarshal([]byte(v), &strct.Options); err != nil {
                return err
             }
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *HealthCheck) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Command" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Command\": ")
	if tmp, err := json.Marshal(strct.Command); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Interval" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Interval\": ")
	if tmp, err := json.Marshal(strct.Interval); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Retries" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Retries\": ")
	if tmp, err := json.Marshal(strct.Retries); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StartPeriod" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StartPeriod\": ")
	if tmp, err := json.Marshal(strct.StartPeriod); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Timeout" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Timeout\": ")
	if tmp, err := json.Marshal(strct.Timeout); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *HealthCheck) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Command":
            if err := json.Unmarshal([]byte(v), &strct.Command); err != nil {
                return err
             }
        case "Interval":
            if err := json.Unmarshal([]byte(v), &strct.Interval); err != nil {
                return err
             }
        case "Retries":
            if err := json.Unmarshal([]byte(v), &strct.Retries); err != nil {
                return err
             }
        case "StartPeriod":
            if err := json.Unmarshal([]byte(v), &strct.StartPeriod); err != nil {
                return err
             }
        case "Timeout":
            if err := json.Unmarshal([]byte(v), &strct.Timeout); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *HostEntry) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Hostname" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Hostname\": ")
	if tmp, err := json.Marshal(strct.Hostname); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IpAddress" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IpAddress\": ")
	if tmp, err := json.Marshal(strct.IpAddress); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *HostEntry) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Hostname":
            if err := json.Unmarshal([]byte(v), &strct.Hostname); err != nil {
                return err
             }
        case "IpAddress":
            if err := json.Unmarshal([]byte(v), &strct.IpAddress); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *HostVolumeProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "SourcePath" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SourcePath\": ")
	if tmp, err := json.Marshal(strct.SourcePath); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *HostVolumeProperties) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "SourcePath":
            if err := json.Unmarshal([]byte(v), &strct.SourcePath); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *InferenceAccelerator) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DeviceName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DeviceName\": ")
	if tmp, err := json.Marshal(strct.DeviceName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DeviceType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DeviceType\": ")
	if tmp, err := json.Marshal(strct.DeviceType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *InferenceAccelerator) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DeviceName":
            if err := json.Unmarshal([]byte(v), &strct.DeviceName); err != nil {
                return err
             }
        case "DeviceType":
            if err := json.Unmarshal([]byte(v), &strct.DeviceType); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *KernelCapabilities) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Add" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Add\": ")
	if tmp, err := json.Marshal(strct.Add); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Drop" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Drop\": ")
	if tmp, err := json.Marshal(strct.Drop); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *KernelCapabilities) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Add":
            if err := json.Unmarshal([]byte(v), &strct.Add); err != nil {
                return err
             }
        case "Drop":
            if err := json.Unmarshal([]byte(v), &strct.Drop); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *KeyValuePair) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *KeyValuePair) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Labels) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Labels) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *LinuxParameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Capabilities" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Capabilities\": ")
	if tmp, err := json.Marshal(strct.Capabilities); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Devices" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Devices\": ")
	if tmp, err := json.Marshal(strct.Devices); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "InitProcessEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InitProcessEnabled\": ")
	if tmp, err := json.Marshal(strct.InitProcessEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MaxSwap" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaxSwap\": ")
	if tmp, err := json.Marshal(strct.MaxSwap); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SharedMemorySize" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SharedMemorySize\": ")
	if tmp, err := json.Marshal(strct.SharedMemorySize); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Swappiness" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Swappiness\": ")
	if tmp, err := json.Marshal(strct.Swappiness); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tmpfs" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tmpfs\": ")
	if tmp, err := json.Marshal(strct.Tmpfs); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LinuxParameters) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Capabilities":
            if err := json.Unmarshal([]byte(v), &strct.Capabilities); err != nil {
                return err
             }
        case "Devices":
            if err := json.Unmarshal([]byte(v), &strct.Devices); err != nil {
                return err
             }
        case "InitProcessEnabled":
            if err := json.Unmarshal([]byte(v), &strct.InitProcessEnabled); err != nil {
                return err
             }
        case "MaxSwap":
            if err := json.Unmarshal([]byte(v), &strct.MaxSwap); err != nil {
                return err
             }
        case "SharedMemorySize":
            if err := json.Unmarshal([]byte(v), &strct.SharedMemorySize); err != nil {
                return err
             }
        case "Swappiness":
            if err := json.Unmarshal([]byte(v), &strct.Swappiness); err != nil {
                return err
             }
        case "Tmpfs":
            if err := json.Unmarshal([]byte(v), &strct.Tmpfs); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *LogConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "LogDriver" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "LogDriver" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LogDriver\": ")
	if tmp, err := json.Marshal(strct.LogDriver); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Options" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Options\": ")
	if tmp, err := json.Marshal(strct.Options); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SecretOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SecretOptions\": ")
	if tmp, err := json.Marshal(strct.SecretOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LogConfiguration) UnmarshalJSON(b []byte) error {
    LogDriverReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "LogDriver":
            if err := json.Unmarshal([]byte(v), &strct.LogDriver); err != nil {
                return err
             }
            LogDriverReceived = true
        case "Options":
            if err := json.Unmarshal([]byte(v), &strct.Options); err != nil {
                return err
             }
        case "SecretOptions":
            if err := json.Unmarshal([]byte(v), &strct.SecretOptions); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if LogDriver (a required property) was received
    if !LogDriverReceived {
        return errors.New("\"LogDriver\" is required but was not present")
    }
    return nil
}

func (strct *MountPoint) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ContainerPath" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ContainerPath\": ")
	if tmp, err := json.Marshal(strct.ContainerPath); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ReadOnly" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ReadOnly\": ")
	if tmp, err := json.Marshal(strct.ReadOnly); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SourceVolume" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SourceVolume\": ")
	if tmp, err := json.Marshal(strct.SourceVolume); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MountPoint) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ContainerPath":
            if err := json.Unmarshal([]byte(v), &strct.ContainerPath); err != nil {
                return err
             }
        case "ReadOnly":
            if err := json.Unmarshal([]byte(v), &strct.ReadOnly); err != nil {
                return err
             }
        case "SourceVolume":
            if err := json.Unmarshal([]byte(v), &strct.SourceVolume); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Options) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Options) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *PortMapping) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AppProtocol" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AppProtocol\": ")
	if tmp, err := json.Marshal(strct.AppProtocol); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ContainerPort" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ContainerPort\": ")
	if tmp, err := json.Marshal(strct.ContainerPort); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ContainerPortRange" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ContainerPortRange\": ")
	if tmp, err := json.Marshal(strct.ContainerPortRange); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "HostPort" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HostPort\": ")
	if tmp, err := json.Marshal(strct.HostPort); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Protocol" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Protocol\": ")
	if tmp, err := json.Marshal(strct.Protocol); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PortMapping) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AppProtocol":
            if err := json.Unmarshal([]byte(v), &strct.AppProtocol); err != nil {
                return err
             }
        case "ContainerPort":
            if err := json.Unmarshal([]byte(v), &strct.ContainerPort); err != nil {
                return err
             }
        case "ContainerPortRange":
            if err := json.Unmarshal([]byte(v), &strct.ContainerPortRange); err != nil {
                return err
             }
        case "HostPort":
            if err := json.Unmarshal([]byte(v), &strct.HostPort); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "Protocol":
            if err := json.Unmarshal([]byte(v), &strct.Protocol); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ProxyConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ContainerName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ContainerName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ContainerName\": ")
	if tmp, err := json.Marshal(strct.ContainerName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ProxyConfigurationProperties" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ProxyConfigurationProperties\": ")
	if tmp, err := json.Marshal(strct.ProxyConfigurationProperties); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ProxyConfiguration) UnmarshalJSON(b []byte) error {
    ContainerNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ContainerName":
            if err := json.Unmarshal([]byte(v), &strct.ContainerName); err != nil {
                return err
             }
            ContainerNameReceived = true
        case "ProxyConfigurationProperties":
            if err := json.Unmarshal([]byte(v), &strct.ProxyConfigurationProperties); err != nil {
                return err
             }
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ContainerName (a required property) was received
    if !ContainerNameReceived {
        return errors.New("\"ContainerName\" is required but was not present")
    }
    return nil
}

func (strct *RepositoryCredentials) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CredentialsParameter" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CredentialsParameter\": ")
	if tmp, err := json.Marshal(strct.CredentialsParameter); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RepositoryCredentials) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CredentialsParameter":
            if err := json.Unmarshal([]byte(v), &strct.CredentialsParameter); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ContainerDefinitions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ContainerDefinitions\": ")
	if tmp, err := json.Marshal(strct.ContainerDefinitions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Cpu" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Cpu\": ")
	if tmp, err := json.Marshal(strct.Cpu); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EphemeralStorage" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EphemeralStorage\": ")
	if tmp, err := json.Marshal(strct.EphemeralStorage); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ExecutionRoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ExecutionRoleArn\": ")
	if tmp, err := json.Marshal(strct.ExecutionRoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Family" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Family\": ")
	if tmp, err := json.Marshal(strct.Family); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "InferenceAccelerators" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InferenceAccelerators\": ")
	if tmp, err := json.Marshal(strct.InferenceAccelerators); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IpcMode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IpcMode\": ")
	if tmp, err := json.Marshal(strct.IpcMode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Memory" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Memory\": ")
	if tmp, err := json.Marshal(strct.Memory); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "NetworkMode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NetworkMode\": ")
	if tmp, err := json.Marshal(strct.NetworkMode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PidMode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PidMode\": ")
	if tmp, err := json.Marshal(strct.PidMode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PlacementConstraints" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PlacementConstraints\": ")
	if tmp, err := json.Marshal(strct.PlacementConstraints); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ProxyConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ProxyConfiguration\": ")
	if tmp, err := json.Marshal(strct.ProxyConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RequiresCompatibilities" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RequiresCompatibilities\": ")
	if tmp, err := json.Marshal(strct.RequiresCompatibilities); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RuntimePlatform" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RuntimePlatform\": ")
	if tmp, err := json.Marshal(strct.RuntimePlatform); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TaskDefinitionArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TaskDefinitionArn\": ")
	if tmp, err := json.Marshal(strct.TaskDefinitionArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TaskRoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TaskRoleArn\": ")
	if tmp, err := json.Marshal(strct.TaskRoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Volumes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Volumes\": ")
	if tmp, err := json.Marshal(strct.Volumes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ContainerDefinitions":
            if err := json.Unmarshal([]byte(v), &strct.ContainerDefinitions); err != nil {
                return err
             }
        case "Cpu":
            if err := json.Unmarshal([]byte(v), &strct.Cpu); err != nil {
                return err
             }
        case "EphemeralStorage":
            if err := json.Unmarshal([]byte(v), &strct.EphemeralStorage); err != nil {
                return err
             }
        case "ExecutionRoleArn":
            if err := json.Unmarshal([]byte(v), &strct.ExecutionRoleArn); err != nil {
                return err
             }
        case "Family":
            if err := json.Unmarshal([]byte(v), &strct.Family); err != nil {
                return err
             }
        case "InferenceAccelerators":
            if err := json.Unmarshal([]byte(v), &strct.InferenceAccelerators); err != nil {
                return err
             }
        case "IpcMode":
            if err := json.Unmarshal([]byte(v), &strct.IpcMode); err != nil {
                return err
             }
        case "Memory":
            if err := json.Unmarshal([]byte(v), &strct.Memory); err != nil {
                return err
             }
        case "NetworkMode":
            if err := json.Unmarshal([]byte(v), &strct.NetworkMode); err != nil {
                return err
             }
        case "PidMode":
            if err := json.Unmarshal([]byte(v), &strct.PidMode); err != nil {
                return err
             }
        case "PlacementConstraints":
            if err := json.Unmarshal([]byte(v), &strct.PlacementConstraints); err != nil {
                return err
             }
        case "ProxyConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.ProxyConfiguration); err != nil {
                return err
             }
        case "RequiresCompatibilities":
            if err := json.Unmarshal([]byte(v), &strct.RequiresCompatibilities); err != nil {
                return err
             }
        case "RuntimePlatform":
            if err := json.Unmarshal([]byte(v), &strct.RuntimePlatform); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        case "TaskDefinitionArn":
            if err := json.Unmarshal([]byte(v), &strct.TaskDefinitionArn); err != nil {
                return err
             }
        case "TaskRoleArn":
            if err := json.Unmarshal([]byte(v), &strct.TaskRoleArn); err != nil {
                return err
             }
        case "Volumes":
            if err := json.Unmarshal([]byte(v), &strct.Volumes); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ResourceRequirement) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ResourceRequirement) UnmarshalJSON(b []byte) error {
    TypeReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            TypeReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Type (a required property) was received
    if !TypeReceived {
        return errors.New("\"Type\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *RuntimePlatform) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CpuArchitecture" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CpuArchitecture\": ")
	if tmp, err := json.Marshal(strct.CpuArchitecture); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OperatingSystemFamily" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OperatingSystemFamily\": ")
	if tmp, err := json.Marshal(strct.OperatingSystemFamily); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RuntimePlatform) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CpuArchitecture":
            if err := json.Unmarshal([]byte(v), &strct.CpuArchitecture); err != nil {
                return err
             }
        case "OperatingSystemFamily":
            if err := json.Unmarshal([]byte(v), &strct.OperatingSystemFamily); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Secret) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ValueFrom" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ValueFrom" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ValueFrom\": ")
	if tmp, err := json.Marshal(strct.ValueFrom); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Secret) UnmarshalJSON(b []byte) error {
    NameReceived := false
    ValueFromReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        case "ValueFrom":
            if err := json.Unmarshal([]byte(v), &strct.ValueFrom); err != nil {
                return err
             }
            ValueFromReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    // check if ValueFrom (a required property) was received
    if !ValueFromReceived {
        return errors.New("\"ValueFrom\" is required but was not present")
    }
    return nil
}

func (strct *SystemControl) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Namespace" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Namespace\": ")
	if tmp, err := json.Marshal(strct.Namespace); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SystemControl) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Namespace":
            if err := json.Unmarshal([]byte(v), &strct.Namespace); err != nil {
                return err
             }
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *TaskDefinitionPlacementConstraint) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Expression" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Expression\": ")
	if tmp, err := json.Marshal(strct.Expression); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TaskDefinitionPlacementConstraint) UnmarshalJSON(b []byte) error {
    TypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Expression":
            if err := json.Unmarshal([]byte(v), &strct.Expression); err != nil {
                return err
             }
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            TypeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Type (a required property) was received
    if !TypeReceived {
        return errors.New("\"Type\" is required but was not present")
    }
    return nil
}

func (strct *Tmpfs) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ContainerPath" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ContainerPath\": ")
	if tmp, err := json.Marshal(strct.ContainerPath); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MountOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MountOptions\": ")
	if tmp, err := json.Marshal(strct.MountOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Size" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Size" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Size\": ")
	if tmp, err := json.Marshal(strct.Size); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tmpfs) UnmarshalJSON(b []byte) error {
    SizeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ContainerPath":
            if err := json.Unmarshal([]byte(v), &strct.ContainerPath); err != nil {
                return err
             }
        case "MountOptions":
            if err := json.Unmarshal([]byte(v), &strct.MountOptions); err != nil {
                return err
             }
        case "Size":
            if err := json.Unmarshal([]byte(v), &strct.Size); err != nil {
                return err
             }
            SizeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Size (a required property) was received
    if !SizeReceived {
        return errors.New("\"Size\" is required but was not present")
    }
    return nil
}

func (strct *Ulimit) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "HardLimit" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "HardLimit" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HardLimit\": ")
	if tmp, err := json.Marshal(strct.HardLimit); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "SoftLimit" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "SoftLimit" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SoftLimit\": ")
	if tmp, err := json.Marshal(strct.SoftLimit); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Ulimit) UnmarshalJSON(b []byte) error {
    HardLimitReceived := false
    NameReceived := false
    SoftLimitReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "HardLimit":
            if err := json.Unmarshal([]byte(v), &strct.HardLimit); err != nil {
                return err
             }
            HardLimitReceived = true
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        case "SoftLimit":
            if err := json.Unmarshal([]byte(v), &strct.SoftLimit); err != nil {
                return err
             }
            SoftLimitReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if HardLimit (a required property) was received
    if !HardLimitReceived {
        return errors.New("\"HardLimit\" is required but was not present")
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    // check if SoftLimit (a required property) was received
    if !SoftLimitReceived {
        return errors.New("\"SoftLimit\" is required but was not present")
    }
    return nil
}

func (strct *Volume) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DockerVolumeConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DockerVolumeConfiguration\": ")
	if tmp, err := json.Marshal(strct.DockerVolumeConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EFSVolumeConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EFSVolumeConfiguration\": ")
	if tmp, err := json.Marshal(strct.EFSVolumeConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Host" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Host\": ")
	if tmp, err := json.Marshal(strct.Host); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Volume) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DockerVolumeConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.DockerVolumeConfiguration); err != nil {
                return err
             }
        case "EFSVolumeConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.EFSVolumeConfiguration); err != nil {
                return err
             }
        case "Host":
            if err := json.Unmarshal([]byte(v), &strct.Host); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *VolumeFrom) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ReadOnly" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ReadOnly\": ")
	if tmp, err := json.Marshal(strct.ReadOnly); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SourceContainer" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SourceContainer\": ")
	if tmp, err := json.Marshal(strct.SourceContainer); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *VolumeFrom) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ReadOnly":
            if err := json.Unmarshal([]byte(v), &strct.ReadOnly); err != nil {
                return err
             }
        case "SourceContainer":
            if err := json.Unmarshal([]byte(v), &strct.SourceContainer); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}
