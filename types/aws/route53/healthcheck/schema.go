// Code generated by schema-generate. DO NOT EDIT.

package healthcheck

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// AlarmIdentifier A complex type that identifies the CloudWatch alarm that you want Amazon Route 53 health checkers to use to determine whether the specified health check is healthy.
type AlarmIdentifier struct {

  // The name of the CloudWatch alarm that you want Amazon Route 53 health checkers to use to determine whether this health check is healthy.
  Name string `json:"Name"`

  // For the CloudWatch alarm that you want Route 53 health checkers to use to determine whether this health check is healthy, the region that the alarm was created in.
  Region string `json:"Region"`
}

// HealthCheckConfig A complex type that contains information about the health check.
type HealthCheckConfig struct {
  AlarmIdentifier *AlarmIdentifier `json:"AlarmIdentifier,omitempty"`
  ChildHealthChecks []string `json:"ChildHealthChecks,omitempty"`
  EnableSNI bool `json:"EnableSNI,omitempty"`
  FailureThreshold int `json:"FailureThreshold,omitempty"`
  FullyQualifiedDomainName string `json:"FullyQualifiedDomainName,omitempty"`
  HealthThreshold int `json:"HealthThreshold,omitempty"`
  IPAddress string `json:"IPAddress,omitempty"`
  InsufficientDataHealthStatus string `json:"InsufficientDataHealthStatus,omitempty"`
  Inverted bool `json:"Inverted,omitempty"`
  MeasureLatency bool `json:"MeasureLatency,omitempty"`
  Port int `json:"Port,omitempty"`
  Regions []string `json:"Regions,omitempty"`
  RequestInterval int `json:"RequestInterval,omitempty"`
  ResourcePath string `json:"ResourcePath,omitempty"`
  RoutingControlArn string `json:"RoutingControlArn,omitempty"`
  SearchString string `json:"SearchString,omitempty"`
  Type string `json:"Type"`
}

// HealthCheckTag A key-value pair to associate with a resource.
type HealthCheckTag struct {

  // The key name of the tag.
  Key string `json:"Key"`

  // The value for the tag.
  Value string `json:"Value"`
}

// Resource Resource schema for AWS::Route53::HealthCheck.
type Resource struct {

  // A complex type that contains information about the health check.
  HealthCheckConfig *HealthCheckConfig `json:"HealthCheckConfig"`
  HealthCheckId string `json:"HealthCheckId,omitempty"`

  // An array of key-value pairs to apply to this resource.
  HealthCheckTags []*HealthCheckTag `json:"HealthCheckTags,omitempty"`
}

func (strct *AlarmIdentifier) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Region" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Region" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Region\": ")
	if tmp, err := json.Marshal(strct.Region); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AlarmIdentifier) UnmarshalJSON(b []byte) error {
    NameReceived := false
    RegionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        case "Region":
            if err := json.Unmarshal([]byte(v), &strct.Region); err != nil {
                return err
             }
            RegionReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    // check if Region (a required property) was received
    if !RegionReceived {
        return errors.New("\"Region\" is required but was not present")
    }
    return nil
}

func (strct *HealthCheckConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AlarmIdentifier" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AlarmIdentifier\": ")
	if tmp, err := json.Marshal(strct.AlarmIdentifier); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ChildHealthChecks" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ChildHealthChecks\": ")
	if tmp, err := json.Marshal(strct.ChildHealthChecks); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EnableSNI" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EnableSNI\": ")
	if tmp, err := json.Marshal(strct.EnableSNI); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FailureThreshold" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FailureThreshold\": ")
	if tmp, err := json.Marshal(strct.FailureThreshold); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FullyQualifiedDomainName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FullyQualifiedDomainName\": ")
	if tmp, err := json.Marshal(strct.FullyQualifiedDomainName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "HealthThreshold" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HealthThreshold\": ")
	if tmp, err := json.Marshal(strct.HealthThreshold); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IPAddress" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IPAddress\": ")
	if tmp, err := json.Marshal(strct.IPAddress); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "InsufficientDataHealthStatus" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InsufficientDataHealthStatus\": ")
	if tmp, err := json.Marshal(strct.InsufficientDataHealthStatus); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Inverted" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Inverted\": ")
	if tmp, err := json.Marshal(strct.Inverted); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MeasureLatency" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MeasureLatency\": ")
	if tmp, err := json.Marshal(strct.MeasureLatency); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Port" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Port\": ")
	if tmp, err := json.Marshal(strct.Port); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Regions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Regions\": ")
	if tmp, err := json.Marshal(strct.Regions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RequestInterval" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RequestInterval\": ")
	if tmp, err := json.Marshal(strct.RequestInterval); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ResourcePath" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ResourcePath\": ")
	if tmp, err := json.Marshal(strct.ResourcePath); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RoutingControlArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoutingControlArn\": ")
	if tmp, err := json.Marshal(strct.RoutingControlArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SearchString" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SearchString\": ")
	if tmp, err := json.Marshal(strct.SearchString); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *HealthCheckConfig) UnmarshalJSON(b []byte) error {
    TypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AlarmIdentifier":
            if err := json.Unmarshal([]byte(v), &strct.AlarmIdentifier); err != nil {
                return err
             }
        case "ChildHealthChecks":
            if err := json.Unmarshal([]byte(v), &strct.ChildHealthChecks); err != nil {
                return err
             }
        case "EnableSNI":
            if err := json.Unmarshal([]byte(v), &strct.EnableSNI); err != nil {
                return err
             }
        case "FailureThreshold":
            if err := json.Unmarshal([]byte(v), &strct.FailureThreshold); err != nil {
                return err
             }
        case "FullyQualifiedDomainName":
            if err := json.Unmarshal([]byte(v), &strct.FullyQualifiedDomainName); err != nil {
                return err
             }
        case "HealthThreshold":
            if err := json.Unmarshal([]byte(v), &strct.HealthThreshold); err != nil {
                return err
             }
        case "IPAddress":
            if err := json.Unmarshal([]byte(v), &strct.IPAddress); err != nil {
                return err
             }
        case "InsufficientDataHealthStatus":
            if err := json.Unmarshal([]byte(v), &strct.InsufficientDataHealthStatus); err != nil {
                return err
             }
        case "Inverted":
            if err := json.Unmarshal([]byte(v), &strct.Inverted); err != nil {
                return err
             }
        case "MeasureLatency":
            if err := json.Unmarshal([]byte(v), &strct.MeasureLatency); err != nil {
                return err
             }
        case "Port":
            if err := json.Unmarshal([]byte(v), &strct.Port); err != nil {
                return err
             }
        case "Regions":
            if err := json.Unmarshal([]byte(v), &strct.Regions); err != nil {
                return err
             }
        case "RequestInterval":
            if err := json.Unmarshal([]byte(v), &strct.RequestInterval); err != nil {
                return err
             }
        case "ResourcePath":
            if err := json.Unmarshal([]byte(v), &strct.ResourcePath); err != nil {
                return err
             }
        case "RoutingControlArn":
            if err := json.Unmarshal([]byte(v), &strct.RoutingControlArn); err != nil {
                return err
             }
        case "SearchString":
            if err := json.Unmarshal([]byte(v), &strct.SearchString); err != nil {
                return err
             }
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            TypeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Type (a required property) was received
    if !TypeReceived {
        return errors.New("\"Type\" is required but was not present")
    }
    return nil
}

func (strct *HealthCheckTag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *HealthCheckTag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "HealthCheckConfig" field is required
    if strct.HealthCheckConfig == nil {
        return nil, errors.New("HealthCheckConfig is a required field")
    }
    // Marshal the "HealthCheckConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HealthCheckConfig\": ")
	if tmp, err := json.Marshal(strct.HealthCheckConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "HealthCheckId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HealthCheckId\": ")
	if tmp, err := json.Marshal(strct.HealthCheckId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "HealthCheckTags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HealthCheckTags\": ")
	if tmp, err := json.Marshal(strct.HealthCheckTags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    HealthCheckConfigReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "HealthCheckConfig":
            if err := json.Unmarshal([]byte(v), &strct.HealthCheckConfig); err != nil {
                return err
             }
            HealthCheckConfigReceived = true
        case "HealthCheckId":
            if err := json.Unmarshal([]byte(v), &strct.HealthCheckId); err != nil {
                return err
             }
        case "HealthCheckTags":
            if err := json.Unmarshal([]byte(v), &strct.HealthCheckTags); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if HealthCheckConfig (a required property) was received
    if !HealthCheckConfigReceived {
        return errors.New("\"HealthCheckConfig\" is required but was not present")
    }
    return nil
}
