// Code generated by schema-generate. DO NOT EDIT.

package task

import (
    "encoding/json"
    "fmt"
    "errors"
    "bytes"
)

// FilterRule Specifies which files folders and objects to include or exclude when transferring files from source to destination.
type FilterRule struct {

  // The type of filter rule to apply. AWS DataSync only supports the SIMPLE_PATTERN rule type.
  FilterType string `json:"FilterType,omitempty"`

  // A single filter string that consists of the patterns to include or exclude. The patterns are delimited by "|".
  Value string `json:"Value,omitempty"`
}

// Options Represents the options that are available to control the behavior of a StartTaskExecution operation.
type Options struct {

  // A file metadata value that shows the last time a file was accessed (that is, when the file was read or written to).
  Atime string `json:"Atime,omitempty"`

  // A value that limits the bandwidth used by AWS DataSync.
  BytesPerSecond int `json:"BytesPerSecond,omitempty"`

  // The group ID (GID) of the file's owners.
  Gid string `json:"Gid,omitempty"`

  // A value that determines the types of logs that DataSync publishes to a log stream in the Amazon CloudWatch log group that you provide.
  LogLevel string `json:"LogLevel,omitempty"`

  // A value that indicates the last time that a file was modified (that is, a file was written to) before the PREPARING phase.
  Mtime string `json:"Mtime,omitempty"`

  // A value that determines whether object tags should be read from the source object store and written to the destination object store.
  ObjectTags string `json:"ObjectTags,omitempty"`

  // A value that determines whether files at the destination should be overwritten or preserved when copying files.
  OverwriteMode string `json:"OverwriteMode,omitempty"`

  // A value that determines which users or groups can access a file for a specific purpose such as reading, writing, or execution of the file.
  PosixPermissions string `json:"PosixPermissions,omitempty"`

  // A value that specifies whether files in the destination that don't exist in the source file system should be preserved.
  PreserveDeletedFiles string `json:"PreserveDeletedFiles,omitempty"`

  // A value that determines whether AWS DataSync should preserve the metadata of block and character devices in the source file system, and recreate the files with that device name and metadata on the destination.
  PreserveDevices string `json:"PreserveDevices,omitempty"`

  // A value that determines which components of the SMB security descriptor are copied during transfer.
  SecurityDescriptorCopyFlags string `json:"SecurityDescriptorCopyFlags,omitempty"`

  // A value that determines whether tasks should be queued before executing the tasks.
  TaskQueueing string `json:"TaskQueueing,omitempty"`

  // A value that determines whether DataSync transfers only the data and metadata that differ between the source and the destination location, or whether DataSync transfers all the content from the source, without comparing to the destination location.
  TransferMode string `json:"TransferMode,omitempty"`

  // The user ID (UID) of the file's owner.
  Uid string `json:"Uid,omitempty"`

  // A value that determines whether a data integrity verification should be performed at the end of a task execution after all data and metadata have been transferred.
  VerifyMode string `json:"VerifyMode,omitempty"`
}

// Resource Resource schema for AWS::DataSync::Task.
type Resource struct {

  // The ARN of the Amazon CloudWatch log group that is used to monitor and log events in the task.
  CloudWatchLogGroupArn string `json:"CloudWatchLogGroupArn,omitempty"`

  // The ARN of an AWS storage resource's location.
  DestinationLocationArn string `json:"DestinationLocationArn"`
  DestinationNetworkInterfaceArns []string `json:"DestinationNetworkInterfaceArns,omitempty"`
  Excludes []*FilterRule `json:"Excludes,omitempty"`
  Includes []*FilterRule `json:"Includes,omitempty"`

  // The name of a task. This value is a text reference that is used to identify the task in the console.
  Name string `json:"Name,omitempty"`
  Options *Options `json:"Options,omitempty"`
  Schedule *TaskSchedule `json:"Schedule,omitempty"`

  // The ARN of the source location for the task.
  SourceLocationArn string `json:"SourceLocationArn"`
  SourceNetworkInterfaceArns []string `json:"SourceNetworkInterfaceArns,omitempty"`

  // The status of the task that was described.
  Status string `json:"Status,omitempty"`

  // An array of key-value pairs to apply to this resource.
  Tags []*Tag `json:"Tags,omitempty"`

  // The ARN of the task.
  TaskArn string `json:"TaskArn,omitempty"`
}

// Tag A key-value pair to associate with a resource.
type Tag struct {

  // The key for an AWS resource tag.
  Key string `json:"Key"`

  // The value for an AWS resource tag.
  Value string `json:"Value"`
}

// TaskSchedule Specifies the schedule you want your task to use for repeated executions.
type TaskSchedule struct {

  // A cron expression that specifies when AWS DataSync initiates a scheduled transfer from a source to a destination location
  ScheduleExpression string `json:"ScheduleExpression"`
}

func (strct *FilterRule) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "FilterType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FilterType\": ")
	if tmp, err := json.Marshal(strct.FilterType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FilterRule) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "FilterType":
            if err := json.Unmarshal([]byte(v), &strct.FilterType); err != nil {
                return err
             }
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Options) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Atime" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Atime\": ")
	if tmp, err := json.Marshal(strct.Atime); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BytesPerSecond" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BytesPerSecond\": ")
	if tmp, err := json.Marshal(strct.BytesPerSecond); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Gid" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Gid\": ")
	if tmp, err := json.Marshal(strct.Gid); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LogLevel" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LogLevel\": ")
	if tmp, err := json.Marshal(strct.LogLevel); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Mtime" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Mtime\": ")
	if tmp, err := json.Marshal(strct.Mtime); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ObjectTags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ObjectTags\": ")
	if tmp, err := json.Marshal(strct.ObjectTags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OverwriteMode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OverwriteMode\": ")
	if tmp, err := json.Marshal(strct.OverwriteMode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PosixPermissions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PosixPermissions\": ")
	if tmp, err := json.Marshal(strct.PosixPermissions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PreserveDeletedFiles" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PreserveDeletedFiles\": ")
	if tmp, err := json.Marshal(strct.PreserveDeletedFiles); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PreserveDevices" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PreserveDevices\": ")
	if tmp, err := json.Marshal(strct.PreserveDevices); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SecurityDescriptorCopyFlags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SecurityDescriptorCopyFlags\": ")
	if tmp, err := json.Marshal(strct.SecurityDescriptorCopyFlags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TaskQueueing" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TaskQueueing\": ")
	if tmp, err := json.Marshal(strct.TaskQueueing); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TransferMode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TransferMode\": ")
	if tmp, err := json.Marshal(strct.TransferMode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Uid" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Uid\": ")
	if tmp, err := json.Marshal(strct.Uid); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VerifyMode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VerifyMode\": ")
	if tmp, err := json.Marshal(strct.VerifyMode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Options) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Atime":
            if err := json.Unmarshal([]byte(v), &strct.Atime); err != nil {
                return err
             }
        case "BytesPerSecond":
            if err := json.Unmarshal([]byte(v), &strct.BytesPerSecond); err != nil {
                return err
             }
        case "Gid":
            if err := json.Unmarshal([]byte(v), &strct.Gid); err != nil {
                return err
             }
        case "LogLevel":
            if err := json.Unmarshal([]byte(v), &strct.LogLevel); err != nil {
                return err
             }
        case "Mtime":
            if err := json.Unmarshal([]byte(v), &strct.Mtime); err != nil {
                return err
             }
        case "ObjectTags":
            if err := json.Unmarshal([]byte(v), &strct.ObjectTags); err != nil {
                return err
             }
        case "OverwriteMode":
            if err := json.Unmarshal([]byte(v), &strct.OverwriteMode); err != nil {
                return err
             }
        case "PosixPermissions":
            if err := json.Unmarshal([]byte(v), &strct.PosixPermissions); err != nil {
                return err
             }
        case "PreserveDeletedFiles":
            if err := json.Unmarshal([]byte(v), &strct.PreserveDeletedFiles); err != nil {
                return err
             }
        case "PreserveDevices":
            if err := json.Unmarshal([]byte(v), &strct.PreserveDevices); err != nil {
                return err
             }
        case "SecurityDescriptorCopyFlags":
            if err := json.Unmarshal([]byte(v), &strct.SecurityDescriptorCopyFlags); err != nil {
                return err
             }
        case "TaskQueueing":
            if err := json.Unmarshal([]byte(v), &strct.TaskQueueing); err != nil {
                return err
             }
        case "TransferMode":
            if err := json.Unmarshal([]byte(v), &strct.TransferMode); err != nil {
                return err
             }
        case "Uid":
            if err := json.Unmarshal([]byte(v), &strct.Uid); err != nil {
                return err
             }
        case "VerifyMode":
            if err := json.Unmarshal([]byte(v), &strct.VerifyMode); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CloudWatchLogGroupArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CloudWatchLogGroupArn\": ")
	if tmp, err := json.Marshal(strct.CloudWatchLogGroupArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "DestinationLocationArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "DestinationLocationArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DestinationLocationArn\": ")
	if tmp, err := json.Marshal(strct.DestinationLocationArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DestinationNetworkInterfaceArns" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DestinationNetworkInterfaceArns\": ")
	if tmp, err := json.Marshal(strct.DestinationNetworkInterfaceArns); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Excludes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Excludes\": ")
	if tmp, err := json.Marshal(strct.Excludes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Includes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Includes\": ")
	if tmp, err := json.Marshal(strct.Includes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Options" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Options\": ")
	if tmp, err := json.Marshal(strct.Options); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Schedule" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Schedule\": ")
	if tmp, err := json.Marshal(strct.Schedule); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "SourceLocationArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "SourceLocationArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SourceLocationArn\": ")
	if tmp, err := json.Marshal(strct.SourceLocationArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SourceNetworkInterfaceArns" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SourceNetworkInterfaceArns\": ")
	if tmp, err := json.Marshal(strct.SourceNetworkInterfaceArns); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Status" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Status\": ")
	if tmp, err := json.Marshal(strct.Status); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TaskArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TaskArn\": ")
	if tmp, err := json.Marshal(strct.TaskArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    DestinationLocationArnReceived := false
    SourceLocationArnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CloudWatchLogGroupArn":
            if err := json.Unmarshal([]byte(v), &strct.CloudWatchLogGroupArn); err != nil {
                return err
             }
        case "DestinationLocationArn":
            if err := json.Unmarshal([]byte(v), &strct.DestinationLocationArn); err != nil {
                return err
             }
            DestinationLocationArnReceived = true
        case "DestinationNetworkInterfaceArns":
            if err := json.Unmarshal([]byte(v), &strct.DestinationNetworkInterfaceArns); err != nil {
                return err
             }
        case "Excludes":
            if err := json.Unmarshal([]byte(v), &strct.Excludes); err != nil {
                return err
             }
        case "Includes":
            if err := json.Unmarshal([]byte(v), &strct.Includes); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "Options":
            if err := json.Unmarshal([]byte(v), &strct.Options); err != nil {
                return err
             }
        case "Schedule":
            if err := json.Unmarshal([]byte(v), &strct.Schedule); err != nil {
                return err
             }
        case "SourceLocationArn":
            if err := json.Unmarshal([]byte(v), &strct.SourceLocationArn); err != nil {
                return err
             }
            SourceLocationArnReceived = true
        case "SourceNetworkInterfaceArns":
            if err := json.Unmarshal([]byte(v), &strct.SourceNetworkInterfaceArns); err != nil {
                return err
             }
        case "Status":
            if err := json.Unmarshal([]byte(v), &strct.Status); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        case "TaskArn":
            if err := json.Unmarshal([]byte(v), &strct.TaskArn); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if DestinationLocationArn (a required property) was received
    if !DestinationLocationArnReceived {
        return errors.New("\"DestinationLocationArn\" is required but was not present")
    }
    // check if SourceLocationArn (a required property) was received
    if !SourceLocationArnReceived {
        return errors.New("\"SourceLocationArn\" is required but was not present")
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *TaskSchedule) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ScheduleExpression" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ScheduleExpression" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ScheduleExpression\": ")
	if tmp, err := json.Marshal(strct.ScheduleExpression); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TaskSchedule) UnmarshalJSON(b []byte) error {
    ScheduleExpressionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ScheduleExpression":
            if err := json.Unmarshal([]byte(v), &strct.ScheduleExpression); err != nil {
                return err
             }
            ScheduleExpressionReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ScheduleExpression (a required property) was received
    if !ScheduleExpressionReceived {
        return errors.New("\"ScheduleExpression\" is required but was not present")
    }
    return nil
}
