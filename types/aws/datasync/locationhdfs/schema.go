// Code generated by schema-generate. DO NOT EDIT.

package locationhdfs

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// NameNode HDFS Name Node IP and port information.
type NameNode struct {

  // The DNS name or IP address of the Name Node in the customer's on premises HDFS cluster.
  Hostname string `json:"Hostname"`

  // The port on which the Name Node is listening on for client requests.
  Port int `json:"Port"`
}

// QopConfiguration Configuration information for RPC Protection and Data Transfer Protection. These parameters can be set to AUTHENTICATION, INTEGRITY, or PRIVACY. The default value is PRIVACY.
type QopConfiguration struct {

  // Configuration for Data Transfer Protection.
  DataTransferProtection string `json:"DataTransferProtection,omitempty"`

  // Configuration for RPC Protection.
  RpcProtection string `json:"RpcProtection,omitempty"`
}

// Resource Resource schema for AWS::DataSync::LocationHDFS.
type Resource struct {

  // ARN(s) of the agent(s) to use for an HDFS location.
  AgentArns []string `json:"AgentArns"`

  // The authentication mode used to determine identity of user.
  AuthenticationType string `json:"AuthenticationType"`

  // Size of chunks (blocks) in bytes that the data is divided into when stored in the HDFS cluster.
  BlockSize int `json:"BlockSize,omitempty"`

  // The Base64 string representation of the Keytab file.
  KerberosKeytab string `json:"KerberosKeytab,omitempty"`

  // The string representation of the Krb5Conf file, or the presigned URL to access the Krb5.conf file within an S3 bucket.
  KerberosKrb5Conf string `json:"KerberosKrb5Conf,omitempty"`

  // The unique identity, or principal, to which Kerberos can assign tickets.
  KerberosPrincipal string `json:"KerberosPrincipal,omitempty"`

  // The identifier for the Key Management Server where the encryption keys that encrypt data inside HDFS clusters are stored.
  KmsKeyProviderUri string `json:"KmsKeyProviderUri,omitempty"`

  // The Amazon Resource Name (ARN) of the HDFS location.
  LocationArn string `json:"LocationArn,omitempty"`

  // The URL of the HDFS location that was described.
  LocationUri string `json:"LocationUri,omitempty"`

  // An array of Name Node(s) of the HDFS location.
  NameNodes []*NameNode `json:"NameNodes"`
  QopConfiguration *QopConfiguration `json:"QopConfiguration,omitempty"`

  // Number of copies of each block that exists inside the HDFS cluster.
  ReplicationFactor int `json:"ReplicationFactor,omitempty"`

  // The user name that has read and write permissions on the specified HDFS cluster.
  SimpleUser string `json:"SimpleUser,omitempty"`

  // The subdirectory in HDFS that is used to read data from the HDFS source location or write data to the HDFS destination.
  Subdirectory string `json:"Subdirectory,omitempty"`

  // An array of key-value pairs to apply to this resource.
  Tags []*Tag `json:"Tags,omitempty"`
}

// Tag A key-value pair to associate with a resource.
type Tag struct {

  // The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
  Key string `json:"Key"`

  // The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
  Value string `json:"Value"`
}

func (strct *NameNode) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Hostname" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Hostname" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Hostname\": ")
	if tmp, err := json.Marshal(strct.Hostname); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Port" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Port" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Port\": ")
	if tmp, err := json.Marshal(strct.Port); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *NameNode) UnmarshalJSON(b []byte) error {
    HostnameReceived := false
    PortReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Hostname":
            if err := json.Unmarshal([]byte(v), &strct.Hostname); err != nil {
                return err
             }
            HostnameReceived = true
        case "Port":
            if err := json.Unmarshal([]byte(v), &strct.Port); err != nil {
                return err
             }
            PortReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Hostname (a required property) was received
    if !HostnameReceived {
        return errors.New("\"Hostname\" is required but was not present")
    }
    // check if Port (a required property) was received
    if !PortReceived {
        return errors.New("\"Port\" is required but was not present")
    }
    return nil
}

func (strct *QopConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DataTransferProtection" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DataTransferProtection\": ")
	if tmp, err := json.Marshal(strct.DataTransferProtection); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RpcProtection" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RpcProtection\": ")
	if tmp, err := json.Marshal(strct.RpcProtection); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *QopConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DataTransferProtection":
            if err := json.Unmarshal([]byte(v), &strct.DataTransferProtection); err != nil {
                return err
             }
        case "RpcProtection":
            if err := json.Unmarshal([]byte(v), &strct.RpcProtection); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AgentArns" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AgentArns" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AgentArns\": ")
	if tmp, err := json.Marshal(strct.AgentArns); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "AuthenticationType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AuthenticationType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AuthenticationType\": ")
	if tmp, err := json.Marshal(strct.AuthenticationType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BlockSize" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BlockSize\": ")
	if tmp, err := json.Marshal(strct.BlockSize); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "KerberosKeytab" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KerberosKeytab\": ")
	if tmp, err := json.Marshal(strct.KerberosKeytab); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "KerberosKrb5Conf" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KerberosKrb5Conf\": ")
	if tmp, err := json.Marshal(strct.KerberosKrb5Conf); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "KerberosPrincipal" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KerberosPrincipal\": ")
	if tmp, err := json.Marshal(strct.KerberosPrincipal); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "KmsKeyProviderUri" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KmsKeyProviderUri\": ")
	if tmp, err := json.Marshal(strct.KmsKeyProviderUri); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LocationArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LocationArn\": ")
	if tmp, err := json.Marshal(strct.LocationArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LocationUri" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LocationUri\": ")
	if tmp, err := json.Marshal(strct.LocationUri); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "NameNodes" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "NameNodes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NameNodes\": ")
	if tmp, err := json.Marshal(strct.NameNodes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "QopConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"QopConfiguration\": ")
	if tmp, err := json.Marshal(strct.QopConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ReplicationFactor" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ReplicationFactor\": ")
	if tmp, err := json.Marshal(strct.ReplicationFactor); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SimpleUser" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SimpleUser\": ")
	if tmp, err := json.Marshal(strct.SimpleUser); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Subdirectory" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Subdirectory\": ")
	if tmp, err := json.Marshal(strct.Subdirectory); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    AgentArnsReceived := false
    AuthenticationTypeReceived := false
    NameNodesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AgentArns":
            if err := json.Unmarshal([]byte(v), &strct.AgentArns); err != nil {
                return err
             }
            AgentArnsReceived = true
        case "AuthenticationType":
            if err := json.Unmarshal([]byte(v), &strct.AuthenticationType); err != nil {
                return err
             }
            AuthenticationTypeReceived = true
        case "BlockSize":
            if err := json.Unmarshal([]byte(v), &strct.BlockSize); err != nil {
                return err
             }
        case "KerberosKeytab":
            if err := json.Unmarshal([]byte(v), &strct.KerberosKeytab); err != nil {
                return err
             }
        case "KerberosKrb5Conf":
            if err := json.Unmarshal([]byte(v), &strct.KerberosKrb5Conf); err != nil {
                return err
             }
        case "KerberosPrincipal":
            if err := json.Unmarshal([]byte(v), &strct.KerberosPrincipal); err != nil {
                return err
             }
        case "KmsKeyProviderUri":
            if err := json.Unmarshal([]byte(v), &strct.KmsKeyProviderUri); err != nil {
                return err
             }
        case "LocationArn":
            if err := json.Unmarshal([]byte(v), &strct.LocationArn); err != nil {
                return err
             }
        case "LocationUri":
            if err := json.Unmarshal([]byte(v), &strct.LocationUri); err != nil {
                return err
             }
        case "NameNodes":
            if err := json.Unmarshal([]byte(v), &strct.NameNodes); err != nil {
                return err
             }
            NameNodesReceived = true
        case "QopConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.QopConfiguration); err != nil {
                return err
             }
        case "ReplicationFactor":
            if err := json.Unmarshal([]byte(v), &strct.ReplicationFactor); err != nil {
                return err
             }
        case "SimpleUser":
            if err := json.Unmarshal([]byte(v), &strct.SimpleUser); err != nil {
                return err
             }
        case "Subdirectory":
            if err := json.Unmarshal([]byte(v), &strct.Subdirectory); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if AgentArns (a required property) was received
    if !AgentArnsReceived {
        return errors.New("\"AgentArns\" is required but was not present")
    }
    // check if AuthenticationType (a required property) was received
    if !AuthenticationTypeReceived {
        return errors.New("\"AuthenticationType\" is required but was not present")
    }
    // check if NameNodes (a required property) was received
    if !NameNodesReceived {
        return errors.New("\"NameNodes\" is required but was not present")
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}
