// Code generated by schema-generate. DO NOT EDIT.

package connectorprofile

import (
    "encoding/json"
    "errors"
    "fmt"
    "bytes"
)

// AmplitudeConnectorProfileCredentials 
type AmplitudeConnectorProfileCredentials struct {

  // A unique alphanumeric identi?er used to authenticate a user, developer, or calling program to your API.
  ApiKey string `json:"ApiKey"`
  SecretKey string `json:"SecretKey"`
}

// ApiKeyCredentials 
type ApiKeyCredentials struct {
  ApiKey string `json:"ApiKey"`
  ApiSecretKey string `json:"ApiSecretKey,omitempty"`
}

// BasicAuthCredentials 
type BasicAuthCredentials struct {
  Password string `json:"Password"`
  Username string `json:"Username"`
}

// ConnectorOAuthRequest 
type ConnectorOAuthRequest struct {

  // The code provided by the connector when it has been authenticated via the connected app.
  AuthCode string `json:"AuthCode,omitempty"`

  // The URL to which the authentication server redirects the browser after authorization has been
  // granted.
  RedirectUri string `json:"RedirectUri,omitempty"`
}

// ConnectorProfileConfig Connector specific configurations needed to create connector profile
type ConnectorProfileConfig struct {
  ConnectorProfileCredentials *ConnectorProfileCredentials `json:"ConnectorProfileCredentials,omitempty"`
  ConnectorProfileProperties *ConnectorProfileProperties `json:"ConnectorProfileProperties,omitempty"`
}

// ConnectorProfileCredentials Connector specific configuration needed to create connector profile based on Authentication mechanism
type ConnectorProfileCredentials struct {
  Amplitude *AmplitudeConnectorProfileCredentials `json:"Amplitude,omitempty"`
  CustomConnector *CustomConnectorProfileCredentials `json:"CustomConnector,omitempty"`
  Datadog *DatadogConnectorProfileCredentials `json:"Datadog,omitempty"`
  Dynatrace *DynatraceConnectorProfileCredentials `json:"Dynatrace,omitempty"`
  GoogleAnalytics *GoogleAnalyticsConnectorProfileCredentials `json:"GoogleAnalytics,omitempty"`
  InforNexus *InforNexusConnectorProfileCredentials `json:"InforNexus,omitempty"`
  Marketo *MarketoConnectorProfileCredentials `json:"Marketo,omitempty"`
  Pardot *PardotConnectorProfileCredentials `json:"Pardot,omitempty"`
  Redshift *RedshiftConnectorProfileCredentials `json:"Redshift,omitempty"`
  SAPOData *SAPODataConnectorProfileCredentials `json:"SAPOData,omitempty"`
  Salesforce *SalesforceConnectorProfileCredentials `json:"Salesforce,omitempty"`
  ServiceNow *ServiceNowConnectorProfileCredentials `json:"ServiceNow,omitempty"`
  Singular *SingularConnectorProfileCredentials `json:"Singular,omitempty"`
  Slack *SlackConnectorProfileCredentials `json:"Slack,omitempty"`
  Snowflake *SnowflakeConnectorProfileCredentials `json:"Snowflake,omitempty"`
  Trendmicro *TrendmicroConnectorProfileCredentials `json:"Trendmicro,omitempty"`
  Veeva *VeevaConnectorProfileCredentials `json:"Veeva,omitempty"`
  Zendesk *ZendeskConnectorProfileCredentials `json:"Zendesk,omitempty"`
}

// ConnectorProfileProperties Connector specific properties needed to create connector profile - currently not needed for Amplitude, Trendmicro, Googleanalytics and Singular
type ConnectorProfileProperties struct {
  CustomConnector *CustomConnectorProfileProperties `json:"CustomConnector,omitempty"`
  Datadog *DatadogConnectorProfileProperties `json:"Datadog,omitempty"`
  Dynatrace *DynatraceConnectorProfileProperties `json:"Dynatrace,omitempty"`
  InforNexus *InforNexusConnectorProfileProperties `json:"InforNexus,omitempty"`
  Marketo *MarketoConnectorProfileProperties `json:"Marketo,omitempty"`
  Pardot *PardotConnectorProfileProperties `json:"Pardot,omitempty"`
  Redshift *RedshiftConnectorProfileProperties `json:"Redshift,omitempty"`
  SAPOData *SAPODataConnectorProfileProperties `json:"SAPOData,omitempty"`
  Salesforce *SalesforceConnectorProfileProperties `json:"Salesforce,omitempty"`
  ServiceNow *ServiceNowConnectorProfileProperties `json:"ServiceNow,omitempty"`
  Slack *SlackConnectorProfileProperties `json:"Slack,omitempty"`
  Snowflake *SnowflakeConnectorProfileProperties `json:"Snowflake,omitempty"`
  Veeva *VeevaConnectorProfileProperties `json:"Veeva,omitempty"`
  Zendesk *ZendeskConnectorProfileProperties `json:"Zendesk,omitempty"`
}

// CredentialsMap A map for properties for custom authentication.
type CredentialsMap struct {
}

// CustomAuthCredentials 
type CustomAuthCredentials struct {
  CredentialsMap *CredentialsMap `json:"CredentialsMap,omitempty"`
  CustomAuthenticationType string `json:"CustomAuthenticationType"`
}

// CustomConnectorProfileCredentials 
type CustomConnectorProfileCredentials struct {
  ApiKey *ApiKeyCredentials `json:"ApiKey,omitempty"`
  AuthenticationType string `json:"AuthenticationType"`
  Basic *BasicAuthCredentials `json:"Basic,omitempty"`
  Custom *CustomAuthCredentials `json:"Custom,omitempty"`
  Oauth2 *OAuth2Credentials `json:"Oauth2,omitempty"`
}

// CustomConnectorProfileProperties 
type CustomConnectorProfileProperties struct {
  OAuth2Properties *OAuth2Properties `json:"OAuth2Properties,omitempty"`
  ProfileProperties *ProfileProperties `json:"ProfileProperties,omitempty"`
}

// DatadogConnectorProfileCredentials 
type DatadogConnectorProfileCredentials struct {

  // A unique alphanumeric identi?er used to authenticate a user, developer, or calling program to your API.
  ApiKey string `json:"ApiKey"`

  // Application keys, in conjunction with your API key, give you full access to Datadog?s programmatic API. Application keys are associated with the user account that created them. The application key is used to log all requests made to the API.
  ApplicationKey string `json:"ApplicationKey"`
}

// DatadogConnectorProfileProperties 
type DatadogConnectorProfileProperties struct {

  // The location of the Datadog resource
  InstanceUrl string `json:"InstanceUrl"`
}

// DynatraceConnectorProfileCredentials 
type DynatraceConnectorProfileCredentials struct {

  // The API tokens used by Dynatrace API to authenticate various API calls.
  ApiToken string `json:"ApiToken"`
}

// DynatraceConnectorProfileProperties 
type DynatraceConnectorProfileProperties struct {

  // The location of the Dynatrace resource
  InstanceUrl string `json:"InstanceUrl"`
}

// GoogleAnalyticsConnectorProfileCredentials 
type GoogleAnalyticsConnectorProfileCredentials struct {

  // The credentials used to access protected resources.
  AccessToken string `json:"AccessToken,omitempty"`

  // The identi?er for the desired client.
  ClientId string `json:"ClientId"`

  // The client secret used by the oauth client to authenticate to the authorization server.
  ClientSecret string `json:"ClientSecret"`

  // The oauth needed to request security tokens from the connector endpoint.
  ConnectorOAuthRequest *ConnectorOAuthRequest `json:"ConnectorOAuthRequest,omitempty"`

  // The credentials used to acquire new access tokens.
  RefreshToken string `json:"RefreshToken,omitempty"`
}

// InforNexusConnectorProfileCredentials 
type InforNexusConnectorProfileCredentials struct {

  // The Access Key portion of the credentials.
  AccessKeyId string `json:"AccessKeyId"`

  // The encryption keys used to encrypt data.
  Datakey string `json:"Datakey"`

  // The secret key used to sign requests.
  SecretAccessKey string `json:"SecretAccessKey"`

  // The identi?er for the user.
  UserId string `json:"UserId"`
}

// InforNexusConnectorProfileProperties 
type InforNexusConnectorProfileProperties struct {

  // The location of the InforNexus resource
  InstanceUrl string `json:"InstanceUrl"`
}

// MarketoConnectorProfileCredentials 
type MarketoConnectorProfileCredentials struct {

  // The credentials used to access protected resources.
  AccessToken string `json:"AccessToken,omitempty"`

  // The identi?er for the desired client.
  ClientId string `json:"ClientId"`

  // The client secret used by the oauth client to authenticate to the authorization server.
  ClientSecret string `json:"ClientSecret"`

  // The oauth needed to request security tokens from the connector endpoint.
  ConnectorOAuthRequest *ConnectorOAuthRequest `json:"ConnectorOAuthRequest,omitempty"`
}

// MarketoConnectorProfileProperties 
type MarketoConnectorProfileProperties struct {

  // The location of the Marketo resource
  InstanceUrl string `json:"InstanceUrl"`
}

// OAuth2Credentials 
type OAuth2Credentials struct {
  AccessToken string `json:"AccessToken,omitempty"`
  ClientId string `json:"ClientId,omitempty"`
  ClientSecret string `json:"ClientSecret,omitempty"`
  OAuthRequest *ConnectorOAuthRequest `json:"OAuthRequest,omitempty"`
  RefreshToken string `json:"RefreshToken,omitempty"`
}

// OAuth2Properties 
type OAuth2Properties struct {
  OAuth2GrantType string `json:"OAuth2GrantType,omitempty"`
  TokenUrl string `json:"TokenUrl,omitempty"`
  TokenUrlCustomProperties *TokenUrlCustomProperties `json:"TokenUrlCustomProperties,omitempty"`
}

// OAuthCredentials 
type OAuthCredentials struct {
  AccessToken string `json:"AccessToken,omitempty"`
  ClientId string `json:"ClientId,omitempty"`
  ClientSecret string `json:"ClientSecret,omitempty"`
  ConnectorOAuthRequest *ConnectorOAuthRequest `json:"ConnectorOAuthRequest,omitempty"`
  RefreshToken string `json:"RefreshToken,omitempty"`
}

// OAuthProperties 
type OAuthProperties struct {
  AuthCodeUrl string `json:"AuthCodeUrl,omitempty"`
  OAuthScopes []string `json:"OAuthScopes,omitempty"`
  TokenUrl string `json:"TokenUrl,omitempty"`
}

// PardotConnectorProfileCredentials 
type PardotConnectorProfileCredentials struct {

  // The credentials used to access protected resources.
  AccessToken string `json:"AccessToken,omitempty"`

  // The client credentials to fetch access token and refresh token.
  ClientCredentialsArn string `json:"ClientCredentialsArn,omitempty"`

  // The oauth needed to request security tokens from the connector endpoint.
  ConnectorOAuthRequest *ConnectorOAuthRequest `json:"ConnectorOAuthRequest,omitempty"`

  // The credentials used to acquire new access tokens.
  RefreshToken string `json:"RefreshToken,omitempty"`
}

// PardotConnectorProfileProperties 
type PardotConnectorProfileProperties struct {

  // The Business unit id of Salesforce Pardot instance to be connected
  BusinessUnitId string `json:"BusinessUnitId"`

  // The location of the Salesforce Pardot resource
  InstanceUrl string `json:"InstanceUrl,omitempty"`

  // Indicates whether the connector profile applies to a demo or production environment
  IsSandboxEnvironment bool `json:"IsSandboxEnvironment,omitempty"`
}

// ProfileProperties A map for properties for custom connector.
type ProfileProperties struct {
}

// RedshiftConnectorProfileCredentials 
type RedshiftConnectorProfileCredentials struct {

  // The password that corresponds to the username.
  Password string `json:"Password,omitempty"`

  // The name of the user.
  Username string `json:"Username,omitempty"`
}

// RedshiftConnectorProfileProperties 
type RedshiftConnectorProfileProperties struct {

  // The name of the Amazon S3 bucket associated with Redshift.
  BucketName string `json:"BucketName"`

  // The object key for the destination bucket in which Amazon AppFlow will place the ?les.
  BucketPrefix string `json:"BucketPrefix,omitempty"`

  // The unique identifier of the Amazon Redshift cluster.
  ClusterIdentifier string `json:"ClusterIdentifier,omitempty"`

  // The Amazon Resource Name (ARN) of the IAM role that grants Amazon AppFlow access to the data through the Amazon Redshift Data API.
  DataApiRoleArn string `json:"DataApiRoleArn,omitempty"`

  // The name of the Amazon Redshift database that will store the transferred data.
  DatabaseName string `json:"DatabaseName,omitempty"`

  // The JDBC URL of the Amazon Redshift cluster.
  DatabaseUrl string `json:"DatabaseUrl,omitempty"`

  // If Amazon AppFlow will connect to Amazon Redshift Serverless or Amazon Redshift cluster.
  IsRedshiftServerless bool `json:"IsRedshiftServerless,omitempty"`

  // The Amazon Resource Name (ARN) of the IAM role.
  RoleArn string `json:"RoleArn"`

  // The name of the Amazon Redshift serverless workgroup
  WorkgroupName string `json:"WorkgroupName,omitempty"`
}

// Resource Resource Type definition for AWS::AppFlow::ConnectorProfile
type Resource struct {

  // Mode in which data transfer should be enabled. Private connection mode is currently enabled for Salesforce, Snowflake, Trendmicro and Singular
  ConnectionMode string `json:"ConnectionMode"`

  // The label of the connector. The label is unique for each ConnectorRegistration in your AWS account. Only needed if calling for CUSTOMCONNECTOR connector type/.
  ConnectorLabel string `json:"ConnectorLabel,omitempty"`

  // Unique identifier for connector profile resources
  ConnectorProfileArn string `json:"ConnectorProfileArn,omitempty"`

  // Connector specific configurations needed to create connector profile
  ConnectorProfileConfig *ConnectorProfileConfig `json:"ConnectorProfileConfig,omitempty"`

  // The maximum number of items to retrieve in a single batch.
  ConnectorProfileName string `json:"ConnectorProfileName"`

  // List of Saas providers that need connector profile to be created
  ConnectorType string `json:"ConnectorType"`

  // A unique Arn for Connector-Profile resource
  CredentialsArn string `json:"CredentialsArn,omitempty"`

  // The ARN of the AWS Key Management Service (AWS KMS) key that's used to encrypt your function's environment variables. If it's not provided, AWS Lambda uses a default service key.
  KMSArn string `json:"KMSArn,omitempty"`
}

// SAPODataConnectorProfileCredentials 
type SAPODataConnectorProfileCredentials struct {
  BasicAuthCredentials *BasicAuthCredentials `json:"BasicAuthCredentials,omitempty"`
  OAuthCredentials *OAuthCredentials `json:"OAuthCredentials,omitempty"`
}

// SAPODataConnectorProfileProperties 
type SAPODataConnectorProfileProperties struct {
  ApplicationHostUrl string `json:"ApplicationHostUrl,omitempty"`
  ApplicationServicePath string `json:"ApplicationServicePath,omitempty"`
  ClientNumber string `json:"ClientNumber,omitempty"`
  LogonLanguage string `json:"LogonLanguage,omitempty"`
  OAuthProperties *OAuthProperties `json:"OAuthProperties,omitempty"`
  PortNumber int `json:"PortNumber,omitempty"`
  PrivateLinkServiceName string `json:"PrivateLinkServiceName,omitempty"`
}

// SalesforceConnectorProfileCredentials 
type SalesforceConnectorProfileCredentials struct {

  // The credentials used to access protected resources.
  AccessToken string `json:"AccessToken,omitempty"`

  // The client credentials to fetch access token and refresh token.
  ClientCredentialsArn string `json:"ClientCredentialsArn,omitempty"`

  // The oauth needed to request security tokens from the connector endpoint.
  ConnectorOAuthRequest *ConnectorOAuthRequest `json:"ConnectorOAuthRequest,omitempty"`

  // The credentials used to acquire new access tokens.
  RefreshToken string `json:"RefreshToken,omitempty"`
}

// SalesforceConnectorProfileProperties 
type SalesforceConnectorProfileProperties struct {

  // The location of the Salesforce resource
  InstanceUrl string `json:"InstanceUrl,omitempty"`

  // Indicates whether the connector profile applies to a sandbox or production environment
  IsSandboxEnvironment bool `json:"isSandboxEnvironment,omitempty"`
}

// ServiceNowConnectorProfileCredentials 
type ServiceNowConnectorProfileCredentials struct {

  // The password that corresponds to the username.
  Password string `json:"Password"`

  // The name of the user.
  Username string `json:"Username"`
}

// ServiceNowConnectorProfileProperties 
type ServiceNowConnectorProfileProperties struct {

  // The location of the ServiceNow resource
  InstanceUrl string `json:"InstanceUrl"`
}

// SingularConnectorProfileCredentials 
type SingularConnectorProfileCredentials struct {

  // A unique alphanumeric identi?er used to authenticate a user, developer, or calling program to your API.
  ApiKey string `json:"ApiKey"`
}

// SlackConnectorProfileCredentials 
type SlackConnectorProfileCredentials struct {

  // The credentials used to access protected resources.
  AccessToken string `json:"AccessToken,omitempty"`

  // The identi?er for the desired client.
  ClientId string `json:"ClientId"`

  // The client secret used by the oauth client to authenticate to the authorization server.
  ClientSecret string `json:"ClientSecret"`

  // The oauth needed to request security tokens from the connector endpoint.
  ConnectorOAuthRequest *ConnectorOAuthRequest `json:"ConnectorOAuthRequest,omitempty"`
}

// SlackConnectorProfileProperties 
type SlackConnectorProfileProperties struct {

  // The location of the Slack resource
  InstanceUrl string `json:"InstanceUrl"`
}

// SnowflakeConnectorProfileCredentials 
type SnowflakeConnectorProfileCredentials struct {

  // The password that corresponds to the username.
  Password string `json:"Password"`

  // The name of the user.
  Username string `json:"Username"`
}

// SnowflakeConnectorProfileProperties 
type SnowflakeConnectorProfileProperties struct {

  // The name of the account.
  AccountName string `json:"AccountName,omitempty"`

  // The name of the Amazon S3 bucket associated with Snow?ake.
  BucketName string `json:"BucketName"`

  // The bucket prefix that refers to the Amazon S3 bucket associated with Snow?ake.
  BucketPrefix string `json:"BucketPrefix,omitempty"`

  // The Snow?ake Private Link service name to be used for private data transfers.
  PrivateLinkServiceName string `json:"PrivateLinkServiceName,omitempty"`

  // The region of the Snow?ake account.
  Region string `json:"Region,omitempty"`

  // The name of the Amazon S3 stage that was created while setting up an Amazon S3 stage in the
  // Snow?ake account. This is written in the following format: < Database>< Schema><Stage Name>.
  Stage string `json:"Stage"`

  // The name of the Snow?ake warehouse.
  Warehouse string `json:"Warehouse"`
}

// TokenUrlCustomProperties A map for properties for custom connector Token Url.
type TokenUrlCustomProperties struct {
}

// TrendmicroConnectorProfileCredentials 
type TrendmicroConnectorProfileCredentials struct {

  // The Secret Access Key portion of the credentials.
  ApiSecretKey string `json:"ApiSecretKey"`
}

// VeevaConnectorProfileCredentials 
type VeevaConnectorProfileCredentials struct {

  // The password that corresponds to the username.
  Password string `json:"Password"`

  // The name of the user.
  Username string `json:"Username"`
}

// VeevaConnectorProfileProperties 
type VeevaConnectorProfileProperties struct {

  // The location of the Veeva resource
  InstanceUrl string `json:"InstanceUrl"`
}

// ZendeskConnectorProfileCredentials 
type ZendeskConnectorProfileCredentials struct {

  // The credentials used to access protected resources.
  AccessToken string `json:"AccessToken,omitempty"`

  // The identi?er for the desired client.
  ClientId string `json:"ClientId"`

  // The client secret used by the oauth client to authenticate to the authorization server.
  ClientSecret string `json:"ClientSecret"`

  // The oauth needed to request security tokens from the connector endpoint.
  ConnectorOAuthRequest *ConnectorOAuthRequest `json:"ConnectorOAuthRequest,omitempty"`
}

// ZendeskConnectorProfileProperties 
type ZendeskConnectorProfileProperties struct {

  // The location of the Zendesk resource
  InstanceUrl string `json:"InstanceUrl"`
}

func (strct *AmplitudeConnectorProfileCredentials) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ApiKey" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ApiKey" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ApiKey\": ")
	if tmp, err := json.Marshal(strct.ApiKey); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "SecretKey" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "SecretKey" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SecretKey\": ")
	if tmp, err := json.Marshal(strct.SecretKey); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AmplitudeConnectorProfileCredentials) UnmarshalJSON(b []byte) error {
    ApiKeyReceived := false
    SecretKeyReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ApiKey":
            if err := json.Unmarshal([]byte(v), &strct.ApiKey); err != nil {
                return err
             }
            ApiKeyReceived = true
        case "SecretKey":
            if err := json.Unmarshal([]byte(v), &strct.SecretKey); err != nil {
                return err
             }
            SecretKeyReceived = true
        }
    }
    // check if ApiKey (a required property) was received
    if !ApiKeyReceived {
        return errors.New("\"ApiKey\" is required but was not present")
    }
    // check if SecretKey (a required property) was received
    if !SecretKeyReceived {
        return errors.New("\"SecretKey\" is required but was not present")
    }
    return nil
}

func (strct *ApiKeyCredentials) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ApiKey" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ApiKey" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ApiKey\": ")
	if tmp, err := json.Marshal(strct.ApiKey); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ApiSecretKey" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ApiSecretKey\": ")
	if tmp, err := json.Marshal(strct.ApiSecretKey); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ApiKeyCredentials) UnmarshalJSON(b []byte) error {
    ApiKeyReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ApiKey":
            if err := json.Unmarshal([]byte(v), &strct.ApiKey); err != nil {
                return err
             }
            ApiKeyReceived = true
        case "ApiSecretKey":
            if err := json.Unmarshal([]byte(v), &strct.ApiSecretKey); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ApiKey (a required property) was received
    if !ApiKeyReceived {
        return errors.New("\"ApiKey\" is required but was not present")
    }
    return nil
}

func (strct *BasicAuthCredentials) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Password" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Password" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Password\": ")
	if tmp, err := json.Marshal(strct.Password); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Username" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Username" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Username\": ")
	if tmp, err := json.Marshal(strct.Username); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BasicAuthCredentials) UnmarshalJSON(b []byte) error {
    PasswordReceived := false
    UsernameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Password":
            if err := json.Unmarshal([]byte(v), &strct.Password); err != nil {
                return err
             }
            PasswordReceived = true
        case "Username":
            if err := json.Unmarshal([]byte(v), &strct.Username); err != nil {
                return err
             }
            UsernameReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Password (a required property) was received
    if !PasswordReceived {
        return errors.New("\"Password\" is required but was not present")
    }
    // check if Username (a required property) was received
    if !UsernameReceived {
        return errors.New("\"Username\" is required but was not present")
    }
    return nil
}

func (strct *CredentialsMap) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CredentialsMap) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *CustomAuthCredentials) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CredentialsMap" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CredentialsMap\": ")
	if tmp, err := json.Marshal(strct.CredentialsMap); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "CustomAuthenticationType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "CustomAuthenticationType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CustomAuthenticationType\": ")
	if tmp, err := json.Marshal(strct.CustomAuthenticationType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CustomAuthCredentials) UnmarshalJSON(b []byte) error {
    CustomAuthenticationTypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CredentialsMap":
            if err := json.Unmarshal([]byte(v), &strct.CredentialsMap); err != nil {
                return err
             }
        case "CustomAuthenticationType":
            if err := json.Unmarshal([]byte(v), &strct.CustomAuthenticationType); err != nil {
                return err
             }
            CustomAuthenticationTypeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if CustomAuthenticationType (a required property) was received
    if !CustomAuthenticationTypeReceived {
        return errors.New("\"CustomAuthenticationType\" is required but was not present")
    }
    return nil
}

func (strct *CustomConnectorProfileCredentials) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ApiKey" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ApiKey\": ")
	if tmp, err := json.Marshal(strct.ApiKey); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "AuthenticationType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AuthenticationType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AuthenticationType\": ")
	if tmp, err := json.Marshal(strct.AuthenticationType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Basic" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Basic\": ")
	if tmp, err := json.Marshal(strct.Basic); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Custom" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Custom\": ")
	if tmp, err := json.Marshal(strct.Custom); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Oauth2" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Oauth2\": ")
	if tmp, err := json.Marshal(strct.Oauth2); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CustomConnectorProfileCredentials) UnmarshalJSON(b []byte) error {
    AuthenticationTypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ApiKey":
            if err := json.Unmarshal([]byte(v), &strct.ApiKey); err != nil {
                return err
             }
        case "AuthenticationType":
            if err := json.Unmarshal([]byte(v), &strct.AuthenticationType); err != nil {
                return err
             }
            AuthenticationTypeReceived = true
        case "Basic":
            if err := json.Unmarshal([]byte(v), &strct.Basic); err != nil {
                return err
             }
        case "Custom":
            if err := json.Unmarshal([]byte(v), &strct.Custom); err != nil {
                return err
             }
        case "Oauth2":
            if err := json.Unmarshal([]byte(v), &strct.Oauth2); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if AuthenticationType (a required property) was received
    if !AuthenticationTypeReceived {
        return errors.New("\"AuthenticationType\" is required but was not present")
    }
    return nil
}

func (strct *CustomConnectorProfileProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "OAuth2Properties" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OAuth2Properties\": ")
	if tmp, err := json.Marshal(strct.OAuth2Properties); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ProfileProperties" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ProfileProperties\": ")
	if tmp, err := json.Marshal(strct.ProfileProperties); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CustomConnectorProfileProperties) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "OAuth2Properties":
            if err := json.Unmarshal([]byte(v), &strct.OAuth2Properties); err != nil {
                return err
             }
        case "ProfileProperties":
            if err := json.Unmarshal([]byte(v), &strct.ProfileProperties); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *DatadogConnectorProfileCredentials) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ApiKey" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ApiKey" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ApiKey\": ")
	if tmp, err := json.Marshal(strct.ApiKey); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ApplicationKey" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ApplicationKey" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ApplicationKey\": ")
	if tmp, err := json.Marshal(strct.ApplicationKey); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DatadogConnectorProfileCredentials) UnmarshalJSON(b []byte) error {
    ApiKeyReceived := false
    ApplicationKeyReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ApiKey":
            if err := json.Unmarshal([]byte(v), &strct.ApiKey); err != nil {
                return err
             }
            ApiKeyReceived = true
        case "ApplicationKey":
            if err := json.Unmarshal([]byte(v), &strct.ApplicationKey); err != nil {
                return err
             }
            ApplicationKeyReceived = true
        }
    }
    // check if ApiKey (a required property) was received
    if !ApiKeyReceived {
        return errors.New("\"ApiKey\" is required but was not present")
    }
    // check if ApplicationKey (a required property) was received
    if !ApplicationKeyReceived {
        return errors.New("\"ApplicationKey\" is required but was not present")
    }
    return nil
}

func (strct *DatadogConnectorProfileProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "InstanceUrl" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "InstanceUrl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InstanceUrl\": ")
	if tmp, err := json.Marshal(strct.InstanceUrl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DatadogConnectorProfileProperties) UnmarshalJSON(b []byte) error {
    InstanceUrlReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "InstanceUrl":
            if err := json.Unmarshal([]byte(v), &strct.InstanceUrl); err != nil {
                return err
             }
            InstanceUrlReceived = true
        }
    }
    // check if InstanceUrl (a required property) was received
    if !InstanceUrlReceived {
        return errors.New("\"InstanceUrl\" is required but was not present")
    }
    return nil
}

func (strct *DynatraceConnectorProfileCredentials) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ApiToken" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ApiToken" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ApiToken\": ")
	if tmp, err := json.Marshal(strct.ApiToken); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DynatraceConnectorProfileCredentials) UnmarshalJSON(b []byte) error {
    ApiTokenReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ApiToken":
            if err := json.Unmarshal([]byte(v), &strct.ApiToken); err != nil {
                return err
             }
            ApiTokenReceived = true
        }
    }
    // check if ApiToken (a required property) was received
    if !ApiTokenReceived {
        return errors.New("\"ApiToken\" is required but was not present")
    }
    return nil
}

func (strct *DynatraceConnectorProfileProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "InstanceUrl" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "InstanceUrl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InstanceUrl\": ")
	if tmp, err := json.Marshal(strct.InstanceUrl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DynatraceConnectorProfileProperties) UnmarshalJSON(b []byte) error {
    InstanceUrlReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "InstanceUrl":
            if err := json.Unmarshal([]byte(v), &strct.InstanceUrl); err != nil {
                return err
             }
            InstanceUrlReceived = true
        }
    }
    // check if InstanceUrl (a required property) was received
    if !InstanceUrlReceived {
        return errors.New("\"InstanceUrl\" is required but was not present")
    }
    return nil
}

func (strct *GoogleAnalyticsConnectorProfileCredentials) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AccessToken" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AccessToken\": ")
	if tmp, err := json.Marshal(strct.AccessToken); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ClientId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ClientId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ClientId\": ")
	if tmp, err := json.Marshal(strct.ClientId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ClientSecret" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ClientSecret" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ClientSecret\": ")
	if tmp, err := json.Marshal(strct.ClientSecret); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ConnectorOAuthRequest" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConnectorOAuthRequest\": ")
	if tmp, err := json.Marshal(strct.ConnectorOAuthRequest); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RefreshToken" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RefreshToken\": ")
	if tmp, err := json.Marshal(strct.RefreshToken); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *GoogleAnalyticsConnectorProfileCredentials) UnmarshalJSON(b []byte) error {
    ClientIdReceived := false
    ClientSecretReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AccessToken":
            if err := json.Unmarshal([]byte(v), &strct.AccessToken); err != nil {
                return err
             }
        case "ClientId":
            if err := json.Unmarshal([]byte(v), &strct.ClientId); err != nil {
                return err
             }
            ClientIdReceived = true
        case "ClientSecret":
            if err := json.Unmarshal([]byte(v), &strct.ClientSecret); err != nil {
                return err
             }
            ClientSecretReceived = true
        case "ConnectorOAuthRequest":
            if err := json.Unmarshal([]byte(v), &strct.ConnectorOAuthRequest); err != nil {
                return err
             }
        case "RefreshToken":
            if err := json.Unmarshal([]byte(v), &strct.RefreshToken); err != nil {
                return err
             }
        }
    }
    // check if ClientId (a required property) was received
    if !ClientIdReceived {
        return errors.New("\"ClientId\" is required but was not present")
    }
    // check if ClientSecret (a required property) was received
    if !ClientSecretReceived {
        return errors.New("\"ClientSecret\" is required but was not present")
    }
    return nil
}

func (strct *InforNexusConnectorProfileCredentials) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AccessKeyId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AccessKeyId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AccessKeyId\": ")
	if tmp, err := json.Marshal(strct.AccessKeyId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Datakey" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Datakey" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Datakey\": ")
	if tmp, err := json.Marshal(strct.Datakey); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "SecretAccessKey" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "SecretAccessKey" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SecretAccessKey\": ")
	if tmp, err := json.Marshal(strct.SecretAccessKey); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "UserId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "UserId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UserId\": ")
	if tmp, err := json.Marshal(strct.UserId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *InforNexusConnectorProfileCredentials) UnmarshalJSON(b []byte) error {
    AccessKeyIdReceived := false
    DatakeyReceived := false
    SecretAccessKeyReceived := false
    UserIdReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AccessKeyId":
            if err := json.Unmarshal([]byte(v), &strct.AccessKeyId); err != nil {
                return err
             }
            AccessKeyIdReceived = true
        case "Datakey":
            if err := json.Unmarshal([]byte(v), &strct.Datakey); err != nil {
                return err
             }
            DatakeyReceived = true
        case "SecretAccessKey":
            if err := json.Unmarshal([]byte(v), &strct.SecretAccessKey); err != nil {
                return err
             }
            SecretAccessKeyReceived = true
        case "UserId":
            if err := json.Unmarshal([]byte(v), &strct.UserId); err != nil {
                return err
             }
            UserIdReceived = true
        }
    }
    // check if AccessKeyId (a required property) was received
    if !AccessKeyIdReceived {
        return errors.New("\"AccessKeyId\" is required but was not present")
    }
    // check if Datakey (a required property) was received
    if !DatakeyReceived {
        return errors.New("\"Datakey\" is required but was not present")
    }
    // check if SecretAccessKey (a required property) was received
    if !SecretAccessKeyReceived {
        return errors.New("\"SecretAccessKey\" is required but was not present")
    }
    // check if UserId (a required property) was received
    if !UserIdReceived {
        return errors.New("\"UserId\" is required but was not present")
    }
    return nil
}

func (strct *InforNexusConnectorProfileProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "InstanceUrl" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "InstanceUrl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InstanceUrl\": ")
	if tmp, err := json.Marshal(strct.InstanceUrl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *InforNexusConnectorProfileProperties) UnmarshalJSON(b []byte) error {
    InstanceUrlReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "InstanceUrl":
            if err := json.Unmarshal([]byte(v), &strct.InstanceUrl); err != nil {
                return err
             }
            InstanceUrlReceived = true
        }
    }
    // check if InstanceUrl (a required property) was received
    if !InstanceUrlReceived {
        return errors.New("\"InstanceUrl\" is required but was not present")
    }
    return nil
}

func (strct *MarketoConnectorProfileCredentials) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AccessToken" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AccessToken\": ")
	if tmp, err := json.Marshal(strct.AccessToken); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ClientId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ClientId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ClientId\": ")
	if tmp, err := json.Marshal(strct.ClientId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ClientSecret" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ClientSecret" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ClientSecret\": ")
	if tmp, err := json.Marshal(strct.ClientSecret); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ConnectorOAuthRequest" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConnectorOAuthRequest\": ")
	if tmp, err := json.Marshal(strct.ConnectorOAuthRequest); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MarketoConnectorProfileCredentials) UnmarshalJSON(b []byte) error {
    ClientIdReceived := false
    ClientSecretReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AccessToken":
            if err := json.Unmarshal([]byte(v), &strct.AccessToken); err != nil {
                return err
             }
        case "ClientId":
            if err := json.Unmarshal([]byte(v), &strct.ClientId); err != nil {
                return err
             }
            ClientIdReceived = true
        case "ClientSecret":
            if err := json.Unmarshal([]byte(v), &strct.ClientSecret); err != nil {
                return err
             }
            ClientSecretReceived = true
        case "ConnectorOAuthRequest":
            if err := json.Unmarshal([]byte(v), &strct.ConnectorOAuthRequest); err != nil {
                return err
             }
        }
    }
    // check if ClientId (a required property) was received
    if !ClientIdReceived {
        return errors.New("\"ClientId\" is required but was not present")
    }
    // check if ClientSecret (a required property) was received
    if !ClientSecretReceived {
        return errors.New("\"ClientSecret\" is required but was not present")
    }
    return nil
}

func (strct *MarketoConnectorProfileProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "InstanceUrl" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "InstanceUrl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InstanceUrl\": ")
	if tmp, err := json.Marshal(strct.InstanceUrl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MarketoConnectorProfileProperties) UnmarshalJSON(b []byte) error {
    InstanceUrlReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "InstanceUrl":
            if err := json.Unmarshal([]byte(v), &strct.InstanceUrl); err != nil {
                return err
             }
            InstanceUrlReceived = true
        }
    }
    // check if InstanceUrl (a required property) was received
    if !InstanceUrlReceived {
        return errors.New("\"InstanceUrl\" is required but was not present")
    }
    return nil
}

func (strct *OAuth2Credentials) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AccessToken" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AccessToken\": ")
	if tmp, err := json.Marshal(strct.AccessToken); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ClientId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ClientId\": ")
	if tmp, err := json.Marshal(strct.ClientId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ClientSecret" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ClientSecret\": ")
	if tmp, err := json.Marshal(strct.ClientSecret); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OAuthRequest" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OAuthRequest\": ")
	if tmp, err := json.Marshal(strct.OAuthRequest); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RefreshToken" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RefreshToken\": ")
	if tmp, err := json.Marshal(strct.RefreshToken); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *OAuth2Credentials) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AccessToken":
            if err := json.Unmarshal([]byte(v), &strct.AccessToken); err != nil {
                return err
             }
        case "ClientId":
            if err := json.Unmarshal([]byte(v), &strct.ClientId); err != nil {
                return err
             }
        case "ClientSecret":
            if err := json.Unmarshal([]byte(v), &strct.ClientSecret); err != nil {
                return err
             }
        case "OAuthRequest":
            if err := json.Unmarshal([]byte(v), &strct.OAuthRequest); err != nil {
                return err
             }
        case "RefreshToken":
            if err := json.Unmarshal([]byte(v), &strct.RefreshToken); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *OAuth2Properties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "OAuth2GrantType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OAuth2GrantType\": ")
	if tmp, err := json.Marshal(strct.OAuth2GrantType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TokenUrl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TokenUrl\": ")
	if tmp, err := json.Marshal(strct.TokenUrl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TokenUrlCustomProperties" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TokenUrlCustomProperties\": ")
	if tmp, err := json.Marshal(strct.TokenUrlCustomProperties); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *OAuth2Properties) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "OAuth2GrantType":
            if err := json.Unmarshal([]byte(v), &strct.OAuth2GrantType); err != nil {
                return err
             }
        case "TokenUrl":
            if err := json.Unmarshal([]byte(v), &strct.TokenUrl); err != nil {
                return err
             }
        case "TokenUrlCustomProperties":
            if err := json.Unmarshal([]byte(v), &strct.TokenUrlCustomProperties); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *PardotConnectorProfileProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "BusinessUnitId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "BusinessUnitId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BusinessUnitId\": ")
	if tmp, err := json.Marshal(strct.BusinessUnitId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "InstanceUrl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InstanceUrl\": ")
	if tmp, err := json.Marshal(strct.InstanceUrl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IsSandboxEnvironment" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IsSandboxEnvironment\": ")
	if tmp, err := json.Marshal(strct.IsSandboxEnvironment); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PardotConnectorProfileProperties) UnmarshalJSON(b []byte) error {
    BusinessUnitIdReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BusinessUnitId":
            if err := json.Unmarshal([]byte(v), &strct.BusinessUnitId); err != nil {
                return err
             }
            BusinessUnitIdReceived = true
        case "InstanceUrl":
            if err := json.Unmarshal([]byte(v), &strct.InstanceUrl); err != nil {
                return err
             }
        case "IsSandboxEnvironment":
            if err := json.Unmarshal([]byte(v), &strct.IsSandboxEnvironment); err != nil {
                return err
             }
        }
    }
    // check if BusinessUnitId (a required property) was received
    if !BusinessUnitIdReceived {
        return errors.New("\"BusinessUnitId\" is required but was not present")
    }
    return nil
}

func (strct *ProfileProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ProfileProperties) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *RedshiftConnectorProfileProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "BucketName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "BucketName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BucketName\": ")
	if tmp, err := json.Marshal(strct.BucketName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BucketPrefix" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BucketPrefix\": ")
	if tmp, err := json.Marshal(strct.BucketPrefix); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ClusterIdentifier" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ClusterIdentifier\": ")
	if tmp, err := json.Marshal(strct.ClusterIdentifier); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DataApiRoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DataApiRoleArn\": ")
	if tmp, err := json.Marshal(strct.DataApiRoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DatabaseName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DatabaseName\": ")
	if tmp, err := json.Marshal(strct.DatabaseName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DatabaseUrl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DatabaseUrl\": ")
	if tmp, err := json.Marshal(strct.DatabaseUrl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IsRedshiftServerless" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IsRedshiftServerless\": ")
	if tmp, err := json.Marshal(strct.IsRedshiftServerless); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RoleArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoleArn\": ")
	if tmp, err := json.Marshal(strct.RoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "WorkgroupName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"WorkgroupName\": ")
	if tmp, err := json.Marshal(strct.WorkgroupName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RedshiftConnectorProfileProperties) UnmarshalJSON(b []byte) error {
    BucketNameReceived := false
    RoleArnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BucketName":
            if err := json.Unmarshal([]byte(v), &strct.BucketName); err != nil {
                return err
             }
            BucketNameReceived = true
        case "BucketPrefix":
            if err := json.Unmarshal([]byte(v), &strct.BucketPrefix); err != nil {
                return err
             }
        case "ClusterIdentifier":
            if err := json.Unmarshal([]byte(v), &strct.ClusterIdentifier); err != nil {
                return err
             }
        case "DataApiRoleArn":
            if err := json.Unmarshal([]byte(v), &strct.DataApiRoleArn); err != nil {
                return err
             }
        case "DatabaseName":
            if err := json.Unmarshal([]byte(v), &strct.DatabaseName); err != nil {
                return err
             }
        case "DatabaseUrl":
            if err := json.Unmarshal([]byte(v), &strct.DatabaseUrl); err != nil {
                return err
             }
        case "IsRedshiftServerless":
            if err := json.Unmarshal([]byte(v), &strct.IsRedshiftServerless); err != nil {
                return err
             }
        case "RoleArn":
            if err := json.Unmarshal([]byte(v), &strct.RoleArn); err != nil {
                return err
             }
            RoleArnReceived = true
        case "WorkgroupName":
            if err := json.Unmarshal([]byte(v), &strct.WorkgroupName); err != nil {
                return err
             }
        }
    }
    // check if BucketName (a required property) was received
    if !BucketNameReceived {
        return errors.New("\"BucketName\" is required but was not present")
    }
    // check if RoleArn (a required property) was received
    if !RoleArnReceived {
        return errors.New("\"RoleArn\" is required but was not present")
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ConnectionMode" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ConnectionMode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConnectionMode\": ")
	if tmp, err := json.Marshal(strct.ConnectionMode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ConnectorLabel" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConnectorLabel\": ")
	if tmp, err := json.Marshal(strct.ConnectorLabel); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ConnectorProfileArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConnectorProfileArn\": ")
	if tmp, err := json.Marshal(strct.ConnectorProfileArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ConnectorProfileConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConnectorProfileConfig\": ")
	if tmp, err := json.Marshal(strct.ConnectorProfileConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ConnectorProfileName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ConnectorProfileName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConnectorProfileName\": ")
	if tmp, err := json.Marshal(strct.ConnectorProfileName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ConnectorType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ConnectorType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConnectorType\": ")
	if tmp, err := json.Marshal(strct.ConnectorType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CredentialsArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CredentialsArn\": ")
	if tmp, err := json.Marshal(strct.CredentialsArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "KMSArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KMSArn\": ")
	if tmp, err := json.Marshal(strct.KMSArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    ConnectionModeReceived := false
    ConnectorProfileNameReceived := false
    ConnectorTypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ConnectionMode":
            if err := json.Unmarshal([]byte(v), &strct.ConnectionMode); err != nil {
                return err
             }
            ConnectionModeReceived = true
        case "ConnectorLabel":
            if err := json.Unmarshal([]byte(v), &strct.ConnectorLabel); err != nil {
                return err
             }
        case "ConnectorProfileArn":
            if err := json.Unmarshal([]byte(v), &strct.ConnectorProfileArn); err != nil {
                return err
             }
        case "ConnectorProfileConfig":
            if err := json.Unmarshal([]byte(v), &strct.ConnectorProfileConfig); err != nil {
                return err
             }
        case "ConnectorProfileName":
            if err := json.Unmarshal([]byte(v), &strct.ConnectorProfileName); err != nil {
                return err
             }
            ConnectorProfileNameReceived = true
        case "ConnectorType":
            if err := json.Unmarshal([]byte(v), &strct.ConnectorType); err != nil {
                return err
             }
            ConnectorTypeReceived = true
        case "CredentialsArn":
            if err := json.Unmarshal([]byte(v), &strct.CredentialsArn); err != nil {
                return err
             }
        case "KMSArn":
            if err := json.Unmarshal([]byte(v), &strct.KMSArn); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ConnectionMode (a required property) was received
    if !ConnectionModeReceived {
        return errors.New("\"ConnectionMode\" is required but was not present")
    }
    // check if ConnectorProfileName (a required property) was received
    if !ConnectorProfileNameReceived {
        return errors.New("\"ConnectorProfileName\" is required but was not present")
    }
    // check if ConnectorType (a required property) was received
    if !ConnectorTypeReceived {
        return errors.New("\"ConnectorType\" is required but was not present")
    }
    return nil
}

func (strct *ServiceNowConnectorProfileCredentials) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Password" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Password" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Password\": ")
	if tmp, err := json.Marshal(strct.Password); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Username" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Username" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Username\": ")
	if tmp, err := json.Marshal(strct.Username); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ServiceNowConnectorProfileCredentials) UnmarshalJSON(b []byte) error {
    PasswordReceived := false
    UsernameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Password":
            if err := json.Unmarshal([]byte(v), &strct.Password); err != nil {
                return err
             }
            PasswordReceived = true
        case "Username":
            if err := json.Unmarshal([]byte(v), &strct.Username); err != nil {
                return err
             }
            UsernameReceived = true
        }
    }
    // check if Password (a required property) was received
    if !PasswordReceived {
        return errors.New("\"Password\" is required but was not present")
    }
    // check if Username (a required property) was received
    if !UsernameReceived {
        return errors.New("\"Username\" is required but was not present")
    }
    return nil
}

func (strct *ServiceNowConnectorProfileProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "InstanceUrl" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "InstanceUrl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InstanceUrl\": ")
	if tmp, err := json.Marshal(strct.InstanceUrl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ServiceNowConnectorProfileProperties) UnmarshalJSON(b []byte) error {
    InstanceUrlReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "InstanceUrl":
            if err := json.Unmarshal([]byte(v), &strct.InstanceUrl); err != nil {
                return err
             }
            InstanceUrlReceived = true
        }
    }
    // check if InstanceUrl (a required property) was received
    if !InstanceUrlReceived {
        return errors.New("\"InstanceUrl\" is required but was not present")
    }
    return nil
}

func (strct *SingularConnectorProfileCredentials) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ApiKey" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ApiKey" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ApiKey\": ")
	if tmp, err := json.Marshal(strct.ApiKey); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SingularConnectorProfileCredentials) UnmarshalJSON(b []byte) error {
    ApiKeyReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ApiKey":
            if err := json.Unmarshal([]byte(v), &strct.ApiKey); err != nil {
                return err
             }
            ApiKeyReceived = true
        }
    }
    // check if ApiKey (a required property) was received
    if !ApiKeyReceived {
        return errors.New("\"ApiKey\" is required but was not present")
    }
    return nil
}

func (strct *SlackConnectorProfileCredentials) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AccessToken" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AccessToken\": ")
	if tmp, err := json.Marshal(strct.AccessToken); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ClientId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ClientId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ClientId\": ")
	if tmp, err := json.Marshal(strct.ClientId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ClientSecret" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ClientSecret" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ClientSecret\": ")
	if tmp, err := json.Marshal(strct.ClientSecret); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ConnectorOAuthRequest" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConnectorOAuthRequest\": ")
	if tmp, err := json.Marshal(strct.ConnectorOAuthRequest); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SlackConnectorProfileCredentials) UnmarshalJSON(b []byte) error {
    ClientIdReceived := false
    ClientSecretReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AccessToken":
            if err := json.Unmarshal([]byte(v), &strct.AccessToken); err != nil {
                return err
             }
        case "ClientId":
            if err := json.Unmarshal([]byte(v), &strct.ClientId); err != nil {
                return err
             }
            ClientIdReceived = true
        case "ClientSecret":
            if err := json.Unmarshal([]byte(v), &strct.ClientSecret); err != nil {
                return err
             }
            ClientSecretReceived = true
        case "ConnectorOAuthRequest":
            if err := json.Unmarshal([]byte(v), &strct.ConnectorOAuthRequest); err != nil {
                return err
             }
        }
    }
    // check if ClientId (a required property) was received
    if !ClientIdReceived {
        return errors.New("\"ClientId\" is required but was not present")
    }
    // check if ClientSecret (a required property) was received
    if !ClientSecretReceived {
        return errors.New("\"ClientSecret\" is required but was not present")
    }
    return nil
}

func (strct *SlackConnectorProfileProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "InstanceUrl" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "InstanceUrl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InstanceUrl\": ")
	if tmp, err := json.Marshal(strct.InstanceUrl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SlackConnectorProfileProperties) UnmarshalJSON(b []byte) error {
    InstanceUrlReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "InstanceUrl":
            if err := json.Unmarshal([]byte(v), &strct.InstanceUrl); err != nil {
                return err
             }
            InstanceUrlReceived = true
        }
    }
    // check if InstanceUrl (a required property) was received
    if !InstanceUrlReceived {
        return errors.New("\"InstanceUrl\" is required but was not present")
    }
    return nil
}

func (strct *SnowflakeConnectorProfileCredentials) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Password" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Password" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Password\": ")
	if tmp, err := json.Marshal(strct.Password); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Username" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Username" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Username\": ")
	if tmp, err := json.Marshal(strct.Username); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SnowflakeConnectorProfileCredentials) UnmarshalJSON(b []byte) error {
    PasswordReceived := false
    UsernameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Password":
            if err := json.Unmarshal([]byte(v), &strct.Password); err != nil {
                return err
             }
            PasswordReceived = true
        case "Username":
            if err := json.Unmarshal([]byte(v), &strct.Username); err != nil {
                return err
             }
            UsernameReceived = true
        }
    }
    // check if Password (a required property) was received
    if !PasswordReceived {
        return errors.New("\"Password\" is required but was not present")
    }
    // check if Username (a required property) was received
    if !UsernameReceived {
        return errors.New("\"Username\" is required but was not present")
    }
    return nil
}

func (strct *SnowflakeConnectorProfileProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AccountName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AccountName\": ")
	if tmp, err := json.Marshal(strct.AccountName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "BucketName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "BucketName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BucketName\": ")
	if tmp, err := json.Marshal(strct.BucketName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BucketPrefix" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BucketPrefix\": ")
	if tmp, err := json.Marshal(strct.BucketPrefix); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PrivateLinkServiceName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PrivateLinkServiceName\": ")
	if tmp, err := json.Marshal(strct.PrivateLinkServiceName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Region" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Region\": ")
	if tmp, err := json.Marshal(strct.Region); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Stage" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Stage" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Stage\": ")
	if tmp, err := json.Marshal(strct.Stage); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Warehouse" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Warehouse" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Warehouse\": ")
	if tmp, err := json.Marshal(strct.Warehouse); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SnowflakeConnectorProfileProperties) UnmarshalJSON(b []byte) error {
    BucketNameReceived := false
    StageReceived := false
    WarehouseReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AccountName":
            if err := json.Unmarshal([]byte(v), &strct.AccountName); err != nil {
                return err
             }
        case "BucketName":
            if err := json.Unmarshal([]byte(v), &strct.BucketName); err != nil {
                return err
             }
            BucketNameReceived = true
        case "BucketPrefix":
            if err := json.Unmarshal([]byte(v), &strct.BucketPrefix); err != nil {
                return err
             }
        case "PrivateLinkServiceName":
            if err := json.Unmarshal([]byte(v), &strct.PrivateLinkServiceName); err != nil {
                return err
             }
        case "Region":
            if err := json.Unmarshal([]byte(v), &strct.Region); err != nil {
                return err
             }
        case "Stage":
            if err := json.Unmarshal([]byte(v), &strct.Stage); err != nil {
                return err
             }
            StageReceived = true
        case "Warehouse":
            if err := json.Unmarshal([]byte(v), &strct.Warehouse); err != nil {
                return err
             }
            WarehouseReceived = true
        }
    }
    // check if BucketName (a required property) was received
    if !BucketNameReceived {
        return errors.New("\"BucketName\" is required but was not present")
    }
    // check if Stage (a required property) was received
    if !StageReceived {
        return errors.New("\"Stage\" is required but was not present")
    }
    // check if Warehouse (a required property) was received
    if !WarehouseReceived {
        return errors.New("\"Warehouse\" is required but was not present")
    }
    return nil
}

func (strct *TokenUrlCustomProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TokenUrlCustomProperties) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *TrendmicroConnectorProfileCredentials) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ApiSecretKey" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ApiSecretKey" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ApiSecretKey\": ")
	if tmp, err := json.Marshal(strct.ApiSecretKey); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TrendmicroConnectorProfileCredentials) UnmarshalJSON(b []byte) error {
    ApiSecretKeyReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ApiSecretKey":
            if err := json.Unmarshal([]byte(v), &strct.ApiSecretKey); err != nil {
                return err
             }
            ApiSecretKeyReceived = true
        }
    }
    // check if ApiSecretKey (a required property) was received
    if !ApiSecretKeyReceived {
        return errors.New("\"ApiSecretKey\" is required but was not present")
    }
    return nil
}

func (strct *VeevaConnectorProfileCredentials) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Password" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Password" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Password\": ")
	if tmp, err := json.Marshal(strct.Password); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Username" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Username" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Username\": ")
	if tmp, err := json.Marshal(strct.Username); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *VeevaConnectorProfileCredentials) UnmarshalJSON(b []byte) error {
    PasswordReceived := false
    UsernameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Password":
            if err := json.Unmarshal([]byte(v), &strct.Password); err != nil {
                return err
             }
            PasswordReceived = true
        case "Username":
            if err := json.Unmarshal([]byte(v), &strct.Username); err != nil {
                return err
             }
            UsernameReceived = true
        }
    }
    // check if Password (a required property) was received
    if !PasswordReceived {
        return errors.New("\"Password\" is required but was not present")
    }
    // check if Username (a required property) was received
    if !UsernameReceived {
        return errors.New("\"Username\" is required but was not present")
    }
    return nil
}

func (strct *VeevaConnectorProfileProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "InstanceUrl" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "InstanceUrl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InstanceUrl\": ")
	if tmp, err := json.Marshal(strct.InstanceUrl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *VeevaConnectorProfileProperties) UnmarshalJSON(b []byte) error {
    InstanceUrlReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "InstanceUrl":
            if err := json.Unmarshal([]byte(v), &strct.InstanceUrl); err != nil {
                return err
             }
            InstanceUrlReceived = true
        }
    }
    // check if InstanceUrl (a required property) was received
    if !InstanceUrlReceived {
        return errors.New("\"InstanceUrl\" is required but was not present")
    }
    return nil
}

func (strct *ZendeskConnectorProfileCredentials) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AccessToken" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AccessToken\": ")
	if tmp, err := json.Marshal(strct.AccessToken); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ClientId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ClientId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ClientId\": ")
	if tmp, err := json.Marshal(strct.ClientId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ClientSecret" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ClientSecret" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ClientSecret\": ")
	if tmp, err := json.Marshal(strct.ClientSecret); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ConnectorOAuthRequest" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConnectorOAuthRequest\": ")
	if tmp, err := json.Marshal(strct.ConnectorOAuthRequest); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ZendeskConnectorProfileCredentials) UnmarshalJSON(b []byte) error {
    ClientIdReceived := false
    ClientSecretReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AccessToken":
            if err := json.Unmarshal([]byte(v), &strct.AccessToken); err != nil {
                return err
             }
        case "ClientId":
            if err := json.Unmarshal([]byte(v), &strct.ClientId); err != nil {
                return err
             }
            ClientIdReceived = true
        case "ClientSecret":
            if err := json.Unmarshal([]byte(v), &strct.ClientSecret); err != nil {
                return err
             }
            ClientSecretReceived = true
        case "ConnectorOAuthRequest":
            if err := json.Unmarshal([]byte(v), &strct.ConnectorOAuthRequest); err != nil {
                return err
             }
        }
    }
    // check if ClientId (a required property) was received
    if !ClientIdReceived {
        return errors.New("\"ClientId\" is required but was not present")
    }
    // check if ClientSecret (a required property) was received
    if !ClientSecretReceived {
        return errors.New("\"ClientSecret\" is required but was not present")
    }
    return nil
}

func (strct *ZendeskConnectorProfileProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "InstanceUrl" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "InstanceUrl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InstanceUrl\": ")
	if tmp, err := json.Marshal(strct.InstanceUrl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ZendeskConnectorProfileProperties) UnmarshalJSON(b []byte) error {
    InstanceUrlReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "InstanceUrl":
            if err := json.Unmarshal([]byte(v), &strct.InstanceUrl); err != nil {
                return err
             }
            InstanceUrlReceived = true
        }
    }
    // check if InstanceUrl (a required property) was received
    if !InstanceUrlReceived {
        return errors.New("\"InstanceUrl\" is required but was not present")
    }
    return nil
}
