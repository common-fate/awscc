// Code generated by schema-generate. DO NOT EDIT.

package flow

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// AggregationConfig 
type AggregationConfig struct {
  AggregationType string `json:"AggregationType,omitempty"`
  TargetFileSize int `json:"TargetFileSize,omitempty"`
}

// AmplitudeSourceProperties 
type AmplitudeSourceProperties struct {
  Object string `json:"Object"`
}

// ConnectorOperator Operation to be performed on provided source fields
type ConnectorOperator struct {
  Amplitude string `json:"Amplitude,omitempty"`
  CustomConnector string `json:"CustomConnector,omitempty"`
  Datadog string `json:"Datadog,omitempty"`
  Dynatrace string `json:"Dynatrace,omitempty"`
  GoogleAnalytics string `json:"GoogleAnalytics,omitempty"`
  InforNexus string `json:"InforNexus,omitempty"`
  Marketo string `json:"Marketo,omitempty"`
  Pardot string `json:"Pardot,omitempty"`
  S3 string `json:"S3,omitempty"`
  SAPOData string `json:"SAPOData,omitempty"`
  Salesforce string `json:"Salesforce,omitempty"`
  ServiceNow string `json:"ServiceNow,omitempty"`
  Singular string `json:"Singular,omitempty"`
  Slack string `json:"Slack,omitempty"`
  Trendmicro string `json:"Trendmicro,omitempty"`
  Veeva string `json:"Veeva,omitempty"`
  Zendesk string `json:"Zendesk,omitempty"`
}

// CustomConnectorDestinationProperties 
type CustomConnectorDestinationProperties struct {
  CustomProperties *CustomProperties `json:"CustomProperties,omitempty"`
  EntityName string `json:"EntityName"`
  ErrorHandlingConfig *ErrorHandlingConfig `json:"ErrorHandlingConfig,omitempty"`

  // List of fields used as ID when performing a write operation.
  IdFieldNames []string `json:"IdFieldNames,omitempty"`
  WriteOperationType string `json:"WriteOperationType,omitempty"`
}

// CustomConnectorSourceProperties 
type CustomConnectorSourceProperties struct {
  CustomProperties *CustomProperties `json:"CustomProperties,omitempty"`
  EntityName string `json:"EntityName"`
}

// CustomProperties A map for properties for custom connector.
type CustomProperties struct {
}

// DatadogSourceProperties 
type DatadogSourceProperties struct {
  Object string `json:"Object"`
}

// DestinationConnectorProperties Destination connector details
type DestinationConnectorProperties struct {
  CustomConnector *CustomConnectorDestinationProperties `json:"CustomConnector,omitempty"`
  EventBridge *EventBridgeDestinationProperties `json:"EventBridge,omitempty"`
  LookoutMetrics *LookoutMetricsDestinationProperties `json:"LookoutMetrics,omitempty"`
  Marketo *MarketoDestinationProperties `json:"Marketo,omitempty"`
  Redshift *RedshiftDestinationProperties `json:"Redshift,omitempty"`
  S3 *S3DestinationProperties `json:"S3,omitempty"`
  SAPOData *SAPODataDestinationProperties `json:"SAPOData,omitempty"`
  Salesforce *SalesforceDestinationProperties `json:"Salesforce,omitempty"`
  Snowflake *SnowflakeDestinationProperties `json:"Snowflake,omitempty"`
  Upsolver *UpsolverDestinationProperties `json:"Upsolver,omitempty"`
  Zendesk *ZendeskDestinationProperties `json:"Zendesk,omitempty"`
}

// DestinationFlowConfig Configurations of destination connector.
type DestinationFlowConfig struct {

  // The API version that the destination connector uses.
  ApiVersion string `json:"ApiVersion,omitempty"`

  // Name of destination connector profile
  ConnectorProfileName string `json:"ConnectorProfileName,omitempty"`

  // Destination connector type
  ConnectorType string `json:"ConnectorType"`

  // Destination connector details
  DestinationConnectorProperties *DestinationConnectorProperties `json:"DestinationConnectorProperties"`
}

// DynatraceSourceProperties 
type DynatraceSourceProperties struct {
  Object string `json:"Object"`
}

// ErrorHandlingConfig 
type ErrorHandlingConfig struct {
  BucketName string `json:"BucketName,omitempty"`
  BucketPrefix string `json:"BucketPrefix,omitempty"`
  FailOnFirstError bool `json:"FailOnFirstError,omitempty"`
}

// EventBridgeDestinationProperties 
type EventBridgeDestinationProperties struct {
  ErrorHandlingConfig *ErrorHandlingConfig `json:"ErrorHandlingConfig,omitempty"`
  Object string `json:"Object"`
}

// GlueDataCatalog Trigger settings of the flow.
type GlueDataCatalog struct {

  // A string containing the value for the tag
  DatabaseName string `json:"DatabaseName"`

  // A string containing the value for the tag
  RoleArn string `json:"RoleArn"`

  // A string containing the value for the tag
  TablePrefix string `json:"TablePrefix"`
}

// GoogleAnalyticsSourceProperties 
type GoogleAnalyticsSourceProperties struct {
  Object string `json:"Object"`
}

// IncrementalPullConfig Configuration for scheduled incremental data pull
type IncrementalPullConfig struct {
  DatetimeTypeFieldName string `json:"DatetimeTypeFieldName,omitempty"`
}

// InforNexusSourceProperties 
type InforNexusSourceProperties struct {
  Object string `json:"Object"`
}

// LookoutMetricsDestinationProperties 
type LookoutMetricsDestinationProperties struct {
  Object string `json:"Object,omitempty"`
}

// MarketoDestinationProperties 
type MarketoDestinationProperties struct {
  ErrorHandlingConfig *ErrorHandlingConfig `json:"ErrorHandlingConfig,omitempty"`
  Object string `json:"Object"`
}

// MarketoSourceProperties 
type MarketoSourceProperties struct {
  Object string `json:"Object"`
}

// MetadataCatalogConfig Configurations of metadata catalog of the flow.
type MetadataCatalogConfig struct {

  // Configurations of glue data catalog of the flow.
  GlueDataCatalog *GlueDataCatalog `json:"GlueDataCatalog,omitempty"`
}

// PardotSourceProperties 
type PardotSourceProperties struct {
  Object string `json:"Object"`
}

// PrefixConfig 
type PrefixConfig struct {
  PathPrefixHierarchy []string `json:"PathPrefixHierarchy,omitempty"`
  PrefixFormat string `json:"PrefixFormat,omitempty"`
  PrefixType string `json:"PrefixType,omitempty"`
}

// RedshiftDestinationProperties 
type RedshiftDestinationProperties struct {
  BucketPrefix string `json:"BucketPrefix,omitempty"`
  ErrorHandlingConfig *ErrorHandlingConfig `json:"ErrorHandlingConfig,omitempty"`
  IntermediateBucketName string `json:"IntermediateBucketName"`
  Object string `json:"Object"`
}

// Resource Resource schema for AWS::AppFlow::Flow.
type Resource struct {

  // Description of the flow.
  Description string `json:"Description,omitempty"`

  // List of Destination connectors of the flow.
  DestinationFlowConfigList []*DestinationFlowConfig `json:"DestinationFlowConfigList"`

  // ARN identifier of the flow.
  FlowArn string `json:"FlowArn,omitempty"`

  // Name of the flow.
  FlowName string `json:"FlowName"`

  // The ARN of the AWS Key Management Service (AWS KMS) key that's used to encrypt your function's environment variables. If it's not provided, AWS Lambda uses a default service key.
  KMSArn string `json:"KMSArn,omitempty"`

  // Configurations of metadata catalog of the flow.
  MetadataCatalogConfig *MetadataCatalogConfig `json:"MetadataCatalogConfig,omitempty"`

  // Configurations of Source connector of the flow.
  SourceFlowConfig *SourceFlowConfig `json:"SourceFlowConfig"`

  // List of Tags.
  Tags []*Tag `json:"Tags,omitempty"`

  // List of tasks for the flow.
  Tasks []*Task `json:"Tasks"`

  // Trigger settings of the flow.
  TriggerConfig *TriggerConfig `json:"TriggerConfig"`
}

// S3DestinationProperties 
type S3DestinationProperties struct {
  BucketName string `json:"BucketName"`
  BucketPrefix string `json:"BucketPrefix,omitempty"`
  S3OutputFormatConfig *S3OutputFormatConfig `json:"S3OutputFormatConfig,omitempty"`
}

// S3InputFormatConfig 
type S3InputFormatConfig struct {
  S3InputFileType string `json:"S3InputFileType,omitempty"`
}

// S3OutputFormatConfig 
type S3OutputFormatConfig struct {
  AggregationConfig *AggregationConfig `json:"AggregationConfig,omitempty"`
  FileType string `json:"FileType,omitempty"`
  PrefixConfig *PrefixConfig `json:"PrefixConfig,omitempty"`
  PreserveSourceDataTyping bool `json:"PreserveSourceDataTyping,omitempty"`
}

// S3SourceProperties 
type S3SourceProperties struct {
  BucketName string `json:"BucketName"`
  BucketPrefix string `json:"BucketPrefix"`
  S3InputFormatConfig *S3InputFormatConfig `json:"S3InputFormatConfig,omitempty"`
}

// SAPODataDestinationProperties 
type SAPODataDestinationProperties struct {
  ErrorHandlingConfig *ErrorHandlingConfig `json:"ErrorHandlingConfig,omitempty"`

  // List of fields used as ID when performing a write operation.
  IdFieldNames []string `json:"IdFieldNames,omitempty"`
  ObjectPath string `json:"ObjectPath"`
  SuccessResponseHandlingConfig *SuccessResponseHandlingConfig `json:"SuccessResponseHandlingConfig,omitempty"`
  WriteOperationType string `json:"WriteOperationType,omitempty"`
}

// SAPODataSourceProperties 
type SAPODataSourceProperties struct {
  ObjectPath string `json:"ObjectPath"`
}

// SalesforceDestinationProperties 
type SalesforceDestinationProperties struct {
  DataTransferApi string `json:"DataTransferApi,omitempty"`
  ErrorHandlingConfig *ErrorHandlingConfig `json:"ErrorHandlingConfig,omitempty"`

  // List of fields used as ID when performing a write operation.
  IdFieldNames []string `json:"IdFieldNames,omitempty"`
  Object string `json:"Object"`
  WriteOperationType string `json:"WriteOperationType,omitempty"`
}

// SalesforceSourceProperties 
type SalesforceSourceProperties struct {
  DataTransferApi string `json:"DataTransferApi,omitempty"`
  EnableDynamicFieldUpdate bool `json:"EnableDynamicFieldUpdate,omitempty"`
  IncludeDeletedRecords bool `json:"IncludeDeletedRecords,omitempty"`
  Object string `json:"Object"`
}

// ScheduledTriggerProperties Details required for scheduled trigger type
type ScheduledTriggerProperties struct {
  DataPullMode string `json:"DataPullMode,omitempty"`
  FirstExecutionFrom float64 `json:"FirstExecutionFrom,omitempty"`
  FlowErrorDeactivationThreshold int `json:"FlowErrorDeactivationThreshold,omitempty"`
  ScheduleEndTime float64 `json:"ScheduleEndTime,omitempty"`
  ScheduleExpression string `json:"ScheduleExpression"`
  ScheduleOffset float64 `json:"ScheduleOffset,omitempty"`
  ScheduleStartTime float64 `json:"ScheduleStartTime,omitempty"`
  TimeZone string `json:"TimeZone,omitempty"`
}

// ServiceNowSourceProperties 
type ServiceNowSourceProperties struct {
  Object string `json:"Object"`
}

// SingularSourceProperties 
type SingularSourceProperties struct {
  Object string `json:"Object"`
}

// SlackSourceProperties 
type SlackSourceProperties struct {
  Object string `json:"Object"`
}

// SnowflakeDestinationProperties 
type SnowflakeDestinationProperties struct {
  BucketPrefix string `json:"BucketPrefix,omitempty"`
  ErrorHandlingConfig *ErrorHandlingConfig `json:"ErrorHandlingConfig,omitempty"`
  IntermediateBucketName string `json:"IntermediateBucketName"`
  Object string `json:"Object"`
}

// SourceConnectorProperties Source connector details required to query a connector
type SourceConnectorProperties struct {
  Amplitude *AmplitudeSourceProperties `json:"Amplitude,omitempty"`
  CustomConnector *CustomConnectorSourceProperties `json:"CustomConnector,omitempty"`
  Datadog *DatadogSourceProperties `json:"Datadog,omitempty"`
  Dynatrace *DynatraceSourceProperties `json:"Dynatrace,omitempty"`
  GoogleAnalytics *GoogleAnalyticsSourceProperties `json:"GoogleAnalytics,omitempty"`
  InforNexus *InforNexusSourceProperties `json:"InforNexus,omitempty"`
  Marketo *MarketoSourceProperties `json:"Marketo,omitempty"`
  Pardot *PardotSourceProperties `json:"Pardot,omitempty"`
  S3 *S3SourceProperties `json:"S3,omitempty"`
  SAPOData *SAPODataSourceProperties `json:"SAPOData,omitempty"`
  Salesforce *SalesforceSourceProperties `json:"Salesforce,omitempty"`
  ServiceNow *ServiceNowSourceProperties `json:"ServiceNow,omitempty"`
  Singular *SingularSourceProperties `json:"Singular,omitempty"`
  Slack *SlackSourceProperties `json:"Slack,omitempty"`
  Trendmicro *TrendmicroSourceProperties `json:"Trendmicro,omitempty"`
  Veeva *VeevaSourceProperties `json:"Veeva,omitempty"`
  Zendesk *ZendeskSourceProperties `json:"Zendesk,omitempty"`
}

// SourceFlowConfig Configurations of Source connector of the flow.
type SourceFlowConfig struct {

  // The API version that the destination connector uses.
  ApiVersion string `json:"ApiVersion,omitempty"`

  // Name of source connector profile
  ConnectorProfileName string `json:"ConnectorProfileName,omitempty"`

  // Type of source connector
  ConnectorType string `json:"ConnectorType"`

  // Configuration for scheduled incremental data pull
  IncrementalPullConfig *IncrementalPullConfig `json:"IncrementalPullConfig,omitempty"`

  // Source connector details required to query a connector
  SourceConnectorProperties *SourceConnectorProperties `json:"SourceConnectorProperties"`
}

// SuccessResponseHandlingConfig 
type SuccessResponseHandlingConfig struct {
  BucketName string `json:"BucketName,omitempty"`
  BucketPrefix string `json:"BucketPrefix,omitempty"`
}

// Tag A label for tagging AppFlow resources
type Tag struct {

  // A string used to identify this tag
  Key string `json:"Key"`

  // A string containing the value for the tag
  Value string `json:"Value"`
}

// Task 
type Task struct {

  // Operation to be performed on provided source fields
  ConnectorOperator *ConnectorOperator `json:"ConnectorOperator,omitempty"`

  // A field value on which source field should be validated
  DestinationField string `json:"DestinationField,omitempty"`

  // Source fields on which particular task will be applied
  SourceFields []string `json:"SourceFields"`

  // A Map used to store task related info
  TaskProperties []*TaskPropertiesObject `json:"TaskProperties,omitempty"`

  // Type of task
  TaskType string `json:"TaskType"`
}

// TaskPropertiesObject An object used to store task related info
type TaskPropertiesObject struct {
  Key string `json:"Key"`
  Value string `json:"Value"`
}

// TrendmicroSourceProperties 
type TrendmicroSourceProperties struct {
  Object string `json:"Object"`
}

// TriggerConfig Trigger settings of the flow.
type TriggerConfig struct {

  // Details required based on the type of trigger
  TriggerProperties *ScheduledTriggerProperties `json:"TriggerProperties,omitempty"`

  // Trigger type of the flow
  TriggerType string `json:"TriggerType"`
}

// UpsolverDestinationProperties 
type UpsolverDestinationProperties struct {
  BucketName string `json:"BucketName"`
  BucketPrefix string `json:"BucketPrefix,omitempty"`
  S3OutputFormatConfig *UpsolverS3OutputFormatConfig `json:"S3OutputFormatConfig"`
}

// UpsolverS3OutputFormatConfig 
type UpsolverS3OutputFormatConfig struct {
  AggregationConfig *AggregationConfig `json:"AggregationConfig,omitempty"`
  FileType string `json:"FileType,omitempty"`
  PrefixConfig *PrefixConfig `json:"PrefixConfig"`
}

// VeevaSourceProperties 
type VeevaSourceProperties struct {
  DocumentType string `json:"DocumentType,omitempty"`
  IncludeAllVersions bool `json:"IncludeAllVersions,omitempty"`
  IncludeRenditions bool `json:"IncludeRenditions,omitempty"`
  IncludeSourceFiles bool `json:"IncludeSourceFiles,omitempty"`
  Object string `json:"Object"`
}

// ZendeskDestinationProperties 
type ZendeskDestinationProperties struct {
  ErrorHandlingConfig *ErrorHandlingConfig `json:"ErrorHandlingConfig,omitempty"`

  // List of fields used as ID when performing a write operation.
  IdFieldNames []string `json:"IdFieldNames,omitempty"`
  Object string `json:"Object"`
  WriteOperationType string `json:"WriteOperationType,omitempty"`
}

// ZendeskSourceProperties 
type ZendeskSourceProperties struct {
  Object string `json:"Object"`
}

func (strct *AmplitudeSourceProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Object" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Object" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Object\": ")
	if tmp, err := json.Marshal(strct.Object); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AmplitudeSourceProperties) UnmarshalJSON(b []byte) error {
    ObjectReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Object":
            if err := json.Unmarshal([]byte(v), &strct.Object); err != nil {
                return err
             }
            ObjectReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Object (a required property) was received
    if !ObjectReceived {
        return errors.New("\"Object\" is required but was not present")
    }
    return nil
}

func (strct *CustomConnectorDestinationProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CustomProperties" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CustomProperties\": ")
	if tmp, err := json.Marshal(strct.CustomProperties); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "EntityName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "EntityName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EntityName\": ")
	if tmp, err := json.Marshal(strct.EntityName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ErrorHandlingConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ErrorHandlingConfig\": ")
	if tmp, err := json.Marshal(strct.ErrorHandlingConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IdFieldNames" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IdFieldNames\": ")
	if tmp, err := json.Marshal(strct.IdFieldNames); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "WriteOperationType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"WriteOperationType\": ")
	if tmp, err := json.Marshal(strct.WriteOperationType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CustomConnectorDestinationProperties) UnmarshalJSON(b []byte) error {
    EntityNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CustomProperties":
            if err := json.Unmarshal([]byte(v), &strct.CustomProperties); err != nil {
                return err
             }
        case "EntityName":
            if err := json.Unmarshal([]byte(v), &strct.EntityName); err != nil {
                return err
             }
            EntityNameReceived = true
        case "ErrorHandlingConfig":
            if err := json.Unmarshal([]byte(v), &strct.ErrorHandlingConfig); err != nil {
                return err
             }
        case "IdFieldNames":
            if err := json.Unmarshal([]byte(v), &strct.IdFieldNames); err != nil {
                return err
             }
        case "WriteOperationType":
            if err := json.Unmarshal([]byte(v), &strct.WriteOperationType); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if EntityName (a required property) was received
    if !EntityNameReceived {
        return errors.New("\"EntityName\" is required but was not present")
    }
    return nil
}

func (strct *CustomConnectorSourceProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CustomProperties" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CustomProperties\": ")
	if tmp, err := json.Marshal(strct.CustomProperties); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "EntityName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "EntityName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EntityName\": ")
	if tmp, err := json.Marshal(strct.EntityName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CustomConnectorSourceProperties) UnmarshalJSON(b []byte) error {
    EntityNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CustomProperties":
            if err := json.Unmarshal([]byte(v), &strct.CustomProperties); err != nil {
                return err
             }
        case "EntityName":
            if err := json.Unmarshal([]byte(v), &strct.EntityName); err != nil {
                return err
             }
            EntityNameReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if EntityName (a required property) was received
    if !EntityNameReceived {
        return errors.New("\"EntityName\" is required but was not present")
    }
    return nil
}

func (strct *CustomProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CustomProperties) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *DatadogSourceProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Object" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Object" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Object\": ")
	if tmp, err := json.Marshal(strct.Object); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DatadogSourceProperties) UnmarshalJSON(b []byte) error {
    ObjectReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Object":
            if err := json.Unmarshal([]byte(v), &strct.Object); err != nil {
                return err
             }
            ObjectReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Object (a required property) was received
    if !ObjectReceived {
        return errors.New("\"Object\" is required but was not present")
    }
    return nil
}

func (strct *DestinationFlowConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ApiVersion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ApiVersion\": ")
	if tmp, err := json.Marshal(strct.ApiVersion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ConnectorProfileName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConnectorProfileName\": ")
	if tmp, err := json.Marshal(strct.ConnectorProfileName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ConnectorType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ConnectorType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConnectorType\": ")
	if tmp, err := json.Marshal(strct.ConnectorType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "DestinationConnectorProperties" field is required
    if strct.DestinationConnectorProperties == nil {
        return nil, errors.New("DestinationConnectorProperties is a required field")
    }
    // Marshal the "DestinationConnectorProperties" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DestinationConnectorProperties\": ")
	if tmp, err := json.Marshal(strct.DestinationConnectorProperties); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DestinationFlowConfig) UnmarshalJSON(b []byte) error {
    ConnectorTypeReceived := false
    DestinationConnectorPropertiesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ApiVersion":
            if err := json.Unmarshal([]byte(v), &strct.ApiVersion); err != nil {
                return err
             }
        case "ConnectorProfileName":
            if err := json.Unmarshal([]byte(v), &strct.ConnectorProfileName); err != nil {
                return err
             }
        case "ConnectorType":
            if err := json.Unmarshal([]byte(v), &strct.ConnectorType); err != nil {
                return err
             }
            ConnectorTypeReceived = true
        case "DestinationConnectorProperties":
            if err := json.Unmarshal([]byte(v), &strct.DestinationConnectorProperties); err != nil {
                return err
             }
            DestinationConnectorPropertiesReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ConnectorType (a required property) was received
    if !ConnectorTypeReceived {
        return errors.New("\"ConnectorType\" is required but was not present")
    }
    // check if DestinationConnectorProperties (a required property) was received
    if !DestinationConnectorPropertiesReceived {
        return errors.New("\"DestinationConnectorProperties\" is required but was not present")
    }
    return nil
}

func (strct *DynatraceSourceProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Object" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Object" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Object\": ")
	if tmp, err := json.Marshal(strct.Object); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DynatraceSourceProperties) UnmarshalJSON(b []byte) error {
    ObjectReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Object":
            if err := json.Unmarshal([]byte(v), &strct.Object); err != nil {
                return err
             }
            ObjectReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Object (a required property) was received
    if !ObjectReceived {
        return errors.New("\"Object\" is required but was not present")
    }
    return nil
}

func (strct *ErrorHandlingConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "BucketName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BucketName\": ")
	if tmp, err := json.Marshal(strct.BucketName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BucketPrefix" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BucketPrefix\": ")
	if tmp, err := json.Marshal(strct.BucketPrefix); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FailOnFirstError" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FailOnFirstError\": ")
	if tmp, err := json.Marshal(strct.FailOnFirstError); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ErrorHandlingConfig) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BucketName":
            if err := json.Unmarshal([]byte(v), &strct.BucketName); err != nil {
                return err
             }
        case "BucketPrefix":
            if err := json.Unmarshal([]byte(v), &strct.BucketPrefix); err != nil {
                return err
             }
        case "FailOnFirstError":
            if err := json.Unmarshal([]byte(v), &strct.FailOnFirstError); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *EventBridgeDestinationProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ErrorHandlingConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ErrorHandlingConfig\": ")
	if tmp, err := json.Marshal(strct.ErrorHandlingConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Object" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Object" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Object\": ")
	if tmp, err := json.Marshal(strct.Object); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *EventBridgeDestinationProperties) UnmarshalJSON(b []byte) error {
    ObjectReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ErrorHandlingConfig":
            if err := json.Unmarshal([]byte(v), &strct.ErrorHandlingConfig); err != nil {
                return err
             }
        case "Object":
            if err := json.Unmarshal([]byte(v), &strct.Object); err != nil {
                return err
             }
            ObjectReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Object (a required property) was received
    if !ObjectReceived {
        return errors.New("\"Object\" is required but was not present")
    }
    return nil
}

func (strct *GlueDataCatalog) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "DatabaseName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "DatabaseName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DatabaseName\": ")
	if tmp, err := json.Marshal(strct.DatabaseName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RoleArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoleArn\": ")
	if tmp, err := json.Marshal(strct.RoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TablePrefix" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TablePrefix" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TablePrefix\": ")
	if tmp, err := json.Marshal(strct.TablePrefix); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *GlueDataCatalog) UnmarshalJSON(b []byte) error {
    DatabaseNameReceived := false
    RoleArnReceived := false
    TablePrefixReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DatabaseName":
            if err := json.Unmarshal([]byte(v), &strct.DatabaseName); err != nil {
                return err
             }
            DatabaseNameReceived = true
        case "RoleArn":
            if err := json.Unmarshal([]byte(v), &strct.RoleArn); err != nil {
                return err
             }
            RoleArnReceived = true
        case "TablePrefix":
            if err := json.Unmarshal([]byte(v), &strct.TablePrefix); err != nil {
                return err
             }
            TablePrefixReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if DatabaseName (a required property) was received
    if !DatabaseNameReceived {
        return errors.New("\"DatabaseName\" is required but was not present")
    }
    // check if RoleArn (a required property) was received
    if !RoleArnReceived {
        return errors.New("\"RoleArn\" is required but was not present")
    }
    // check if TablePrefix (a required property) was received
    if !TablePrefixReceived {
        return errors.New("\"TablePrefix\" is required but was not present")
    }
    return nil
}

func (strct *GoogleAnalyticsSourceProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Object" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Object" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Object\": ")
	if tmp, err := json.Marshal(strct.Object); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *GoogleAnalyticsSourceProperties) UnmarshalJSON(b []byte) error {
    ObjectReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Object":
            if err := json.Unmarshal([]byte(v), &strct.Object); err != nil {
                return err
             }
            ObjectReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Object (a required property) was received
    if !ObjectReceived {
        return errors.New("\"Object\" is required but was not present")
    }
    return nil
}

func (strct *InforNexusSourceProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Object" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Object" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Object\": ")
	if tmp, err := json.Marshal(strct.Object); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *InforNexusSourceProperties) UnmarshalJSON(b []byte) error {
    ObjectReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Object":
            if err := json.Unmarshal([]byte(v), &strct.Object); err != nil {
                return err
             }
            ObjectReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Object (a required property) was received
    if !ObjectReceived {
        return errors.New("\"Object\" is required but was not present")
    }
    return nil
}

func (strct *LookoutMetricsDestinationProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Object" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Object\": ")
	if tmp, err := json.Marshal(strct.Object); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LookoutMetricsDestinationProperties) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Object":
            if err := json.Unmarshal([]byte(v), &strct.Object); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *MarketoDestinationProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ErrorHandlingConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ErrorHandlingConfig\": ")
	if tmp, err := json.Marshal(strct.ErrorHandlingConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Object" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Object" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Object\": ")
	if tmp, err := json.Marshal(strct.Object); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MarketoDestinationProperties) UnmarshalJSON(b []byte) error {
    ObjectReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ErrorHandlingConfig":
            if err := json.Unmarshal([]byte(v), &strct.ErrorHandlingConfig); err != nil {
                return err
             }
        case "Object":
            if err := json.Unmarshal([]byte(v), &strct.Object); err != nil {
                return err
             }
            ObjectReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Object (a required property) was received
    if !ObjectReceived {
        return errors.New("\"Object\" is required but was not present")
    }
    return nil
}

func (strct *MarketoSourceProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Object" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Object" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Object\": ")
	if tmp, err := json.Marshal(strct.Object); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MarketoSourceProperties) UnmarshalJSON(b []byte) error {
    ObjectReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Object":
            if err := json.Unmarshal([]byte(v), &strct.Object); err != nil {
                return err
             }
            ObjectReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Object (a required property) was received
    if !ObjectReceived {
        return errors.New("\"Object\" is required but was not present")
    }
    return nil
}

func (strct *MetadataCatalogConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "GlueDataCatalog" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"GlueDataCatalog\": ")
	if tmp, err := json.Marshal(strct.GlueDataCatalog); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MetadataCatalogConfig) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "GlueDataCatalog":
            if err := json.Unmarshal([]byte(v), &strct.GlueDataCatalog); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *PardotSourceProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Object" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Object" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Object\": ")
	if tmp, err := json.Marshal(strct.Object); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PardotSourceProperties) UnmarshalJSON(b []byte) error {
    ObjectReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Object":
            if err := json.Unmarshal([]byte(v), &strct.Object); err != nil {
                return err
             }
            ObjectReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Object (a required property) was received
    if !ObjectReceived {
        return errors.New("\"Object\" is required but was not present")
    }
    return nil
}

func (strct *PrefixConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "PathPrefixHierarchy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PathPrefixHierarchy\": ")
	if tmp, err := json.Marshal(strct.PathPrefixHierarchy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PrefixFormat" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PrefixFormat\": ")
	if tmp, err := json.Marshal(strct.PrefixFormat); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PrefixType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PrefixType\": ")
	if tmp, err := json.Marshal(strct.PrefixType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PrefixConfig) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "PathPrefixHierarchy":
            if err := json.Unmarshal([]byte(v), &strct.PathPrefixHierarchy); err != nil {
                return err
             }
        case "PrefixFormat":
            if err := json.Unmarshal([]byte(v), &strct.PrefixFormat); err != nil {
                return err
             }
        case "PrefixType":
            if err := json.Unmarshal([]byte(v), &strct.PrefixType); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *RedshiftDestinationProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "BucketPrefix" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BucketPrefix\": ")
	if tmp, err := json.Marshal(strct.BucketPrefix); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ErrorHandlingConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ErrorHandlingConfig\": ")
	if tmp, err := json.Marshal(strct.ErrorHandlingConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "IntermediateBucketName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "IntermediateBucketName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IntermediateBucketName\": ")
	if tmp, err := json.Marshal(strct.IntermediateBucketName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Object" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Object" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Object\": ")
	if tmp, err := json.Marshal(strct.Object); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RedshiftDestinationProperties) UnmarshalJSON(b []byte) error {
    IntermediateBucketNameReceived := false
    ObjectReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BucketPrefix":
            if err := json.Unmarshal([]byte(v), &strct.BucketPrefix); err != nil {
                return err
             }
        case "ErrorHandlingConfig":
            if err := json.Unmarshal([]byte(v), &strct.ErrorHandlingConfig); err != nil {
                return err
             }
        case "IntermediateBucketName":
            if err := json.Unmarshal([]byte(v), &strct.IntermediateBucketName); err != nil {
                return err
             }
            IntermediateBucketNameReceived = true
        case "Object":
            if err := json.Unmarshal([]byte(v), &strct.Object); err != nil {
                return err
             }
            ObjectReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if IntermediateBucketName (a required property) was received
    if !IntermediateBucketNameReceived {
        return errors.New("\"IntermediateBucketName\" is required but was not present")
    }
    // check if Object (a required property) was received
    if !ObjectReceived {
        return errors.New("\"Object\" is required but was not present")
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "DestinationFlowConfigList" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "DestinationFlowConfigList" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DestinationFlowConfigList\": ")
	if tmp, err := json.Marshal(strct.DestinationFlowConfigList); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FlowArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FlowArn\": ")
	if tmp, err := json.Marshal(strct.FlowArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "FlowName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "FlowName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FlowName\": ")
	if tmp, err := json.Marshal(strct.FlowName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "KMSArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KMSArn\": ")
	if tmp, err := json.Marshal(strct.KMSArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MetadataCatalogConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MetadataCatalogConfig\": ")
	if tmp, err := json.Marshal(strct.MetadataCatalogConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "SourceFlowConfig" field is required
    if strct.SourceFlowConfig == nil {
        return nil, errors.New("SourceFlowConfig is a required field")
    }
    // Marshal the "SourceFlowConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SourceFlowConfig\": ")
	if tmp, err := json.Marshal(strct.SourceFlowConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Tasks" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Tasks" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tasks\": ")
	if tmp, err := json.Marshal(strct.Tasks); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TriggerConfig" field is required
    if strct.TriggerConfig == nil {
        return nil, errors.New("TriggerConfig is a required field")
    }
    // Marshal the "TriggerConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TriggerConfig\": ")
	if tmp, err := json.Marshal(strct.TriggerConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    DestinationFlowConfigListReceived := false
    FlowNameReceived := false
    SourceFlowConfigReceived := false
    TasksReceived := false
    TriggerConfigReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "DestinationFlowConfigList":
            if err := json.Unmarshal([]byte(v), &strct.DestinationFlowConfigList); err != nil {
                return err
             }
            DestinationFlowConfigListReceived = true
        case "FlowArn":
            if err := json.Unmarshal([]byte(v), &strct.FlowArn); err != nil {
                return err
             }
        case "FlowName":
            if err := json.Unmarshal([]byte(v), &strct.FlowName); err != nil {
                return err
             }
            FlowNameReceived = true
        case "KMSArn":
            if err := json.Unmarshal([]byte(v), &strct.KMSArn); err != nil {
                return err
             }
        case "MetadataCatalogConfig":
            if err := json.Unmarshal([]byte(v), &strct.MetadataCatalogConfig); err != nil {
                return err
             }
        case "SourceFlowConfig":
            if err := json.Unmarshal([]byte(v), &strct.SourceFlowConfig); err != nil {
                return err
             }
            SourceFlowConfigReceived = true
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        case "Tasks":
            if err := json.Unmarshal([]byte(v), &strct.Tasks); err != nil {
                return err
             }
            TasksReceived = true
        case "TriggerConfig":
            if err := json.Unmarshal([]byte(v), &strct.TriggerConfig); err != nil {
                return err
             }
            TriggerConfigReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if DestinationFlowConfigList (a required property) was received
    if !DestinationFlowConfigListReceived {
        return errors.New("\"DestinationFlowConfigList\" is required but was not present")
    }
    // check if FlowName (a required property) was received
    if !FlowNameReceived {
        return errors.New("\"FlowName\" is required but was not present")
    }
    // check if SourceFlowConfig (a required property) was received
    if !SourceFlowConfigReceived {
        return errors.New("\"SourceFlowConfig\" is required but was not present")
    }
    // check if Tasks (a required property) was received
    if !TasksReceived {
        return errors.New("\"Tasks\" is required but was not present")
    }
    // check if TriggerConfig (a required property) was received
    if !TriggerConfigReceived {
        return errors.New("\"TriggerConfig\" is required but was not present")
    }
    return nil
}

func (strct *S3DestinationProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "BucketName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "BucketName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BucketName\": ")
	if tmp, err := json.Marshal(strct.BucketName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BucketPrefix" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BucketPrefix\": ")
	if tmp, err := json.Marshal(strct.BucketPrefix); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "S3OutputFormatConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3OutputFormatConfig\": ")
	if tmp, err := json.Marshal(strct.S3OutputFormatConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *S3DestinationProperties) UnmarshalJSON(b []byte) error {
    BucketNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BucketName":
            if err := json.Unmarshal([]byte(v), &strct.BucketName); err != nil {
                return err
             }
            BucketNameReceived = true
        case "BucketPrefix":
            if err := json.Unmarshal([]byte(v), &strct.BucketPrefix); err != nil {
                return err
             }
        case "S3OutputFormatConfig":
            if err := json.Unmarshal([]byte(v), &strct.S3OutputFormatConfig); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if BucketName (a required property) was received
    if !BucketNameReceived {
        return errors.New("\"BucketName\" is required but was not present")
    }
    return nil
}

func (strct *S3OutputFormatConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AggregationConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AggregationConfig\": ")
	if tmp, err := json.Marshal(strct.AggregationConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FileType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FileType\": ")
	if tmp, err := json.Marshal(strct.FileType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PrefixConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PrefixConfig\": ")
	if tmp, err := json.Marshal(strct.PrefixConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PreserveSourceDataTyping" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PreserveSourceDataTyping\": ")
	if tmp, err := json.Marshal(strct.PreserveSourceDataTyping); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *S3OutputFormatConfig) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AggregationConfig":
            if err := json.Unmarshal([]byte(v), &strct.AggregationConfig); err != nil {
                return err
             }
        case "FileType":
            if err := json.Unmarshal([]byte(v), &strct.FileType); err != nil {
                return err
             }
        case "PrefixConfig":
            if err := json.Unmarshal([]byte(v), &strct.PrefixConfig); err != nil {
                return err
             }
        case "PreserveSourceDataTyping":
            if err := json.Unmarshal([]byte(v), &strct.PreserveSourceDataTyping); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *S3SourceProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "BucketName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "BucketName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BucketName\": ")
	if tmp, err := json.Marshal(strct.BucketName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "BucketPrefix" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "BucketPrefix" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BucketPrefix\": ")
	if tmp, err := json.Marshal(strct.BucketPrefix); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "S3InputFormatConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3InputFormatConfig\": ")
	if tmp, err := json.Marshal(strct.S3InputFormatConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *S3SourceProperties) UnmarshalJSON(b []byte) error {
    BucketNameReceived := false
    BucketPrefixReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BucketName":
            if err := json.Unmarshal([]byte(v), &strct.BucketName); err != nil {
                return err
             }
            BucketNameReceived = true
        case "BucketPrefix":
            if err := json.Unmarshal([]byte(v), &strct.BucketPrefix); err != nil {
                return err
             }
            BucketPrefixReceived = true
        case "S3InputFormatConfig":
            if err := json.Unmarshal([]byte(v), &strct.S3InputFormatConfig); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if BucketName (a required property) was received
    if !BucketNameReceived {
        return errors.New("\"BucketName\" is required but was not present")
    }
    // check if BucketPrefix (a required property) was received
    if !BucketPrefixReceived {
        return errors.New("\"BucketPrefix\" is required but was not present")
    }
    return nil
}

func (strct *SAPODataDestinationProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ErrorHandlingConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ErrorHandlingConfig\": ")
	if tmp, err := json.Marshal(strct.ErrorHandlingConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IdFieldNames" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IdFieldNames\": ")
	if tmp, err := json.Marshal(strct.IdFieldNames); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ObjectPath" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ObjectPath" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ObjectPath\": ")
	if tmp, err := json.Marshal(strct.ObjectPath); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SuccessResponseHandlingConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SuccessResponseHandlingConfig\": ")
	if tmp, err := json.Marshal(strct.SuccessResponseHandlingConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "WriteOperationType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"WriteOperationType\": ")
	if tmp, err := json.Marshal(strct.WriteOperationType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SAPODataDestinationProperties) UnmarshalJSON(b []byte) error {
    ObjectPathReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ErrorHandlingConfig":
            if err := json.Unmarshal([]byte(v), &strct.ErrorHandlingConfig); err != nil {
                return err
             }
        case "IdFieldNames":
            if err := json.Unmarshal([]byte(v), &strct.IdFieldNames); err != nil {
                return err
             }
        case "ObjectPath":
            if err := json.Unmarshal([]byte(v), &strct.ObjectPath); err != nil {
                return err
             }
            ObjectPathReceived = true
        case "SuccessResponseHandlingConfig":
            if err := json.Unmarshal([]byte(v), &strct.SuccessResponseHandlingConfig); err != nil {
                return err
             }
        case "WriteOperationType":
            if err := json.Unmarshal([]byte(v), &strct.WriteOperationType); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ObjectPath (a required property) was received
    if !ObjectPathReceived {
        return errors.New("\"ObjectPath\" is required but was not present")
    }
    return nil
}

func (strct *SAPODataSourceProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ObjectPath" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ObjectPath" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ObjectPath\": ")
	if tmp, err := json.Marshal(strct.ObjectPath); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SAPODataSourceProperties) UnmarshalJSON(b []byte) error {
    ObjectPathReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ObjectPath":
            if err := json.Unmarshal([]byte(v), &strct.ObjectPath); err != nil {
                return err
             }
            ObjectPathReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ObjectPath (a required property) was received
    if !ObjectPathReceived {
        return errors.New("\"ObjectPath\" is required but was not present")
    }
    return nil
}

func (strct *SalesforceDestinationProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DataTransferApi" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DataTransferApi\": ")
	if tmp, err := json.Marshal(strct.DataTransferApi); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ErrorHandlingConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ErrorHandlingConfig\": ")
	if tmp, err := json.Marshal(strct.ErrorHandlingConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IdFieldNames" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IdFieldNames\": ")
	if tmp, err := json.Marshal(strct.IdFieldNames); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Object" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Object" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Object\": ")
	if tmp, err := json.Marshal(strct.Object); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "WriteOperationType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"WriteOperationType\": ")
	if tmp, err := json.Marshal(strct.WriteOperationType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SalesforceDestinationProperties) UnmarshalJSON(b []byte) error {
    ObjectReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DataTransferApi":
            if err := json.Unmarshal([]byte(v), &strct.DataTransferApi); err != nil {
                return err
             }
        case "ErrorHandlingConfig":
            if err := json.Unmarshal([]byte(v), &strct.ErrorHandlingConfig); err != nil {
                return err
             }
        case "IdFieldNames":
            if err := json.Unmarshal([]byte(v), &strct.IdFieldNames); err != nil {
                return err
             }
        case "Object":
            if err := json.Unmarshal([]byte(v), &strct.Object); err != nil {
                return err
             }
            ObjectReceived = true
        case "WriteOperationType":
            if err := json.Unmarshal([]byte(v), &strct.WriteOperationType); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Object (a required property) was received
    if !ObjectReceived {
        return errors.New("\"Object\" is required but was not present")
    }
    return nil
}

func (strct *SalesforceSourceProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DataTransferApi" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DataTransferApi\": ")
	if tmp, err := json.Marshal(strct.DataTransferApi); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EnableDynamicFieldUpdate" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EnableDynamicFieldUpdate\": ")
	if tmp, err := json.Marshal(strct.EnableDynamicFieldUpdate); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IncludeDeletedRecords" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IncludeDeletedRecords\": ")
	if tmp, err := json.Marshal(strct.IncludeDeletedRecords); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Object" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Object" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Object\": ")
	if tmp, err := json.Marshal(strct.Object); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SalesforceSourceProperties) UnmarshalJSON(b []byte) error {
    ObjectReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DataTransferApi":
            if err := json.Unmarshal([]byte(v), &strct.DataTransferApi); err != nil {
                return err
             }
        case "EnableDynamicFieldUpdate":
            if err := json.Unmarshal([]byte(v), &strct.EnableDynamicFieldUpdate); err != nil {
                return err
             }
        case "IncludeDeletedRecords":
            if err := json.Unmarshal([]byte(v), &strct.IncludeDeletedRecords); err != nil {
                return err
             }
        case "Object":
            if err := json.Unmarshal([]byte(v), &strct.Object); err != nil {
                return err
             }
            ObjectReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Object (a required property) was received
    if !ObjectReceived {
        return errors.New("\"Object\" is required but was not present")
    }
    return nil
}

func (strct *ScheduledTriggerProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DataPullMode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DataPullMode\": ")
	if tmp, err := json.Marshal(strct.DataPullMode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FirstExecutionFrom" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FirstExecutionFrom\": ")
	if tmp, err := json.Marshal(strct.FirstExecutionFrom); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FlowErrorDeactivationThreshold" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FlowErrorDeactivationThreshold\": ")
	if tmp, err := json.Marshal(strct.FlowErrorDeactivationThreshold); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ScheduleEndTime" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ScheduleEndTime\": ")
	if tmp, err := json.Marshal(strct.ScheduleEndTime); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ScheduleExpression" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ScheduleExpression" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ScheduleExpression\": ")
	if tmp, err := json.Marshal(strct.ScheduleExpression); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ScheduleOffset" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ScheduleOffset\": ")
	if tmp, err := json.Marshal(strct.ScheduleOffset); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ScheduleStartTime" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ScheduleStartTime\": ")
	if tmp, err := json.Marshal(strct.ScheduleStartTime); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TimeZone" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TimeZone\": ")
	if tmp, err := json.Marshal(strct.TimeZone); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ScheduledTriggerProperties) UnmarshalJSON(b []byte) error {
    ScheduleExpressionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DataPullMode":
            if err := json.Unmarshal([]byte(v), &strct.DataPullMode); err != nil {
                return err
             }
        case "FirstExecutionFrom":
            if err := json.Unmarshal([]byte(v), &strct.FirstExecutionFrom); err != nil {
                return err
             }
        case "FlowErrorDeactivationThreshold":
            if err := json.Unmarshal([]byte(v), &strct.FlowErrorDeactivationThreshold); err != nil {
                return err
             }
        case "ScheduleEndTime":
            if err := json.Unmarshal([]byte(v), &strct.ScheduleEndTime); err != nil {
                return err
             }
        case "ScheduleExpression":
            if err := json.Unmarshal([]byte(v), &strct.ScheduleExpression); err != nil {
                return err
             }
            ScheduleExpressionReceived = true
        case "ScheduleOffset":
            if err := json.Unmarshal([]byte(v), &strct.ScheduleOffset); err != nil {
                return err
             }
        case "ScheduleStartTime":
            if err := json.Unmarshal([]byte(v), &strct.ScheduleStartTime); err != nil {
                return err
             }
        case "TimeZone":
            if err := json.Unmarshal([]byte(v), &strct.TimeZone); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ScheduleExpression (a required property) was received
    if !ScheduleExpressionReceived {
        return errors.New("\"ScheduleExpression\" is required but was not present")
    }
    return nil
}

func (strct *ServiceNowSourceProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Object" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Object" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Object\": ")
	if tmp, err := json.Marshal(strct.Object); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ServiceNowSourceProperties) UnmarshalJSON(b []byte) error {
    ObjectReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Object":
            if err := json.Unmarshal([]byte(v), &strct.Object); err != nil {
                return err
             }
            ObjectReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Object (a required property) was received
    if !ObjectReceived {
        return errors.New("\"Object\" is required but was not present")
    }
    return nil
}

func (strct *SingularSourceProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Object" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Object" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Object\": ")
	if tmp, err := json.Marshal(strct.Object); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SingularSourceProperties) UnmarshalJSON(b []byte) error {
    ObjectReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Object":
            if err := json.Unmarshal([]byte(v), &strct.Object); err != nil {
                return err
             }
            ObjectReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Object (a required property) was received
    if !ObjectReceived {
        return errors.New("\"Object\" is required but was not present")
    }
    return nil
}

func (strct *SlackSourceProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Object" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Object" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Object\": ")
	if tmp, err := json.Marshal(strct.Object); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SlackSourceProperties) UnmarshalJSON(b []byte) error {
    ObjectReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Object":
            if err := json.Unmarshal([]byte(v), &strct.Object); err != nil {
                return err
             }
            ObjectReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Object (a required property) was received
    if !ObjectReceived {
        return errors.New("\"Object\" is required but was not present")
    }
    return nil
}

func (strct *SnowflakeDestinationProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "BucketPrefix" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BucketPrefix\": ")
	if tmp, err := json.Marshal(strct.BucketPrefix); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ErrorHandlingConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ErrorHandlingConfig\": ")
	if tmp, err := json.Marshal(strct.ErrorHandlingConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "IntermediateBucketName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "IntermediateBucketName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IntermediateBucketName\": ")
	if tmp, err := json.Marshal(strct.IntermediateBucketName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Object" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Object" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Object\": ")
	if tmp, err := json.Marshal(strct.Object); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SnowflakeDestinationProperties) UnmarshalJSON(b []byte) error {
    IntermediateBucketNameReceived := false
    ObjectReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BucketPrefix":
            if err := json.Unmarshal([]byte(v), &strct.BucketPrefix); err != nil {
                return err
             }
        case "ErrorHandlingConfig":
            if err := json.Unmarshal([]byte(v), &strct.ErrorHandlingConfig); err != nil {
                return err
             }
        case "IntermediateBucketName":
            if err := json.Unmarshal([]byte(v), &strct.IntermediateBucketName); err != nil {
                return err
             }
            IntermediateBucketNameReceived = true
        case "Object":
            if err := json.Unmarshal([]byte(v), &strct.Object); err != nil {
                return err
             }
            ObjectReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if IntermediateBucketName (a required property) was received
    if !IntermediateBucketNameReceived {
        return errors.New("\"IntermediateBucketName\" is required but was not present")
    }
    // check if Object (a required property) was received
    if !ObjectReceived {
        return errors.New("\"Object\" is required but was not present")
    }
    return nil
}

func (strct *SourceFlowConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ApiVersion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ApiVersion\": ")
	if tmp, err := json.Marshal(strct.ApiVersion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ConnectorProfileName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConnectorProfileName\": ")
	if tmp, err := json.Marshal(strct.ConnectorProfileName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ConnectorType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ConnectorType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConnectorType\": ")
	if tmp, err := json.Marshal(strct.ConnectorType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IncrementalPullConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IncrementalPullConfig\": ")
	if tmp, err := json.Marshal(strct.IncrementalPullConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "SourceConnectorProperties" field is required
    if strct.SourceConnectorProperties == nil {
        return nil, errors.New("SourceConnectorProperties is a required field")
    }
    // Marshal the "SourceConnectorProperties" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SourceConnectorProperties\": ")
	if tmp, err := json.Marshal(strct.SourceConnectorProperties); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SourceFlowConfig) UnmarshalJSON(b []byte) error {
    ConnectorTypeReceived := false
    SourceConnectorPropertiesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ApiVersion":
            if err := json.Unmarshal([]byte(v), &strct.ApiVersion); err != nil {
                return err
             }
        case "ConnectorProfileName":
            if err := json.Unmarshal([]byte(v), &strct.ConnectorProfileName); err != nil {
                return err
             }
        case "ConnectorType":
            if err := json.Unmarshal([]byte(v), &strct.ConnectorType); err != nil {
                return err
             }
            ConnectorTypeReceived = true
        case "IncrementalPullConfig":
            if err := json.Unmarshal([]byte(v), &strct.IncrementalPullConfig); err != nil {
                return err
             }
        case "SourceConnectorProperties":
            if err := json.Unmarshal([]byte(v), &strct.SourceConnectorProperties); err != nil {
                return err
             }
            SourceConnectorPropertiesReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ConnectorType (a required property) was received
    if !ConnectorTypeReceived {
        return errors.New("\"ConnectorType\" is required but was not present")
    }
    // check if SourceConnectorProperties (a required property) was received
    if !SourceConnectorPropertiesReceived {
        return errors.New("\"SourceConnectorProperties\" is required but was not present")
    }
    return nil
}

func (strct *SuccessResponseHandlingConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "BucketName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BucketName\": ")
	if tmp, err := json.Marshal(strct.BucketName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BucketPrefix" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BucketPrefix\": ")
	if tmp, err := json.Marshal(strct.BucketPrefix); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SuccessResponseHandlingConfig) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BucketName":
            if err := json.Unmarshal([]byte(v), &strct.BucketName); err != nil {
                return err
             }
        case "BucketPrefix":
            if err := json.Unmarshal([]byte(v), &strct.BucketPrefix); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *Task) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ConnectorOperator" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConnectorOperator\": ")
	if tmp, err := json.Marshal(strct.ConnectorOperator); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DestinationField" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DestinationField\": ")
	if tmp, err := json.Marshal(strct.DestinationField); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "SourceFields" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "SourceFields" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SourceFields\": ")
	if tmp, err := json.Marshal(strct.SourceFields); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TaskProperties" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TaskProperties\": ")
	if tmp, err := json.Marshal(strct.TaskProperties); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TaskType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TaskType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TaskType\": ")
	if tmp, err := json.Marshal(strct.TaskType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Task) UnmarshalJSON(b []byte) error {
    SourceFieldsReceived := false
    TaskTypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ConnectorOperator":
            if err := json.Unmarshal([]byte(v), &strct.ConnectorOperator); err != nil {
                return err
             }
        case "DestinationField":
            if err := json.Unmarshal([]byte(v), &strct.DestinationField); err != nil {
                return err
             }
        case "SourceFields":
            if err := json.Unmarshal([]byte(v), &strct.SourceFields); err != nil {
                return err
             }
            SourceFieldsReceived = true
        case "TaskProperties":
            if err := json.Unmarshal([]byte(v), &strct.TaskProperties); err != nil {
                return err
             }
        case "TaskType":
            if err := json.Unmarshal([]byte(v), &strct.TaskType); err != nil {
                return err
             }
            TaskTypeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if SourceFields (a required property) was received
    if !SourceFieldsReceived {
        return errors.New("\"SourceFields\" is required but was not present")
    }
    // check if TaskType (a required property) was received
    if !TaskTypeReceived {
        return errors.New("\"TaskType\" is required but was not present")
    }
    return nil
}

func (strct *TaskPropertiesObject) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TaskPropertiesObject) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *TrendmicroSourceProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Object" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Object" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Object\": ")
	if tmp, err := json.Marshal(strct.Object); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TrendmicroSourceProperties) UnmarshalJSON(b []byte) error {
    ObjectReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Object":
            if err := json.Unmarshal([]byte(v), &strct.Object); err != nil {
                return err
             }
            ObjectReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Object (a required property) was received
    if !ObjectReceived {
        return errors.New("\"Object\" is required but was not present")
    }
    return nil
}

func (strct *TriggerConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "TriggerProperties" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TriggerProperties\": ")
	if tmp, err := json.Marshal(strct.TriggerProperties); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TriggerType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TriggerType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TriggerType\": ")
	if tmp, err := json.Marshal(strct.TriggerType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TriggerConfig) UnmarshalJSON(b []byte) error {
    TriggerTypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "TriggerProperties":
            if err := json.Unmarshal([]byte(v), &strct.TriggerProperties); err != nil {
                return err
             }
        case "TriggerType":
            if err := json.Unmarshal([]byte(v), &strct.TriggerType); err != nil {
                return err
             }
            TriggerTypeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if TriggerType (a required property) was received
    if !TriggerTypeReceived {
        return errors.New("\"TriggerType\" is required but was not present")
    }
    return nil
}

func (strct *UpsolverDestinationProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "BucketName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "BucketName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BucketName\": ")
	if tmp, err := json.Marshal(strct.BucketName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BucketPrefix" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BucketPrefix\": ")
	if tmp, err := json.Marshal(strct.BucketPrefix); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "S3OutputFormatConfig" field is required
    if strct.S3OutputFormatConfig == nil {
        return nil, errors.New("S3OutputFormatConfig is a required field")
    }
    // Marshal the "S3OutputFormatConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3OutputFormatConfig\": ")
	if tmp, err := json.Marshal(strct.S3OutputFormatConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *UpsolverDestinationProperties) UnmarshalJSON(b []byte) error {
    BucketNameReceived := false
    S3OutputFormatConfigReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BucketName":
            if err := json.Unmarshal([]byte(v), &strct.BucketName); err != nil {
                return err
             }
            BucketNameReceived = true
        case "BucketPrefix":
            if err := json.Unmarshal([]byte(v), &strct.BucketPrefix); err != nil {
                return err
             }
        case "S3OutputFormatConfig":
            if err := json.Unmarshal([]byte(v), &strct.S3OutputFormatConfig); err != nil {
                return err
             }
            S3OutputFormatConfigReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if BucketName (a required property) was received
    if !BucketNameReceived {
        return errors.New("\"BucketName\" is required but was not present")
    }
    // check if S3OutputFormatConfig (a required property) was received
    if !S3OutputFormatConfigReceived {
        return errors.New("\"S3OutputFormatConfig\" is required but was not present")
    }
    return nil
}

func (strct *UpsolverS3OutputFormatConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AggregationConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AggregationConfig\": ")
	if tmp, err := json.Marshal(strct.AggregationConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FileType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FileType\": ")
	if tmp, err := json.Marshal(strct.FileType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "PrefixConfig" field is required
    if strct.PrefixConfig == nil {
        return nil, errors.New("PrefixConfig is a required field")
    }
    // Marshal the "PrefixConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PrefixConfig\": ")
	if tmp, err := json.Marshal(strct.PrefixConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *UpsolverS3OutputFormatConfig) UnmarshalJSON(b []byte) error {
    PrefixConfigReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AggregationConfig":
            if err := json.Unmarshal([]byte(v), &strct.AggregationConfig); err != nil {
                return err
             }
        case "FileType":
            if err := json.Unmarshal([]byte(v), &strct.FileType); err != nil {
                return err
             }
        case "PrefixConfig":
            if err := json.Unmarshal([]byte(v), &strct.PrefixConfig); err != nil {
                return err
             }
            PrefixConfigReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if PrefixConfig (a required property) was received
    if !PrefixConfigReceived {
        return errors.New("\"PrefixConfig\" is required but was not present")
    }
    return nil
}

func (strct *VeevaSourceProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DocumentType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DocumentType\": ")
	if tmp, err := json.Marshal(strct.DocumentType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IncludeAllVersions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IncludeAllVersions\": ")
	if tmp, err := json.Marshal(strct.IncludeAllVersions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IncludeRenditions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IncludeRenditions\": ")
	if tmp, err := json.Marshal(strct.IncludeRenditions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IncludeSourceFiles" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IncludeSourceFiles\": ")
	if tmp, err := json.Marshal(strct.IncludeSourceFiles); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Object" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Object" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Object\": ")
	if tmp, err := json.Marshal(strct.Object); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *VeevaSourceProperties) UnmarshalJSON(b []byte) error {
    ObjectReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DocumentType":
            if err := json.Unmarshal([]byte(v), &strct.DocumentType); err != nil {
                return err
             }
        case "IncludeAllVersions":
            if err := json.Unmarshal([]byte(v), &strct.IncludeAllVersions); err != nil {
                return err
             }
        case "IncludeRenditions":
            if err := json.Unmarshal([]byte(v), &strct.IncludeRenditions); err != nil {
                return err
             }
        case "IncludeSourceFiles":
            if err := json.Unmarshal([]byte(v), &strct.IncludeSourceFiles); err != nil {
                return err
             }
        case "Object":
            if err := json.Unmarshal([]byte(v), &strct.Object); err != nil {
                return err
             }
            ObjectReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Object (a required property) was received
    if !ObjectReceived {
        return errors.New("\"Object\" is required but was not present")
    }
    return nil
}

func (strct *ZendeskDestinationProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ErrorHandlingConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ErrorHandlingConfig\": ")
	if tmp, err := json.Marshal(strct.ErrorHandlingConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IdFieldNames" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IdFieldNames\": ")
	if tmp, err := json.Marshal(strct.IdFieldNames); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Object" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Object" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Object\": ")
	if tmp, err := json.Marshal(strct.Object); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "WriteOperationType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"WriteOperationType\": ")
	if tmp, err := json.Marshal(strct.WriteOperationType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ZendeskDestinationProperties) UnmarshalJSON(b []byte) error {
    ObjectReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ErrorHandlingConfig":
            if err := json.Unmarshal([]byte(v), &strct.ErrorHandlingConfig); err != nil {
                return err
             }
        case "IdFieldNames":
            if err := json.Unmarshal([]byte(v), &strct.IdFieldNames); err != nil {
                return err
             }
        case "Object":
            if err := json.Unmarshal([]byte(v), &strct.Object); err != nil {
                return err
             }
            ObjectReceived = true
        case "WriteOperationType":
            if err := json.Unmarshal([]byte(v), &strct.WriteOperationType); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Object (a required property) was received
    if !ObjectReceived {
        return errors.New("\"Object\" is required but was not present")
    }
    return nil
}

func (strct *ZendeskSourceProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Object" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Object" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Object\": ")
	if tmp, err := json.Marshal(strct.Object); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ZendeskSourceProperties) UnmarshalJSON(b []byte) error {
    ObjectReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Object":
            if err := json.Unmarshal([]byte(v), &strct.Object); err != nil {
                return err
             }
            ObjectReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Object (a required property) was received
    if !ObjectReceived {
        return errors.New("\"Object\" is required but was not present")
    }
    return nil
}
