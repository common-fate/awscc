// Code generated by schema-generate. DO NOT EDIT.

package connector

import (
    "encoding/json"
    "fmt"
    "bytes"
    "errors"
)

// ApacheKafkaCluster Details of how to connect to an Apache Kafka cluster.
type ApacheKafkaCluster struct {

  // The bootstrap servers string of the Apache Kafka cluster.
  BootstrapServers string `json:"BootstrapServers"`
  Vpc *Vpc `json:"Vpc"`
}

// AutoScaling Details about auto scaling of a connector. 
type AutoScaling struct {

  // The maximum number of workers for a connector.
  MaxWorkerCount int `json:"MaxWorkerCount"`

  // Specifies how many MSK Connect Units (MCU) as the minimum scaling unit.
  McuCount int `json:"McuCount"`

  // The minimum number of workers for a connector.
  MinWorkerCount int `json:"MinWorkerCount"`
  ScaleInPolicy *ScaleInPolicy `json:"ScaleInPolicy"`
  ScaleOutPolicy *ScaleOutPolicy `json:"ScaleOutPolicy"`
}

// Capacity Information about the capacity allocated to the connector.
type Capacity struct {
  AutoScaling *AutoScaling `json:"AutoScaling,omitempty"`
  ProvisionedCapacity *ProvisionedCapacity `json:"ProvisionedCapacity,omitempty"`
}

// CloudWatchLogsLogDelivery Details about delivering logs to Amazon CloudWatch Logs.
type CloudWatchLogsLogDelivery struct {

  // Specifies whether the logs get sent to the specified CloudWatch Logs destination.
  Enabled bool `json:"Enabled"`

  // The CloudWatch log group that is the destination for log delivery.
  LogGroup string `json:"LogGroup,omitempty"`
}

// ConnectorConfiguration The configuration for the connector.
type ConnectorConfiguration struct {
}

// CustomPlugin Details about a custom plugin.
type CustomPlugin struct {

  // The Amazon Resource Name (ARN) of the custom plugin to use.
  CustomPluginArn string `json:"CustomPluginArn"`

  // The revision of the custom plugin to use.
  Revision int `json:"Revision"`
}

// FirehoseLogDelivery Details about delivering logs to Amazon Kinesis Data Firehose.
type FirehoseLogDelivery struct {

  // The Kinesis Data Firehose delivery stream that is the destination for log delivery.
  DeliveryStream string `json:"DeliveryStream,omitempty"`

  // Specifies whether the logs get sent to the specified Kinesis Data Firehose delivery stream.
  Enabled bool `json:"Enabled"`
}

// KafkaCluster Details of how to connect to the Kafka cluster.
type KafkaCluster struct {
  ApacheKafkaCluster *ApacheKafkaCluster `json:"ApacheKafkaCluster"`
}

// KafkaClusterClientAuthentication Details of the client authentication used by the Kafka cluster.
type KafkaClusterClientAuthentication struct {
  AuthenticationType string `json:"AuthenticationType"`
}

// KafkaClusterEncryptionInTransit Details of encryption in transit to the Kafka cluster.
type KafkaClusterEncryptionInTransit struct {
  EncryptionType string `json:"EncryptionType"`
}

// LogDelivery Details of what logs are delivered and where they are delivered.
type LogDelivery struct {
  WorkerLogDelivery *WorkerLogDelivery `json:"WorkerLogDelivery"`
}

// Plugin Details about a Kafka Connect plugin which will be used with the connector.
type Plugin struct {
  CustomPlugin *CustomPlugin `json:"CustomPlugin"`
}

// ProvisionedCapacity Details about a fixed capacity allocated to a connector.
type ProvisionedCapacity struct {

  // Specifies how many MSK Connect Units (MCU) are allocated to the connector.
  McuCount int `json:"McuCount,omitempty"`

  // Number of workers for a connector.
  WorkerCount int `json:"WorkerCount"`
}

// Resource Resource Type definition for AWS::KafkaConnect::Connector
type Resource struct {
  Capacity *Capacity `json:"Capacity"`

  // Amazon Resource Name for the created Connector.
  ConnectorArn string `json:"ConnectorArn,omitempty"`

  // The configuration for the connector.
  ConnectorConfiguration *ConnectorConfiguration `json:"ConnectorConfiguration"`

  // A summary description of the connector.
  ConnectorDescription string `json:"ConnectorDescription,omitempty"`

  // The name of the connector.
  ConnectorName string `json:"ConnectorName"`
  KafkaCluster *KafkaCluster `json:"KafkaCluster"`
  KafkaClusterClientAuthentication *KafkaClusterClientAuthentication `json:"KafkaClusterClientAuthentication"`
  KafkaClusterEncryptionInTransit *KafkaClusterEncryptionInTransit `json:"KafkaClusterEncryptionInTransit"`

  // The version of Kafka Connect. It has to be compatible with both the Kafka cluster's version and the plugins.
  KafkaConnectVersion string `json:"KafkaConnectVersion"`
  LogDelivery *LogDelivery `json:"LogDelivery,omitempty"`

  // List of plugins to use with the connector.
  Plugins []*Plugin `json:"Plugins"`

  // The Amazon Resource Name (ARN) of the IAM role used by the connector to access Amazon S3 objects and other external resources.
  ServiceExecutionRoleArn string `json:"ServiceExecutionRoleArn"`
  WorkerConfiguration *WorkerConfiguration `json:"WorkerConfiguration,omitempty"`
}

// S3LogDelivery Details about delivering logs to Amazon S3.
type S3LogDelivery struct {

  // The name of the S3 bucket that is the destination for log delivery.
  Bucket string `json:"Bucket,omitempty"`

  // Specifies whether the logs get sent to the specified Amazon S3 destination.
  Enabled bool `json:"Enabled"`

  // The S3 prefix that is the destination for log delivery.
  Prefix string `json:"Prefix,omitempty"`
}

// ScaleInPolicy Information about the scale in policy of the connector.
type ScaleInPolicy struct {

  // Specifies the CPU utilization percentage threshold at which connector scale in should trigger.
  CpuUtilizationPercentage int `json:"CpuUtilizationPercentage"`
}

// ScaleOutPolicy Information about the scale out policy of the connector.
type ScaleOutPolicy struct {

  // Specifies the CPU utilization percentage threshold at which connector scale out should trigger.
  CpuUtilizationPercentage int `json:"CpuUtilizationPercentage"`
}

// Vpc Information about a VPC used with the connector.
type Vpc struct {

  // The AWS security groups to associate with the elastic network interfaces in order to specify what the connector has access to.
  SecurityGroups []string `json:"SecurityGroups"`

  // The list of subnets to connect to in the virtual private cloud (VPC). AWS creates elastic network interfaces inside these subnets.
  Subnets []string `json:"Subnets"`
}

// WorkerConfiguration Specifies the worker configuration to use with the connector.
type WorkerConfiguration struct {

  // The revision of the worker configuration to use.
  Revision int `json:"Revision"`

  // The Amazon Resource Name (ARN) of the worker configuration to use.
  WorkerConfigurationArn string `json:"WorkerConfigurationArn"`
}

// WorkerLogDelivery Specifies where worker logs are delivered.
type WorkerLogDelivery struct {
  CloudWatchLogs *CloudWatchLogsLogDelivery `json:"CloudWatchLogs,omitempty"`
  Firehose *FirehoseLogDelivery `json:"Firehose,omitempty"`
  S3 *S3LogDelivery `json:"S3,omitempty"`
}

func (strct *ApacheKafkaCluster) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "BootstrapServers" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "BootstrapServers" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BootstrapServers\": ")
	if tmp, err := json.Marshal(strct.BootstrapServers); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Vpc" field is required
    if strct.Vpc == nil {
        return nil, errors.New("Vpc is a required field")
    }
    // Marshal the "Vpc" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Vpc\": ")
	if tmp, err := json.Marshal(strct.Vpc); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ApacheKafkaCluster) UnmarshalJSON(b []byte) error {
    BootstrapServersReceived := false
    VpcReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BootstrapServers":
            if err := json.Unmarshal([]byte(v), &strct.BootstrapServers); err != nil {
                return err
             }
            BootstrapServersReceived = true
        case "Vpc":
            if err := json.Unmarshal([]byte(v), &strct.Vpc); err != nil {
                return err
             }
            VpcReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if BootstrapServers (a required property) was received
    if !BootstrapServersReceived {
        return errors.New("\"BootstrapServers\" is required but was not present")
    }
    // check if Vpc (a required property) was received
    if !VpcReceived {
        return errors.New("\"Vpc\" is required but was not present")
    }
    return nil
}

func (strct *AutoScaling) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "MaxWorkerCount" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "MaxWorkerCount" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaxWorkerCount\": ")
	if tmp, err := json.Marshal(strct.MaxWorkerCount); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "McuCount" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "McuCount" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"McuCount\": ")
	if tmp, err := json.Marshal(strct.McuCount); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "MinWorkerCount" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "MinWorkerCount" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MinWorkerCount\": ")
	if tmp, err := json.Marshal(strct.MinWorkerCount); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ScaleInPolicy" field is required
    if strct.ScaleInPolicy == nil {
        return nil, errors.New("ScaleInPolicy is a required field")
    }
    // Marshal the "ScaleInPolicy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ScaleInPolicy\": ")
	if tmp, err := json.Marshal(strct.ScaleInPolicy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ScaleOutPolicy" field is required
    if strct.ScaleOutPolicy == nil {
        return nil, errors.New("ScaleOutPolicy is a required field")
    }
    // Marshal the "ScaleOutPolicy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ScaleOutPolicy\": ")
	if tmp, err := json.Marshal(strct.ScaleOutPolicy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AutoScaling) UnmarshalJSON(b []byte) error {
    MaxWorkerCountReceived := false
    McuCountReceived := false
    MinWorkerCountReceived := false
    ScaleInPolicyReceived := false
    ScaleOutPolicyReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "MaxWorkerCount":
            if err := json.Unmarshal([]byte(v), &strct.MaxWorkerCount); err != nil {
                return err
             }
            MaxWorkerCountReceived = true
        case "McuCount":
            if err := json.Unmarshal([]byte(v), &strct.McuCount); err != nil {
                return err
             }
            McuCountReceived = true
        case "MinWorkerCount":
            if err := json.Unmarshal([]byte(v), &strct.MinWorkerCount); err != nil {
                return err
             }
            MinWorkerCountReceived = true
        case "ScaleInPolicy":
            if err := json.Unmarshal([]byte(v), &strct.ScaleInPolicy); err != nil {
                return err
             }
            ScaleInPolicyReceived = true
        case "ScaleOutPolicy":
            if err := json.Unmarshal([]byte(v), &strct.ScaleOutPolicy); err != nil {
                return err
             }
            ScaleOutPolicyReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if MaxWorkerCount (a required property) was received
    if !MaxWorkerCountReceived {
        return errors.New("\"MaxWorkerCount\" is required but was not present")
    }
    // check if McuCount (a required property) was received
    if !McuCountReceived {
        return errors.New("\"McuCount\" is required but was not present")
    }
    // check if MinWorkerCount (a required property) was received
    if !MinWorkerCountReceived {
        return errors.New("\"MinWorkerCount\" is required but was not present")
    }
    // check if ScaleInPolicy (a required property) was received
    if !ScaleInPolicyReceived {
        return errors.New("\"ScaleInPolicy\" is required but was not present")
    }
    // check if ScaleOutPolicy (a required property) was received
    if !ScaleOutPolicyReceived {
        return errors.New("\"ScaleOutPolicy\" is required but was not present")
    }
    return nil
}

func (strct *Capacity) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AutoScaling" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AutoScaling\": ")
	if tmp, err := json.Marshal(strct.AutoScaling); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ProvisionedCapacity" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ProvisionedCapacity\": ")
	if tmp, err := json.Marshal(strct.ProvisionedCapacity); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Capacity) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AutoScaling":
            if err := json.Unmarshal([]byte(v), &strct.AutoScaling); err != nil {
                return err
             }
        case "ProvisionedCapacity":
            if err := json.Unmarshal([]byte(v), &strct.ProvisionedCapacity); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *CloudWatchLogsLogDelivery) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Enabled" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Enabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LogGroup" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LogGroup\": ")
	if tmp, err := json.Marshal(strct.LogGroup); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CloudWatchLogsLogDelivery) UnmarshalJSON(b []byte) error {
    EnabledReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Enabled":
            if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
                return err
             }
            EnabledReceived = true
        case "LogGroup":
            if err := json.Unmarshal([]byte(v), &strct.LogGroup); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Enabled (a required property) was received
    if !EnabledReceived {
        return errors.New("\"Enabled\" is required but was not present")
    }
    return nil
}

func (strct *ConnectorConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ConnectorConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *CustomPlugin) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "CustomPluginArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "CustomPluginArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CustomPluginArn\": ")
	if tmp, err := json.Marshal(strct.CustomPluginArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Revision" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Revision" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Revision\": ")
	if tmp, err := json.Marshal(strct.Revision); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CustomPlugin) UnmarshalJSON(b []byte) error {
    CustomPluginArnReceived := false
    RevisionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CustomPluginArn":
            if err := json.Unmarshal([]byte(v), &strct.CustomPluginArn); err != nil {
                return err
             }
            CustomPluginArnReceived = true
        case "Revision":
            if err := json.Unmarshal([]byte(v), &strct.Revision); err != nil {
                return err
             }
            RevisionReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if CustomPluginArn (a required property) was received
    if !CustomPluginArnReceived {
        return errors.New("\"CustomPluginArn\" is required but was not present")
    }
    // check if Revision (a required property) was received
    if !RevisionReceived {
        return errors.New("\"Revision\" is required but was not present")
    }
    return nil
}

func (strct *FirehoseLogDelivery) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DeliveryStream" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DeliveryStream\": ")
	if tmp, err := json.Marshal(strct.DeliveryStream); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Enabled" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Enabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FirehoseLogDelivery) UnmarshalJSON(b []byte) error {
    EnabledReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DeliveryStream":
            if err := json.Unmarshal([]byte(v), &strct.DeliveryStream); err != nil {
                return err
             }
        case "Enabled":
            if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
                return err
             }
            EnabledReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Enabled (a required property) was received
    if !EnabledReceived {
        return errors.New("\"Enabled\" is required but was not present")
    }
    return nil
}

func (strct *KafkaCluster) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ApacheKafkaCluster" field is required
    if strct.ApacheKafkaCluster == nil {
        return nil, errors.New("ApacheKafkaCluster is a required field")
    }
    // Marshal the "ApacheKafkaCluster" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ApacheKafkaCluster\": ")
	if tmp, err := json.Marshal(strct.ApacheKafkaCluster); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *KafkaCluster) UnmarshalJSON(b []byte) error {
    ApacheKafkaClusterReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ApacheKafkaCluster":
            if err := json.Unmarshal([]byte(v), &strct.ApacheKafkaCluster); err != nil {
                return err
             }
            ApacheKafkaClusterReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ApacheKafkaCluster (a required property) was received
    if !ApacheKafkaClusterReceived {
        return errors.New("\"ApacheKafkaCluster\" is required but was not present")
    }
    return nil
}

func (strct *KafkaClusterClientAuthentication) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AuthenticationType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AuthenticationType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AuthenticationType\": ")
	if tmp, err := json.Marshal(strct.AuthenticationType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *KafkaClusterClientAuthentication) UnmarshalJSON(b []byte) error {
    AuthenticationTypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AuthenticationType":
            if err := json.Unmarshal([]byte(v), &strct.AuthenticationType); err != nil {
                return err
             }
            AuthenticationTypeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if AuthenticationType (a required property) was received
    if !AuthenticationTypeReceived {
        return errors.New("\"AuthenticationType\" is required but was not present")
    }
    return nil
}

func (strct *KafkaClusterEncryptionInTransit) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "EncryptionType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "EncryptionType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EncryptionType\": ")
	if tmp, err := json.Marshal(strct.EncryptionType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *KafkaClusterEncryptionInTransit) UnmarshalJSON(b []byte) error {
    EncryptionTypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "EncryptionType":
            if err := json.Unmarshal([]byte(v), &strct.EncryptionType); err != nil {
                return err
             }
            EncryptionTypeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if EncryptionType (a required property) was received
    if !EncryptionTypeReceived {
        return errors.New("\"EncryptionType\" is required but was not present")
    }
    return nil
}

func (strct *LogDelivery) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "WorkerLogDelivery" field is required
    if strct.WorkerLogDelivery == nil {
        return nil, errors.New("WorkerLogDelivery is a required field")
    }
    // Marshal the "WorkerLogDelivery" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"WorkerLogDelivery\": ")
	if tmp, err := json.Marshal(strct.WorkerLogDelivery); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LogDelivery) UnmarshalJSON(b []byte) error {
    WorkerLogDeliveryReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "WorkerLogDelivery":
            if err := json.Unmarshal([]byte(v), &strct.WorkerLogDelivery); err != nil {
                return err
             }
            WorkerLogDeliveryReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if WorkerLogDelivery (a required property) was received
    if !WorkerLogDeliveryReceived {
        return errors.New("\"WorkerLogDelivery\" is required but was not present")
    }
    return nil
}

func (strct *Plugin) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "CustomPlugin" field is required
    if strct.CustomPlugin == nil {
        return nil, errors.New("CustomPlugin is a required field")
    }
    // Marshal the "CustomPlugin" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CustomPlugin\": ")
	if tmp, err := json.Marshal(strct.CustomPlugin); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Plugin) UnmarshalJSON(b []byte) error {
    CustomPluginReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CustomPlugin":
            if err := json.Unmarshal([]byte(v), &strct.CustomPlugin); err != nil {
                return err
             }
            CustomPluginReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if CustomPlugin (a required property) was received
    if !CustomPluginReceived {
        return errors.New("\"CustomPlugin\" is required but was not present")
    }
    return nil
}

func (strct *ProvisionedCapacity) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "McuCount" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"McuCount\": ")
	if tmp, err := json.Marshal(strct.McuCount); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "WorkerCount" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "WorkerCount" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"WorkerCount\": ")
	if tmp, err := json.Marshal(strct.WorkerCount); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ProvisionedCapacity) UnmarshalJSON(b []byte) error {
    WorkerCountReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "McuCount":
            if err := json.Unmarshal([]byte(v), &strct.McuCount); err != nil {
                return err
             }
        case "WorkerCount":
            if err := json.Unmarshal([]byte(v), &strct.WorkerCount); err != nil {
                return err
             }
            WorkerCountReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if WorkerCount (a required property) was received
    if !WorkerCountReceived {
        return errors.New("\"WorkerCount\" is required but was not present")
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Capacity" field is required
    if strct.Capacity == nil {
        return nil, errors.New("Capacity is a required field")
    }
    // Marshal the "Capacity" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Capacity\": ")
	if tmp, err := json.Marshal(strct.Capacity); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ConnectorArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConnectorArn\": ")
	if tmp, err := json.Marshal(strct.ConnectorArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ConnectorConfiguration" field is required
    if strct.ConnectorConfiguration == nil {
        return nil, errors.New("ConnectorConfiguration is a required field")
    }
    // Marshal the "ConnectorConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConnectorConfiguration\": ")
	if tmp, err := json.Marshal(strct.ConnectorConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ConnectorDescription" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConnectorDescription\": ")
	if tmp, err := json.Marshal(strct.ConnectorDescription); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ConnectorName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ConnectorName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConnectorName\": ")
	if tmp, err := json.Marshal(strct.ConnectorName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "KafkaCluster" field is required
    if strct.KafkaCluster == nil {
        return nil, errors.New("KafkaCluster is a required field")
    }
    // Marshal the "KafkaCluster" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KafkaCluster\": ")
	if tmp, err := json.Marshal(strct.KafkaCluster); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "KafkaClusterClientAuthentication" field is required
    if strct.KafkaClusterClientAuthentication == nil {
        return nil, errors.New("KafkaClusterClientAuthentication is a required field")
    }
    // Marshal the "KafkaClusterClientAuthentication" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KafkaClusterClientAuthentication\": ")
	if tmp, err := json.Marshal(strct.KafkaClusterClientAuthentication); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "KafkaClusterEncryptionInTransit" field is required
    if strct.KafkaClusterEncryptionInTransit == nil {
        return nil, errors.New("KafkaClusterEncryptionInTransit is a required field")
    }
    // Marshal the "KafkaClusterEncryptionInTransit" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KafkaClusterEncryptionInTransit\": ")
	if tmp, err := json.Marshal(strct.KafkaClusterEncryptionInTransit); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "KafkaConnectVersion" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "KafkaConnectVersion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KafkaConnectVersion\": ")
	if tmp, err := json.Marshal(strct.KafkaConnectVersion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LogDelivery" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LogDelivery\": ")
	if tmp, err := json.Marshal(strct.LogDelivery); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Plugins" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Plugins" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Plugins\": ")
	if tmp, err := json.Marshal(strct.Plugins); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ServiceExecutionRoleArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ServiceExecutionRoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ServiceExecutionRoleArn\": ")
	if tmp, err := json.Marshal(strct.ServiceExecutionRoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "WorkerConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"WorkerConfiguration\": ")
	if tmp, err := json.Marshal(strct.WorkerConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    CapacityReceived := false
    ConnectorConfigurationReceived := false
    ConnectorNameReceived := false
    KafkaClusterReceived := false
    KafkaClusterClientAuthenticationReceived := false
    KafkaClusterEncryptionInTransitReceived := false
    KafkaConnectVersionReceived := false
    PluginsReceived := false
    ServiceExecutionRoleArnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Capacity":
            if err := json.Unmarshal([]byte(v), &strct.Capacity); err != nil {
                return err
             }
            CapacityReceived = true
        case "ConnectorArn":
            if err := json.Unmarshal([]byte(v), &strct.ConnectorArn); err != nil {
                return err
             }
        case "ConnectorConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.ConnectorConfiguration); err != nil {
                return err
             }
            ConnectorConfigurationReceived = true
        case "ConnectorDescription":
            if err := json.Unmarshal([]byte(v), &strct.ConnectorDescription); err != nil {
                return err
             }
        case "ConnectorName":
            if err := json.Unmarshal([]byte(v), &strct.ConnectorName); err != nil {
                return err
             }
            ConnectorNameReceived = true
        case "KafkaCluster":
            if err := json.Unmarshal([]byte(v), &strct.KafkaCluster); err != nil {
                return err
             }
            KafkaClusterReceived = true
        case "KafkaClusterClientAuthentication":
            if err := json.Unmarshal([]byte(v), &strct.KafkaClusterClientAuthentication); err != nil {
                return err
             }
            KafkaClusterClientAuthenticationReceived = true
        case "KafkaClusterEncryptionInTransit":
            if err := json.Unmarshal([]byte(v), &strct.KafkaClusterEncryptionInTransit); err != nil {
                return err
             }
            KafkaClusterEncryptionInTransitReceived = true
        case "KafkaConnectVersion":
            if err := json.Unmarshal([]byte(v), &strct.KafkaConnectVersion); err != nil {
                return err
             }
            KafkaConnectVersionReceived = true
        case "LogDelivery":
            if err := json.Unmarshal([]byte(v), &strct.LogDelivery); err != nil {
                return err
             }
        case "Plugins":
            if err := json.Unmarshal([]byte(v), &strct.Plugins); err != nil {
                return err
             }
            PluginsReceived = true
        case "ServiceExecutionRoleArn":
            if err := json.Unmarshal([]byte(v), &strct.ServiceExecutionRoleArn); err != nil {
                return err
             }
            ServiceExecutionRoleArnReceived = true
        case "WorkerConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.WorkerConfiguration); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Capacity (a required property) was received
    if !CapacityReceived {
        return errors.New("\"Capacity\" is required but was not present")
    }
    // check if ConnectorConfiguration (a required property) was received
    if !ConnectorConfigurationReceived {
        return errors.New("\"ConnectorConfiguration\" is required but was not present")
    }
    // check if ConnectorName (a required property) was received
    if !ConnectorNameReceived {
        return errors.New("\"ConnectorName\" is required but was not present")
    }
    // check if KafkaCluster (a required property) was received
    if !KafkaClusterReceived {
        return errors.New("\"KafkaCluster\" is required but was not present")
    }
    // check if KafkaClusterClientAuthentication (a required property) was received
    if !KafkaClusterClientAuthenticationReceived {
        return errors.New("\"KafkaClusterClientAuthentication\" is required but was not present")
    }
    // check if KafkaClusterEncryptionInTransit (a required property) was received
    if !KafkaClusterEncryptionInTransitReceived {
        return errors.New("\"KafkaClusterEncryptionInTransit\" is required but was not present")
    }
    // check if KafkaConnectVersion (a required property) was received
    if !KafkaConnectVersionReceived {
        return errors.New("\"KafkaConnectVersion\" is required but was not present")
    }
    // check if Plugins (a required property) was received
    if !PluginsReceived {
        return errors.New("\"Plugins\" is required but was not present")
    }
    // check if ServiceExecutionRoleArn (a required property) was received
    if !ServiceExecutionRoleArnReceived {
        return errors.New("\"ServiceExecutionRoleArn\" is required but was not present")
    }
    return nil
}

func (strct *S3LogDelivery) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Bucket" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Bucket\": ")
	if tmp, err := json.Marshal(strct.Bucket); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Enabled" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Enabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Prefix" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Prefix\": ")
	if tmp, err := json.Marshal(strct.Prefix); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *S3LogDelivery) UnmarshalJSON(b []byte) error {
    EnabledReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Bucket":
            if err := json.Unmarshal([]byte(v), &strct.Bucket); err != nil {
                return err
             }
        case "Enabled":
            if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
                return err
             }
            EnabledReceived = true
        case "Prefix":
            if err := json.Unmarshal([]byte(v), &strct.Prefix); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Enabled (a required property) was received
    if !EnabledReceived {
        return errors.New("\"Enabled\" is required but was not present")
    }
    return nil
}

func (strct *ScaleInPolicy) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "CpuUtilizationPercentage" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "CpuUtilizationPercentage" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CpuUtilizationPercentage\": ")
	if tmp, err := json.Marshal(strct.CpuUtilizationPercentage); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ScaleInPolicy) UnmarshalJSON(b []byte) error {
    CpuUtilizationPercentageReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CpuUtilizationPercentage":
            if err := json.Unmarshal([]byte(v), &strct.CpuUtilizationPercentage); err != nil {
                return err
             }
            CpuUtilizationPercentageReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if CpuUtilizationPercentage (a required property) was received
    if !CpuUtilizationPercentageReceived {
        return errors.New("\"CpuUtilizationPercentage\" is required but was not present")
    }
    return nil
}

func (strct *ScaleOutPolicy) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "CpuUtilizationPercentage" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "CpuUtilizationPercentage" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CpuUtilizationPercentage\": ")
	if tmp, err := json.Marshal(strct.CpuUtilizationPercentage); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ScaleOutPolicy) UnmarshalJSON(b []byte) error {
    CpuUtilizationPercentageReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CpuUtilizationPercentage":
            if err := json.Unmarshal([]byte(v), &strct.CpuUtilizationPercentage); err != nil {
                return err
             }
            CpuUtilizationPercentageReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if CpuUtilizationPercentage (a required property) was received
    if !CpuUtilizationPercentageReceived {
        return errors.New("\"CpuUtilizationPercentage\" is required but was not present")
    }
    return nil
}

func (strct *Vpc) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "SecurityGroups" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "SecurityGroups" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SecurityGroups\": ")
	if tmp, err := json.Marshal(strct.SecurityGroups); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Subnets" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Subnets" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Subnets\": ")
	if tmp, err := json.Marshal(strct.Subnets); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Vpc) UnmarshalJSON(b []byte) error {
    SecurityGroupsReceived := false
    SubnetsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "SecurityGroups":
            if err := json.Unmarshal([]byte(v), &strct.SecurityGroups); err != nil {
                return err
             }
            SecurityGroupsReceived = true
        case "Subnets":
            if err := json.Unmarshal([]byte(v), &strct.Subnets); err != nil {
                return err
             }
            SubnetsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if SecurityGroups (a required property) was received
    if !SecurityGroupsReceived {
        return errors.New("\"SecurityGroups\" is required but was not present")
    }
    // check if Subnets (a required property) was received
    if !SubnetsReceived {
        return errors.New("\"Subnets\" is required but was not present")
    }
    return nil
}

func (strct *WorkerConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Revision" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Revision" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Revision\": ")
	if tmp, err := json.Marshal(strct.Revision); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "WorkerConfigurationArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "WorkerConfigurationArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"WorkerConfigurationArn\": ")
	if tmp, err := json.Marshal(strct.WorkerConfigurationArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *WorkerConfiguration) UnmarshalJSON(b []byte) error {
    RevisionReceived := false
    WorkerConfigurationArnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Revision":
            if err := json.Unmarshal([]byte(v), &strct.Revision); err != nil {
                return err
             }
            RevisionReceived = true
        case "WorkerConfigurationArn":
            if err := json.Unmarshal([]byte(v), &strct.WorkerConfigurationArn); err != nil {
                return err
             }
            WorkerConfigurationArnReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Revision (a required property) was received
    if !RevisionReceived {
        return errors.New("\"Revision\" is required but was not present")
    }
    // check if WorkerConfigurationArn (a required property) was received
    if !WorkerConfigurationArnReceived {
        return errors.New("\"WorkerConfigurationArn\" is required but was not present")
    }
    return nil
}

func (strct *WorkerLogDelivery) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CloudWatchLogs" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CloudWatchLogs\": ")
	if tmp, err := json.Marshal(strct.CloudWatchLogs); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Firehose" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Firehose\": ")
	if tmp, err := json.Marshal(strct.Firehose); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "S3" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3\": ")
	if tmp, err := json.Marshal(strct.S3); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *WorkerLogDelivery) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CloudWatchLogs":
            if err := json.Unmarshal([]byte(v), &strct.CloudWatchLogs); err != nil {
                return err
             }
        case "Firehose":
            if err := json.Unmarshal([]byte(v), &strct.Firehose); err != nil {
                return err
             }
        case "S3":
            if err := json.Unmarshal([]byte(v), &strct.S3); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}
