// Code generated by schema-generate. DO NOT EDIT.

package domain

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// AccessPolicies 
type AccessPolicies struct {
}

// AdvancedOptions 
type AdvancedOptions struct {
}

// AdvancedSecurityOptionsInput 
type AdvancedSecurityOptionsInput struct {
  AnonymousAuthDisableDate string `json:"AnonymousAuthDisableDate,omitempty"`
  AnonymousAuthEnabled bool `json:"AnonymousAuthEnabled,omitempty"`
  Enabled bool `json:"Enabled,omitempty"`
  InternalUserDatabaseEnabled bool `json:"InternalUserDatabaseEnabled,omitempty"`
  MasterUserOptions *MasterUserOptions `json:"MasterUserOptions,omitempty"`
  SAMLOptions *SAMLOptions `json:"SAMLOptions,omitempty"`
}

// ClusterConfig 
type ClusterConfig struct {
  DedicatedMasterCount int `json:"DedicatedMasterCount,omitempty"`
  DedicatedMasterEnabled bool `json:"DedicatedMasterEnabled,omitempty"`
  DedicatedMasterType string `json:"DedicatedMasterType,omitempty"`
  InstanceCount int `json:"InstanceCount,omitempty"`
  InstanceType string `json:"InstanceType,omitempty"`
  WarmCount int `json:"WarmCount,omitempty"`
  WarmEnabled bool `json:"WarmEnabled,omitempty"`
  WarmType string `json:"WarmType,omitempty"`
  ZoneAwarenessConfig *ZoneAwarenessConfig `json:"ZoneAwarenessConfig,omitempty"`
  ZoneAwarenessEnabled bool `json:"ZoneAwarenessEnabled,omitempty"`
}

// CognitoOptions 
type CognitoOptions struct {
  Enabled bool `json:"Enabled,omitempty"`
  IdentityPoolId string `json:"IdentityPoolId,omitempty"`
  RoleArn string `json:"RoleArn,omitempty"`
  UserPoolId string `json:"UserPoolId,omitempty"`
}

// DomainEndpointOptions 
type DomainEndpointOptions struct {
  CustomEndpoint string `json:"CustomEndpoint,omitempty"`
  CustomEndpointCertificateArn string `json:"CustomEndpointCertificateArn,omitempty"`
  CustomEndpointEnabled bool `json:"CustomEndpointEnabled,omitempty"`
  EnforceHTTPS bool `json:"EnforceHTTPS,omitempty"`
  TLSSecurityPolicy string `json:"TLSSecurityPolicy,omitempty"`
}

// DomainEndpoints 
type DomainEndpoints struct {
}

// EBSOptions 
type EBSOptions struct {
  EBSEnabled bool `json:"EBSEnabled,omitempty"`
  Iops int `json:"Iops,omitempty"`
  Throughput int `json:"Throughput,omitempty"`
  VolumeSize int `json:"VolumeSize,omitempty"`
  VolumeType string `json:"VolumeType,omitempty"`
}

// EncryptionAtRestOptions 
type EncryptionAtRestOptions struct {
  Enabled bool `json:"Enabled,omitempty"`
  KmsKeyId string `json:"KmsKeyId,omitempty"`
}

// Idp 
type Idp struct {
  EntityId string `json:"EntityId"`
  MetadataContent string `json:"MetadataContent"`
}

// LogPublishingOption 
type LogPublishingOption struct {
  CloudWatchLogsLogGroupArn string `json:"CloudWatchLogsLogGroupArn,omitempty"`
  Enabled bool `json:"Enabled,omitempty"`
}

// LogPublishingOptions 
type LogPublishingOptions struct {
}

// MasterUserOptions 
type MasterUserOptions struct {
  MasterUserARN string `json:"MasterUserARN,omitempty"`
  MasterUserName string `json:"MasterUserName,omitempty"`
  MasterUserPassword string `json:"MasterUserPassword,omitempty"`
}

// NodeToNodeEncryptionOptions 
type NodeToNodeEncryptionOptions struct {
  Enabled bool `json:"Enabled,omitempty"`
}

// Resource An example resource schema demonstrating some basic constructs and validation rules.
type Resource struct {
  AccessPolicies *AccessPolicies `json:"AccessPolicies,omitempty"`
  AdvancedOptions *AdvancedOptions `json:"AdvancedOptions,omitempty"`
  AdvancedSecurityOptions *AdvancedSecurityOptionsInput `json:"AdvancedSecurityOptions,omitempty"`
  Arn string `json:"Arn,omitempty"`
  ClusterConfig *ClusterConfig `json:"ClusterConfig,omitempty"`
  CognitoOptions *CognitoOptions `json:"CognitoOptions,omitempty"`
  DomainArn string `json:"DomainArn,omitempty"`
  DomainEndpoint string `json:"DomainEndpoint,omitempty"`
  DomainEndpointOptions *DomainEndpointOptions `json:"DomainEndpointOptions,omitempty"`
  DomainEndpoints *DomainEndpoints `json:"DomainEndpoints,omitempty"`
  DomainName string `json:"DomainName,omitempty"`
  EBSOptions *EBSOptions `json:"EBSOptions,omitempty"`
  EncryptionAtRestOptions *EncryptionAtRestOptions `json:"EncryptionAtRestOptions,omitempty"`
  EngineVersion string `json:"EngineVersion,omitempty"`
  Id string `json:"Id,omitempty"`
  LogPublishingOptions *LogPublishingOptions `json:"LogPublishingOptions,omitempty"`
  NodeToNodeEncryptionOptions *NodeToNodeEncryptionOptions `json:"NodeToNodeEncryptionOptions,omitempty"`
  ServiceSoftwareOptions *ServiceSoftwareOptions `json:"ServiceSoftwareOptions,omitempty"`
  SnapshotOptions *SnapshotOptions `json:"SnapshotOptions,omitempty"`

  // An arbitrary set of tags (key-value pairs) for this Domain.
  Tags []*Tag `json:"Tags,omitempty"`
  VPCOptions *VPCOptions `json:"VPCOptions,omitempty"`
}

// SAMLOptions 
type SAMLOptions struct {
  Enabled bool `json:"Enabled,omitempty"`
  Idp *Idp `json:"Idp,omitempty"`
  MasterBackendRole string `json:"MasterBackendRole,omitempty"`
  MasterUserName string `json:"MasterUserName,omitempty"`
  RolesKey string `json:"RolesKey,omitempty"`
  SessionTimeoutMinutes int `json:"SessionTimeoutMinutes,omitempty"`
  SubjectKey string `json:"SubjectKey,omitempty"`
}

// ServiceSoftwareOptions 
type ServiceSoftwareOptions struct {
  AutomatedUpdateDate string `json:"AutomatedUpdateDate,omitempty"`
  Cancellable bool `json:"Cancellable,omitempty"`
  CurrentVersion string `json:"CurrentVersion,omitempty"`
  Description string `json:"Description,omitempty"`
  NewVersion string `json:"NewVersion,omitempty"`
  OptionalDeployment bool `json:"OptionalDeployment,omitempty"`
  UpdateAvailable bool `json:"UpdateAvailable,omitempty"`
  UpdateStatus string `json:"UpdateStatus,omitempty"`
}

// SnapshotOptions 
type SnapshotOptions struct {
  AutomatedSnapshotStartHour int `json:"AutomatedSnapshotStartHour,omitempty"`
}

// Tag 
type Tag struct {

  // The value of the tag.
  Key string `json:"Key"`

  // The key of the tag.
  Value string `json:"Value"`
}

// VPCOptions 
type VPCOptions struct {
  SecurityGroupIds []string `json:"SecurityGroupIds,omitempty"`
  SubnetIds []string `json:"SubnetIds,omitempty"`
}

// ZoneAwarenessConfig 
type ZoneAwarenessConfig struct {
  AvailabilityZoneCount int `json:"AvailabilityZoneCount,omitempty"`
}

func (strct *AdvancedOptions) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AdvancedOptions) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *AdvancedSecurityOptionsInput) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AnonymousAuthDisableDate" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AnonymousAuthDisableDate\": ")
	if tmp, err := json.Marshal(strct.AnonymousAuthDisableDate); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AnonymousAuthEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AnonymousAuthEnabled\": ")
	if tmp, err := json.Marshal(strct.AnonymousAuthEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Enabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "InternalUserDatabaseEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InternalUserDatabaseEnabled\": ")
	if tmp, err := json.Marshal(strct.InternalUserDatabaseEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MasterUserOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MasterUserOptions\": ")
	if tmp, err := json.Marshal(strct.MasterUserOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SAMLOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SAMLOptions\": ")
	if tmp, err := json.Marshal(strct.SAMLOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AdvancedSecurityOptionsInput) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AnonymousAuthDisableDate":
            if err := json.Unmarshal([]byte(v), &strct.AnonymousAuthDisableDate); err != nil {
                return err
             }
        case "AnonymousAuthEnabled":
            if err := json.Unmarshal([]byte(v), &strct.AnonymousAuthEnabled); err != nil {
                return err
             }
        case "Enabled":
            if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
                return err
             }
        case "InternalUserDatabaseEnabled":
            if err := json.Unmarshal([]byte(v), &strct.InternalUserDatabaseEnabled); err != nil {
                return err
             }
        case "MasterUserOptions":
            if err := json.Unmarshal([]byte(v), &strct.MasterUserOptions); err != nil {
                return err
             }
        case "SAMLOptions":
            if err := json.Unmarshal([]byte(v), &strct.SAMLOptions); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ClusterConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DedicatedMasterCount" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DedicatedMasterCount\": ")
	if tmp, err := json.Marshal(strct.DedicatedMasterCount); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DedicatedMasterEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DedicatedMasterEnabled\": ")
	if tmp, err := json.Marshal(strct.DedicatedMasterEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DedicatedMasterType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DedicatedMasterType\": ")
	if tmp, err := json.Marshal(strct.DedicatedMasterType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "InstanceCount" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InstanceCount\": ")
	if tmp, err := json.Marshal(strct.InstanceCount); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "InstanceType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InstanceType\": ")
	if tmp, err := json.Marshal(strct.InstanceType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "WarmCount" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"WarmCount\": ")
	if tmp, err := json.Marshal(strct.WarmCount); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "WarmEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"WarmEnabled\": ")
	if tmp, err := json.Marshal(strct.WarmEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "WarmType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"WarmType\": ")
	if tmp, err := json.Marshal(strct.WarmType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ZoneAwarenessConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ZoneAwarenessConfig\": ")
	if tmp, err := json.Marshal(strct.ZoneAwarenessConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ZoneAwarenessEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ZoneAwarenessEnabled\": ")
	if tmp, err := json.Marshal(strct.ZoneAwarenessEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ClusterConfig) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DedicatedMasterCount":
            if err := json.Unmarshal([]byte(v), &strct.DedicatedMasterCount); err != nil {
                return err
             }
        case "DedicatedMasterEnabled":
            if err := json.Unmarshal([]byte(v), &strct.DedicatedMasterEnabled); err != nil {
                return err
             }
        case "DedicatedMasterType":
            if err := json.Unmarshal([]byte(v), &strct.DedicatedMasterType); err != nil {
                return err
             }
        case "InstanceCount":
            if err := json.Unmarshal([]byte(v), &strct.InstanceCount); err != nil {
                return err
             }
        case "InstanceType":
            if err := json.Unmarshal([]byte(v), &strct.InstanceType); err != nil {
                return err
             }
        case "WarmCount":
            if err := json.Unmarshal([]byte(v), &strct.WarmCount); err != nil {
                return err
             }
        case "WarmEnabled":
            if err := json.Unmarshal([]byte(v), &strct.WarmEnabled); err != nil {
                return err
             }
        case "WarmType":
            if err := json.Unmarshal([]byte(v), &strct.WarmType); err != nil {
                return err
             }
        case "ZoneAwarenessConfig":
            if err := json.Unmarshal([]byte(v), &strct.ZoneAwarenessConfig); err != nil {
                return err
             }
        case "ZoneAwarenessEnabled":
            if err := json.Unmarshal([]byte(v), &strct.ZoneAwarenessEnabled); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *CognitoOptions) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Enabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IdentityPoolId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IdentityPoolId\": ")
	if tmp, err := json.Marshal(strct.IdentityPoolId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoleArn\": ")
	if tmp, err := json.Marshal(strct.RoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "UserPoolId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UserPoolId\": ")
	if tmp, err := json.Marshal(strct.UserPoolId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CognitoOptions) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Enabled":
            if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
                return err
             }
        case "IdentityPoolId":
            if err := json.Unmarshal([]byte(v), &strct.IdentityPoolId); err != nil {
                return err
             }
        case "RoleArn":
            if err := json.Unmarshal([]byte(v), &strct.RoleArn); err != nil {
                return err
             }
        case "UserPoolId":
            if err := json.Unmarshal([]byte(v), &strct.UserPoolId); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *DomainEndpointOptions) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CustomEndpoint" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CustomEndpoint\": ")
	if tmp, err := json.Marshal(strct.CustomEndpoint); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CustomEndpointCertificateArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CustomEndpointCertificateArn\": ")
	if tmp, err := json.Marshal(strct.CustomEndpointCertificateArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CustomEndpointEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CustomEndpointEnabled\": ")
	if tmp, err := json.Marshal(strct.CustomEndpointEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EnforceHTTPS" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EnforceHTTPS\": ")
	if tmp, err := json.Marshal(strct.EnforceHTTPS); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TLSSecurityPolicy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TLSSecurityPolicy\": ")
	if tmp, err := json.Marshal(strct.TLSSecurityPolicy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DomainEndpointOptions) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CustomEndpoint":
            if err := json.Unmarshal([]byte(v), &strct.CustomEndpoint); err != nil {
                return err
             }
        case "CustomEndpointCertificateArn":
            if err := json.Unmarshal([]byte(v), &strct.CustomEndpointCertificateArn); err != nil {
                return err
             }
        case "CustomEndpointEnabled":
            if err := json.Unmarshal([]byte(v), &strct.CustomEndpointEnabled); err != nil {
                return err
             }
        case "EnforceHTTPS":
            if err := json.Unmarshal([]byte(v), &strct.EnforceHTTPS); err != nil {
                return err
             }
        case "TLSSecurityPolicy":
            if err := json.Unmarshal([]byte(v), &strct.TLSSecurityPolicy); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *DomainEndpoints) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DomainEndpoints) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *EBSOptions) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "EBSEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EBSEnabled\": ")
	if tmp, err := json.Marshal(strct.EBSEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Iops" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Iops\": ")
	if tmp, err := json.Marshal(strct.Iops); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Throughput" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Throughput\": ")
	if tmp, err := json.Marshal(strct.Throughput); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VolumeSize" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VolumeSize\": ")
	if tmp, err := json.Marshal(strct.VolumeSize); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VolumeType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VolumeType\": ")
	if tmp, err := json.Marshal(strct.VolumeType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *EBSOptions) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "EBSEnabled":
            if err := json.Unmarshal([]byte(v), &strct.EBSEnabled); err != nil {
                return err
             }
        case "Iops":
            if err := json.Unmarshal([]byte(v), &strct.Iops); err != nil {
                return err
             }
        case "Throughput":
            if err := json.Unmarshal([]byte(v), &strct.Throughput); err != nil {
                return err
             }
        case "VolumeSize":
            if err := json.Unmarshal([]byte(v), &strct.VolumeSize); err != nil {
                return err
             }
        case "VolumeType":
            if err := json.Unmarshal([]byte(v), &strct.VolumeType); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *EncryptionAtRestOptions) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Enabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "KmsKeyId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KmsKeyId\": ")
	if tmp, err := json.Marshal(strct.KmsKeyId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *EncryptionAtRestOptions) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Enabled":
            if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
                return err
             }
        case "KmsKeyId":
            if err := json.Unmarshal([]byte(v), &strct.KmsKeyId); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Idp) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "EntityId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "EntityId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EntityId\": ")
	if tmp, err := json.Marshal(strct.EntityId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "MetadataContent" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "MetadataContent" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MetadataContent\": ")
	if tmp, err := json.Marshal(strct.MetadataContent); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Idp) UnmarshalJSON(b []byte) error {
    EntityIdReceived := false
    MetadataContentReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "EntityId":
            if err := json.Unmarshal([]byte(v), &strct.EntityId); err != nil {
                return err
             }
            EntityIdReceived = true
        case "MetadataContent":
            if err := json.Unmarshal([]byte(v), &strct.MetadataContent); err != nil {
                return err
             }
            MetadataContentReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if EntityId (a required property) was received
    if !EntityIdReceived {
        return errors.New("\"EntityId\" is required but was not present")
    }
    // check if MetadataContent (a required property) was received
    if !MetadataContentReceived {
        return errors.New("\"MetadataContent\" is required but was not present")
    }
    return nil
}

func (strct *LogPublishingOption) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CloudWatchLogsLogGroupArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CloudWatchLogsLogGroupArn\": ")
	if tmp, err := json.Marshal(strct.CloudWatchLogsLogGroupArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Enabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LogPublishingOption) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CloudWatchLogsLogGroupArn":
            if err := json.Unmarshal([]byte(v), &strct.CloudWatchLogsLogGroupArn); err != nil {
                return err
             }
        case "Enabled":
            if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *LogPublishingOptions) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LogPublishingOptions) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *MasterUserOptions) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "MasterUserARN" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MasterUserARN\": ")
	if tmp, err := json.Marshal(strct.MasterUserARN); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MasterUserName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MasterUserName\": ")
	if tmp, err := json.Marshal(strct.MasterUserName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MasterUserPassword" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MasterUserPassword\": ")
	if tmp, err := json.Marshal(strct.MasterUserPassword); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MasterUserOptions) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "MasterUserARN":
            if err := json.Unmarshal([]byte(v), &strct.MasterUserARN); err != nil {
                return err
             }
        case "MasterUserName":
            if err := json.Unmarshal([]byte(v), &strct.MasterUserName); err != nil {
                return err
             }
        case "MasterUserPassword":
            if err := json.Unmarshal([]byte(v), &strct.MasterUserPassword); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *NodeToNodeEncryptionOptions) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Enabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *NodeToNodeEncryptionOptions) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Enabled":
            if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AccessPolicies" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AccessPolicies\": ")
	if tmp, err := json.Marshal(strct.AccessPolicies); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AdvancedOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AdvancedOptions\": ")
	if tmp, err := json.Marshal(strct.AdvancedOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AdvancedSecurityOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AdvancedSecurityOptions\": ")
	if tmp, err := json.Marshal(strct.AdvancedSecurityOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Arn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Arn\": ")
	if tmp, err := json.Marshal(strct.Arn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ClusterConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ClusterConfig\": ")
	if tmp, err := json.Marshal(strct.ClusterConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CognitoOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CognitoOptions\": ")
	if tmp, err := json.Marshal(strct.CognitoOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DomainArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DomainArn\": ")
	if tmp, err := json.Marshal(strct.DomainArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DomainEndpoint" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DomainEndpoint\": ")
	if tmp, err := json.Marshal(strct.DomainEndpoint); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DomainEndpointOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DomainEndpointOptions\": ")
	if tmp, err := json.Marshal(strct.DomainEndpointOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DomainEndpoints" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DomainEndpoints\": ")
	if tmp, err := json.Marshal(strct.DomainEndpoints); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DomainName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DomainName\": ")
	if tmp, err := json.Marshal(strct.DomainName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EBSOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EBSOptions\": ")
	if tmp, err := json.Marshal(strct.EBSOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EncryptionAtRestOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EncryptionAtRestOptions\": ")
	if tmp, err := json.Marshal(strct.EncryptionAtRestOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EngineVersion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EngineVersion\": ")
	if tmp, err := json.Marshal(strct.EngineVersion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Id" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LogPublishingOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LogPublishingOptions\": ")
	if tmp, err := json.Marshal(strct.LogPublishingOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "NodeToNodeEncryptionOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NodeToNodeEncryptionOptions\": ")
	if tmp, err := json.Marshal(strct.NodeToNodeEncryptionOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ServiceSoftwareOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ServiceSoftwareOptions\": ")
	if tmp, err := json.Marshal(strct.ServiceSoftwareOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SnapshotOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SnapshotOptions\": ")
	if tmp, err := json.Marshal(strct.SnapshotOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VPCOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VPCOptions\": ")
	if tmp, err := json.Marshal(strct.VPCOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AccessPolicies":
            if err := json.Unmarshal([]byte(v), &strct.AccessPolicies); err != nil {
                return err
             }
        case "AdvancedOptions":
            if err := json.Unmarshal([]byte(v), &strct.AdvancedOptions); err != nil {
                return err
             }
        case "AdvancedSecurityOptions":
            if err := json.Unmarshal([]byte(v), &strct.AdvancedSecurityOptions); err != nil {
                return err
             }
        case "Arn":
            if err := json.Unmarshal([]byte(v), &strct.Arn); err != nil {
                return err
             }
        case "ClusterConfig":
            if err := json.Unmarshal([]byte(v), &strct.ClusterConfig); err != nil {
                return err
             }
        case "CognitoOptions":
            if err := json.Unmarshal([]byte(v), &strct.CognitoOptions); err != nil {
                return err
             }
        case "DomainArn":
            if err := json.Unmarshal([]byte(v), &strct.DomainArn); err != nil {
                return err
             }
        case "DomainEndpoint":
            if err := json.Unmarshal([]byte(v), &strct.DomainEndpoint); err != nil {
                return err
             }
        case "DomainEndpointOptions":
            if err := json.Unmarshal([]byte(v), &strct.DomainEndpointOptions); err != nil {
                return err
             }
        case "DomainEndpoints":
            if err := json.Unmarshal([]byte(v), &strct.DomainEndpoints); err != nil {
                return err
             }
        case "DomainName":
            if err := json.Unmarshal([]byte(v), &strct.DomainName); err != nil {
                return err
             }
        case "EBSOptions":
            if err := json.Unmarshal([]byte(v), &strct.EBSOptions); err != nil {
                return err
             }
        case "EncryptionAtRestOptions":
            if err := json.Unmarshal([]byte(v), &strct.EncryptionAtRestOptions); err != nil {
                return err
             }
        case "EngineVersion":
            if err := json.Unmarshal([]byte(v), &strct.EngineVersion); err != nil {
                return err
             }
        case "Id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
        case "LogPublishingOptions":
            if err := json.Unmarshal([]byte(v), &strct.LogPublishingOptions); err != nil {
                return err
             }
        case "NodeToNodeEncryptionOptions":
            if err := json.Unmarshal([]byte(v), &strct.NodeToNodeEncryptionOptions); err != nil {
                return err
             }
        case "ServiceSoftwareOptions":
            if err := json.Unmarshal([]byte(v), &strct.ServiceSoftwareOptions); err != nil {
                return err
             }
        case "SnapshotOptions":
            if err := json.Unmarshal([]byte(v), &strct.SnapshotOptions); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        case "VPCOptions":
            if err := json.Unmarshal([]byte(v), &strct.VPCOptions); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *SAMLOptions) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Enabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Idp" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Idp\": ")
	if tmp, err := json.Marshal(strct.Idp); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MasterBackendRole" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MasterBackendRole\": ")
	if tmp, err := json.Marshal(strct.MasterBackendRole); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MasterUserName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MasterUserName\": ")
	if tmp, err := json.Marshal(strct.MasterUserName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RolesKey" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RolesKey\": ")
	if tmp, err := json.Marshal(strct.RolesKey); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SessionTimeoutMinutes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SessionTimeoutMinutes\": ")
	if tmp, err := json.Marshal(strct.SessionTimeoutMinutes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SubjectKey" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SubjectKey\": ")
	if tmp, err := json.Marshal(strct.SubjectKey); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SAMLOptions) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Enabled":
            if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
                return err
             }
        case "Idp":
            if err := json.Unmarshal([]byte(v), &strct.Idp); err != nil {
                return err
             }
        case "MasterBackendRole":
            if err := json.Unmarshal([]byte(v), &strct.MasterBackendRole); err != nil {
                return err
             }
        case "MasterUserName":
            if err := json.Unmarshal([]byte(v), &strct.MasterUserName); err != nil {
                return err
             }
        case "RolesKey":
            if err := json.Unmarshal([]byte(v), &strct.RolesKey); err != nil {
                return err
             }
        case "SessionTimeoutMinutes":
            if err := json.Unmarshal([]byte(v), &strct.SessionTimeoutMinutes); err != nil {
                return err
             }
        case "SubjectKey":
            if err := json.Unmarshal([]byte(v), &strct.SubjectKey); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ServiceSoftwareOptions) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AutomatedUpdateDate" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AutomatedUpdateDate\": ")
	if tmp, err := json.Marshal(strct.AutomatedUpdateDate); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Cancellable" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Cancellable\": ")
	if tmp, err := json.Marshal(strct.Cancellable); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CurrentVersion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CurrentVersion\": ")
	if tmp, err := json.Marshal(strct.CurrentVersion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "NewVersion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NewVersion\": ")
	if tmp, err := json.Marshal(strct.NewVersion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OptionalDeployment" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OptionalDeployment\": ")
	if tmp, err := json.Marshal(strct.OptionalDeployment); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "UpdateAvailable" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UpdateAvailable\": ")
	if tmp, err := json.Marshal(strct.UpdateAvailable); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "UpdateStatus" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UpdateStatus\": ")
	if tmp, err := json.Marshal(strct.UpdateStatus); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ServiceSoftwareOptions) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AutomatedUpdateDate":
            if err := json.Unmarshal([]byte(v), &strct.AutomatedUpdateDate); err != nil {
                return err
             }
        case "Cancellable":
            if err := json.Unmarshal([]byte(v), &strct.Cancellable); err != nil {
                return err
             }
        case "CurrentVersion":
            if err := json.Unmarshal([]byte(v), &strct.CurrentVersion); err != nil {
                return err
             }
        case "Description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "NewVersion":
            if err := json.Unmarshal([]byte(v), &strct.NewVersion); err != nil {
                return err
             }
        case "OptionalDeployment":
            if err := json.Unmarshal([]byte(v), &strct.OptionalDeployment); err != nil {
                return err
             }
        case "UpdateAvailable":
            if err := json.Unmarshal([]byte(v), &strct.UpdateAvailable); err != nil {
                return err
             }
        case "UpdateStatus":
            if err := json.Unmarshal([]byte(v), &strct.UpdateStatus); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *SnapshotOptions) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AutomatedSnapshotStartHour" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AutomatedSnapshotStartHour\": ")
	if tmp, err := json.Marshal(strct.AutomatedSnapshotStartHour); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SnapshotOptions) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AutomatedSnapshotStartHour":
            if err := json.Unmarshal([]byte(v), &strct.AutomatedSnapshotStartHour); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *VPCOptions) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "SecurityGroupIds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SecurityGroupIds\": ")
	if tmp, err := json.Marshal(strct.SecurityGroupIds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SubnetIds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SubnetIds\": ")
	if tmp, err := json.Marshal(strct.SubnetIds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *VPCOptions) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "SecurityGroupIds":
            if err := json.Unmarshal([]byte(v), &strct.SecurityGroupIds); err != nil {
                return err
             }
        case "SubnetIds":
            if err := json.Unmarshal([]byte(v), &strct.SubnetIds); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ZoneAwarenessConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AvailabilityZoneCount" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AvailabilityZoneCount\": ")
	if tmp, err := json.Marshal(strct.AvailabilityZoneCount); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ZoneAwarenessConfig) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AvailabilityZoneCount":
            if err := json.Unmarshal([]byte(v), &strct.AvailabilityZoneCount); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}
