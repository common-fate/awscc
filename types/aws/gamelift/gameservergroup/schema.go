// Code generated by schema-generate. DO NOT EDIT.

package gameservergroup

import (
    "bytes"
    "errors"
    "encoding/json"
    "fmt"
)

// AutoScalingPolicy Configuration settings to define a scaling policy for the Auto Scaling group that is optimized for game hosting
type AutoScalingPolicy struct {
  EstimatedInstanceWarmup float64 `json:"EstimatedInstanceWarmup,omitempty"`
  TargetTrackingConfiguration *TargetTrackingConfiguration `json:"TargetTrackingConfiguration"`
}

// GameServerGroup Properties that describe a game server group resource. A game server group manages certain properties of a corresponding EC2 Auto Scaling group.
type GameServerGroup struct {
  AutoScalingGroupArn string `json:"AutoScalingGroupArn,omitempty"`
  BalancingStrategy string `json:"BalancingStrategy,omitempty"`
  CreationTime string `json:"CreationTime,omitempty"`
  GameServerGroupArn string `json:"GameServerGroupArn,omitempty"`
  GameServerGroupName string `json:"GameServerGroupName,omitempty"`
  GameServerProtectionPolicy string `json:"GameServerProtectionPolicy,omitempty"`
  InstanceDefinitions []*InstanceDefinition `json:"InstanceDefinitions,omitempty"`
  LastUpdatedTime string `json:"LastUpdatedTime,omitempty"`
  RoleArn string `json:"RoleArn,omitempty"`
  Status string `json:"Status,omitempty"`
  StatusReason string `json:"StatusReason,omitempty"`
  SuspendedActions []string `json:"SuspendedActions,omitempty"`
}

// InstanceDefinition An allowed instance type for your game server group.
type InstanceDefinition struct {
  InstanceType string `json:"InstanceType"`
  WeightedCapacity string `json:"WeightedCapacity,omitempty"`
}

// LaunchTemplate The EC2 launch template that contains configuration settings and game server code to be deployed to all instances in the game server group.
type LaunchTemplate struct {
  LaunchTemplateId string `json:"LaunchTemplateId,omitempty"`
  LaunchTemplateName string `json:"LaunchTemplateName,omitempty"`
  Version string `json:"Version,omitempty"`
}

// Resource The AWS::GameLift::GameServerGroup resource creates an Amazon GameLift (GameLift) GameServerGroup.
type Resource struct {

  // A generated unique ID for the EC2 Auto Scaling group that is associated with this game server group.
  AutoScalingGroupArn string `json:"AutoScalingGroupArn,omitempty"`

  // Configuration settings to define a scaling policy for the Auto Scaling group that is optimized for game hosting
  AutoScalingPolicy *AutoScalingPolicy `json:"AutoScalingPolicy,omitempty"`

  // The fallback balancing method to use for the game server group when Spot Instances in a Region become unavailable or are not viable for game hosting.
  BalancingStrategy string `json:"BalancingStrategy,omitempty"`

  // The type of delete to perform.
  DeleteOption string `json:"DeleteOption,omitempty"`

  // A generated unique ID for the game server group.
  GameServerGroupArn string `json:"GameServerGroupArn,omitempty"`

  // An identifier for the new game server group.
  GameServerGroupName string `json:"GameServerGroupName"`

  // A flag that indicates whether instances in the game server group are protected from early termination.
  GameServerProtectionPolicy string `json:"GameServerProtectionPolicy,omitempty"`

  // A set of EC2 instance types to use when creating instances in the group.
  InstanceDefinitions []*InstanceDefinition `json:"InstanceDefinitions"`

  // The EC2 launch template that contains configuration settings and game server code to be deployed to all instances in the game server group.
  LaunchTemplate *LaunchTemplate `json:"LaunchTemplate"`

  // The maximum number of instances allowed in the EC2 Auto Scaling group.
  MaxSize float64 `json:"MaxSize,omitempty"`

  // The minimum number of instances allowed in the EC2 Auto Scaling group.
  MinSize float64 `json:"MinSize,omitempty"`

  // The Amazon Resource Name (ARN) for an IAM role that allows Amazon GameLift to access your EC2 Auto Scaling groups.
  RoleArn string `json:"RoleArn"`

  // A list of labels to assign to the new game server group resource.
  Tags []*Tag `json:"Tags,omitempty"`

  // A list of virtual private cloud (VPC) subnets to use with instances in the game server group.
  VpcSubnets []string `json:"VpcSubnets,omitempty"`
}

// Tag 
type Tag struct {

  // The key for a developer-defined key:value pair for tagging an AWS resource.
  Key string `json:"Key,omitempty"`

  // The value for a developer-defined key:value pair for tagging an AWS resource.
  Value string `json:"Value,omitempty"`
}

// TargetTrackingConfiguration Settings for a target-based scaling policy applied to Auto Scaling group.
type TargetTrackingConfiguration struct {
  TargetValue float64 `json:"TargetValue"`
}

func (strct *AutoScalingPolicy) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "EstimatedInstanceWarmup" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EstimatedInstanceWarmup\": ")
	if tmp, err := json.Marshal(strct.EstimatedInstanceWarmup); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TargetTrackingConfiguration" field is required
    if strct.TargetTrackingConfiguration == nil {
        return nil, errors.New("TargetTrackingConfiguration is a required field")
    }
    // Marshal the "TargetTrackingConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TargetTrackingConfiguration\": ")
	if tmp, err := json.Marshal(strct.TargetTrackingConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AutoScalingPolicy) UnmarshalJSON(b []byte) error {
    TargetTrackingConfigurationReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "EstimatedInstanceWarmup":
            if err := json.Unmarshal([]byte(v), &strct.EstimatedInstanceWarmup); err != nil {
                return err
             }
        case "TargetTrackingConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.TargetTrackingConfiguration); err != nil {
                return err
             }
            TargetTrackingConfigurationReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if TargetTrackingConfiguration (a required property) was received
    if !TargetTrackingConfigurationReceived {
        return errors.New("\"TargetTrackingConfiguration\" is required but was not present")
    }
    return nil
}

func (strct *GameServerGroup) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AutoScalingGroupArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AutoScalingGroupArn\": ")
	if tmp, err := json.Marshal(strct.AutoScalingGroupArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BalancingStrategy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BalancingStrategy\": ")
	if tmp, err := json.Marshal(strct.BalancingStrategy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CreationTime" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CreationTime\": ")
	if tmp, err := json.Marshal(strct.CreationTime); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "GameServerGroupArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"GameServerGroupArn\": ")
	if tmp, err := json.Marshal(strct.GameServerGroupArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "GameServerGroupName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"GameServerGroupName\": ")
	if tmp, err := json.Marshal(strct.GameServerGroupName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "GameServerProtectionPolicy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"GameServerProtectionPolicy\": ")
	if tmp, err := json.Marshal(strct.GameServerProtectionPolicy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "InstanceDefinitions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InstanceDefinitions\": ")
	if tmp, err := json.Marshal(strct.InstanceDefinitions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LastUpdatedTime" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LastUpdatedTime\": ")
	if tmp, err := json.Marshal(strct.LastUpdatedTime); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoleArn\": ")
	if tmp, err := json.Marshal(strct.RoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Status" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Status\": ")
	if tmp, err := json.Marshal(strct.Status); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StatusReason" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StatusReason\": ")
	if tmp, err := json.Marshal(strct.StatusReason); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SuspendedActions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SuspendedActions\": ")
	if tmp, err := json.Marshal(strct.SuspendedActions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *GameServerGroup) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AutoScalingGroupArn":
            if err := json.Unmarshal([]byte(v), &strct.AutoScalingGroupArn); err != nil {
                return err
             }
        case "BalancingStrategy":
            if err := json.Unmarshal([]byte(v), &strct.BalancingStrategy); err != nil {
                return err
             }
        case "CreationTime":
            if err := json.Unmarshal([]byte(v), &strct.CreationTime); err != nil {
                return err
             }
        case "GameServerGroupArn":
            if err := json.Unmarshal([]byte(v), &strct.GameServerGroupArn); err != nil {
                return err
             }
        case "GameServerGroupName":
            if err := json.Unmarshal([]byte(v), &strct.GameServerGroupName); err != nil {
                return err
             }
        case "GameServerProtectionPolicy":
            if err := json.Unmarshal([]byte(v), &strct.GameServerProtectionPolicy); err != nil {
                return err
             }
        case "InstanceDefinitions":
            if err := json.Unmarshal([]byte(v), &strct.InstanceDefinitions); err != nil {
                return err
             }
        case "LastUpdatedTime":
            if err := json.Unmarshal([]byte(v), &strct.LastUpdatedTime); err != nil {
                return err
             }
        case "RoleArn":
            if err := json.Unmarshal([]byte(v), &strct.RoleArn); err != nil {
                return err
             }
        case "Status":
            if err := json.Unmarshal([]byte(v), &strct.Status); err != nil {
                return err
             }
        case "StatusReason":
            if err := json.Unmarshal([]byte(v), &strct.StatusReason); err != nil {
                return err
             }
        case "SuspendedActions":
            if err := json.Unmarshal([]byte(v), &strct.SuspendedActions); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *InstanceDefinition) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "InstanceType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "InstanceType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InstanceType\": ")
	if tmp, err := json.Marshal(strct.InstanceType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "WeightedCapacity" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"WeightedCapacity\": ")
	if tmp, err := json.Marshal(strct.WeightedCapacity); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *InstanceDefinition) UnmarshalJSON(b []byte) error {
    InstanceTypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "InstanceType":
            if err := json.Unmarshal([]byte(v), &strct.InstanceType); err != nil {
                return err
             }
            InstanceTypeReceived = true
        case "WeightedCapacity":
            if err := json.Unmarshal([]byte(v), &strct.WeightedCapacity); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if InstanceType (a required property) was received
    if !InstanceTypeReceived {
        return errors.New("\"InstanceType\" is required but was not present")
    }
    return nil
}

func (strct *LaunchTemplate) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "LaunchTemplateId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LaunchTemplateId\": ")
	if tmp, err := json.Marshal(strct.LaunchTemplateId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LaunchTemplateName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LaunchTemplateName\": ")
	if tmp, err := json.Marshal(strct.LaunchTemplateName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Version" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Version\": ")
	if tmp, err := json.Marshal(strct.Version); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LaunchTemplate) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "LaunchTemplateId":
            if err := json.Unmarshal([]byte(v), &strct.LaunchTemplateId); err != nil {
                return err
             }
        case "LaunchTemplateName":
            if err := json.Unmarshal([]byte(v), &strct.LaunchTemplateName); err != nil {
                return err
             }
        case "Version":
            if err := json.Unmarshal([]byte(v), &strct.Version); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AutoScalingGroupArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AutoScalingGroupArn\": ")
	if tmp, err := json.Marshal(strct.AutoScalingGroupArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AutoScalingPolicy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AutoScalingPolicy\": ")
	if tmp, err := json.Marshal(strct.AutoScalingPolicy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BalancingStrategy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BalancingStrategy\": ")
	if tmp, err := json.Marshal(strct.BalancingStrategy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DeleteOption" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DeleteOption\": ")
	if tmp, err := json.Marshal(strct.DeleteOption); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "GameServerGroupArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"GameServerGroupArn\": ")
	if tmp, err := json.Marshal(strct.GameServerGroupArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "GameServerGroupName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "GameServerGroupName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"GameServerGroupName\": ")
	if tmp, err := json.Marshal(strct.GameServerGroupName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "GameServerProtectionPolicy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"GameServerProtectionPolicy\": ")
	if tmp, err := json.Marshal(strct.GameServerProtectionPolicy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "InstanceDefinitions" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "InstanceDefinitions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InstanceDefinitions\": ")
	if tmp, err := json.Marshal(strct.InstanceDefinitions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "LaunchTemplate" field is required
    if strct.LaunchTemplate == nil {
        return nil, errors.New("LaunchTemplate is a required field")
    }
    // Marshal the "LaunchTemplate" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LaunchTemplate\": ")
	if tmp, err := json.Marshal(strct.LaunchTemplate); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MaxSize" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaxSize\": ")
	if tmp, err := json.Marshal(strct.MaxSize); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MinSize" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MinSize\": ")
	if tmp, err := json.Marshal(strct.MinSize); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RoleArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoleArn\": ")
	if tmp, err := json.Marshal(strct.RoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VpcSubnets" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VpcSubnets\": ")
	if tmp, err := json.Marshal(strct.VpcSubnets); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    GameServerGroupNameReceived := false
    InstanceDefinitionsReceived := false
    LaunchTemplateReceived := false
    RoleArnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AutoScalingGroupArn":
            if err := json.Unmarshal([]byte(v), &strct.AutoScalingGroupArn); err != nil {
                return err
             }
        case "AutoScalingPolicy":
            if err := json.Unmarshal([]byte(v), &strct.AutoScalingPolicy); err != nil {
                return err
             }
        case "BalancingStrategy":
            if err := json.Unmarshal([]byte(v), &strct.BalancingStrategy); err != nil {
                return err
             }
        case "DeleteOption":
            if err := json.Unmarshal([]byte(v), &strct.DeleteOption); err != nil {
                return err
             }
        case "GameServerGroupArn":
            if err := json.Unmarshal([]byte(v), &strct.GameServerGroupArn); err != nil {
                return err
             }
        case "GameServerGroupName":
            if err := json.Unmarshal([]byte(v), &strct.GameServerGroupName); err != nil {
                return err
             }
            GameServerGroupNameReceived = true
        case "GameServerProtectionPolicy":
            if err := json.Unmarshal([]byte(v), &strct.GameServerProtectionPolicy); err != nil {
                return err
             }
        case "InstanceDefinitions":
            if err := json.Unmarshal([]byte(v), &strct.InstanceDefinitions); err != nil {
                return err
             }
            InstanceDefinitionsReceived = true
        case "LaunchTemplate":
            if err := json.Unmarshal([]byte(v), &strct.LaunchTemplate); err != nil {
                return err
             }
            LaunchTemplateReceived = true
        case "MaxSize":
            if err := json.Unmarshal([]byte(v), &strct.MaxSize); err != nil {
                return err
             }
        case "MinSize":
            if err := json.Unmarshal([]byte(v), &strct.MinSize); err != nil {
                return err
             }
        case "RoleArn":
            if err := json.Unmarshal([]byte(v), &strct.RoleArn); err != nil {
                return err
             }
            RoleArnReceived = true
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        case "VpcSubnets":
            if err := json.Unmarshal([]byte(v), &strct.VpcSubnets); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if GameServerGroupName (a required property) was received
    if !GameServerGroupNameReceived {
        return errors.New("\"GameServerGroupName\" is required but was not present")
    }
    // check if InstanceDefinitions (a required property) was received
    if !InstanceDefinitionsReceived {
        return errors.New("\"InstanceDefinitions\" is required but was not present")
    }
    // check if LaunchTemplate (a required property) was received
    if !LaunchTemplateReceived {
        return errors.New("\"LaunchTemplate\" is required but was not present")
    }
    // check if RoleArn (a required property) was received
    if !RoleArnReceived {
        return errors.New("\"RoleArn\" is required but was not present")
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *TargetTrackingConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "TargetValue" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TargetValue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TargetValue\": ")
	if tmp, err := json.Marshal(strct.TargetValue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TargetTrackingConfiguration) UnmarshalJSON(b []byte) error {
    TargetValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "TargetValue":
            if err := json.Unmarshal([]byte(v), &strct.TargetValue); err != nil {
                return err
             }
            TargetValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if TargetValue (a required property) was received
    if !TargetValueReceived {
        return errors.New("\"TargetValue\" is required but was not present")
    }
    return nil
}
