// Code generated by schema-generate. DO NOT EDIT.

package fleet

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// AnywhereConfiguration Configuration for Anywhere fleet.
type AnywhereConfiguration struct {

  // Cost of compute can be specified on Anywhere Fleets to prioritize placement across Queue destinations based on Cost.
  Cost string `json:"Cost"`
}

// CertificateConfiguration Information about the use of a TLS/SSL certificate for a fleet. TLS certificate generation is enabled at the fleet level, with one certificate generated for the fleet. When this feature is enabled, the certificate can be retrieved using the GameLift Server SDK call GetInstanceCertificate. All instances in a fleet share the same certificate.
type CertificateConfiguration struct {
  CertificateType string `json:"CertificateType"`
}

// IpPermission A range of IP addresses and port settings that allow inbound traffic to connect to server processes on an Amazon GameLift hosting resource. New game sessions that are started on the fleet are assigned an IP address/port number combination, which must fall into the fleet's allowed ranges. For fleets created with a custom game server, the ranges reflect the server's game session assignments. For Realtime Servers fleets, Amazon GameLift automatically opens two port ranges, one for TCP messaging and one for UDP, for use by the Realtime servers.
type IpPermission struct {

  // A starting value for a range of allowed port numbers.
  FromPort int `json:"FromPort"`

  // A range of allowed IP addresses. This value must be expressed in CIDR notation. Example: "000.000.000.000/[subnet mask]" or optionally the shortened version "0.0.0.0/[subnet mask]".
  IpRange string `json:"IpRange"`

  // The network communication protocol used by the fleet.
  Protocol string `json:"Protocol"`

  // An ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than FromPort.
  ToPort int `json:"ToPort"`
}

// LocationCapacity Current resource capacity settings in a specified fleet or location. The location value might refer to a fleet's remote location or its home Region.
type LocationCapacity struct {

  // The number of EC2 instances you want to maintain in the specified fleet location. This value must fall between the minimum and maximum size limits.
  DesiredEC2Instances int `json:"DesiredEC2Instances"`

  // The maximum value that is allowed for the fleet's instance count for a location. When creating a new fleet, GameLift automatically sets this value to "1". Once the fleet is active, you can change this value.
  MaxSize int `json:"MaxSize"`

  // The minimum value allowed for the fleet's instance count for a location. When creating a new fleet, GameLift automatically sets this value to "0". After the fleet is active, you can change this value.
  MinSize int `json:"MinSize"`
}

// LocationConfiguration A remote location where a multi-location fleet can deploy EC2 instances for game hosting.
type LocationConfiguration struct {
  Location string `json:"Location"`
  LocationCapacity *LocationCapacity `json:"LocationCapacity,omitempty"`
}

// Resource The AWS::GameLift::Fleet resource creates an Amazon GameLift (GameLift) fleet to host game servers. A fleet is a set of EC2 or Anywhere instances, each of which can host multiple game sessions.
type Resource struct {

  // Configuration for Anywhere fleet.
  AnywhereConfiguration *AnywhereConfiguration `json:"AnywhereConfiguration,omitempty"`

  // A unique identifier for a build to be deployed on the new fleet. If you are deploying the fleet with a custom game build, you must specify this property. The build must have been successfully uploaded to Amazon GameLift and be in a READY status. This fleet setting cannot be changed once the fleet is created.
  BuildId string `json:"BuildId,omitempty"`

  // Indicates whether to generate a TLS/SSL certificate for the new fleet. TLS certificates are used for encrypting traffic between game clients and game servers running on GameLift. If this parameter is not set, certificate generation is disabled. This fleet setting cannot be changed once the fleet is created.
  CertificateConfiguration *CertificateConfiguration `json:"CertificateConfiguration,omitempty"`

  // ComputeType to differentiate EC2 hardware managed by GameLift and Anywhere hardware managed by the customer.
  ComputeType string `json:"ComputeType,omitempty"`

  // A human-readable description of a fleet.
  Description string `json:"Description,omitempty"`

  // [DEPRECATED] The number of EC2 instances that you want this fleet to host. When creating a new fleet, GameLift automatically sets this value to "1" and initiates a single instance. Once the fleet is active, update this value to trigger GameLift to add or remove instances from the fleet.
  DesiredEC2Instances int `json:"DesiredEC2Instances,omitempty"`

  // A range of IP addresses and port settings that allow inbound traffic to connect to server processes on an Amazon GameLift server.
  EC2InboundPermissions []*IpPermission `json:"EC2InboundPermissions,omitempty"`

  // The name of an EC2 instance type that is supported in Amazon GameLift. A fleet instance type determines the computing resources of each instance in the fleet, including CPU, memory, storage, and networking capacity. Amazon GameLift supports the following EC2 instance types. See Amazon EC2 Instance Types for detailed descriptions.
  EC2InstanceType string `json:"EC2InstanceType,omitempty"`

  // Unique fleet ID
  FleetId string `json:"FleetId,omitempty"`

  // Indicates whether to use On-Demand instances or Spot instances for this fleet. If empty, the default is ON_DEMAND. Both categories of instances use identical hardware and configurations based on the instance type selected for this fleet.
  FleetType string `json:"FleetType,omitempty"`

  // A unique identifier for an AWS IAM role that manages access to your AWS services. With an instance role ARN set, any application that runs on an instance in this fleet can assume the role, including install scripts, server processes, and daemons (background processes). Create a role or look up a role's ARN from the IAM dashboard in the AWS Management Console.
  InstanceRoleARN string `json:"InstanceRoleARN,omitempty"`
  Locations []*LocationConfiguration `json:"Locations,omitempty"`

  // This parameter is no longer used. When hosting a custom game build, specify where Amazon GameLift should store log files using the Amazon GameLift server API call ProcessReady()
  LogPaths []string `json:"LogPaths,omitempty"`

  // [DEPRECATED] The maximum value that is allowed for the fleet's instance count. When creating a new fleet, GameLift automatically sets this value to "1". Once the fleet is active, you can change this value.
  MaxSize int `json:"MaxSize,omitempty"`

  // The name of an Amazon CloudWatch metric group. A metric group aggregates the metrics for all fleets in the group. Specify a string containing the metric group name. You can use an existing name or use a new name to create a new metric group. Currently, this parameter can have only one string.
  MetricGroups []string `json:"MetricGroups,omitempty"`

  // [DEPRECATED] The minimum value allowed for the fleet's instance count. When creating a new fleet, GameLift automatically sets this value to "0". After the fleet is active, you can change this value.
  MinSize int `json:"MinSize,omitempty"`

  // A descriptive label that is associated with a fleet. Fleet names do not need to be unique.
  Name string `json:"Name"`

  // A game session protection policy to apply to all game sessions hosted on instances in this fleet. When protected, active game sessions cannot be terminated during a scale-down event. If this parameter is not set, instances in this fleet default to no protection. You can change a fleet's protection policy to affect future game sessions on the fleet. You can also set protection for individual game sessions.
  NewGameSessionProtectionPolicy string `json:"NewGameSessionProtectionPolicy,omitempty"`

  // A unique identifier for the AWS account with the VPC that you want to peer your Amazon GameLift fleet with. You can find your account ID in the AWS Management Console under account settings.
  PeerVpcAwsAccountId string `json:"PeerVpcAwsAccountId,omitempty"`

  // A unique identifier for a VPC with resources to be accessed by your Amazon GameLift fleet. The VPC must be in the same Region as your fleet. To look up a VPC ID, use the VPC Dashboard in the AWS Management Console.
  PeerVpcId string `json:"PeerVpcId,omitempty"`

  // A policy that limits the number of game sessions an individual player can create over a span of time for this fleet.
  ResourceCreationLimitPolicy *ResourceCreationLimitPolicy `json:"ResourceCreationLimitPolicy,omitempty"`

  // Instructions for launching server processes on each instance in the fleet. Server processes run either a custom game build executable or a Realtime script. The runtime configuration defines the server executables or launch script file, launch parameters, and the number of processes to run concurrently on each instance. When creating a fleet, the runtime configuration must have at least one server process configuration; otherwise the request fails with an invalid request exception.
  // 
  // This parameter is required unless the parameters ServerLaunchPath and ServerLaunchParameters are defined. Runtime configuration has replaced these parameters, but fleets that use them will continue to work.
  RuntimeConfiguration *RuntimeConfiguration `json:"RuntimeConfiguration,omitempty"`

  // A unique identifier for a Realtime script to be deployed on a new Realtime Servers fleet. The script must have been successfully uploaded to Amazon GameLift. This fleet setting cannot be changed once the fleet is created.
  // 
  // Note: It is not currently possible to use the !Ref command to reference a script created with a CloudFormation template for the fleet property ScriptId. Instead, use Fn::GetAtt Script.Arn or Fn::GetAtt Script.Id to retrieve either of these properties as input for ScriptId. Alternatively, enter a ScriptId string manually.
  ScriptId string `json:"ScriptId,omitempty"`

  // This parameter is no longer used but is retained for backward compatibility. Instead, specify server launch parameters in the RuntimeConfiguration parameter. A request must specify either a runtime configuration or values for both ServerLaunchParameters and ServerLaunchPath.
  ServerLaunchParameters string `json:"ServerLaunchParameters,omitempty"`

  // This parameter is no longer used. Instead, specify a server launch path using the RuntimeConfiguration parameter. Requests that specify a server launch path and launch parameters instead of a runtime configuration will continue to work.
  ServerLaunchPath string `json:"ServerLaunchPath,omitempty"`
}

// ResourceCreationLimitPolicy A policy that limits the number of game sessions a player can create on the same fleet. This optional policy gives game owners control over how players can consume available game server resources. A resource creation policy makes the following statement: "An individual player can create a maximum number of new game sessions within a specified time period".
// 
// The policy is evaluated when a player tries to create a new game session. For example, assume you have a policy of 10 new game sessions and a time period of 60 minutes. On receiving a CreateGameSession request, Amazon GameLift checks that the player (identified by CreatorId) has created fewer than 10 game sessions in the past 60 minutes.
type ResourceCreationLimitPolicy struct {

  // The maximum number of game sessions that an individual can create during the policy period.
  NewGameSessionsPerCreator int `json:"NewGameSessionsPerCreator,omitempty"`

  // The time span used in evaluating the resource creation limit policy.
  PolicyPeriodInMinutes int `json:"PolicyPeriodInMinutes,omitempty"`
}

// RuntimeConfiguration A collection of server process configurations that describe the processes to run on each instance in a fleet. All fleets must have a runtime configuration. Each instance in the fleet maintains server processes as specified in the runtime configuration, launching new ones as existing processes end. Each instance regularly checks for an updated runtime configuration makes adjustments as called for.
// 
// The runtime configuration enables the instances in a fleet to run multiple processes simultaneously. Potential scenarios are as follows: (1) Run multiple processes of a single game server executable to maximize usage of your hosting resources. (2) Run one or more processes of different executables, such as your game server and a metrics tracking program. (3) Run multiple processes of a single game server but with different launch parameters, for example to run one process on each instance in debug mode.
// 
// An Amazon GameLift instance is limited to 50 processes running simultaneously. A runtime configuration must specify fewer than this limit. To calculate the total number of processes specified in a runtime configuration, add the values of the ConcurrentExecutions parameter for each ServerProcess object in the runtime configuration.
type RuntimeConfiguration struct {

  // The maximum amount of time (in seconds) that a game session can remain in status ACTIVATING. If the game session is not active before the timeout, activation is terminated and the game session status is changed to TERMINATED.
  GameSessionActivationTimeoutSeconds int `json:"GameSessionActivationTimeoutSeconds,omitempty"`

  // The maximum number of game sessions with status ACTIVATING to allow on an instance simultaneously. This setting limits the amount of instance resources that can be used for new game activations at any one time.
  MaxConcurrentGameSessionActivations int `json:"MaxConcurrentGameSessionActivations,omitempty"`

  // A collection of server process configurations that describe which server processes to run on each instance in a fleet.
  ServerProcesses []*ServerProcess `json:"ServerProcesses,omitempty"`
}

// ServerProcess A set of instructions for launching server processes on each instance in a fleet. Each instruction set identifies the location of the server executable, optional launch parameters, and the number of server processes with this configuration to maintain concurrently on the instance. Server process configurations make up a fleet's RuntimeConfiguration.
type ServerProcess struct {

  // The number of server processes that use this configuration to run concurrently on an instance.
  ConcurrentExecutions int `json:"ConcurrentExecutions"`

  // The location of the server executable in a custom game build or the name of the Realtime script file that contains the Init() function. Game builds and Realtime scripts are installed on instances at the root:
  // 
  // Windows (for custom game builds only): C:\game. Example: "C:\game\MyGame\server.exe"
  // 
  // Linux: /local/game. Examples: "/local/game/MyGame/server.exe" or "/local/game/MyRealtimeScript.js"
  LaunchPath string `json:"LaunchPath"`

  // An optional list of parameters to pass to the server executable or Realtime script on launch.
  Parameters string `json:"Parameters,omitempty"`
}

func (strct *AnywhereConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Cost" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Cost" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Cost\": ")
	if tmp, err := json.Marshal(strct.Cost); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AnywhereConfiguration) UnmarshalJSON(b []byte) error {
    CostReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Cost":
            if err := json.Unmarshal([]byte(v), &strct.Cost); err != nil {
                return err
             }
            CostReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Cost (a required property) was received
    if !CostReceived {
        return errors.New("\"Cost\" is required but was not present")
    }
    return nil
}

func (strct *CertificateConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "CertificateType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "CertificateType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CertificateType\": ")
	if tmp, err := json.Marshal(strct.CertificateType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CertificateConfiguration) UnmarshalJSON(b []byte) error {
    CertificateTypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CertificateType":
            if err := json.Unmarshal([]byte(v), &strct.CertificateType); err != nil {
                return err
             }
            CertificateTypeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if CertificateType (a required property) was received
    if !CertificateTypeReceived {
        return errors.New("\"CertificateType\" is required but was not present")
    }
    return nil
}

func (strct *IpPermission) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "FromPort" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "FromPort" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FromPort\": ")
	if tmp, err := json.Marshal(strct.FromPort); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "IpRange" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "IpRange" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IpRange\": ")
	if tmp, err := json.Marshal(strct.IpRange); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Protocol" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Protocol" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Protocol\": ")
	if tmp, err := json.Marshal(strct.Protocol); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ToPort" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ToPort" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ToPort\": ")
	if tmp, err := json.Marshal(strct.ToPort); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *IpPermission) UnmarshalJSON(b []byte) error {
    FromPortReceived := false
    IpRangeReceived := false
    ProtocolReceived := false
    ToPortReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "FromPort":
            if err := json.Unmarshal([]byte(v), &strct.FromPort); err != nil {
                return err
             }
            FromPortReceived = true
        case "IpRange":
            if err := json.Unmarshal([]byte(v), &strct.IpRange); err != nil {
                return err
             }
            IpRangeReceived = true
        case "Protocol":
            if err := json.Unmarshal([]byte(v), &strct.Protocol); err != nil {
                return err
             }
            ProtocolReceived = true
        case "ToPort":
            if err := json.Unmarshal([]byte(v), &strct.ToPort); err != nil {
                return err
             }
            ToPortReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if FromPort (a required property) was received
    if !FromPortReceived {
        return errors.New("\"FromPort\" is required but was not present")
    }
    // check if IpRange (a required property) was received
    if !IpRangeReceived {
        return errors.New("\"IpRange\" is required but was not present")
    }
    // check if Protocol (a required property) was received
    if !ProtocolReceived {
        return errors.New("\"Protocol\" is required but was not present")
    }
    // check if ToPort (a required property) was received
    if !ToPortReceived {
        return errors.New("\"ToPort\" is required but was not present")
    }
    return nil
}

func (strct *LocationCapacity) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "DesiredEC2Instances" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "DesiredEC2Instances" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DesiredEC2Instances\": ")
	if tmp, err := json.Marshal(strct.DesiredEC2Instances); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "MaxSize" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "MaxSize" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaxSize\": ")
	if tmp, err := json.Marshal(strct.MaxSize); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "MinSize" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "MinSize" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MinSize\": ")
	if tmp, err := json.Marshal(strct.MinSize); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LocationCapacity) UnmarshalJSON(b []byte) error {
    DesiredEC2InstancesReceived := false
    MaxSizeReceived := false
    MinSizeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DesiredEC2Instances":
            if err := json.Unmarshal([]byte(v), &strct.DesiredEC2Instances); err != nil {
                return err
             }
            DesiredEC2InstancesReceived = true
        case "MaxSize":
            if err := json.Unmarshal([]byte(v), &strct.MaxSize); err != nil {
                return err
             }
            MaxSizeReceived = true
        case "MinSize":
            if err := json.Unmarshal([]byte(v), &strct.MinSize); err != nil {
                return err
             }
            MinSizeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if DesiredEC2Instances (a required property) was received
    if !DesiredEC2InstancesReceived {
        return errors.New("\"DesiredEC2Instances\" is required but was not present")
    }
    // check if MaxSize (a required property) was received
    if !MaxSizeReceived {
        return errors.New("\"MaxSize\" is required but was not present")
    }
    // check if MinSize (a required property) was received
    if !MinSizeReceived {
        return errors.New("\"MinSize\" is required but was not present")
    }
    return nil
}

func (strct *LocationConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Location" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Location" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Location\": ")
	if tmp, err := json.Marshal(strct.Location); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LocationCapacity" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LocationCapacity\": ")
	if tmp, err := json.Marshal(strct.LocationCapacity); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LocationConfiguration) UnmarshalJSON(b []byte) error {
    LocationReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Location":
            if err := json.Unmarshal([]byte(v), &strct.Location); err != nil {
                return err
             }
            LocationReceived = true
        case "LocationCapacity":
            if err := json.Unmarshal([]byte(v), &strct.LocationCapacity); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Location (a required property) was received
    if !LocationReceived {
        return errors.New("\"Location\" is required but was not present")
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AnywhereConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AnywhereConfiguration\": ")
	if tmp, err := json.Marshal(strct.AnywhereConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BuildId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BuildId\": ")
	if tmp, err := json.Marshal(strct.BuildId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CertificateConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CertificateConfiguration\": ")
	if tmp, err := json.Marshal(strct.CertificateConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ComputeType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ComputeType\": ")
	if tmp, err := json.Marshal(strct.ComputeType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DesiredEC2Instances" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DesiredEC2Instances\": ")
	if tmp, err := json.Marshal(strct.DesiredEC2Instances); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EC2InboundPermissions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EC2InboundPermissions\": ")
	if tmp, err := json.Marshal(strct.EC2InboundPermissions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EC2InstanceType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EC2InstanceType\": ")
	if tmp, err := json.Marshal(strct.EC2InstanceType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FleetId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FleetId\": ")
	if tmp, err := json.Marshal(strct.FleetId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FleetType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FleetType\": ")
	if tmp, err := json.Marshal(strct.FleetType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "InstanceRoleARN" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InstanceRoleARN\": ")
	if tmp, err := json.Marshal(strct.InstanceRoleARN); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Locations" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Locations\": ")
	if tmp, err := json.Marshal(strct.Locations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LogPaths" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LogPaths\": ")
	if tmp, err := json.Marshal(strct.LogPaths); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MaxSize" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaxSize\": ")
	if tmp, err := json.Marshal(strct.MaxSize); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MetricGroups" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MetricGroups\": ")
	if tmp, err := json.Marshal(strct.MetricGroups); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MinSize" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MinSize\": ")
	if tmp, err := json.Marshal(strct.MinSize); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "NewGameSessionProtectionPolicy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NewGameSessionProtectionPolicy\": ")
	if tmp, err := json.Marshal(strct.NewGameSessionProtectionPolicy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PeerVpcAwsAccountId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PeerVpcAwsAccountId\": ")
	if tmp, err := json.Marshal(strct.PeerVpcAwsAccountId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PeerVpcId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PeerVpcId\": ")
	if tmp, err := json.Marshal(strct.PeerVpcId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ResourceCreationLimitPolicy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ResourceCreationLimitPolicy\": ")
	if tmp, err := json.Marshal(strct.ResourceCreationLimitPolicy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RuntimeConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RuntimeConfiguration\": ")
	if tmp, err := json.Marshal(strct.RuntimeConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ScriptId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ScriptId\": ")
	if tmp, err := json.Marshal(strct.ScriptId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ServerLaunchParameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ServerLaunchParameters\": ")
	if tmp, err := json.Marshal(strct.ServerLaunchParameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ServerLaunchPath" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ServerLaunchPath\": ")
	if tmp, err := json.Marshal(strct.ServerLaunchPath); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    NameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AnywhereConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.AnywhereConfiguration); err != nil {
                return err
             }
        case "BuildId":
            if err := json.Unmarshal([]byte(v), &strct.BuildId); err != nil {
                return err
             }
        case "CertificateConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.CertificateConfiguration); err != nil {
                return err
             }
        case "ComputeType":
            if err := json.Unmarshal([]byte(v), &strct.ComputeType); err != nil {
                return err
             }
        case "Description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "DesiredEC2Instances":
            if err := json.Unmarshal([]byte(v), &strct.DesiredEC2Instances); err != nil {
                return err
             }
        case "EC2InboundPermissions":
            if err := json.Unmarshal([]byte(v), &strct.EC2InboundPermissions); err != nil {
                return err
             }
        case "EC2InstanceType":
            if err := json.Unmarshal([]byte(v), &strct.EC2InstanceType); err != nil {
                return err
             }
        case "FleetId":
            if err := json.Unmarshal([]byte(v), &strct.FleetId); err != nil {
                return err
             }
        case "FleetType":
            if err := json.Unmarshal([]byte(v), &strct.FleetType); err != nil {
                return err
             }
        case "InstanceRoleARN":
            if err := json.Unmarshal([]byte(v), &strct.InstanceRoleARN); err != nil {
                return err
             }
        case "Locations":
            if err := json.Unmarshal([]byte(v), &strct.Locations); err != nil {
                return err
             }
        case "LogPaths":
            if err := json.Unmarshal([]byte(v), &strct.LogPaths); err != nil {
                return err
             }
        case "MaxSize":
            if err := json.Unmarshal([]byte(v), &strct.MaxSize); err != nil {
                return err
             }
        case "MetricGroups":
            if err := json.Unmarshal([]byte(v), &strct.MetricGroups); err != nil {
                return err
             }
        case "MinSize":
            if err := json.Unmarshal([]byte(v), &strct.MinSize); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        case "NewGameSessionProtectionPolicy":
            if err := json.Unmarshal([]byte(v), &strct.NewGameSessionProtectionPolicy); err != nil {
                return err
             }
        case "PeerVpcAwsAccountId":
            if err := json.Unmarshal([]byte(v), &strct.PeerVpcAwsAccountId); err != nil {
                return err
             }
        case "PeerVpcId":
            if err := json.Unmarshal([]byte(v), &strct.PeerVpcId); err != nil {
                return err
             }
        case "ResourceCreationLimitPolicy":
            if err := json.Unmarshal([]byte(v), &strct.ResourceCreationLimitPolicy); err != nil {
                return err
             }
        case "RuntimeConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.RuntimeConfiguration); err != nil {
                return err
             }
        case "ScriptId":
            if err := json.Unmarshal([]byte(v), &strct.ScriptId); err != nil {
                return err
             }
        case "ServerLaunchParameters":
            if err := json.Unmarshal([]byte(v), &strct.ServerLaunchParameters); err != nil {
                return err
             }
        case "ServerLaunchPath":
            if err := json.Unmarshal([]byte(v), &strct.ServerLaunchPath); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    return nil
}

func (strct *ResourceCreationLimitPolicy) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "NewGameSessionsPerCreator" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NewGameSessionsPerCreator\": ")
	if tmp, err := json.Marshal(strct.NewGameSessionsPerCreator); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PolicyPeriodInMinutes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PolicyPeriodInMinutes\": ")
	if tmp, err := json.Marshal(strct.PolicyPeriodInMinutes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ResourceCreationLimitPolicy) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "NewGameSessionsPerCreator":
            if err := json.Unmarshal([]byte(v), &strct.NewGameSessionsPerCreator); err != nil {
                return err
             }
        case "PolicyPeriodInMinutes":
            if err := json.Unmarshal([]byte(v), &strct.PolicyPeriodInMinutes); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *RuntimeConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "GameSessionActivationTimeoutSeconds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"GameSessionActivationTimeoutSeconds\": ")
	if tmp, err := json.Marshal(strct.GameSessionActivationTimeoutSeconds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MaxConcurrentGameSessionActivations" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaxConcurrentGameSessionActivations\": ")
	if tmp, err := json.Marshal(strct.MaxConcurrentGameSessionActivations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ServerProcesses" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ServerProcesses\": ")
	if tmp, err := json.Marshal(strct.ServerProcesses); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RuntimeConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "GameSessionActivationTimeoutSeconds":
            if err := json.Unmarshal([]byte(v), &strct.GameSessionActivationTimeoutSeconds); err != nil {
                return err
             }
        case "MaxConcurrentGameSessionActivations":
            if err := json.Unmarshal([]byte(v), &strct.MaxConcurrentGameSessionActivations); err != nil {
                return err
             }
        case "ServerProcesses":
            if err := json.Unmarshal([]byte(v), &strct.ServerProcesses); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ServerProcess) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ConcurrentExecutions" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ConcurrentExecutions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConcurrentExecutions\": ")
	if tmp, err := json.Marshal(strct.ConcurrentExecutions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "LaunchPath" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "LaunchPath" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LaunchPath\": ")
	if tmp, err := json.Marshal(strct.LaunchPath); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Parameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Parameters\": ")
	if tmp, err := json.Marshal(strct.Parameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ServerProcess) UnmarshalJSON(b []byte) error {
    ConcurrentExecutionsReceived := false
    LaunchPathReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ConcurrentExecutions":
            if err := json.Unmarshal([]byte(v), &strct.ConcurrentExecutions); err != nil {
                return err
             }
            ConcurrentExecutionsReceived = true
        case "LaunchPath":
            if err := json.Unmarshal([]byte(v), &strct.LaunchPath); err != nil {
                return err
             }
            LaunchPathReceived = true
        case "Parameters":
            if err := json.Unmarshal([]byte(v), &strct.Parameters); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ConcurrentExecutions (a required property) was received
    if !ConcurrentExecutionsReceived {
        return errors.New("\"ConcurrentExecutions\" is required but was not present")
    }
    // check if LaunchPath (a required property) was received
    if !LaunchPathReceived {
        return errors.New("\"LaunchPath\" is required but was not present")
    }
    return nil
}
