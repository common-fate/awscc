// Code generated by schema-generate. DO NOT EDIT.

package table

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// BillingMode 
type BillingMode struct {
  Mode string `json:"Mode"`
  ProvisionedThroughput *ProvisionedThroughput `json:"ProvisionedThroughput,omitempty"`
}

// ClusteringKeyColumn 
type ClusteringKeyColumn struct {
  Column *Column `json:"Column"`
  OrderBy string `json:"OrderBy,omitempty"`
}

// Column 
type Column struct {
  ColumnName string `json:"ColumnName"`
  ColumnType string `json:"ColumnType"`
}

// EncryptionSpecification Represents the settings used to enable server-side encryption
type EncryptionSpecification struct {
  EncryptionType string `json:"EncryptionType"`
  KmsKeyIdentifier string `json:"KmsKeyIdentifier,omitempty"`
}

// ProvisionedThroughput Throughput for the specified table, which consists of values for ReadCapacityUnits and WriteCapacityUnits
type ProvisionedThroughput struct {
  ReadCapacityUnits int `json:"ReadCapacityUnits"`
  WriteCapacityUnits int `json:"WriteCapacityUnits"`
}

// Resource Resource schema for AWS::Cassandra::Table
type Resource struct {
  BillingMode *BillingMode `json:"BillingMode,omitempty"`

  // Clustering key columns of the table
  ClusteringKeyColumns []*ClusteringKeyColumn `json:"ClusteringKeyColumns,omitempty"`

  // Default TTL (Time To Live) in seconds, where zero is disabled. If the value is greater than zero, TTL is enabled for the entire table and an expiration timestamp is added to each column.
  DefaultTimeToLive int `json:"DefaultTimeToLive,omitempty"`
  EncryptionSpecification *EncryptionSpecification `json:"EncryptionSpecification,omitempty"`

  // Name for Cassandra keyspace
  KeyspaceName string `json:"KeyspaceName"`

  // Partition key columns of the table
  PartitionKeyColumns []*Column `json:"PartitionKeyColumns"`

  // Indicates whether point in time recovery is enabled (true) or disabled (false) on the table
  PointInTimeRecoveryEnabled bool `json:"PointInTimeRecoveryEnabled,omitempty"`

  // Non-key columns of the table
  RegularColumns []*Column `json:"RegularColumns,omitempty"`

  // Name for Cassandra table
  TableName string `json:"TableName,omitempty"`

  // An array of key-value pairs to apply to this resource
  Tags []*Tag `json:"Tags,omitempty"`
}

// Tag A key-value pair to apply to the resource
type Tag struct {
  Key string `json:"Key"`
  Value string `json:"Value"`
}

func (strct *BillingMode) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Mode" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Mode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Mode\": ")
	if tmp, err := json.Marshal(strct.Mode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ProvisionedThroughput" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ProvisionedThroughput\": ")
	if tmp, err := json.Marshal(strct.ProvisionedThroughput); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BillingMode) UnmarshalJSON(b []byte) error {
    ModeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Mode":
            if err := json.Unmarshal([]byte(v), &strct.Mode); err != nil {
                return err
             }
            ModeReceived = true
        case "ProvisionedThroughput":
            if err := json.Unmarshal([]byte(v), &strct.ProvisionedThroughput); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Mode (a required property) was received
    if !ModeReceived {
        return errors.New("\"Mode\" is required but was not present")
    }
    return nil
}

func (strct *ClusteringKeyColumn) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Column" field is required
    if strct.Column == nil {
        return nil, errors.New("Column is a required field")
    }
    // Marshal the "Column" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Column\": ")
	if tmp, err := json.Marshal(strct.Column); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OrderBy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OrderBy\": ")
	if tmp, err := json.Marshal(strct.OrderBy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ClusteringKeyColumn) UnmarshalJSON(b []byte) error {
    ColumnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Column":
            if err := json.Unmarshal([]byte(v), &strct.Column); err != nil {
                return err
             }
            ColumnReceived = true
        case "OrderBy":
            if err := json.Unmarshal([]byte(v), &strct.OrderBy); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Column (a required property) was received
    if !ColumnReceived {
        return errors.New("\"Column\" is required but was not present")
    }
    return nil
}

func (strct *Column) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ColumnName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ColumnName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ColumnName\": ")
	if tmp, err := json.Marshal(strct.ColumnName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ColumnType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ColumnType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ColumnType\": ")
	if tmp, err := json.Marshal(strct.ColumnType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Column) UnmarshalJSON(b []byte) error {
    ColumnNameReceived := false
    ColumnTypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ColumnName":
            if err := json.Unmarshal([]byte(v), &strct.ColumnName); err != nil {
                return err
             }
            ColumnNameReceived = true
        case "ColumnType":
            if err := json.Unmarshal([]byte(v), &strct.ColumnType); err != nil {
                return err
             }
            ColumnTypeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ColumnName (a required property) was received
    if !ColumnNameReceived {
        return errors.New("\"ColumnName\" is required but was not present")
    }
    // check if ColumnType (a required property) was received
    if !ColumnTypeReceived {
        return errors.New("\"ColumnType\" is required but was not present")
    }
    return nil
}

func (strct *EncryptionSpecification) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "EncryptionType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "EncryptionType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EncryptionType\": ")
	if tmp, err := json.Marshal(strct.EncryptionType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "KmsKeyIdentifier" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KmsKeyIdentifier\": ")
	if tmp, err := json.Marshal(strct.KmsKeyIdentifier); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *EncryptionSpecification) UnmarshalJSON(b []byte) error {
    EncryptionTypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "EncryptionType":
            if err := json.Unmarshal([]byte(v), &strct.EncryptionType); err != nil {
                return err
             }
            EncryptionTypeReceived = true
        case "KmsKeyIdentifier":
            if err := json.Unmarshal([]byte(v), &strct.KmsKeyIdentifier); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if EncryptionType (a required property) was received
    if !EncryptionTypeReceived {
        return errors.New("\"EncryptionType\" is required but was not present")
    }
    return nil
}

func (strct *ProvisionedThroughput) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ReadCapacityUnits" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ReadCapacityUnits" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ReadCapacityUnits\": ")
	if tmp, err := json.Marshal(strct.ReadCapacityUnits); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "WriteCapacityUnits" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "WriteCapacityUnits" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"WriteCapacityUnits\": ")
	if tmp, err := json.Marshal(strct.WriteCapacityUnits); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ProvisionedThroughput) UnmarshalJSON(b []byte) error {
    ReadCapacityUnitsReceived := false
    WriteCapacityUnitsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ReadCapacityUnits":
            if err := json.Unmarshal([]byte(v), &strct.ReadCapacityUnits); err != nil {
                return err
             }
            ReadCapacityUnitsReceived = true
        case "WriteCapacityUnits":
            if err := json.Unmarshal([]byte(v), &strct.WriteCapacityUnits); err != nil {
                return err
             }
            WriteCapacityUnitsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ReadCapacityUnits (a required property) was received
    if !ReadCapacityUnitsReceived {
        return errors.New("\"ReadCapacityUnits\" is required but was not present")
    }
    // check if WriteCapacityUnits (a required property) was received
    if !WriteCapacityUnitsReceived {
        return errors.New("\"WriteCapacityUnits\" is required but was not present")
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "BillingMode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BillingMode\": ")
	if tmp, err := json.Marshal(strct.BillingMode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ClusteringKeyColumns" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ClusteringKeyColumns\": ")
	if tmp, err := json.Marshal(strct.ClusteringKeyColumns); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DefaultTimeToLive" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DefaultTimeToLive\": ")
	if tmp, err := json.Marshal(strct.DefaultTimeToLive); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EncryptionSpecification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EncryptionSpecification\": ")
	if tmp, err := json.Marshal(strct.EncryptionSpecification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "KeyspaceName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "KeyspaceName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KeyspaceName\": ")
	if tmp, err := json.Marshal(strct.KeyspaceName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "PartitionKeyColumns" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "PartitionKeyColumns" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PartitionKeyColumns\": ")
	if tmp, err := json.Marshal(strct.PartitionKeyColumns); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PointInTimeRecoveryEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PointInTimeRecoveryEnabled\": ")
	if tmp, err := json.Marshal(strct.PointInTimeRecoveryEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RegularColumns" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RegularColumns\": ")
	if tmp, err := json.Marshal(strct.RegularColumns); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TableName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TableName\": ")
	if tmp, err := json.Marshal(strct.TableName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    KeyspaceNameReceived := false
    PartitionKeyColumnsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BillingMode":
            if err := json.Unmarshal([]byte(v), &strct.BillingMode); err != nil {
                return err
             }
        case "ClusteringKeyColumns":
            if err := json.Unmarshal([]byte(v), &strct.ClusteringKeyColumns); err != nil {
                return err
             }
        case "DefaultTimeToLive":
            if err := json.Unmarshal([]byte(v), &strct.DefaultTimeToLive); err != nil {
                return err
             }
        case "EncryptionSpecification":
            if err := json.Unmarshal([]byte(v), &strct.EncryptionSpecification); err != nil {
                return err
             }
        case "KeyspaceName":
            if err := json.Unmarshal([]byte(v), &strct.KeyspaceName); err != nil {
                return err
             }
            KeyspaceNameReceived = true
        case "PartitionKeyColumns":
            if err := json.Unmarshal([]byte(v), &strct.PartitionKeyColumns); err != nil {
                return err
             }
            PartitionKeyColumnsReceived = true
        case "PointInTimeRecoveryEnabled":
            if err := json.Unmarshal([]byte(v), &strct.PointInTimeRecoveryEnabled); err != nil {
                return err
             }
        case "RegularColumns":
            if err := json.Unmarshal([]byte(v), &strct.RegularColumns); err != nil {
                return err
             }
        case "TableName":
            if err := json.Unmarshal([]byte(v), &strct.TableName); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if KeyspaceName (a required property) was received
    if !KeyspaceNameReceived {
        return errors.New("\"KeyspaceName\" is required but was not present")
    }
    // check if PartitionKeyColumns (a required property) was received
    if !PartitionKeyColumnsReceived {
        return errors.New("\"PartitionKeyColumns\" is required but was not present")
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}
