// Code generated by schema-generate. DO NOT EDIT.

package webacl

import (
    "errors"
    "bytes"
    "encoding/json"
    "fmt"
)

// AWSManagedRulesBotControlRuleSet Configures how to use the Bot Control managed rule group in the web ACL
type AWSManagedRulesBotControlRuleSet struct {
  InspectionLevel string `json:"InspectionLevel"`
}

// All Inspect all parts of the web request cookies.
type All struct {
}

// AllQueryArguments All query arguments of a web request.
type AllQueryArguments struct {
}

// AllowAction Allow traffic towards application.
type AllowAction struct {
  CustomRequestHandling *CustomRequestHandling `json:"CustomRequestHandling,omitempty"`
}

// AndStatement 
type AndStatement struct {
  Statements []*Statement `json:"Statements"`
}

// BlockAction Block traffic towards application.
type BlockAction struct {
  CustomResponse *CustomResponse `json:"CustomResponse,omitempty"`
}

// Body The body of a web request. This immediately follows the request headers.
type Body struct {
  OversizeHandling string `json:"OversizeHandling,omitempty"`
}

// ByteMatchStatement Byte Match statement.
type ByteMatchStatement struct {
  FieldToMatch *FieldToMatch `json:"FieldToMatch"`
  PositionalConstraint string `json:"PositionalConstraint"`
  SearchString string `json:"SearchString,omitempty"`
  SearchStringBase64 string `json:"SearchStringBase64,omitempty"`
  TextTransformations []*TextTransformation `json:"TextTransformations"`
}

// CaptchaAction Checks valid token exists with request.
type CaptchaAction struct {
  CustomRequestHandling *CustomRequestHandling `json:"CustomRequestHandling,omitempty"`
}

// CaptchaConfig 
type CaptchaConfig struct {
  ImmunityTimeProperty *ImmunityTimeProperty `json:"ImmunityTimeProperty,omitempty"`
}

// ChallengeAction Checks that the request has a valid token with an unexpired challenge timestamp and, if not, returns a browser challenge to the client.
type ChallengeAction struct {
  CustomRequestHandling *CustomRequestHandling `json:"CustomRequestHandling,omitempty"`
}

// ChallengeConfig 
type ChallengeConfig struct {
  ImmunityTimeProperty *ImmunityTimeProperty `json:"ImmunityTimeProperty,omitempty"`
}

// CookieMatchPattern The pattern to look for in the request cookies.
type CookieMatchPattern struct {

  // Inspect all parts of the web request cookies.
  All *All `json:"All,omitempty"`
  ExcludedCookies []string `json:"ExcludedCookies,omitempty"`
  IncludedCookies []string `json:"IncludedCookies,omitempty"`
}

// Cookies Includes headers of a web request.
type Cookies struct {
  MatchPattern *CookieMatchPattern `json:"MatchPattern"`
  MatchScope string `json:"MatchScope"`
  OversizeHandling string `json:"OversizeHandling"`
}

// Count Count traffic towards application.
type Count struct {
}

// CountAction Allow traffic towards application.
type CountAction struct {
  CustomRequestHandling *CustomRequestHandling `json:"CustomRequestHandling,omitempty"`
}

// CustomHTTPHeader HTTP header.
type CustomHTTPHeader struct {
  Name string `json:"Name"`
  Value string `json:"Value"`
}

// CustomRequestHandling Custom request handling.
type CustomRequestHandling struct {

  // Collection of HTTP headers.
  InsertHeaders []*CustomHTTPHeader `json:"InsertHeaders"`
}

// CustomResponse Custom response.
type CustomResponse struct {

  // Custom response body key.
  CustomResponseBodyKey string `json:"CustomResponseBodyKey,omitempty"`
  ResponseCode int `json:"ResponseCode"`

  // Collection of HTTP headers.
  ResponseHeaders []*CustomHTTPHeader `json:"ResponseHeaders,omitempty"`
}

// CustomResponseBodies Custom response key and body map.
type CustomResponseBodies struct {
}

// CustomResponseBody Custom response body.
type CustomResponseBody struct {
  Content string `json:"Content"`
  ContentType string `json:"ContentType"`
}

// DefaultAction Default Action WebACL will take against ingress traffic when there is no matching Rule.
type DefaultAction struct {
  Allow *AllowAction `json:"Allow,omitempty"`
  Block *BlockAction `json:"Block,omitempty"`
}

// ExcludedRule Excluded Rule in the RuleGroup or ManagedRuleGroup will not be evaluated.
type ExcludedRule struct {
  Name string `json:"Name"`
}

// FieldIdentifier 
type FieldIdentifier struct {
  Identifier string `json:"Identifier"`
}

// FieldToMatch Field of the request to match.
type FieldToMatch struct {

  // All query arguments of a web request.
  AllQueryArguments *AllQueryArguments `json:"AllQueryArguments,omitempty"`
  Body *Body `json:"Body,omitempty"`
  Cookies *Cookies `json:"Cookies,omitempty"`
  Headers *Headers `json:"Headers,omitempty"`
  JsonBody *JsonBody `json:"JsonBody,omitempty"`

  // The HTTP method of a web request. The method indicates the type of operation that the request is asking the origin to perform.
  Method *Method `json:"Method,omitempty"`

  // The query string of a web request. This is the part of a URL that appears after a ? character, if any.
  QueryString *QueryString `json:"QueryString,omitempty"`
  SingleHeader *SingleHeader `json:"SingleHeader,omitempty"`

  // One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
  SingleQueryArgument *SingleQueryArgument `json:"SingleQueryArgument,omitempty"`

  // The path component of the URI of a web request. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg.
  UriPath *UriPath `json:"UriPath,omitempty"`
}

// ForwardedIPConfiguration 
type ForwardedIPConfiguration struct {
  FallbackBehavior string `json:"FallbackBehavior"`
  HeaderName string `json:"HeaderName"`
}

// GeoMatchStatement 
type GeoMatchStatement struct {
  CountryCodes []string `json:"CountryCodes,omitempty"`
  ForwardedIPConfig *ForwardedIPConfiguration `json:"ForwardedIPConfig,omitempty"`
}

// HeaderMatchPattern The pattern to look for in the request headers.
type HeaderMatchPattern struct {

  // Inspect all parts of the web request headers.
  All *All `json:"All,omitempty"`
  ExcludedHeaders []string `json:"ExcludedHeaders,omitempty"`
  IncludedHeaders []string `json:"IncludedHeaders,omitempty"`
}

// Headers Includes headers of a web request.
type Headers struct {
  MatchPattern *HeaderMatchPattern `json:"MatchPattern"`
  MatchScope string `json:"MatchScope"`
  OversizeHandling string `json:"OversizeHandling"`
}

// IPSetForwardedIPConfiguration 
type IPSetForwardedIPConfiguration struct {
  FallbackBehavior string `json:"FallbackBehavior"`
  HeaderName string `json:"HeaderName"`
  Position string `json:"Position"`
}

// IPSetReferenceStatement 
type IPSetReferenceStatement struct {
  Arn string `json:"Arn"`
  IPSetForwardedIPConfig *IPSetForwardedIPConfiguration `json:"IPSetForwardedIPConfig,omitempty"`
}

// ImmunityTimeProperty 
type ImmunityTimeProperty struct {
  ImmunityTime int `json:"ImmunityTime"`
}

// JsonBody Inspect the request body as JSON. The request body immediately follows the request headers.
type JsonBody struct {
  InvalidFallbackBehavior string `json:"InvalidFallbackBehavior,omitempty"`
  MatchPattern *JsonMatchPattern `json:"MatchPattern"`
  MatchScope string `json:"MatchScope"`
  OversizeHandling string `json:"OversizeHandling,omitempty"`
}

// JsonMatchPattern The pattern to look for in the JSON body.
type JsonMatchPattern struct {

  // Inspect all parts of the web request's JSON body.
  All *All `json:"All,omitempty"`
  IncludedPaths []string `json:"IncludedPaths,omitempty"`
}

// Label 
type Label struct {
  Name string `json:"Name"`
}

// LabelMatchStatement 
type LabelMatchStatement struct {
  Key string `json:"Key"`
  Scope string `json:"Scope"`
}

// ManagedRuleGroupConfig ManagedRuleGroupConfig.
type ManagedRuleGroupConfig struct {
  AWSManagedRulesBotControlRuleSet *AWSManagedRulesBotControlRuleSet `json:"AWSManagedRulesBotControlRuleSet,omitempty"`
  LoginPath string `json:"LoginPath,omitempty"`
  PasswordField *FieldIdentifier `json:"PasswordField,omitempty"`
  PayloadType string `json:"PayloadType,omitempty"`
  UsernameField *FieldIdentifier `json:"UsernameField,omitempty"`
}

// ManagedRuleGroupStatement 
type ManagedRuleGroupStatement struct {
  ExcludedRules []*ExcludedRule `json:"ExcludedRules,omitempty"`

  // Collection of ManagedRuleGroupConfig.
  ManagedRuleGroupConfigs []*ManagedRuleGroupConfig `json:"ManagedRuleGroupConfigs,omitempty"`
  Name string `json:"Name"`

  // Action overrides for rules in the rule group.
  RuleActionOverrides []*RuleActionOverride `json:"RuleActionOverrides,omitempty"`
  ScopeDownStatement *Statement `json:"ScopeDownStatement,omitempty"`
  VendorName string `json:"VendorName"`
  Version string `json:"Version,omitempty"`
}

// Method The HTTP method of a web request. The method indicates the type of operation that the request is asking the origin to perform.
type Method struct {
}

// None Keep the RuleGroup or ManagedRuleGroup behavior as is.
type None struct {
}

// NotStatement 
type NotStatement struct {
  Statement *Statement `json:"Statement"`
}

// OrStatement 
type OrStatement struct {
  Statements []*Statement `json:"Statements"`
}

// OverrideAction Override a RuleGroup or ManagedRuleGroup behavior. This can only be applied to Rule that has RuleGroupReferenceStatement or ManagedRuleGroupReferenceStatement.
type OverrideAction struct {

  // Count traffic towards application.
  Count *Count `json:"Count,omitempty"`

  // Keep the RuleGroup or ManagedRuleGroup behavior as is.
  None *None `json:"None,omitempty"`
}

// QueryString The query string of a web request. This is the part of a URL that appears after a ? character, if any.
type QueryString struct {
}

// RateBasedStatement 
type RateBasedStatement struct {
  AggregateKeyType string `json:"AggregateKeyType"`
  ForwardedIPConfig *ForwardedIPConfiguration `json:"ForwardedIPConfig,omitempty"`
  Limit int `json:"Limit"`
  ScopeDownStatement *Statement `json:"ScopeDownStatement,omitempty"`
}

// RegexMatchStatement 
type RegexMatchStatement struct {
  FieldToMatch *FieldToMatch `json:"FieldToMatch"`
  RegexString string `json:"RegexString"`
  TextTransformations []*TextTransformation `json:"TextTransformations"`
}

// RegexPatternSetReferenceStatement 
type RegexPatternSetReferenceStatement struct {
  Arn string `json:"Arn"`
  FieldToMatch *FieldToMatch `json:"FieldToMatch"`
  TextTransformations []*TextTransformation `json:"TextTransformations"`
}

// Resource Contains the Rules that identify the requests that you want to allow, block, or count. In a WebACL, you also specify a default action (ALLOW or BLOCK), and the action for each Rule that you add to a WebACL, for example, block requests from specified IP addresses or block requests from specified referrers. You also associate the WebACL with a CloudFront distribution to identify the requests that you want AWS WAF to filter. If you add more than one Rule to a WebACL, a request needs to match only one of the specifications to be allowed, blocked, or counted.
type Resource struct {
  Arn string `json:"Arn,omitempty"`
  Capacity int `json:"Capacity,omitempty"`
  CaptchaConfig *CaptchaConfig `json:"CaptchaConfig,omitempty"`
  ChallengeConfig *ChallengeConfig `json:"ChallengeConfig,omitempty"`
  CustomResponseBodies *CustomResponseBodies `json:"CustomResponseBodies,omitempty"`
  DefaultAction *DefaultAction `json:"DefaultAction"`
  Description string `json:"Description,omitempty"`
  Id string `json:"Id,omitempty"`
  LabelNamespace string `json:"LabelNamespace,omitempty"`
  Name string `json:"Name,omitempty"`

  // Collection of Rules.
  Rules []*Rule `json:"Rules,omitempty"`
  Scope string `json:"Scope"`
  Tags []*Tag `json:"Tags,omitempty"`
  TokenDomains []string `json:"TokenDomains,omitempty"`
  VisibilityConfig *VisibilityConfig `json:"VisibilityConfig"`
}

// Rule Rule of WebACL that contains condition and action.
type Rule struct {
  Action *RuleAction `json:"Action,omitempty"`
  CaptchaConfig *CaptchaConfig `json:"CaptchaConfig,omitempty"`
  ChallengeConfig *ChallengeConfig `json:"ChallengeConfig,omitempty"`
  Name string `json:"Name"`
  OverrideAction *OverrideAction `json:"OverrideAction,omitempty"`
  Priority int `json:"Priority"`

  // Collection of Rule Labels.
  RuleLabels []*Label `json:"RuleLabels,omitempty"`
  Statement *Statement `json:"Statement"`
  VisibilityConfig *VisibilityConfig `json:"VisibilityConfig"`
}

// RuleAction Action taken when Rule matches its condition.
type RuleAction struct {
  Allow *AllowAction `json:"Allow,omitempty"`
  Block *BlockAction `json:"Block,omitempty"`
  Captcha *CaptchaAction `json:"Captcha,omitempty"`
  Challenge *ChallengeAction `json:"Challenge,omitempty"`
  Count *CountAction `json:"Count,omitempty"`
}

// RuleActionOverride Action override for rules in the rule group.
type RuleActionOverride struct {
  ActionToUse *RuleAction `json:"ActionToUse"`
  Name string `json:"Name"`
}

// RuleGroupReferenceStatement 
type RuleGroupReferenceStatement struct {
  Arn string `json:"Arn"`
  ExcludedRules []*ExcludedRule `json:"ExcludedRules,omitempty"`

  // Action overrides for rules in the rule group.
  RuleActionOverrides []*RuleActionOverride `json:"RuleActionOverrides,omitempty"`
}

// SingleHeader 
type SingleHeader struct {
  Name string `json:"Name"`
}

// SingleQueryArgument One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
type SingleQueryArgument struct {
  Name string `json:"Name"`
}

// SizeConstraintStatement Size Constraint statement.
type SizeConstraintStatement struct {
  ComparisonOperator string `json:"ComparisonOperator"`
  FieldToMatch *FieldToMatch `json:"FieldToMatch"`
  Size float64 `json:"Size"`
  TextTransformations []*TextTransformation `json:"TextTransformations"`
}

// SqliMatchStatement Sqli Match Statement.
type SqliMatchStatement struct {
  FieldToMatch *FieldToMatch `json:"FieldToMatch"`
  SensitivityLevel string `json:"SensitivityLevel,omitempty"`
  TextTransformations []*TextTransformation `json:"TextTransformations"`
}

// Statement First level statement that contains conditions, such as ByteMatch, SizeConstraint, etc
type Statement struct {
  AndStatement *AndStatement `json:"AndStatement,omitempty"`
  ByteMatchStatement *ByteMatchStatement `json:"ByteMatchStatement,omitempty"`
  GeoMatchStatement *GeoMatchStatement `json:"GeoMatchStatement,omitempty"`
  IPSetReferenceStatement *IPSetReferenceStatement `json:"IPSetReferenceStatement,omitempty"`
  LabelMatchStatement *LabelMatchStatement `json:"LabelMatchStatement,omitempty"`
  ManagedRuleGroupStatement *ManagedRuleGroupStatement `json:"ManagedRuleGroupStatement,omitempty"`
  NotStatement *NotStatement `json:"NotStatement,omitempty"`
  OrStatement *OrStatement `json:"OrStatement,omitempty"`
  RateBasedStatement *RateBasedStatement `json:"RateBasedStatement,omitempty"`
  RegexMatchStatement *RegexMatchStatement `json:"RegexMatchStatement,omitempty"`
  RegexPatternSetReferenceStatement *RegexPatternSetReferenceStatement `json:"RegexPatternSetReferenceStatement,omitempty"`
  RuleGroupReferenceStatement *RuleGroupReferenceStatement `json:"RuleGroupReferenceStatement,omitempty"`
  SizeConstraintStatement *SizeConstraintStatement `json:"SizeConstraintStatement,omitempty"`
  SqliMatchStatement *SqliMatchStatement `json:"SqliMatchStatement,omitempty"`
  XssMatchStatement *XssMatchStatement `json:"XssMatchStatement,omitempty"`
}

// Tag 
type Tag struct {
  Key string `json:"Key,omitempty"`
  Value string `json:"Value,omitempty"`
}

// TextTransformation Text Transformation on the Search String before match.
type TextTransformation struct {
  Priority int `json:"Priority"`
  Type string `json:"Type"`
}

// UriPath 
type UriPath struct {
}

// VisibilityConfig Visibility Metric of the WebACL.
type VisibilityConfig struct {
  CloudWatchMetricsEnabled bool `json:"CloudWatchMetricsEnabled"`
  MetricName string `json:"MetricName"`
  SampledRequestsEnabled bool `json:"SampledRequestsEnabled"`
}

// XssMatchStatement Xss Match Statement.
type XssMatchStatement struct {
  FieldToMatch *FieldToMatch `json:"FieldToMatch"`
  TextTransformations []*TextTransformation `json:"TextTransformations"`
}

func (strct *AWSManagedRulesBotControlRuleSet) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "InspectionLevel" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "InspectionLevel" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InspectionLevel\": ")
	if tmp, err := json.Marshal(strct.InspectionLevel); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AWSManagedRulesBotControlRuleSet) UnmarshalJSON(b []byte) error {
    InspectionLevelReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "InspectionLevel":
            if err := json.Unmarshal([]byte(v), &strct.InspectionLevel); err != nil {
                return err
             }
            InspectionLevelReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if InspectionLevel (a required property) was received
    if !InspectionLevelReceived {
        return errors.New("\"InspectionLevel\" is required but was not present")
    }
    return nil
}

func (strct *AllowAction) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CustomRequestHandling" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CustomRequestHandling\": ")
	if tmp, err := json.Marshal(strct.CustomRequestHandling); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AllowAction) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CustomRequestHandling":
            if err := json.Unmarshal([]byte(v), &strct.CustomRequestHandling); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *AndStatement) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Statements" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Statements" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Statements\": ")
	if tmp, err := json.Marshal(strct.Statements); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AndStatement) UnmarshalJSON(b []byte) error {
    StatementsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Statements":
            if err := json.Unmarshal([]byte(v), &strct.Statements); err != nil {
                return err
             }
            StatementsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Statements (a required property) was received
    if !StatementsReceived {
        return errors.New("\"Statements\" is required but was not present")
    }
    return nil
}

func (strct *BlockAction) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CustomResponse" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CustomResponse\": ")
	if tmp, err := json.Marshal(strct.CustomResponse); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BlockAction) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CustomResponse":
            if err := json.Unmarshal([]byte(v), &strct.CustomResponse); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Body) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "OversizeHandling" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OversizeHandling\": ")
	if tmp, err := json.Marshal(strct.OversizeHandling); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Body) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "OversizeHandling":
            if err := json.Unmarshal([]byte(v), &strct.OversizeHandling); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ByteMatchStatement) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "FieldToMatch" field is required
    if strct.FieldToMatch == nil {
        return nil, errors.New("FieldToMatch is a required field")
    }
    // Marshal the "FieldToMatch" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FieldToMatch\": ")
	if tmp, err := json.Marshal(strct.FieldToMatch); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "PositionalConstraint" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "PositionalConstraint" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PositionalConstraint\": ")
	if tmp, err := json.Marshal(strct.PositionalConstraint); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SearchString" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SearchString\": ")
	if tmp, err := json.Marshal(strct.SearchString); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SearchStringBase64" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SearchStringBase64\": ")
	if tmp, err := json.Marshal(strct.SearchStringBase64); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TextTransformations" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TextTransformations" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TextTransformations\": ")
	if tmp, err := json.Marshal(strct.TextTransformations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ByteMatchStatement) UnmarshalJSON(b []byte) error {
    FieldToMatchReceived := false
    PositionalConstraintReceived := false
    TextTransformationsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "FieldToMatch":
            if err := json.Unmarshal([]byte(v), &strct.FieldToMatch); err != nil {
                return err
             }
            FieldToMatchReceived = true
        case "PositionalConstraint":
            if err := json.Unmarshal([]byte(v), &strct.PositionalConstraint); err != nil {
                return err
             }
            PositionalConstraintReceived = true
        case "SearchString":
            if err := json.Unmarshal([]byte(v), &strct.SearchString); err != nil {
                return err
             }
        case "SearchStringBase64":
            if err := json.Unmarshal([]byte(v), &strct.SearchStringBase64); err != nil {
                return err
             }
        case "TextTransformations":
            if err := json.Unmarshal([]byte(v), &strct.TextTransformations); err != nil {
                return err
             }
            TextTransformationsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if FieldToMatch (a required property) was received
    if !FieldToMatchReceived {
        return errors.New("\"FieldToMatch\" is required but was not present")
    }
    // check if PositionalConstraint (a required property) was received
    if !PositionalConstraintReceived {
        return errors.New("\"PositionalConstraint\" is required but was not present")
    }
    // check if TextTransformations (a required property) was received
    if !TextTransformationsReceived {
        return errors.New("\"TextTransformations\" is required but was not present")
    }
    return nil
}

func (strct *CaptchaAction) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CustomRequestHandling" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CustomRequestHandling\": ")
	if tmp, err := json.Marshal(strct.CustomRequestHandling); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CaptchaAction) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CustomRequestHandling":
            if err := json.Unmarshal([]byte(v), &strct.CustomRequestHandling); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *CaptchaConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ImmunityTimeProperty" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ImmunityTimeProperty\": ")
	if tmp, err := json.Marshal(strct.ImmunityTimeProperty); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CaptchaConfig) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ImmunityTimeProperty":
            if err := json.Unmarshal([]byte(v), &strct.ImmunityTimeProperty); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ChallengeAction) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CustomRequestHandling" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CustomRequestHandling\": ")
	if tmp, err := json.Marshal(strct.CustomRequestHandling); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ChallengeAction) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CustomRequestHandling":
            if err := json.Unmarshal([]byte(v), &strct.CustomRequestHandling); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ChallengeConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ImmunityTimeProperty" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ImmunityTimeProperty\": ")
	if tmp, err := json.Marshal(strct.ImmunityTimeProperty); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ChallengeConfig) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ImmunityTimeProperty":
            if err := json.Unmarshal([]byte(v), &strct.ImmunityTimeProperty); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *CookieMatchPattern) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "All" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"All\": ")
	if tmp, err := json.Marshal(strct.All); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ExcludedCookies" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ExcludedCookies\": ")
	if tmp, err := json.Marshal(strct.ExcludedCookies); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IncludedCookies" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IncludedCookies\": ")
	if tmp, err := json.Marshal(strct.IncludedCookies); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CookieMatchPattern) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "All":
            if err := json.Unmarshal([]byte(v), &strct.All); err != nil {
                return err
             }
        case "ExcludedCookies":
            if err := json.Unmarshal([]byte(v), &strct.ExcludedCookies); err != nil {
                return err
             }
        case "IncludedCookies":
            if err := json.Unmarshal([]byte(v), &strct.IncludedCookies); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Cookies) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "MatchPattern" field is required
    if strct.MatchPattern == nil {
        return nil, errors.New("MatchPattern is a required field")
    }
    // Marshal the "MatchPattern" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MatchPattern\": ")
	if tmp, err := json.Marshal(strct.MatchPattern); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "MatchScope" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "MatchScope" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MatchScope\": ")
	if tmp, err := json.Marshal(strct.MatchScope); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "OversizeHandling" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "OversizeHandling" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OversizeHandling\": ")
	if tmp, err := json.Marshal(strct.OversizeHandling); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Cookies) UnmarshalJSON(b []byte) error {
    MatchPatternReceived := false
    MatchScopeReceived := false
    OversizeHandlingReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "MatchPattern":
            if err := json.Unmarshal([]byte(v), &strct.MatchPattern); err != nil {
                return err
             }
            MatchPatternReceived = true
        case "MatchScope":
            if err := json.Unmarshal([]byte(v), &strct.MatchScope); err != nil {
                return err
             }
            MatchScopeReceived = true
        case "OversizeHandling":
            if err := json.Unmarshal([]byte(v), &strct.OversizeHandling); err != nil {
                return err
             }
            OversizeHandlingReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if MatchPattern (a required property) was received
    if !MatchPatternReceived {
        return errors.New("\"MatchPattern\" is required but was not present")
    }
    // check if MatchScope (a required property) was received
    if !MatchScopeReceived {
        return errors.New("\"MatchScope\" is required but was not present")
    }
    // check if OversizeHandling (a required property) was received
    if !OversizeHandlingReceived {
        return errors.New("\"OversizeHandling\" is required but was not present")
    }
    return nil
}

func (strct *CountAction) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CustomRequestHandling" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CustomRequestHandling\": ")
	if tmp, err := json.Marshal(strct.CustomRequestHandling); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CountAction) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CustomRequestHandling":
            if err := json.Unmarshal([]byte(v), &strct.CustomRequestHandling); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *CustomHTTPHeader) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CustomHTTPHeader) UnmarshalJSON(b []byte) error {
    NameReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *CustomRequestHandling) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "InsertHeaders" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "InsertHeaders" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InsertHeaders\": ")
	if tmp, err := json.Marshal(strct.InsertHeaders); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CustomRequestHandling) UnmarshalJSON(b []byte) error {
    InsertHeadersReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "InsertHeaders":
            if err := json.Unmarshal([]byte(v), &strct.InsertHeaders); err != nil {
                return err
             }
            InsertHeadersReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if InsertHeaders (a required property) was received
    if !InsertHeadersReceived {
        return errors.New("\"InsertHeaders\" is required but was not present")
    }
    return nil
}

func (strct *CustomResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CustomResponseBodyKey" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CustomResponseBodyKey\": ")
	if tmp, err := json.Marshal(strct.CustomResponseBodyKey); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ResponseCode" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ResponseCode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ResponseCode\": ")
	if tmp, err := json.Marshal(strct.ResponseCode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ResponseHeaders" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ResponseHeaders\": ")
	if tmp, err := json.Marshal(strct.ResponseHeaders); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CustomResponse) UnmarshalJSON(b []byte) error {
    ResponseCodeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CustomResponseBodyKey":
            if err := json.Unmarshal([]byte(v), &strct.CustomResponseBodyKey); err != nil {
                return err
             }
        case "ResponseCode":
            if err := json.Unmarshal([]byte(v), &strct.ResponseCode); err != nil {
                return err
             }
            ResponseCodeReceived = true
        case "ResponseHeaders":
            if err := json.Unmarshal([]byte(v), &strct.ResponseHeaders); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ResponseCode (a required property) was received
    if !ResponseCodeReceived {
        return errors.New("\"ResponseCode\" is required but was not present")
    }
    return nil
}

func (strct *CustomResponseBodies) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CustomResponseBodies) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *CustomResponseBody) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Content" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Content" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Content\": ")
	if tmp, err := json.Marshal(strct.Content); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ContentType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ContentType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ContentType\": ")
	if tmp, err := json.Marshal(strct.ContentType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CustomResponseBody) UnmarshalJSON(b []byte) error {
    ContentReceived := false
    ContentTypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Content":
            if err := json.Unmarshal([]byte(v), &strct.Content); err != nil {
                return err
             }
            ContentReceived = true
        case "ContentType":
            if err := json.Unmarshal([]byte(v), &strct.ContentType); err != nil {
                return err
             }
            ContentTypeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Content (a required property) was received
    if !ContentReceived {
        return errors.New("\"Content\" is required but was not present")
    }
    // check if ContentType (a required property) was received
    if !ContentTypeReceived {
        return errors.New("\"ContentType\" is required but was not present")
    }
    return nil
}

func (strct *DefaultAction) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Allow" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Allow\": ")
	if tmp, err := json.Marshal(strct.Allow); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Block" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Block\": ")
	if tmp, err := json.Marshal(strct.Block); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DefaultAction) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Allow":
            if err := json.Unmarshal([]byte(v), &strct.Allow); err != nil {
                return err
             }
        case "Block":
            if err := json.Unmarshal([]byte(v), &strct.Block); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ExcludedRule) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ExcludedRule) UnmarshalJSON(b []byte) error {
    NameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    return nil
}

func (strct *FieldIdentifier) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Identifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Identifier" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Identifier\": ")
	if tmp, err := json.Marshal(strct.Identifier); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FieldIdentifier) UnmarshalJSON(b []byte) error {
    IdentifierReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Identifier":
            if err := json.Unmarshal([]byte(v), &strct.Identifier); err != nil {
                return err
             }
            IdentifierReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Identifier (a required property) was received
    if !IdentifierReceived {
        return errors.New("\"Identifier\" is required but was not present")
    }
    return nil
}

func (strct *FieldToMatch) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AllQueryArguments" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AllQueryArguments\": ")
	if tmp, err := json.Marshal(strct.AllQueryArguments); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Body" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Body\": ")
	if tmp, err := json.Marshal(strct.Body); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Cookies" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Cookies\": ")
	if tmp, err := json.Marshal(strct.Cookies); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Headers" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Headers\": ")
	if tmp, err := json.Marshal(strct.Headers); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "JsonBody" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"JsonBody\": ")
	if tmp, err := json.Marshal(strct.JsonBody); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Method" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "QueryString" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"QueryString\": ")
	if tmp, err := json.Marshal(strct.QueryString); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SingleHeader" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SingleHeader\": ")
	if tmp, err := json.Marshal(strct.SingleHeader); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SingleQueryArgument" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SingleQueryArgument\": ")
	if tmp, err := json.Marshal(strct.SingleQueryArgument); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "UriPath" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UriPath\": ")
	if tmp, err := json.Marshal(strct.UriPath); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FieldToMatch) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AllQueryArguments":
            if err := json.Unmarshal([]byte(v), &strct.AllQueryArguments); err != nil {
                return err
             }
        case "Body":
            if err := json.Unmarshal([]byte(v), &strct.Body); err != nil {
                return err
             }
        case "Cookies":
            if err := json.Unmarshal([]byte(v), &strct.Cookies); err != nil {
                return err
             }
        case "Headers":
            if err := json.Unmarshal([]byte(v), &strct.Headers); err != nil {
                return err
             }
        case "JsonBody":
            if err := json.Unmarshal([]byte(v), &strct.JsonBody); err != nil {
                return err
             }
        case "Method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
                return err
             }
        case "QueryString":
            if err := json.Unmarshal([]byte(v), &strct.QueryString); err != nil {
                return err
             }
        case "SingleHeader":
            if err := json.Unmarshal([]byte(v), &strct.SingleHeader); err != nil {
                return err
             }
        case "SingleQueryArgument":
            if err := json.Unmarshal([]byte(v), &strct.SingleQueryArgument); err != nil {
                return err
             }
        case "UriPath":
            if err := json.Unmarshal([]byte(v), &strct.UriPath); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ForwardedIPConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "FallbackBehavior" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "FallbackBehavior" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FallbackBehavior\": ")
	if tmp, err := json.Marshal(strct.FallbackBehavior); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "HeaderName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "HeaderName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HeaderName\": ")
	if tmp, err := json.Marshal(strct.HeaderName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ForwardedIPConfiguration) UnmarshalJSON(b []byte) error {
    FallbackBehaviorReceived := false
    HeaderNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "FallbackBehavior":
            if err := json.Unmarshal([]byte(v), &strct.FallbackBehavior); err != nil {
                return err
             }
            FallbackBehaviorReceived = true
        case "HeaderName":
            if err := json.Unmarshal([]byte(v), &strct.HeaderName); err != nil {
                return err
             }
            HeaderNameReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if FallbackBehavior (a required property) was received
    if !FallbackBehaviorReceived {
        return errors.New("\"FallbackBehavior\" is required but was not present")
    }
    // check if HeaderName (a required property) was received
    if !HeaderNameReceived {
        return errors.New("\"HeaderName\" is required but was not present")
    }
    return nil
}

func (strct *GeoMatchStatement) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CountryCodes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CountryCodes\": ")
	if tmp, err := json.Marshal(strct.CountryCodes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ForwardedIPConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ForwardedIPConfig\": ")
	if tmp, err := json.Marshal(strct.ForwardedIPConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *GeoMatchStatement) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CountryCodes":
            if err := json.Unmarshal([]byte(v), &strct.CountryCodes); err != nil {
                return err
             }
        case "ForwardedIPConfig":
            if err := json.Unmarshal([]byte(v), &strct.ForwardedIPConfig); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *HeaderMatchPattern) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "All" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"All\": ")
	if tmp, err := json.Marshal(strct.All); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ExcludedHeaders" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ExcludedHeaders\": ")
	if tmp, err := json.Marshal(strct.ExcludedHeaders); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IncludedHeaders" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IncludedHeaders\": ")
	if tmp, err := json.Marshal(strct.IncludedHeaders); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *HeaderMatchPattern) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "All":
            if err := json.Unmarshal([]byte(v), &strct.All); err != nil {
                return err
             }
        case "ExcludedHeaders":
            if err := json.Unmarshal([]byte(v), &strct.ExcludedHeaders); err != nil {
                return err
             }
        case "IncludedHeaders":
            if err := json.Unmarshal([]byte(v), &strct.IncludedHeaders); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Headers) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "MatchPattern" field is required
    if strct.MatchPattern == nil {
        return nil, errors.New("MatchPattern is a required field")
    }
    // Marshal the "MatchPattern" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MatchPattern\": ")
	if tmp, err := json.Marshal(strct.MatchPattern); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "MatchScope" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "MatchScope" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MatchScope\": ")
	if tmp, err := json.Marshal(strct.MatchScope); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "OversizeHandling" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "OversizeHandling" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OversizeHandling\": ")
	if tmp, err := json.Marshal(strct.OversizeHandling); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Headers) UnmarshalJSON(b []byte) error {
    MatchPatternReceived := false
    MatchScopeReceived := false
    OversizeHandlingReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "MatchPattern":
            if err := json.Unmarshal([]byte(v), &strct.MatchPattern); err != nil {
                return err
             }
            MatchPatternReceived = true
        case "MatchScope":
            if err := json.Unmarshal([]byte(v), &strct.MatchScope); err != nil {
                return err
             }
            MatchScopeReceived = true
        case "OversizeHandling":
            if err := json.Unmarshal([]byte(v), &strct.OversizeHandling); err != nil {
                return err
             }
            OversizeHandlingReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if MatchPattern (a required property) was received
    if !MatchPatternReceived {
        return errors.New("\"MatchPattern\" is required but was not present")
    }
    // check if MatchScope (a required property) was received
    if !MatchScopeReceived {
        return errors.New("\"MatchScope\" is required but was not present")
    }
    // check if OversizeHandling (a required property) was received
    if !OversizeHandlingReceived {
        return errors.New("\"OversizeHandling\" is required but was not present")
    }
    return nil
}

func (strct *IPSetForwardedIPConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "FallbackBehavior" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "FallbackBehavior" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FallbackBehavior\": ")
	if tmp, err := json.Marshal(strct.FallbackBehavior); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "HeaderName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "HeaderName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HeaderName\": ")
	if tmp, err := json.Marshal(strct.HeaderName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Position" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Position" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Position\": ")
	if tmp, err := json.Marshal(strct.Position); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *IPSetForwardedIPConfiguration) UnmarshalJSON(b []byte) error {
    FallbackBehaviorReceived := false
    HeaderNameReceived := false
    PositionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "FallbackBehavior":
            if err := json.Unmarshal([]byte(v), &strct.FallbackBehavior); err != nil {
                return err
             }
            FallbackBehaviorReceived = true
        case "HeaderName":
            if err := json.Unmarshal([]byte(v), &strct.HeaderName); err != nil {
                return err
             }
            HeaderNameReceived = true
        case "Position":
            if err := json.Unmarshal([]byte(v), &strct.Position); err != nil {
                return err
             }
            PositionReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if FallbackBehavior (a required property) was received
    if !FallbackBehaviorReceived {
        return errors.New("\"FallbackBehavior\" is required but was not present")
    }
    // check if HeaderName (a required property) was received
    if !HeaderNameReceived {
        return errors.New("\"HeaderName\" is required but was not present")
    }
    // check if Position (a required property) was received
    if !PositionReceived {
        return errors.New("\"Position\" is required but was not present")
    }
    return nil
}

func (strct *IPSetReferenceStatement) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Arn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Arn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Arn\": ")
	if tmp, err := json.Marshal(strct.Arn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IPSetForwardedIPConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IPSetForwardedIPConfig\": ")
	if tmp, err := json.Marshal(strct.IPSetForwardedIPConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *IPSetReferenceStatement) UnmarshalJSON(b []byte) error {
    ArnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Arn":
            if err := json.Unmarshal([]byte(v), &strct.Arn); err != nil {
                return err
             }
            ArnReceived = true
        case "IPSetForwardedIPConfig":
            if err := json.Unmarshal([]byte(v), &strct.IPSetForwardedIPConfig); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Arn (a required property) was received
    if !ArnReceived {
        return errors.New("\"Arn\" is required but was not present")
    }
    return nil
}

func (strct *ImmunityTimeProperty) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ImmunityTime" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ImmunityTime" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ImmunityTime\": ")
	if tmp, err := json.Marshal(strct.ImmunityTime); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ImmunityTimeProperty) UnmarshalJSON(b []byte) error {
    ImmunityTimeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ImmunityTime":
            if err := json.Unmarshal([]byte(v), &strct.ImmunityTime); err != nil {
                return err
             }
            ImmunityTimeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ImmunityTime (a required property) was received
    if !ImmunityTimeReceived {
        return errors.New("\"ImmunityTime\" is required but was not present")
    }
    return nil
}

func (strct *JsonBody) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "InvalidFallbackBehavior" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InvalidFallbackBehavior\": ")
	if tmp, err := json.Marshal(strct.InvalidFallbackBehavior); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "MatchPattern" field is required
    if strct.MatchPattern == nil {
        return nil, errors.New("MatchPattern is a required field")
    }
    // Marshal the "MatchPattern" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MatchPattern\": ")
	if tmp, err := json.Marshal(strct.MatchPattern); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "MatchScope" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "MatchScope" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MatchScope\": ")
	if tmp, err := json.Marshal(strct.MatchScope); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OversizeHandling" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OversizeHandling\": ")
	if tmp, err := json.Marshal(strct.OversizeHandling); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *JsonBody) UnmarshalJSON(b []byte) error {
    MatchPatternReceived := false
    MatchScopeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "InvalidFallbackBehavior":
            if err := json.Unmarshal([]byte(v), &strct.InvalidFallbackBehavior); err != nil {
                return err
             }
        case "MatchPattern":
            if err := json.Unmarshal([]byte(v), &strct.MatchPattern); err != nil {
                return err
             }
            MatchPatternReceived = true
        case "MatchScope":
            if err := json.Unmarshal([]byte(v), &strct.MatchScope); err != nil {
                return err
             }
            MatchScopeReceived = true
        case "OversizeHandling":
            if err := json.Unmarshal([]byte(v), &strct.OversizeHandling); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if MatchPattern (a required property) was received
    if !MatchPatternReceived {
        return errors.New("\"MatchPattern\" is required but was not present")
    }
    // check if MatchScope (a required property) was received
    if !MatchScopeReceived {
        return errors.New("\"MatchScope\" is required but was not present")
    }
    return nil
}

func (strct *JsonMatchPattern) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "All" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"All\": ")
	if tmp, err := json.Marshal(strct.All); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IncludedPaths" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IncludedPaths\": ")
	if tmp, err := json.Marshal(strct.IncludedPaths); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *JsonMatchPattern) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "All":
            if err := json.Unmarshal([]byte(v), &strct.All); err != nil {
                return err
             }
        case "IncludedPaths":
            if err := json.Unmarshal([]byte(v), &strct.IncludedPaths); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Label) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Label) UnmarshalJSON(b []byte) error {
    NameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    return nil
}

func (strct *LabelMatchStatement) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Scope" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Scope" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Scope\": ")
	if tmp, err := json.Marshal(strct.Scope); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LabelMatchStatement) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ScopeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Scope":
            if err := json.Unmarshal([]byte(v), &strct.Scope); err != nil {
                return err
             }
            ScopeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Scope (a required property) was received
    if !ScopeReceived {
        return errors.New("\"Scope\" is required but was not present")
    }
    return nil
}

func (strct *ManagedRuleGroupConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AWSManagedRulesBotControlRuleSet" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AWSManagedRulesBotControlRuleSet\": ")
	if tmp, err := json.Marshal(strct.AWSManagedRulesBotControlRuleSet); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LoginPath" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LoginPath\": ")
	if tmp, err := json.Marshal(strct.LoginPath); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PasswordField" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PasswordField\": ")
	if tmp, err := json.Marshal(strct.PasswordField); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PayloadType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PayloadType\": ")
	if tmp, err := json.Marshal(strct.PayloadType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "UsernameField" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UsernameField\": ")
	if tmp, err := json.Marshal(strct.UsernameField); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ManagedRuleGroupConfig) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AWSManagedRulesBotControlRuleSet":
            if err := json.Unmarshal([]byte(v), &strct.AWSManagedRulesBotControlRuleSet); err != nil {
                return err
             }
        case "LoginPath":
            if err := json.Unmarshal([]byte(v), &strct.LoginPath); err != nil {
                return err
             }
        case "PasswordField":
            if err := json.Unmarshal([]byte(v), &strct.PasswordField); err != nil {
                return err
             }
        case "PayloadType":
            if err := json.Unmarshal([]byte(v), &strct.PayloadType); err != nil {
                return err
             }
        case "UsernameField":
            if err := json.Unmarshal([]byte(v), &strct.UsernameField); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ManagedRuleGroupStatement) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ExcludedRules" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ExcludedRules\": ")
	if tmp, err := json.Marshal(strct.ExcludedRules); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ManagedRuleGroupConfigs" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ManagedRuleGroupConfigs\": ")
	if tmp, err := json.Marshal(strct.ManagedRuleGroupConfigs); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RuleActionOverrides" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RuleActionOverrides\": ")
	if tmp, err := json.Marshal(strct.RuleActionOverrides); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ScopeDownStatement" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ScopeDownStatement\": ")
	if tmp, err := json.Marshal(strct.ScopeDownStatement); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "VendorName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "VendorName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VendorName\": ")
	if tmp, err := json.Marshal(strct.VendorName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Version" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Version\": ")
	if tmp, err := json.Marshal(strct.Version); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ManagedRuleGroupStatement) UnmarshalJSON(b []byte) error {
    NameReceived := false
    VendorNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ExcludedRules":
            if err := json.Unmarshal([]byte(v), &strct.ExcludedRules); err != nil {
                return err
             }
        case "ManagedRuleGroupConfigs":
            if err := json.Unmarshal([]byte(v), &strct.ManagedRuleGroupConfigs); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        case "RuleActionOverrides":
            if err := json.Unmarshal([]byte(v), &strct.RuleActionOverrides); err != nil {
                return err
             }
        case "ScopeDownStatement":
            if err := json.Unmarshal([]byte(v), &strct.ScopeDownStatement); err != nil {
                return err
             }
        case "VendorName":
            if err := json.Unmarshal([]byte(v), &strct.VendorName); err != nil {
                return err
             }
            VendorNameReceived = true
        case "Version":
            if err := json.Unmarshal([]byte(v), &strct.Version); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    // check if VendorName (a required property) was received
    if !VendorNameReceived {
        return errors.New("\"VendorName\" is required but was not present")
    }
    return nil
}

func (strct *NotStatement) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Statement" field is required
    if strct.Statement == nil {
        return nil, errors.New("Statement is a required field")
    }
    // Marshal the "Statement" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Statement\": ")
	if tmp, err := json.Marshal(strct.Statement); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *NotStatement) UnmarshalJSON(b []byte) error {
    StatementReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Statement":
            if err := json.Unmarshal([]byte(v), &strct.Statement); err != nil {
                return err
             }
            StatementReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Statement (a required property) was received
    if !StatementReceived {
        return errors.New("\"Statement\" is required but was not present")
    }
    return nil
}

func (strct *OrStatement) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Statements" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Statements" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Statements\": ")
	if tmp, err := json.Marshal(strct.Statements); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *OrStatement) UnmarshalJSON(b []byte) error {
    StatementsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Statements":
            if err := json.Unmarshal([]byte(v), &strct.Statements); err != nil {
                return err
             }
            StatementsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Statements (a required property) was received
    if !StatementsReceived {
        return errors.New("\"Statements\" is required but was not present")
    }
    return nil
}

func (strct *OverrideAction) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Count" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Count\": ")
	if tmp, err := json.Marshal(strct.Count); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "None" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"None\": ")
	if tmp, err := json.Marshal(strct.None); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *OverrideAction) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Count":
            if err := json.Unmarshal([]byte(v), &strct.Count); err != nil {
                return err
             }
        case "None":
            if err := json.Unmarshal([]byte(v), &strct.None); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *RateBasedStatement) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AggregateKeyType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AggregateKeyType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AggregateKeyType\": ")
	if tmp, err := json.Marshal(strct.AggregateKeyType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ForwardedIPConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ForwardedIPConfig\": ")
	if tmp, err := json.Marshal(strct.ForwardedIPConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Limit" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Limit" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Limit\": ")
	if tmp, err := json.Marshal(strct.Limit); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ScopeDownStatement" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ScopeDownStatement\": ")
	if tmp, err := json.Marshal(strct.ScopeDownStatement); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RateBasedStatement) UnmarshalJSON(b []byte) error {
    AggregateKeyTypeReceived := false
    LimitReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AggregateKeyType":
            if err := json.Unmarshal([]byte(v), &strct.AggregateKeyType); err != nil {
                return err
             }
            AggregateKeyTypeReceived = true
        case "ForwardedIPConfig":
            if err := json.Unmarshal([]byte(v), &strct.ForwardedIPConfig); err != nil {
                return err
             }
        case "Limit":
            if err := json.Unmarshal([]byte(v), &strct.Limit); err != nil {
                return err
             }
            LimitReceived = true
        case "ScopeDownStatement":
            if err := json.Unmarshal([]byte(v), &strct.ScopeDownStatement); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if AggregateKeyType (a required property) was received
    if !AggregateKeyTypeReceived {
        return errors.New("\"AggregateKeyType\" is required but was not present")
    }
    // check if Limit (a required property) was received
    if !LimitReceived {
        return errors.New("\"Limit\" is required but was not present")
    }
    return nil
}

func (strct *RegexMatchStatement) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "FieldToMatch" field is required
    if strct.FieldToMatch == nil {
        return nil, errors.New("FieldToMatch is a required field")
    }
    // Marshal the "FieldToMatch" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FieldToMatch\": ")
	if tmp, err := json.Marshal(strct.FieldToMatch); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RegexString" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RegexString" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RegexString\": ")
	if tmp, err := json.Marshal(strct.RegexString); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TextTransformations" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TextTransformations" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TextTransformations\": ")
	if tmp, err := json.Marshal(strct.TextTransformations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RegexMatchStatement) UnmarshalJSON(b []byte) error {
    FieldToMatchReceived := false
    RegexStringReceived := false
    TextTransformationsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "FieldToMatch":
            if err := json.Unmarshal([]byte(v), &strct.FieldToMatch); err != nil {
                return err
             }
            FieldToMatchReceived = true
        case "RegexString":
            if err := json.Unmarshal([]byte(v), &strct.RegexString); err != nil {
                return err
             }
            RegexStringReceived = true
        case "TextTransformations":
            if err := json.Unmarshal([]byte(v), &strct.TextTransformations); err != nil {
                return err
             }
            TextTransformationsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if FieldToMatch (a required property) was received
    if !FieldToMatchReceived {
        return errors.New("\"FieldToMatch\" is required but was not present")
    }
    // check if RegexString (a required property) was received
    if !RegexStringReceived {
        return errors.New("\"RegexString\" is required but was not present")
    }
    // check if TextTransformations (a required property) was received
    if !TextTransformationsReceived {
        return errors.New("\"TextTransformations\" is required but was not present")
    }
    return nil
}

func (strct *RegexPatternSetReferenceStatement) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Arn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Arn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Arn\": ")
	if tmp, err := json.Marshal(strct.Arn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "FieldToMatch" field is required
    if strct.FieldToMatch == nil {
        return nil, errors.New("FieldToMatch is a required field")
    }
    // Marshal the "FieldToMatch" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FieldToMatch\": ")
	if tmp, err := json.Marshal(strct.FieldToMatch); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TextTransformations" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TextTransformations" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TextTransformations\": ")
	if tmp, err := json.Marshal(strct.TextTransformations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RegexPatternSetReferenceStatement) UnmarshalJSON(b []byte) error {
    ArnReceived := false
    FieldToMatchReceived := false
    TextTransformationsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Arn":
            if err := json.Unmarshal([]byte(v), &strct.Arn); err != nil {
                return err
             }
            ArnReceived = true
        case "FieldToMatch":
            if err := json.Unmarshal([]byte(v), &strct.FieldToMatch); err != nil {
                return err
             }
            FieldToMatchReceived = true
        case "TextTransformations":
            if err := json.Unmarshal([]byte(v), &strct.TextTransformations); err != nil {
                return err
             }
            TextTransformationsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Arn (a required property) was received
    if !ArnReceived {
        return errors.New("\"Arn\" is required but was not present")
    }
    // check if FieldToMatch (a required property) was received
    if !FieldToMatchReceived {
        return errors.New("\"FieldToMatch\" is required but was not present")
    }
    // check if TextTransformations (a required property) was received
    if !TextTransformationsReceived {
        return errors.New("\"TextTransformations\" is required but was not present")
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Arn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Arn\": ")
	if tmp, err := json.Marshal(strct.Arn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Capacity" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Capacity\": ")
	if tmp, err := json.Marshal(strct.Capacity); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CaptchaConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CaptchaConfig\": ")
	if tmp, err := json.Marshal(strct.CaptchaConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ChallengeConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ChallengeConfig\": ")
	if tmp, err := json.Marshal(strct.ChallengeConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CustomResponseBodies" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CustomResponseBodies\": ")
	if tmp, err := json.Marshal(strct.CustomResponseBodies); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "DefaultAction" field is required
    if strct.DefaultAction == nil {
        return nil, errors.New("DefaultAction is a required field")
    }
    // Marshal the "DefaultAction" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DefaultAction\": ")
	if tmp, err := json.Marshal(strct.DefaultAction); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Id" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LabelNamespace" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LabelNamespace\": ")
	if tmp, err := json.Marshal(strct.LabelNamespace); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Rules" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Rules\": ")
	if tmp, err := json.Marshal(strct.Rules); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Scope" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Scope" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Scope\": ")
	if tmp, err := json.Marshal(strct.Scope); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TokenDomains" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TokenDomains\": ")
	if tmp, err := json.Marshal(strct.TokenDomains); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "VisibilityConfig" field is required
    if strct.VisibilityConfig == nil {
        return nil, errors.New("VisibilityConfig is a required field")
    }
    // Marshal the "VisibilityConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VisibilityConfig\": ")
	if tmp, err := json.Marshal(strct.VisibilityConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    DefaultActionReceived := false
    ScopeReceived := false
    VisibilityConfigReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Arn":
            if err := json.Unmarshal([]byte(v), &strct.Arn); err != nil {
                return err
             }
        case "Capacity":
            if err := json.Unmarshal([]byte(v), &strct.Capacity); err != nil {
                return err
             }
        case "CaptchaConfig":
            if err := json.Unmarshal([]byte(v), &strct.CaptchaConfig); err != nil {
                return err
             }
        case "ChallengeConfig":
            if err := json.Unmarshal([]byte(v), &strct.ChallengeConfig); err != nil {
                return err
             }
        case "CustomResponseBodies":
            if err := json.Unmarshal([]byte(v), &strct.CustomResponseBodies); err != nil {
                return err
             }
        case "DefaultAction":
            if err := json.Unmarshal([]byte(v), &strct.DefaultAction); err != nil {
                return err
             }
            DefaultActionReceived = true
        case "Description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "Id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
        case "LabelNamespace":
            if err := json.Unmarshal([]byte(v), &strct.LabelNamespace); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "Rules":
            if err := json.Unmarshal([]byte(v), &strct.Rules); err != nil {
                return err
             }
        case "Scope":
            if err := json.Unmarshal([]byte(v), &strct.Scope); err != nil {
                return err
             }
            ScopeReceived = true
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        case "TokenDomains":
            if err := json.Unmarshal([]byte(v), &strct.TokenDomains); err != nil {
                return err
             }
        case "VisibilityConfig":
            if err := json.Unmarshal([]byte(v), &strct.VisibilityConfig); err != nil {
                return err
             }
            VisibilityConfigReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if DefaultAction (a required property) was received
    if !DefaultActionReceived {
        return errors.New("\"DefaultAction\" is required but was not present")
    }
    // check if Scope (a required property) was received
    if !ScopeReceived {
        return errors.New("\"Scope\" is required but was not present")
    }
    // check if VisibilityConfig (a required property) was received
    if !VisibilityConfigReceived {
        return errors.New("\"VisibilityConfig\" is required but was not present")
    }
    return nil
}

func (strct *Rule) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Action" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Action\": ")
	if tmp, err := json.Marshal(strct.Action); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CaptchaConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CaptchaConfig\": ")
	if tmp, err := json.Marshal(strct.CaptchaConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ChallengeConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ChallengeConfig\": ")
	if tmp, err := json.Marshal(strct.ChallengeConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OverrideAction" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OverrideAction\": ")
	if tmp, err := json.Marshal(strct.OverrideAction); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Priority" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Priority" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Priority\": ")
	if tmp, err := json.Marshal(strct.Priority); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RuleLabels" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RuleLabels\": ")
	if tmp, err := json.Marshal(strct.RuleLabels); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Statement" field is required
    if strct.Statement == nil {
        return nil, errors.New("Statement is a required field")
    }
    // Marshal the "Statement" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Statement\": ")
	if tmp, err := json.Marshal(strct.Statement); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "VisibilityConfig" field is required
    if strct.VisibilityConfig == nil {
        return nil, errors.New("VisibilityConfig is a required field")
    }
    // Marshal the "VisibilityConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VisibilityConfig\": ")
	if tmp, err := json.Marshal(strct.VisibilityConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Rule) UnmarshalJSON(b []byte) error {
    NameReceived := false
    PriorityReceived := false
    StatementReceived := false
    VisibilityConfigReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Action":
            if err := json.Unmarshal([]byte(v), &strct.Action); err != nil {
                return err
             }
        case "CaptchaConfig":
            if err := json.Unmarshal([]byte(v), &strct.CaptchaConfig); err != nil {
                return err
             }
        case "ChallengeConfig":
            if err := json.Unmarshal([]byte(v), &strct.ChallengeConfig); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        case "OverrideAction":
            if err := json.Unmarshal([]byte(v), &strct.OverrideAction); err != nil {
                return err
             }
        case "Priority":
            if err := json.Unmarshal([]byte(v), &strct.Priority); err != nil {
                return err
             }
            PriorityReceived = true
        case "RuleLabels":
            if err := json.Unmarshal([]byte(v), &strct.RuleLabels); err != nil {
                return err
             }
        case "Statement":
            if err := json.Unmarshal([]byte(v), &strct.Statement); err != nil {
                return err
             }
            StatementReceived = true
        case "VisibilityConfig":
            if err := json.Unmarshal([]byte(v), &strct.VisibilityConfig); err != nil {
                return err
             }
            VisibilityConfigReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    // check if Priority (a required property) was received
    if !PriorityReceived {
        return errors.New("\"Priority\" is required but was not present")
    }
    // check if Statement (a required property) was received
    if !StatementReceived {
        return errors.New("\"Statement\" is required but was not present")
    }
    // check if VisibilityConfig (a required property) was received
    if !VisibilityConfigReceived {
        return errors.New("\"VisibilityConfig\" is required but was not present")
    }
    return nil
}

func (strct *RuleAction) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Allow" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Allow\": ")
	if tmp, err := json.Marshal(strct.Allow); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Block" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Block\": ")
	if tmp, err := json.Marshal(strct.Block); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Captcha" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Captcha\": ")
	if tmp, err := json.Marshal(strct.Captcha); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Challenge" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Challenge\": ")
	if tmp, err := json.Marshal(strct.Challenge); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Count" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Count\": ")
	if tmp, err := json.Marshal(strct.Count); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RuleAction) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Allow":
            if err := json.Unmarshal([]byte(v), &strct.Allow); err != nil {
                return err
             }
        case "Block":
            if err := json.Unmarshal([]byte(v), &strct.Block); err != nil {
                return err
             }
        case "Captcha":
            if err := json.Unmarshal([]byte(v), &strct.Captcha); err != nil {
                return err
             }
        case "Challenge":
            if err := json.Unmarshal([]byte(v), &strct.Challenge); err != nil {
                return err
             }
        case "Count":
            if err := json.Unmarshal([]byte(v), &strct.Count); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *RuleActionOverride) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ActionToUse" field is required
    if strct.ActionToUse == nil {
        return nil, errors.New("ActionToUse is a required field")
    }
    // Marshal the "ActionToUse" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ActionToUse\": ")
	if tmp, err := json.Marshal(strct.ActionToUse); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RuleActionOverride) UnmarshalJSON(b []byte) error {
    ActionToUseReceived := false
    NameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ActionToUse":
            if err := json.Unmarshal([]byte(v), &strct.ActionToUse); err != nil {
                return err
             }
            ActionToUseReceived = true
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ActionToUse (a required property) was received
    if !ActionToUseReceived {
        return errors.New("\"ActionToUse\" is required but was not present")
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    return nil
}

func (strct *RuleGroupReferenceStatement) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Arn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Arn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Arn\": ")
	if tmp, err := json.Marshal(strct.Arn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ExcludedRules" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ExcludedRules\": ")
	if tmp, err := json.Marshal(strct.ExcludedRules); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RuleActionOverrides" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RuleActionOverrides\": ")
	if tmp, err := json.Marshal(strct.RuleActionOverrides); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RuleGroupReferenceStatement) UnmarshalJSON(b []byte) error {
    ArnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Arn":
            if err := json.Unmarshal([]byte(v), &strct.Arn); err != nil {
                return err
             }
            ArnReceived = true
        case "ExcludedRules":
            if err := json.Unmarshal([]byte(v), &strct.ExcludedRules); err != nil {
                return err
             }
        case "RuleActionOverrides":
            if err := json.Unmarshal([]byte(v), &strct.RuleActionOverrides); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Arn (a required property) was received
    if !ArnReceived {
        return errors.New("\"Arn\" is required but was not present")
    }
    return nil
}

func (strct *SingleHeader) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SingleHeader) UnmarshalJSON(b []byte) error {
    NameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    return nil
}

func (strct *SingleQueryArgument) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SingleQueryArgument) UnmarshalJSON(b []byte) error {
    NameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    return nil
}

func (strct *SizeConstraintStatement) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ComparisonOperator" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ComparisonOperator" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ComparisonOperator\": ")
	if tmp, err := json.Marshal(strct.ComparisonOperator); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "FieldToMatch" field is required
    if strct.FieldToMatch == nil {
        return nil, errors.New("FieldToMatch is a required field")
    }
    // Marshal the "FieldToMatch" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FieldToMatch\": ")
	if tmp, err := json.Marshal(strct.FieldToMatch); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Size" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Size" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Size\": ")
	if tmp, err := json.Marshal(strct.Size); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TextTransformations" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TextTransformations" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TextTransformations\": ")
	if tmp, err := json.Marshal(strct.TextTransformations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SizeConstraintStatement) UnmarshalJSON(b []byte) error {
    ComparisonOperatorReceived := false
    FieldToMatchReceived := false
    SizeReceived := false
    TextTransformationsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ComparisonOperator":
            if err := json.Unmarshal([]byte(v), &strct.ComparisonOperator); err != nil {
                return err
             }
            ComparisonOperatorReceived = true
        case "FieldToMatch":
            if err := json.Unmarshal([]byte(v), &strct.FieldToMatch); err != nil {
                return err
             }
            FieldToMatchReceived = true
        case "Size":
            if err := json.Unmarshal([]byte(v), &strct.Size); err != nil {
                return err
             }
            SizeReceived = true
        case "TextTransformations":
            if err := json.Unmarshal([]byte(v), &strct.TextTransformations); err != nil {
                return err
             }
            TextTransformationsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ComparisonOperator (a required property) was received
    if !ComparisonOperatorReceived {
        return errors.New("\"ComparisonOperator\" is required but was not present")
    }
    // check if FieldToMatch (a required property) was received
    if !FieldToMatchReceived {
        return errors.New("\"FieldToMatch\" is required but was not present")
    }
    // check if Size (a required property) was received
    if !SizeReceived {
        return errors.New("\"Size\" is required but was not present")
    }
    // check if TextTransformations (a required property) was received
    if !TextTransformationsReceived {
        return errors.New("\"TextTransformations\" is required but was not present")
    }
    return nil
}

func (strct *SqliMatchStatement) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "FieldToMatch" field is required
    if strct.FieldToMatch == nil {
        return nil, errors.New("FieldToMatch is a required field")
    }
    // Marshal the "FieldToMatch" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FieldToMatch\": ")
	if tmp, err := json.Marshal(strct.FieldToMatch); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SensitivityLevel" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SensitivityLevel\": ")
	if tmp, err := json.Marshal(strct.SensitivityLevel); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TextTransformations" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TextTransformations" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TextTransformations\": ")
	if tmp, err := json.Marshal(strct.TextTransformations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SqliMatchStatement) UnmarshalJSON(b []byte) error {
    FieldToMatchReceived := false
    TextTransformationsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "FieldToMatch":
            if err := json.Unmarshal([]byte(v), &strct.FieldToMatch); err != nil {
                return err
             }
            FieldToMatchReceived = true
        case "SensitivityLevel":
            if err := json.Unmarshal([]byte(v), &strct.SensitivityLevel); err != nil {
                return err
             }
        case "TextTransformations":
            if err := json.Unmarshal([]byte(v), &strct.TextTransformations); err != nil {
                return err
             }
            TextTransformationsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if FieldToMatch (a required property) was received
    if !FieldToMatchReceived {
        return errors.New("\"FieldToMatch\" is required but was not present")
    }
    // check if TextTransformations (a required property) was received
    if !TextTransformationsReceived {
        return errors.New("\"TextTransformations\" is required but was not present")
    }
    return nil
}

func (strct *Statement) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AndStatement" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AndStatement\": ")
	if tmp, err := json.Marshal(strct.AndStatement); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ByteMatchStatement" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ByteMatchStatement\": ")
	if tmp, err := json.Marshal(strct.ByteMatchStatement); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "GeoMatchStatement" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"GeoMatchStatement\": ")
	if tmp, err := json.Marshal(strct.GeoMatchStatement); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IPSetReferenceStatement" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IPSetReferenceStatement\": ")
	if tmp, err := json.Marshal(strct.IPSetReferenceStatement); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LabelMatchStatement" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LabelMatchStatement\": ")
	if tmp, err := json.Marshal(strct.LabelMatchStatement); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ManagedRuleGroupStatement" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ManagedRuleGroupStatement\": ")
	if tmp, err := json.Marshal(strct.ManagedRuleGroupStatement); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "NotStatement" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NotStatement\": ")
	if tmp, err := json.Marshal(strct.NotStatement); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OrStatement" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OrStatement\": ")
	if tmp, err := json.Marshal(strct.OrStatement); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RateBasedStatement" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RateBasedStatement\": ")
	if tmp, err := json.Marshal(strct.RateBasedStatement); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RegexMatchStatement" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RegexMatchStatement\": ")
	if tmp, err := json.Marshal(strct.RegexMatchStatement); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RegexPatternSetReferenceStatement" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RegexPatternSetReferenceStatement\": ")
	if tmp, err := json.Marshal(strct.RegexPatternSetReferenceStatement); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RuleGroupReferenceStatement" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RuleGroupReferenceStatement\": ")
	if tmp, err := json.Marshal(strct.RuleGroupReferenceStatement); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SizeConstraintStatement" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SizeConstraintStatement\": ")
	if tmp, err := json.Marshal(strct.SizeConstraintStatement); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SqliMatchStatement" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SqliMatchStatement\": ")
	if tmp, err := json.Marshal(strct.SqliMatchStatement); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "XssMatchStatement" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"XssMatchStatement\": ")
	if tmp, err := json.Marshal(strct.XssMatchStatement); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Statement) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AndStatement":
            if err := json.Unmarshal([]byte(v), &strct.AndStatement); err != nil {
                return err
             }
        case "ByteMatchStatement":
            if err := json.Unmarshal([]byte(v), &strct.ByteMatchStatement); err != nil {
                return err
             }
        case "GeoMatchStatement":
            if err := json.Unmarshal([]byte(v), &strct.GeoMatchStatement); err != nil {
                return err
             }
        case "IPSetReferenceStatement":
            if err := json.Unmarshal([]byte(v), &strct.IPSetReferenceStatement); err != nil {
                return err
             }
        case "LabelMatchStatement":
            if err := json.Unmarshal([]byte(v), &strct.LabelMatchStatement); err != nil {
                return err
             }
        case "ManagedRuleGroupStatement":
            if err := json.Unmarshal([]byte(v), &strct.ManagedRuleGroupStatement); err != nil {
                return err
             }
        case "NotStatement":
            if err := json.Unmarshal([]byte(v), &strct.NotStatement); err != nil {
                return err
             }
        case "OrStatement":
            if err := json.Unmarshal([]byte(v), &strct.OrStatement); err != nil {
                return err
             }
        case "RateBasedStatement":
            if err := json.Unmarshal([]byte(v), &strct.RateBasedStatement); err != nil {
                return err
             }
        case "RegexMatchStatement":
            if err := json.Unmarshal([]byte(v), &strct.RegexMatchStatement); err != nil {
                return err
             }
        case "RegexPatternSetReferenceStatement":
            if err := json.Unmarshal([]byte(v), &strct.RegexPatternSetReferenceStatement); err != nil {
                return err
             }
        case "RuleGroupReferenceStatement":
            if err := json.Unmarshal([]byte(v), &strct.RuleGroupReferenceStatement); err != nil {
                return err
             }
        case "SizeConstraintStatement":
            if err := json.Unmarshal([]byte(v), &strct.SizeConstraintStatement); err != nil {
                return err
             }
        case "SqliMatchStatement":
            if err := json.Unmarshal([]byte(v), &strct.SqliMatchStatement); err != nil {
                return err
             }
        case "XssMatchStatement":
            if err := json.Unmarshal([]byte(v), &strct.XssMatchStatement); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *TextTransformation) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Priority" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Priority" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Priority\": ")
	if tmp, err := json.Marshal(strct.Priority); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TextTransformation) UnmarshalJSON(b []byte) error {
    PriorityReceived := false
    TypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Priority":
            if err := json.Unmarshal([]byte(v), &strct.Priority); err != nil {
                return err
             }
            PriorityReceived = true
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            TypeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Priority (a required property) was received
    if !PriorityReceived {
        return errors.New("\"Priority\" is required but was not present")
    }
    // check if Type (a required property) was received
    if !TypeReceived {
        return errors.New("\"Type\" is required but was not present")
    }
    return nil
}

func (strct *VisibilityConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "CloudWatchMetricsEnabled" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "CloudWatchMetricsEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CloudWatchMetricsEnabled\": ")
	if tmp, err := json.Marshal(strct.CloudWatchMetricsEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "MetricName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "MetricName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MetricName\": ")
	if tmp, err := json.Marshal(strct.MetricName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "SampledRequestsEnabled" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "SampledRequestsEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SampledRequestsEnabled\": ")
	if tmp, err := json.Marshal(strct.SampledRequestsEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *VisibilityConfig) UnmarshalJSON(b []byte) error {
    CloudWatchMetricsEnabledReceived := false
    MetricNameReceived := false
    SampledRequestsEnabledReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CloudWatchMetricsEnabled":
            if err := json.Unmarshal([]byte(v), &strct.CloudWatchMetricsEnabled); err != nil {
                return err
             }
            CloudWatchMetricsEnabledReceived = true
        case "MetricName":
            if err := json.Unmarshal([]byte(v), &strct.MetricName); err != nil {
                return err
             }
            MetricNameReceived = true
        case "SampledRequestsEnabled":
            if err := json.Unmarshal([]byte(v), &strct.SampledRequestsEnabled); err != nil {
                return err
             }
            SampledRequestsEnabledReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if CloudWatchMetricsEnabled (a required property) was received
    if !CloudWatchMetricsEnabledReceived {
        return errors.New("\"CloudWatchMetricsEnabled\" is required but was not present")
    }
    // check if MetricName (a required property) was received
    if !MetricNameReceived {
        return errors.New("\"MetricName\" is required but was not present")
    }
    // check if SampledRequestsEnabled (a required property) was received
    if !SampledRequestsEnabledReceived {
        return errors.New("\"SampledRequestsEnabled\" is required but was not present")
    }
    return nil
}

func (strct *XssMatchStatement) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "FieldToMatch" field is required
    if strct.FieldToMatch == nil {
        return nil, errors.New("FieldToMatch is a required field")
    }
    // Marshal the "FieldToMatch" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FieldToMatch\": ")
	if tmp, err := json.Marshal(strct.FieldToMatch); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TextTransformations" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TextTransformations" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TextTransformations\": ")
	if tmp, err := json.Marshal(strct.TextTransformations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *XssMatchStatement) UnmarshalJSON(b []byte) error {
    FieldToMatchReceived := false
    TextTransformationsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "FieldToMatch":
            if err := json.Unmarshal([]byte(v), &strct.FieldToMatch); err != nil {
                return err
             }
            FieldToMatchReceived = true
        case "TextTransformations":
            if err := json.Unmarshal([]byte(v), &strct.TextTransformations); err != nil {
                return err
             }
            TextTransformationsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if FieldToMatch (a required property) was received
    if !FieldToMatchReceived {
        return errors.New("\"FieldToMatch\" is required but was not present")
    }
    // check if TextTransformations (a required property) was received
    if !TextTransformationsReceived {
        return errors.New("\"TextTransformations\" is required but was not present")
    }
    return nil
}
