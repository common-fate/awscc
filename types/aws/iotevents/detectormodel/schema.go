// Code generated by schema-generate. DO NOT EDIT.

package detectormodel

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// Action The actions to be performed.
type Action struct {
  ClearTimer *ClearTimer `json:"ClearTimer,omitempty"`
  DynamoDB *DynamoDB `json:"DynamoDB,omitempty"`
  DynamoDBv2 *DynamoDBv2 `json:"DynamoDBv2,omitempty"`
  Firehose *Firehose `json:"Firehose,omitempty"`
  IotEvents *IotEvents `json:"IotEvents,omitempty"`
  IotSiteWise *IotSiteWise `json:"IotSiteWise,omitempty"`
  IotTopicPublish *IotTopicPublish `json:"IotTopicPublish,omitempty"`
  Lambda *Lambda `json:"Lambda,omitempty"`
  ResetTimer *ResetTimer `json:"ResetTimer,omitempty"`
  SetTimer *SetTimer `json:"SetTimer,omitempty"`
  SetVariable *SetVariable `json:"SetVariable,omitempty"`
  Sns *Sns `json:"Sns,omitempty"`
  Sqs *Sqs `json:"Sqs,omitempty"`
}

// AssetPropertyTimestamp A structure that contains timestamp information. For more information, see [TimeInNanos](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_TimeInNanos.html) in the *AWS IoT SiteWise API Reference*.
type AssetPropertyTimestamp struct {

  // The timestamp, in seconds, in the Unix epoch format. The valid range is between `1-31556889864403199`. You can also specify an expression.
  OffsetInNanos string `json:"OffsetInNanos,omitempty"`

  // The nanosecond offset converted from `timeInSeconds`. The valid range is between `0-999999999`. You can also specify an expression.
  TimeInSeconds string `json:"TimeInSeconds"`
}

// AssetPropertyValue A structure that contains value information. For more information, see [AssetPropertyValue](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_AssetPropertyValue.html) in the *AWS IoT SiteWise API Reference*.
type AssetPropertyValue struct {

  // The quality of the asset property value. The value must be `GOOD`, `BAD`, or `UNCERTAIN`. You can also specify an expression.
  Quality string `json:"Quality,omitempty"`
  Timestamp *AssetPropertyTimestamp `json:"Timestamp,omitempty"`
  Value *AssetPropertyVariant `json:"Value"`
}

// AssetPropertyVariant A structure that contains an asset property value. For more information, see [Variant](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_Variant.html) in the *AWS IoT SiteWise API Reference*.
type AssetPropertyVariant struct {

  // The asset property value is a Boolean value that must be `TRUE` or `FALSE`. You can also specify an expression. If you use an expression, the evaluated result should be a Boolean value.
  BooleanValue string `json:"BooleanValue,omitempty"`

  // The asset property value is a double. You can also specify an expression. If you use an expression, the evaluated result should be a double.
  DoubleValue string `json:"DoubleValue,omitempty"`

  // The asset property value is an integer. You can also specify an expression. If you use an expression, the evaluated result should be an integer.
  IntegerValue string `json:"IntegerValue,omitempty"`

  // The asset property value is a string. You can also specify an expression. If you use an expression, the evaluated result should be a string.
  StringValue string `json:"StringValue,omitempty"`
}

// ClearTimer Information needed to clear the timer.
type ClearTimer struct {
  TimerName string `json:"TimerName"`
}

// DetectorModelDefinition Information that defines how a detector operates.
type DetectorModelDefinition struct {

  // The state that is entered at the creation of each detector (instance).
  InitialStateName string `json:"InitialStateName"`

  // Information about the states of the detector.
  States []*State `json:"States"`
}

// DynamoDB Writes to the DynamoDB table that you created. The default action payload contains all attribute-value pairs that have the information about the detector model instance and the event that triggered the action. You can also customize the [payload](https://docs.aws.amazon.com/iotevents/latest/apireference/API_Payload.html). One column of the DynamoDB table receives all attribute-value pairs in the payload that you specify. For more information, see [Actions](https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-event-actions.html) in *AWS IoT Events Developer Guide*.
type DynamoDB struct {

  // The name of the hash key (also called the partition key).
  HashKeyField string `json:"HashKeyField"`

  // The data type for the hash key (also called the partition key). You can specify the following values:
  // 
  // * `STRING` - The hash key is a string.
  // 
  // * `NUMBER` - The hash key is a number.
  // 
  // If you don't specify `hashKeyType`, the default value is `STRING`.
  HashKeyType string `json:"HashKeyType,omitempty"`

  // The value of the hash key (also called the partition key).
  HashKeyValue string `json:"HashKeyValue"`

  // The type of operation to perform. You can specify the following values:
  // 
  // * `INSERT` - Insert data as a new item into the DynamoDB table. This item uses the specified hash key as a partition key. If you specified a range key, the item uses the range key as a sort key.
  // 
  // * `UPDATE` - Update an existing item of the DynamoDB table with new data. This item's partition key must match the specified hash key. If you specified a range key, the range key must match the item's sort key.
  // 
  // * `DELETE` - Delete an existing item of the DynamoDB table. This item's partition key must match the specified hash key. If you specified a range key, the range key must match the item's sort key.
  // 
  // If you don't specify this parameter, AWS IoT Events triggers the `INSERT` operation.
  Operation string `json:"Operation,omitempty"`
  Payload *Payload `json:"Payload,omitempty"`

  // The name of the DynamoDB column that receives the action payload.
  // 
  // If you don't specify this parameter, the name of the DynamoDB column is `payload`.
  PayloadField string `json:"PayloadField,omitempty"`

  // The name of the range key (also called the sort key).
  RangeKeyField string `json:"RangeKeyField,omitempty"`

  // The data type for the range key (also called the sort key), You can specify the following values:
  // 
  // * `STRING` - The range key is a string.
  // 
  // * `NUMBER` - The range key is number.
  // 
  // If you don't specify `rangeKeyField`, the default value is `STRING`.
  RangeKeyType string `json:"RangeKeyType,omitempty"`

  // The value of the range key (also called the sort key).
  RangeKeyValue string `json:"RangeKeyValue,omitempty"`

  // The name of the DynamoDB table.
  TableName string `json:"TableName"`
}

// DynamoDBv2 Defines an action to write to the Amazon DynamoDB table that you created. The default action payload contains all attribute-value pairs that have the information about the detector model instance and the event that triggered the action. You can also customize the [payload](https://docs.aws.amazon.com/iotevents/latest/apireference/API_Payload.html). A separate column of the DynamoDB table receives one attribute-value pair in the payload that you specify.
// 
// You can use expressions for parameters that are strings. For more information, see [Expressions](https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-expressions.html) in the *AWS IoT Events Developer Guide*.
type DynamoDBv2 struct {
  Payload *Payload `json:"Payload,omitempty"`

  // The name of the DynamoDB table.
  TableName string `json:"TableName"`
}

// Event Specifies the `actions` to be performed when the `condition` evaluates to `TRUE`.
type Event struct {

  // The actions to be performed.
  Actions []*Action `json:"Actions,omitempty"`

  // The Boolean expression that, when `TRUE`, causes the `actions` to be performed. If not present, the `actions` are performed (=`TRUE`). If the expression result is not a `Boolean` value, the `actions` are not performed (=`FALSE`).
  Condition string `json:"Condition,omitempty"`

  // The name of the event.
  EventName string `json:"EventName"`
}

// Firehose Sends information about the detector model instance and the event that triggered the action to an Amazon Kinesis Data Firehose delivery stream.
type Firehose struct {

  // The name of the Kinesis Data Firehose delivery stream where the data is written.
  DeliveryStreamName string `json:"DeliveryStreamName"`
  Payload *Payload `json:"Payload,omitempty"`

  // A character separator that is used to separate records written to the Kinesis Data Firehose delivery stream. Valid values are: '\n' (newline), '\t' (tab), '\r\n' (Windows newline), ',' (comma).
  Separator string `json:"Separator,omitempty"`
}

// IotEvents Sends an AWS IoT Events input, passing in information about the detector model instance and the event that triggered the action.
type IotEvents struct {

  // The name of the AWS IoT Events input where the data is sent.
  InputName string `json:"InputName"`
  Payload *Payload `json:"Payload,omitempty"`
}

// IotSiteWise Sends information about the detector model instance and the event that triggered the action to a specified asset property in AWS IoT SiteWise.
type IotSiteWise struct {

  // The ID of the asset that has the specified property. You can specify an expression.
  AssetId string `json:"AssetId,omitempty"`

  // A unique identifier for this entry. You can use the entry ID to track which data entry causes an error in case of failure. The default is a new unique identifier. You can also specify an expression.
  EntryId string `json:"EntryId,omitempty"`

  // The alias of the asset property. You can also specify an expression.
  PropertyAlias string `json:"PropertyAlias,omitempty"`

  // The ID of the asset property. You can specify an expression.
  PropertyId string `json:"PropertyId,omitempty"`
  PropertyValue *AssetPropertyValue `json:"PropertyValue"`
}

// IotTopicPublish Information required to publish the MQTT message through the AWS IoT message broker.
type IotTopicPublish struct {

  // The MQTT topic of the message. You can use a string expression that includes variables (`$variable.<variable-name>`) and input values (`$input.<input-name>.<path-to-datum>`) as the topic string.
  MqttTopic string `json:"MqttTopic"`
  Payload *Payload `json:"Payload,omitempty"`
}

// Lambda 
type Lambda struct {

  // The ARN of the Lambda function that is executed.
  FunctionArn string `json:"FunctionArn"`
  Payload *Payload `json:"Payload,omitempty"`
}

// OnEnter When entering this state, perform these `actions` if the `condition` is `TRUE`.
type OnEnter struct {

  // Specifies the `actions` that are performed when the state is entered and the `condition` is `TRUE`.
  Events []*Event `json:"Events,omitempty"`
}

// OnExit When exiting this state, perform these `actions` if the specified `condition` is `TRUE`.
type OnExit struct {

  // Specifies the `actions` that are performed when the state is exited and the `condition` is `TRUE`.
  Events []*Event `json:"Events,omitempty"`
}

// OnInput When an input is received and the `condition` is `TRUE`, perform the specified `actions`.
type OnInput struct {

  // Specifies the `actions` performed when the `condition` evaluates to `TRUE`.
  Events []*Event `json:"Events,omitempty"`

  // Specifies the `actions` performed, and the next `state` entered, when a `condition` evaluates to `TRUE`.
  TransitionEvents []*TransitionEvent `json:"TransitionEvents,omitempty"`
}

// Payload Information needed to configure the payload.
// 
// By default, AWS IoT Events generates a standard payload in JSON for any action. This action payload contains all attribute-value pairs that have the information about the detector model instance and the event triggered the action. To configure the action payload, you can use `contentExpression`.
type Payload struct {

  // The content of the payload. You can use a string expression that includes quoted strings (`'<string>'`), variables (`$variable.<variable-name>`), input values (`$input.<input-name>.<path-to-datum>`), string concatenations, and quoted strings that contain `${}` as the content. The recommended maximum size of a content expression is 1 KB.
  ContentExpression string `json:"ContentExpression"`

  // The value of the payload type can be either `STRING` or `JSON`.
  Type string `json:"Type"`
}

// ResetTimer Information required to reset the timer. The timer is reset to the previously evaluated result of the duration. The duration expression isn't reevaluated when you reset the timer.
type ResetTimer struct {

  // The name of the timer to reset.
  TimerName string `json:"TimerName"`
}

// Resource The AWS::IoTEvents::DetectorModel resource creates a detector model. You create a *detector model* (a model of your equipment or process) using *states*. For each state, you define conditional (Boolean) logic that evaluates the incoming inputs to detect significant events. When an event is detected, it can change the state or trigger custom-built or predefined actions using other AWS services. You can define additional events that trigger actions when entering or exiting a state and, optionally, when a condition is met. For more information, see [How to Use AWS IoT Events](https://docs.aws.amazon.com/iotevents/latest/developerguide/how-to-use-iotevents.html) in the *AWS IoT Events Developer Guide*.
type Resource struct {
  DetectorModelDefinition *DetectorModelDefinition `json:"DetectorModelDefinition"`

  // A brief description of the detector model.
  DetectorModelDescription string `json:"DetectorModelDescription,omitempty"`

  // The name of the detector model.
  DetectorModelName string `json:"DetectorModelName,omitempty"`

  // Information about the order in which events are evaluated and how actions are executed.
  EvaluationMethod string `json:"EvaluationMethod,omitempty"`

  // The value used to identify a detector instance. When a device or system sends input, a new detector instance with a unique key value is created. AWS IoT Events can continue to route input to its corresponding detector instance based on this identifying information.
  // 
  // This parameter uses a JSON-path expression to select the attribute-value pair in the message payload that is used for identification. To route the message to the correct detector instance, the device must send a message payload that contains the same attribute-value.
  Key string `json:"Key,omitempty"`

  // The ARN of the role that grants permission to AWS IoT Events to perform its operations.
  RoleArn string `json:"RoleArn"`

  // An array of key-value pairs to apply to this resource.
  // 
  // For more information, see [Tag](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html).
  Tags []*Tag `json:"Tags,omitempty"`
}

// SetTimer Information needed to set the timer.
type SetTimer struct {

  // The duration of the timer, in seconds. You can use a string expression that includes numbers, variables (`$variable.<variable-name>`), and input values (`$input.<input-name>.<path-to-datum>`) as the duration. The range of the duration is `1-31622400` seconds. To ensure accuracy, the minimum duration is `60` seconds. The evaluated result of the duration is rounded down to the nearest whole number.
  DurationExpression string `json:"DurationExpression,omitempty"`

  // The number of seconds until the timer expires. The minimum value is `60` seconds to ensure accuracy. The maximum value is `31622400` seconds.
  Seconds int `json:"Seconds,omitempty"`

  // The name of the timer.
  TimerName string `json:"TimerName"`
}

// SetVariable Information about the variable and its new value.
type SetVariable struct {

  // The new value of the variable.
  Value string `json:"Value"`

  // The name of the variable.
  VariableName string `json:"VariableName"`
}

// Sns Information required to publish the Amazon SNS message.
type Sns struct {
  Payload *Payload `json:"Payload,omitempty"`

  // The ARN of the Amazon SNS target where the message is sent.
  TargetArn string `json:"TargetArn"`
}

// Sqs 
type Sqs struct {
  Payload *Payload `json:"Payload,omitempty"`

  // The URL of the SQS queue where the data is written.
  QueueUrl string `json:"QueueUrl"`

  // Set this to `TRUE` if you want the data to be base-64 encoded before it is written to the queue. Otherwise, set this to `FALSE`.
  UseBase64 bool `json:"UseBase64,omitempty"`
}

// State Information that defines a state of a detector.
type State struct {
  OnEnter *OnEnter `json:"OnEnter,omitempty"`
  OnExit *OnExit `json:"OnExit,omitempty"`
  OnInput *OnInput `json:"OnInput,omitempty"`

  // The name of the state.
  StateName string `json:"StateName"`
}

// Tag Tags to be applied to Input.
type Tag struct {

  // Key of the Tag.
  Key string `json:"Key"`

  // Value of the Tag.
  Value string `json:"Value"`
}

// TransitionEvent Specifies the `actions `performed and the next `state` entered when a `condition` evaluates to `TRUE`.
type TransitionEvent struct {

  // The actions to be performed.
  Actions []*Action `json:"Actions,omitempty"`

  // A Boolean expression that when `TRUE` causes the `actions` to be performed and the `nextState` to be entered.
  Condition string `json:"Condition"`

  // The name of the event.
  EventName string `json:"EventName"`

  // The next state to enter.
  NextState string `json:"NextState"`
}

func (strct *Action) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ClearTimer" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ClearTimer\": ")
	if tmp, err := json.Marshal(strct.ClearTimer); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DynamoDB" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DynamoDB\": ")
	if tmp, err := json.Marshal(strct.DynamoDB); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DynamoDBv2" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DynamoDBv2\": ")
	if tmp, err := json.Marshal(strct.DynamoDBv2); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Firehose" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Firehose\": ")
	if tmp, err := json.Marshal(strct.Firehose); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IotEvents" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IotEvents\": ")
	if tmp, err := json.Marshal(strct.IotEvents); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IotSiteWise" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IotSiteWise\": ")
	if tmp, err := json.Marshal(strct.IotSiteWise); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IotTopicPublish" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IotTopicPublish\": ")
	if tmp, err := json.Marshal(strct.IotTopicPublish); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Lambda" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Lambda\": ")
	if tmp, err := json.Marshal(strct.Lambda); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ResetTimer" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ResetTimer\": ")
	if tmp, err := json.Marshal(strct.ResetTimer); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SetTimer" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SetTimer\": ")
	if tmp, err := json.Marshal(strct.SetTimer); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SetVariable" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SetVariable\": ")
	if tmp, err := json.Marshal(strct.SetVariable); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Sns" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Sns\": ")
	if tmp, err := json.Marshal(strct.Sns); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Sqs" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Sqs\": ")
	if tmp, err := json.Marshal(strct.Sqs); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Action) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ClearTimer":
            if err := json.Unmarshal([]byte(v), &strct.ClearTimer); err != nil {
                return err
             }
        case "DynamoDB":
            if err := json.Unmarshal([]byte(v), &strct.DynamoDB); err != nil {
                return err
             }
        case "DynamoDBv2":
            if err := json.Unmarshal([]byte(v), &strct.DynamoDBv2); err != nil {
                return err
             }
        case "Firehose":
            if err := json.Unmarshal([]byte(v), &strct.Firehose); err != nil {
                return err
             }
        case "IotEvents":
            if err := json.Unmarshal([]byte(v), &strct.IotEvents); err != nil {
                return err
             }
        case "IotSiteWise":
            if err := json.Unmarshal([]byte(v), &strct.IotSiteWise); err != nil {
                return err
             }
        case "IotTopicPublish":
            if err := json.Unmarshal([]byte(v), &strct.IotTopicPublish); err != nil {
                return err
             }
        case "Lambda":
            if err := json.Unmarshal([]byte(v), &strct.Lambda); err != nil {
                return err
             }
        case "ResetTimer":
            if err := json.Unmarshal([]byte(v), &strct.ResetTimer); err != nil {
                return err
             }
        case "SetTimer":
            if err := json.Unmarshal([]byte(v), &strct.SetTimer); err != nil {
                return err
             }
        case "SetVariable":
            if err := json.Unmarshal([]byte(v), &strct.SetVariable); err != nil {
                return err
             }
        case "Sns":
            if err := json.Unmarshal([]byte(v), &strct.Sns); err != nil {
                return err
             }
        case "Sqs":
            if err := json.Unmarshal([]byte(v), &strct.Sqs); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *AssetPropertyTimestamp) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "OffsetInNanos" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OffsetInNanos\": ")
	if tmp, err := json.Marshal(strct.OffsetInNanos); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TimeInSeconds" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TimeInSeconds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TimeInSeconds\": ")
	if tmp, err := json.Marshal(strct.TimeInSeconds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AssetPropertyTimestamp) UnmarshalJSON(b []byte) error {
    TimeInSecondsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "OffsetInNanos":
            if err := json.Unmarshal([]byte(v), &strct.OffsetInNanos); err != nil {
                return err
             }
        case "TimeInSeconds":
            if err := json.Unmarshal([]byte(v), &strct.TimeInSeconds); err != nil {
                return err
             }
            TimeInSecondsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if TimeInSeconds (a required property) was received
    if !TimeInSecondsReceived {
        return errors.New("\"TimeInSeconds\" is required but was not present")
    }
    return nil
}

func (strct *AssetPropertyValue) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Quality" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Quality\": ")
	if tmp, err := json.Marshal(strct.Quality); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Timestamp" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Timestamp\": ")
	if tmp, err := json.Marshal(strct.Timestamp); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    if strct.Value == nil {
        return nil, errors.New("Value is a required field")
    }
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AssetPropertyValue) UnmarshalJSON(b []byte) error {
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Quality":
            if err := json.Unmarshal([]byte(v), &strct.Quality); err != nil {
                return err
             }
        case "Timestamp":
            if err := json.Unmarshal([]byte(v), &strct.Timestamp); err != nil {
                return err
             }
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *AssetPropertyVariant) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "BooleanValue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BooleanValue\": ")
	if tmp, err := json.Marshal(strct.BooleanValue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DoubleValue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DoubleValue\": ")
	if tmp, err := json.Marshal(strct.DoubleValue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IntegerValue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IntegerValue\": ")
	if tmp, err := json.Marshal(strct.IntegerValue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StringValue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StringValue\": ")
	if tmp, err := json.Marshal(strct.StringValue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AssetPropertyVariant) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BooleanValue":
            if err := json.Unmarshal([]byte(v), &strct.BooleanValue); err != nil {
                return err
             }
        case "DoubleValue":
            if err := json.Unmarshal([]byte(v), &strct.DoubleValue); err != nil {
                return err
             }
        case "IntegerValue":
            if err := json.Unmarshal([]byte(v), &strct.IntegerValue); err != nil {
                return err
             }
        case "StringValue":
            if err := json.Unmarshal([]byte(v), &strct.StringValue); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ClearTimer) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "TimerName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TimerName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TimerName\": ")
	if tmp, err := json.Marshal(strct.TimerName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ClearTimer) UnmarshalJSON(b []byte) error {
    TimerNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "TimerName":
            if err := json.Unmarshal([]byte(v), &strct.TimerName); err != nil {
                return err
             }
            TimerNameReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if TimerName (a required property) was received
    if !TimerNameReceived {
        return errors.New("\"TimerName\" is required but was not present")
    }
    return nil
}

func (strct *DetectorModelDefinition) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "InitialStateName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "InitialStateName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InitialStateName\": ")
	if tmp, err := json.Marshal(strct.InitialStateName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "States" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "States" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"States\": ")
	if tmp, err := json.Marshal(strct.States); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DetectorModelDefinition) UnmarshalJSON(b []byte) error {
    InitialStateNameReceived := false
    StatesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "InitialStateName":
            if err := json.Unmarshal([]byte(v), &strct.InitialStateName); err != nil {
                return err
             }
            InitialStateNameReceived = true
        case "States":
            if err := json.Unmarshal([]byte(v), &strct.States); err != nil {
                return err
             }
            StatesReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if InitialStateName (a required property) was received
    if !InitialStateNameReceived {
        return errors.New("\"InitialStateName\" is required but was not present")
    }
    // check if States (a required property) was received
    if !StatesReceived {
        return errors.New("\"States\" is required but was not present")
    }
    return nil
}

func (strct *DynamoDB) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "HashKeyField" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "HashKeyField" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HashKeyField\": ")
	if tmp, err := json.Marshal(strct.HashKeyField); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "HashKeyType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HashKeyType\": ")
	if tmp, err := json.Marshal(strct.HashKeyType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "HashKeyValue" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "HashKeyValue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HashKeyValue\": ")
	if tmp, err := json.Marshal(strct.HashKeyValue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Operation" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Operation\": ")
	if tmp, err := json.Marshal(strct.Operation); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Payload" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Payload\": ")
	if tmp, err := json.Marshal(strct.Payload); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PayloadField" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PayloadField\": ")
	if tmp, err := json.Marshal(strct.PayloadField); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RangeKeyField" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RangeKeyField\": ")
	if tmp, err := json.Marshal(strct.RangeKeyField); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RangeKeyType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RangeKeyType\": ")
	if tmp, err := json.Marshal(strct.RangeKeyType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RangeKeyValue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RangeKeyValue\": ")
	if tmp, err := json.Marshal(strct.RangeKeyValue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TableName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TableName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TableName\": ")
	if tmp, err := json.Marshal(strct.TableName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DynamoDB) UnmarshalJSON(b []byte) error {
    HashKeyFieldReceived := false
    HashKeyValueReceived := false
    TableNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "HashKeyField":
            if err := json.Unmarshal([]byte(v), &strct.HashKeyField); err != nil {
                return err
             }
            HashKeyFieldReceived = true
        case "HashKeyType":
            if err := json.Unmarshal([]byte(v), &strct.HashKeyType); err != nil {
                return err
             }
        case "HashKeyValue":
            if err := json.Unmarshal([]byte(v), &strct.HashKeyValue); err != nil {
                return err
             }
            HashKeyValueReceived = true
        case "Operation":
            if err := json.Unmarshal([]byte(v), &strct.Operation); err != nil {
                return err
             }
        case "Payload":
            if err := json.Unmarshal([]byte(v), &strct.Payload); err != nil {
                return err
             }
        case "PayloadField":
            if err := json.Unmarshal([]byte(v), &strct.PayloadField); err != nil {
                return err
             }
        case "RangeKeyField":
            if err := json.Unmarshal([]byte(v), &strct.RangeKeyField); err != nil {
                return err
             }
        case "RangeKeyType":
            if err := json.Unmarshal([]byte(v), &strct.RangeKeyType); err != nil {
                return err
             }
        case "RangeKeyValue":
            if err := json.Unmarshal([]byte(v), &strct.RangeKeyValue); err != nil {
                return err
             }
        case "TableName":
            if err := json.Unmarshal([]byte(v), &strct.TableName); err != nil {
                return err
             }
            TableNameReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if HashKeyField (a required property) was received
    if !HashKeyFieldReceived {
        return errors.New("\"HashKeyField\" is required but was not present")
    }
    // check if HashKeyValue (a required property) was received
    if !HashKeyValueReceived {
        return errors.New("\"HashKeyValue\" is required but was not present")
    }
    // check if TableName (a required property) was received
    if !TableNameReceived {
        return errors.New("\"TableName\" is required but was not present")
    }
    return nil
}

func (strct *DynamoDBv2) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Payload" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Payload\": ")
	if tmp, err := json.Marshal(strct.Payload); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TableName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TableName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TableName\": ")
	if tmp, err := json.Marshal(strct.TableName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DynamoDBv2) UnmarshalJSON(b []byte) error {
    TableNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Payload":
            if err := json.Unmarshal([]byte(v), &strct.Payload); err != nil {
                return err
             }
        case "TableName":
            if err := json.Unmarshal([]byte(v), &strct.TableName); err != nil {
                return err
             }
            TableNameReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if TableName (a required property) was received
    if !TableNameReceived {
        return errors.New("\"TableName\" is required but was not present")
    }
    return nil
}

func (strct *Event) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Actions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Actions\": ")
	if tmp, err := json.Marshal(strct.Actions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Condition" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Condition\": ")
	if tmp, err := json.Marshal(strct.Condition); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "EventName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "EventName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EventName\": ")
	if tmp, err := json.Marshal(strct.EventName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Event) UnmarshalJSON(b []byte) error {
    EventNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Actions":
            if err := json.Unmarshal([]byte(v), &strct.Actions); err != nil {
                return err
             }
        case "Condition":
            if err := json.Unmarshal([]byte(v), &strct.Condition); err != nil {
                return err
             }
        case "EventName":
            if err := json.Unmarshal([]byte(v), &strct.EventName); err != nil {
                return err
             }
            EventNameReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if EventName (a required property) was received
    if !EventNameReceived {
        return errors.New("\"EventName\" is required but was not present")
    }
    return nil
}

func (strct *Firehose) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "DeliveryStreamName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "DeliveryStreamName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DeliveryStreamName\": ")
	if tmp, err := json.Marshal(strct.DeliveryStreamName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Payload" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Payload\": ")
	if tmp, err := json.Marshal(strct.Payload); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Separator" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Separator\": ")
	if tmp, err := json.Marshal(strct.Separator); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Firehose) UnmarshalJSON(b []byte) error {
    DeliveryStreamNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DeliveryStreamName":
            if err := json.Unmarshal([]byte(v), &strct.DeliveryStreamName); err != nil {
                return err
             }
            DeliveryStreamNameReceived = true
        case "Payload":
            if err := json.Unmarshal([]byte(v), &strct.Payload); err != nil {
                return err
             }
        case "Separator":
            if err := json.Unmarshal([]byte(v), &strct.Separator); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if DeliveryStreamName (a required property) was received
    if !DeliveryStreamNameReceived {
        return errors.New("\"DeliveryStreamName\" is required but was not present")
    }
    return nil
}

func (strct *IotEvents) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "InputName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "InputName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InputName\": ")
	if tmp, err := json.Marshal(strct.InputName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Payload" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Payload\": ")
	if tmp, err := json.Marshal(strct.Payload); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *IotEvents) UnmarshalJSON(b []byte) error {
    InputNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "InputName":
            if err := json.Unmarshal([]byte(v), &strct.InputName); err != nil {
                return err
             }
            InputNameReceived = true
        case "Payload":
            if err := json.Unmarshal([]byte(v), &strct.Payload); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if InputName (a required property) was received
    if !InputNameReceived {
        return errors.New("\"InputName\" is required but was not present")
    }
    return nil
}

func (strct *IotSiteWise) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AssetId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AssetId\": ")
	if tmp, err := json.Marshal(strct.AssetId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EntryId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EntryId\": ")
	if tmp, err := json.Marshal(strct.EntryId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PropertyAlias" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PropertyAlias\": ")
	if tmp, err := json.Marshal(strct.PropertyAlias); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PropertyId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PropertyId\": ")
	if tmp, err := json.Marshal(strct.PropertyId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "PropertyValue" field is required
    if strct.PropertyValue == nil {
        return nil, errors.New("PropertyValue is a required field")
    }
    // Marshal the "PropertyValue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PropertyValue\": ")
	if tmp, err := json.Marshal(strct.PropertyValue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *IotSiteWise) UnmarshalJSON(b []byte) error {
    PropertyValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AssetId":
            if err := json.Unmarshal([]byte(v), &strct.AssetId); err != nil {
                return err
             }
        case "EntryId":
            if err := json.Unmarshal([]byte(v), &strct.EntryId); err != nil {
                return err
             }
        case "PropertyAlias":
            if err := json.Unmarshal([]byte(v), &strct.PropertyAlias); err != nil {
                return err
             }
        case "PropertyId":
            if err := json.Unmarshal([]byte(v), &strct.PropertyId); err != nil {
                return err
             }
        case "PropertyValue":
            if err := json.Unmarshal([]byte(v), &strct.PropertyValue); err != nil {
                return err
             }
            PropertyValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if PropertyValue (a required property) was received
    if !PropertyValueReceived {
        return errors.New("\"PropertyValue\" is required but was not present")
    }
    return nil
}

func (strct *IotTopicPublish) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "MqttTopic" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "MqttTopic" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MqttTopic\": ")
	if tmp, err := json.Marshal(strct.MqttTopic); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Payload" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Payload\": ")
	if tmp, err := json.Marshal(strct.Payload); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *IotTopicPublish) UnmarshalJSON(b []byte) error {
    MqttTopicReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "MqttTopic":
            if err := json.Unmarshal([]byte(v), &strct.MqttTopic); err != nil {
                return err
             }
            MqttTopicReceived = true
        case "Payload":
            if err := json.Unmarshal([]byte(v), &strct.Payload); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if MqttTopic (a required property) was received
    if !MqttTopicReceived {
        return errors.New("\"MqttTopic\" is required but was not present")
    }
    return nil
}

func (strct *Lambda) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "FunctionArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "FunctionArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FunctionArn\": ")
	if tmp, err := json.Marshal(strct.FunctionArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Payload" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Payload\": ")
	if tmp, err := json.Marshal(strct.Payload); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Lambda) UnmarshalJSON(b []byte) error {
    FunctionArnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "FunctionArn":
            if err := json.Unmarshal([]byte(v), &strct.FunctionArn); err != nil {
                return err
             }
            FunctionArnReceived = true
        case "Payload":
            if err := json.Unmarshal([]byte(v), &strct.Payload); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if FunctionArn (a required property) was received
    if !FunctionArnReceived {
        return errors.New("\"FunctionArn\" is required but was not present")
    }
    return nil
}

func (strct *OnEnter) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Events" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Events\": ")
	if tmp, err := json.Marshal(strct.Events); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *OnEnter) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Events":
            if err := json.Unmarshal([]byte(v), &strct.Events); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *OnExit) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Events" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Events\": ")
	if tmp, err := json.Marshal(strct.Events); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *OnExit) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Events":
            if err := json.Unmarshal([]byte(v), &strct.Events); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *OnInput) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Events" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Events\": ")
	if tmp, err := json.Marshal(strct.Events); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TransitionEvents" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TransitionEvents\": ")
	if tmp, err := json.Marshal(strct.TransitionEvents); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *OnInput) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Events":
            if err := json.Unmarshal([]byte(v), &strct.Events); err != nil {
                return err
             }
        case "TransitionEvents":
            if err := json.Unmarshal([]byte(v), &strct.TransitionEvents); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Payload) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ContentExpression" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ContentExpression" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ContentExpression\": ")
	if tmp, err := json.Marshal(strct.ContentExpression); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Payload) UnmarshalJSON(b []byte) error {
    ContentExpressionReceived := false
    TypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ContentExpression":
            if err := json.Unmarshal([]byte(v), &strct.ContentExpression); err != nil {
                return err
             }
            ContentExpressionReceived = true
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            TypeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ContentExpression (a required property) was received
    if !ContentExpressionReceived {
        return errors.New("\"ContentExpression\" is required but was not present")
    }
    // check if Type (a required property) was received
    if !TypeReceived {
        return errors.New("\"Type\" is required but was not present")
    }
    return nil
}

func (strct *ResetTimer) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "TimerName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TimerName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TimerName\": ")
	if tmp, err := json.Marshal(strct.TimerName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ResetTimer) UnmarshalJSON(b []byte) error {
    TimerNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "TimerName":
            if err := json.Unmarshal([]byte(v), &strct.TimerName); err != nil {
                return err
             }
            TimerNameReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if TimerName (a required property) was received
    if !TimerNameReceived {
        return errors.New("\"TimerName\" is required but was not present")
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "DetectorModelDefinition" field is required
    if strct.DetectorModelDefinition == nil {
        return nil, errors.New("DetectorModelDefinition is a required field")
    }
    // Marshal the "DetectorModelDefinition" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DetectorModelDefinition\": ")
	if tmp, err := json.Marshal(strct.DetectorModelDefinition); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DetectorModelDescription" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DetectorModelDescription\": ")
	if tmp, err := json.Marshal(strct.DetectorModelDescription); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DetectorModelName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DetectorModelName\": ")
	if tmp, err := json.Marshal(strct.DetectorModelName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EvaluationMethod" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EvaluationMethod\": ")
	if tmp, err := json.Marshal(strct.EvaluationMethod); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RoleArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoleArn\": ")
	if tmp, err := json.Marshal(strct.RoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    DetectorModelDefinitionReceived := false
    RoleArnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DetectorModelDefinition":
            if err := json.Unmarshal([]byte(v), &strct.DetectorModelDefinition); err != nil {
                return err
             }
            DetectorModelDefinitionReceived = true
        case "DetectorModelDescription":
            if err := json.Unmarshal([]byte(v), &strct.DetectorModelDescription); err != nil {
                return err
             }
        case "DetectorModelName":
            if err := json.Unmarshal([]byte(v), &strct.DetectorModelName); err != nil {
                return err
             }
        case "EvaluationMethod":
            if err := json.Unmarshal([]byte(v), &strct.EvaluationMethod); err != nil {
                return err
             }
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
        case "RoleArn":
            if err := json.Unmarshal([]byte(v), &strct.RoleArn); err != nil {
                return err
             }
            RoleArnReceived = true
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if DetectorModelDefinition (a required property) was received
    if !DetectorModelDefinitionReceived {
        return errors.New("\"DetectorModelDefinition\" is required but was not present")
    }
    // check if RoleArn (a required property) was received
    if !RoleArnReceived {
        return errors.New("\"RoleArn\" is required but was not present")
    }
    return nil
}

func (strct *SetTimer) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DurationExpression" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DurationExpression\": ")
	if tmp, err := json.Marshal(strct.DurationExpression); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Seconds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Seconds\": ")
	if tmp, err := json.Marshal(strct.Seconds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TimerName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TimerName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TimerName\": ")
	if tmp, err := json.Marshal(strct.TimerName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SetTimer) UnmarshalJSON(b []byte) error {
    TimerNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DurationExpression":
            if err := json.Unmarshal([]byte(v), &strct.DurationExpression); err != nil {
                return err
             }
        case "Seconds":
            if err := json.Unmarshal([]byte(v), &strct.Seconds); err != nil {
                return err
             }
        case "TimerName":
            if err := json.Unmarshal([]byte(v), &strct.TimerName); err != nil {
                return err
             }
            TimerNameReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if TimerName (a required property) was received
    if !TimerNameReceived {
        return errors.New("\"TimerName\" is required but was not present")
    }
    return nil
}

func (strct *SetVariable) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "VariableName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "VariableName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VariableName\": ")
	if tmp, err := json.Marshal(strct.VariableName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SetVariable) UnmarshalJSON(b []byte) error {
    ValueReceived := false
    VariableNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        case "VariableName":
            if err := json.Unmarshal([]byte(v), &strct.VariableName); err != nil {
                return err
             }
            VariableNameReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    // check if VariableName (a required property) was received
    if !VariableNameReceived {
        return errors.New("\"VariableName\" is required but was not present")
    }
    return nil
}

func (strct *Sns) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Payload" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Payload\": ")
	if tmp, err := json.Marshal(strct.Payload); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TargetArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TargetArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TargetArn\": ")
	if tmp, err := json.Marshal(strct.TargetArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Sns) UnmarshalJSON(b []byte) error {
    TargetArnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Payload":
            if err := json.Unmarshal([]byte(v), &strct.Payload); err != nil {
                return err
             }
        case "TargetArn":
            if err := json.Unmarshal([]byte(v), &strct.TargetArn); err != nil {
                return err
             }
            TargetArnReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if TargetArn (a required property) was received
    if !TargetArnReceived {
        return errors.New("\"TargetArn\" is required but was not present")
    }
    return nil
}

func (strct *Sqs) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Payload" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Payload\": ")
	if tmp, err := json.Marshal(strct.Payload); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "QueueUrl" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "QueueUrl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"QueueUrl\": ")
	if tmp, err := json.Marshal(strct.QueueUrl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "UseBase64" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UseBase64\": ")
	if tmp, err := json.Marshal(strct.UseBase64); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Sqs) UnmarshalJSON(b []byte) error {
    QueueUrlReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Payload":
            if err := json.Unmarshal([]byte(v), &strct.Payload); err != nil {
                return err
             }
        case "QueueUrl":
            if err := json.Unmarshal([]byte(v), &strct.QueueUrl); err != nil {
                return err
             }
            QueueUrlReceived = true
        case "UseBase64":
            if err := json.Unmarshal([]byte(v), &strct.UseBase64); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if QueueUrl (a required property) was received
    if !QueueUrlReceived {
        return errors.New("\"QueueUrl\" is required but was not present")
    }
    return nil
}

func (strct *State) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "OnEnter" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OnEnter\": ")
	if tmp, err := json.Marshal(strct.OnEnter); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OnExit" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OnExit\": ")
	if tmp, err := json.Marshal(strct.OnExit); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OnInput" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OnInput\": ")
	if tmp, err := json.Marshal(strct.OnInput); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "StateName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "StateName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StateName\": ")
	if tmp, err := json.Marshal(strct.StateName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *State) UnmarshalJSON(b []byte) error {
    StateNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "OnEnter":
            if err := json.Unmarshal([]byte(v), &strct.OnEnter); err != nil {
                return err
             }
        case "OnExit":
            if err := json.Unmarshal([]byte(v), &strct.OnExit); err != nil {
                return err
             }
        case "OnInput":
            if err := json.Unmarshal([]byte(v), &strct.OnInput); err != nil {
                return err
             }
        case "StateName":
            if err := json.Unmarshal([]byte(v), &strct.StateName); err != nil {
                return err
             }
            StateNameReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if StateName (a required property) was received
    if !StateNameReceived {
        return errors.New("\"StateName\" is required but was not present")
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *TransitionEvent) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Actions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Actions\": ")
	if tmp, err := json.Marshal(strct.Actions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Condition" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Condition" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Condition\": ")
	if tmp, err := json.Marshal(strct.Condition); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "EventName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "EventName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EventName\": ")
	if tmp, err := json.Marshal(strct.EventName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "NextState" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "NextState" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NextState\": ")
	if tmp, err := json.Marshal(strct.NextState); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TransitionEvent) UnmarshalJSON(b []byte) error {
    ConditionReceived := false
    EventNameReceived := false
    NextStateReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Actions":
            if err := json.Unmarshal([]byte(v), &strct.Actions); err != nil {
                return err
             }
        case "Condition":
            if err := json.Unmarshal([]byte(v), &strct.Condition); err != nil {
                return err
             }
            ConditionReceived = true
        case "EventName":
            if err := json.Unmarshal([]byte(v), &strct.EventName); err != nil {
                return err
             }
            EventNameReceived = true
        case "NextState":
            if err := json.Unmarshal([]byte(v), &strct.NextState); err != nil {
                return err
             }
            NextStateReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Condition (a required property) was received
    if !ConditionReceived {
        return errors.New("\"Condition\" is required but was not present")
    }
    // check if EventName (a required property) was received
    if !EventNameReceived {
        return errors.New("\"EventName\" is required but was not present")
    }
    // check if NextState (a required property) was received
    if !NextStateReceived {
        return errors.New("\"NextState\" is required but was not present")
    }
    return nil
}
