// Code generated by schema-generate. DO NOT EDIT.

package globaltable

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// AttributeDefinition 
type AttributeDefinition struct {
  AttributeName string `json:"AttributeName"`
  AttributeType string `json:"AttributeType"`
}

// CapacityAutoScalingSettings 
type CapacityAutoScalingSettings struct {
  MaxCapacity int `json:"MaxCapacity"`
  MinCapacity int `json:"MinCapacity"`
  SeedCapacity int `json:"SeedCapacity,omitempty"`
  TargetTrackingScalingPolicyConfiguration *TargetTrackingScalingPolicyConfiguration `json:"TargetTrackingScalingPolicyConfiguration"`
}

// ContributorInsightsSpecification 
type ContributorInsightsSpecification struct {
  Enabled bool `json:"Enabled"`
}

// GlobalSecondaryIndex 
type GlobalSecondaryIndex struct {
  IndexName string `json:"IndexName"`
  KeySchema []*KeySchema `json:"KeySchema"`
  Projection *Projection `json:"Projection"`
  WriteProvisionedThroughputSettings *WriteProvisionedThroughputSettings `json:"WriteProvisionedThroughputSettings,omitempty"`
}

// KeySchema 
type KeySchema struct {
  AttributeName string `json:"AttributeName"`
  KeyType string `json:"KeyType"`
}

// KinesisStreamSpecification 
type KinesisStreamSpecification struct {
  StreamArn string `json:"StreamArn"`
}

// LocalSecondaryIndex 
type LocalSecondaryIndex struct {
  IndexName string `json:"IndexName"`
  KeySchema []*KeySchema `json:"KeySchema"`
  Projection *Projection `json:"Projection"`
}

// PointInTimeRecoverySpecification 
type PointInTimeRecoverySpecification struct {
  PointInTimeRecoveryEnabled bool `json:"PointInTimeRecoveryEnabled,omitempty"`
}

// Projection 
type Projection struct {
  NonKeyAttributes []string `json:"NonKeyAttributes,omitempty"`
  ProjectionType string `json:"ProjectionType,omitempty"`
}

// ReadProvisionedThroughputSettings 
type ReadProvisionedThroughputSettings struct {
  ReadCapacityAutoScalingSettings *CapacityAutoScalingSettings `json:"ReadCapacityAutoScalingSettings,omitempty"`
  ReadCapacityUnits int `json:"ReadCapacityUnits,omitempty"`
}

// ReplicaGlobalSecondaryIndexSpecification 
type ReplicaGlobalSecondaryIndexSpecification struct {
  ContributorInsightsSpecification *ContributorInsightsSpecification `json:"ContributorInsightsSpecification,omitempty"`
  IndexName string `json:"IndexName"`
  ReadProvisionedThroughputSettings *ReadProvisionedThroughputSettings `json:"ReadProvisionedThroughputSettings,omitempty"`
}

// ReplicaSSESpecification 
type ReplicaSSESpecification struct {
  KMSMasterKeyId string `json:"KMSMasterKeyId"`
}

// ReplicaSpecification 
type ReplicaSpecification struct {
  ContributorInsightsSpecification *ContributorInsightsSpecification `json:"ContributorInsightsSpecification,omitempty"`
  GlobalSecondaryIndexes []*ReplicaGlobalSecondaryIndexSpecification `json:"GlobalSecondaryIndexes,omitempty"`
  KinesisStreamSpecification *KinesisStreamSpecification `json:"KinesisStreamSpecification,omitempty"`
  PointInTimeRecoverySpecification *PointInTimeRecoverySpecification `json:"PointInTimeRecoverySpecification,omitempty"`
  ReadProvisionedThroughputSettings *ReadProvisionedThroughputSettings `json:"ReadProvisionedThroughputSettings,omitempty"`
  Region string `json:"Region"`
  SSESpecification *ReplicaSSESpecification `json:"SSESpecification,omitempty"`
  TableClass string `json:"TableClass,omitempty"`
  Tags []*Tag `json:"Tags,omitempty"`
}

// Resource Version: None. Resource Type definition for AWS::DynamoDB::GlobalTable
type Resource struct {
  Arn string `json:"Arn,omitempty"`
  AttributeDefinitions []*AttributeDefinition `json:"AttributeDefinitions"`
  BillingMode string `json:"BillingMode,omitempty"`
  GlobalSecondaryIndexes []*GlobalSecondaryIndex `json:"GlobalSecondaryIndexes,omitempty"`
  KeySchema []*KeySchema `json:"KeySchema"`
  LocalSecondaryIndexes []*LocalSecondaryIndex `json:"LocalSecondaryIndexes,omitempty"`
  Replicas []*ReplicaSpecification `json:"Replicas"`
  SSESpecification *SSESpecification `json:"SSESpecification,omitempty"`
  StreamArn string `json:"StreamArn,omitempty"`
  StreamSpecification *StreamSpecification `json:"StreamSpecification,omitempty"`
  TableId string `json:"TableId,omitempty"`
  TableName string `json:"TableName,omitempty"`
  TimeToLiveSpecification *TimeToLiveSpecification `json:"TimeToLiveSpecification,omitempty"`
  WriteProvisionedThroughputSettings *WriteProvisionedThroughputSettings `json:"WriteProvisionedThroughputSettings,omitempty"`
}

// SSESpecification 
type SSESpecification struct {
  SSEEnabled bool `json:"SSEEnabled"`
  SSEType string `json:"SSEType,omitempty"`
}

// StreamSpecification 
type StreamSpecification struct {
  StreamViewType string `json:"StreamViewType"`
}

// Tag 
type Tag struct {
  Key string `json:"Key"`
  Value string `json:"Value"`
}

// TargetTrackingScalingPolicyConfiguration 
type TargetTrackingScalingPolicyConfiguration struct {
  DisableScaleIn bool `json:"DisableScaleIn,omitempty"`
  ScaleInCooldown int `json:"ScaleInCooldown,omitempty"`
  ScaleOutCooldown int `json:"ScaleOutCooldown,omitempty"`
  TargetValue float64 `json:"TargetValue"`
}

// TimeToLiveSpecification 
type TimeToLiveSpecification struct {
  AttributeName string `json:"AttributeName,omitempty"`
  Enabled bool `json:"Enabled"`
}

// WriteProvisionedThroughputSettings 
type WriteProvisionedThroughputSettings struct {
  WriteCapacityAutoScalingSettings *CapacityAutoScalingSettings `json:"WriteCapacityAutoScalingSettings,omitempty"`
}

func (strct *AttributeDefinition) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AttributeName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AttributeName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AttributeName\": ")
	if tmp, err := json.Marshal(strct.AttributeName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "AttributeType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AttributeType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AttributeType\": ")
	if tmp, err := json.Marshal(strct.AttributeType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AttributeDefinition) UnmarshalJSON(b []byte) error {
    AttributeNameReceived := false
    AttributeTypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AttributeName":
            if err := json.Unmarshal([]byte(v), &strct.AttributeName); err != nil {
                return err
             }
            AttributeNameReceived = true
        case "AttributeType":
            if err := json.Unmarshal([]byte(v), &strct.AttributeType); err != nil {
                return err
             }
            AttributeTypeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if AttributeName (a required property) was received
    if !AttributeNameReceived {
        return errors.New("\"AttributeName\" is required but was not present")
    }
    // check if AttributeType (a required property) was received
    if !AttributeTypeReceived {
        return errors.New("\"AttributeType\" is required but was not present")
    }
    return nil
}

func (strct *CapacityAutoScalingSettings) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "MaxCapacity" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "MaxCapacity" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaxCapacity\": ")
	if tmp, err := json.Marshal(strct.MaxCapacity); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "MinCapacity" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "MinCapacity" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MinCapacity\": ")
	if tmp, err := json.Marshal(strct.MinCapacity); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SeedCapacity" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SeedCapacity\": ")
	if tmp, err := json.Marshal(strct.SeedCapacity); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TargetTrackingScalingPolicyConfiguration" field is required
    if strct.TargetTrackingScalingPolicyConfiguration == nil {
        return nil, errors.New("TargetTrackingScalingPolicyConfiguration is a required field")
    }
    // Marshal the "TargetTrackingScalingPolicyConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TargetTrackingScalingPolicyConfiguration\": ")
	if tmp, err := json.Marshal(strct.TargetTrackingScalingPolicyConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CapacityAutoScalingSettings) UnmarshalJSON(b []byte) error {
    MaxCapacityReceived := false
    MinCapacityReceived := false
    TargetTrackingScalingPolicyConfigurationReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "MaxCapacity":
            if err := json.Unmarshal([]byte(v), &strct.MaxCapacity); err != nil {
                return err
             }
            MaxCapacityReceived = true
        case "MinCapacity":
            if err := json.Unmarshal([]byte(v), &strct.MinCapacity); err != nil {
                return err
             }
            MinCapacityReceived = true
        case "SeedCapacity":
            if err := json.Unmarshal([]byte(v), &strct.SeedCapacity); err != nil {
                return err
             }
        case "TargetTrackingScalingPolicyConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.TargetTrackingScalingPolicyConfiguration); err != nil {
                return err
             }
            TargetTrackingScalingPolicyConfigurationReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if MaxCapacity (a required property) was received
    if !MaxCapacityReceived {
        return errors.New("\"MaxCapacity\" is required but was not present")
    }
    // check if MinCapacity (a required property) was received
    if !MinCapacityReceived {
        return errors.New("\"MinCapacity\" is required but was not present")
    }
    // check if TargetTrackingScalingPolicyConfiguration (a required property) was received
    if !TargetTrackingScalingPolicyConfigurationReceived {
        return errors.New("\"TargetTrackingScalingPolicyConfiguration\" is required but was not present")
    }
    return nil
}

func (strct *ContributorInsightsSpecification) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Enabled" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Enabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ContributorInsightsSpecification) UnmarshalJSON(b []byte) error {
    EnabledReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Enabled":
            if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
                return err
             }
            EnabledReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Enabled (a required property) was received
    if !EnabledReceived {
        return errors.New("\"Enabled\" is required but was not present")
    }
    return nil
}

func (strct *GlobalSecondaryIndex) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "IndexName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "IndexName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IndexName\": ")
	if tmp, err := json.Marshal(strct.IndexName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "KeySchema" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "KeySchema" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KeySchema\": ")
	if tmp, err := json.Marshal(strct.KeySchema); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Projection" field is required
    if strct.Projection == nil {
        return nil, errors.New("Projection is a required field")
    }
    // Marshal the "Projection" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Projection\": ")
	if tmp, err := json.Marshal(strct.Projection); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "WriteProvisionedThroughputSettings" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"WriteProvisionedThroughputSettings\": ")
	if tmp, err := json.Marshal(strct.WriteProvisionedThroughputSettings); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *GlobalSecondaryIndex) UnmarshalJSON(b []byte) error {
    IndexNameReceived := false
    KeySchemaReceived := false
    ProjectionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "IndexName":
            if err := json.Unmarshal([]byte(v), &strct.IndexName); err != nil {
                return err
             }
            IndexNameReceived = true
        case "KeySchema":
            if err := json.Unmarshal([]byte(v), &strct.KeySchema); err != nil {
                return err
             }
            KeySchemaReceived = true
        case "Projection":
            if err := json.Unmarshal([]byte(v), &strct.Projection); err != nil {
                return err
             }
            ProjectionReceived = true
        case "WriteProvisionedThroughputSettings":
            if err := json.Unmarshal([]byte(v), &strct.WriteProvisionedThroughputSettings); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if IndexName (a required property) was received
    if !IndexNameReceived {
        return errors.New("\"IndexName\" is required but was not present")
    }
    // check if KeySchema (a required property) was received
    if !KeySchemaReceived {
        return errors.New("\"KeySchema\" is required but was not present")
    }
    // check if Projection (a required property) was received
    if !ProjectionReceived {
        return errors.New("\"Projection\" is required but was not present")
    }
    return nil
}

func (strct *KeySchema) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AttributeName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AttributeName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AttributeName\": ")
	if tmp, err := json.Marshal(strct.AttributeName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "KeyType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "KeyType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KeyType\": ")
	if tmp, err := json.Marshal(strct.KeyType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *KeySchema) UnmarshalJSON(b []byte) error {
    AttributeNameReceived := false
    KeyTypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AttributeName":
            if err := json.Unmarshal([]byte(v), &strct.AttributeName); err != nil {
                return err
             }
            AttributeNameReceived = true
        case "KeyType":
            if err := json.Unmarshal([]byte(v), &strct.KeyType); err != nil {
                return err
             }
            KeyTypeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if AttributeName (a required property) was received
    if !AttributeNameReceived {
        return errors.New("\"AttributeName\" is required but was not present")
    }
    // check if KeyType (a required property) was received
    if !KeyTypeReceived {
        return errors.New("\"KeyType\" is required but was not present")
    }
    return nil
}

func (strct *KinesisStreamSpecification) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "StreamArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "StreamArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StreamArn\": ")
	if tmp, err := json.Marshal(strct.StreamArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *KinesisStreamSpecification) UnmarshalJSON(b []byte) error {
    StreamArnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "StreamArn":
            if err := json.Unmarshal([]byte(v), &strct.StreamArn); err != nil {
                return err
             }
            StreamArnReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if StreamArn (a required property) was received
    if !StreamArnReceived {
        return errors.New("\"StreamArn\" is required but was not present")
    }
    return nil
}

func (strct *LocalSecondaryIndex) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "IndexName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "IndexName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IndexName\": ")
	if tmp, err := json.Marshal(strct.IndexName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "KeySchema" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "KeySchema" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KeySchema\": ")
	if tmp, err := json.Marshal(strct.KeySchema); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Projection" field is required
    if strct.Projection == nil {
        return nil, errors.New("Projection is a required field")
    }
    // Marshal the "Projection" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Projection\": ")
	if tmp, err := json.Marshal(strct.Projection); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LocalSecondaryIndex) UnmarshalJSON(b []byte) error {
    IndexNameReceived := false
    KeySchemaReceived := false
    ProjectionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "IndexName":
            if err := json.Unmarshal([]byte(v), &strct.IndexName); err != nil {
                return err
             }
            IndexNameReceived = true
        case "KeySchema":
            if err := json.Unmarshal([]byte(v), &strct.KeySchema); err != nil {
                return err
             }
            KeySchemaReceived = true
        case "Projection":
            if err := json.Unmarshal([]byte(v), &strct.Projection); err != nil {
                return err
             }
            ProjectionReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if IndexName (a required property) was received
    if !IndexNameReceived {
        return errors.New("\"IndexName\" is required but was not present")
    }
    // check if KeySchema (a required property) was received
    if !KeySchemaReceived {
        return errors.New("\"KeySchema\" is required but was not present")
    }
    // check if Projection (a required property) was received
    if !ProjectionReceived {
        return errors.New("\"Projection\" is required but was not present")
    }
    return nil
}

func (strct *PointInTimeRecoverySpecification) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "PointInTimeRecoveryEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PointInTimeRecoveryEnabled\": ")
	if tmp, err := json.Marshal(strct.PointInTimeRecoveryEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PointInTimeRecoverySpecification) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "PointInTimeRecoveryEnabled":
            if err := json.Unmarshal([]byte(v), &strct.PointInTimeRecoveryEnabled); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Projection) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "NonKeyAttributes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NonKeyAttributes\": ")
	if tmp, err := json.Marshal(strct.NonKeyAttributes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ProjectionType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ProjectionType\": ")
	if tmp, err := json.Marshal(strct.ProjectionType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Projection) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "NonKeyAttributes":
            if err := json.Unmarshal([]byte(v), &strct.NonKeyAttributes); err != nil {
                return err
             }
        case "ProjectionType":
            if err := json.Unmarshal([]byte(v), &strct.ProjectionType); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ReadProvisionedThroughputSettings) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ReadCapacityAutoScalingSettings" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ReadCapacityAutoScalingSettings\": ")
	if tmp, err := json.Marshal(strct.ReadCapacityAutoScalingSettings); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ReadCapacityUnits" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ReadCapacityUnits\": ")
	if tmp, err := json.Marshal(strct.ReadCapacityUnits); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ReadProvisionedThroughputSettings) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ReadCapacityAutoScalingSettings":
            if err := json.Unmarshal([]byte(v), &strct.ReadCapacityAutoScalingSettings); err != nil {
                return err
             }
        case "ReadCapacityUnits":
            if err := json.Unmarshal([]byte(v), &strct.ReadCapacityUnits); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ReplicaGlobalSecondaryIndexSpecification) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ContributorInsightsSpecification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ContributorInsightsSpecification\": ")
	if tmp, err := json.Marshal(strct.ContributorInsightsSpecification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "IndexName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "IndexName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IndexName\": ")
	if tmp, err := json.Marshal(strct.IndexName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ReadProvisionedThroughputSettings" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ReadProvisionedThroughputSettings\": ")
	if tmp, err := json.Marshal(strct.ReadProvisionedThroughputSettings); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ReplicaGlobalSecondaryIndexSpecification) UnmarshalJSON(b []byte) error {
    IndexNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ContributorInsightsSpecification":
            if err := json.Unmarshal([]byte(v), &strct.ContributorInsightsSpecification); err != nil {
                return err
             }
        case "IndexName":
            if err := json.Unmarshal([]byte(v), &strct.IndexName); err != nil {
                return err
             }
            IndexNameReceived = true
        case "ReadProvisionedThroughputSettings":
            if err := json.Unmarshal([]byte(v), &strct.ReadProvisionedThroughputSettings); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if IndexName (a required property) was received
    if !IndexNameReceived {
        return errors.New("\"IndexName\" is required but was not present")
    }
    return nil
}

func (strct *ReplicaSSESpecification) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "KMSMasterKeyId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "KMSMasterKeyId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KMSMasterKeyId\": ")
	if tmp, err := json.Marshal(strct.KMSMasterKeyId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ReplicaSSESpecification) UnmarshalJSON(b []byte) error {
    KMSMasterKeyIdReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "KMSMasterKeyId":
            if err := json.Unmarshal([]byte(v), &strct.KMSMasterKeyId); err != nil {
                return err
             }
            KMSMasterKeyIdReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if KMSMasterKeyId (a required property) was received
    if !KMSMasterKeyIdReceived {
        return errors.New("\"KMSMasterKeyId\" is required but was not present")
    }
    return nil
}

func (strct *ReplicaSpecification) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ContributorInsightsSpecification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ContributorInsightsSpecification\": ")
	if tmp, err := json.Marshal(strct.ContributorInsightsSpecification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "GlobalSecondaryIndexes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"GlobalSecondaryIndexes\": ")
	if tmp, err := json.Marshal(strct.GlobalSecondaryIndexes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "KinesisStreamSpecification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KinesisStreamSpecification\": ")
	if tmp, err := json.Marshal(strct.KinesisStreamSpecification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PointInTimeRecoverySpecification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PointInTimeRecoverySpecification\": ")
	if tmp, err := json.Marshal(strct.PointInTimeRecoverySpecification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ReadProvisionedThroughputSettings" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ReadProvisionedThroughputSettings\": ")
	if tmp, err := json.Marshal(strct.ReadProvisionedThroughputSettings); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Region" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Region" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Region\": ")
	if tmp, err := json.Marshal(strct.Region); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SSESpecification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SSESpecification\": ")
	if tmp, err := json.Marshal(strct.SSESpecification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TableClass" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TableClass\": ")
	if tmp, err := json.Marshal(strct.TableClass); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ReplicaSpecification) UnmarshalJSON(b []byte) error {
    RegionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ContributorInsightsSpecification":
            if err := json.Unmarshal([]byte(v), &strct.ContributorInsightsSpecification); err != nil {
                return err
             }
        case "GlobalSecondaryIndexes":
            if err := json.Unmarshal([]byte(v), &strct.GlobalSecondaryIndexes); err != nil {
                return err
             }
        case "KinesisStreamSpecification":
            if err := json.Unmarshal([]byte(v), &strct.KinesisStreamSpecification); err != nil {
                return err
             }
        case "PointInTimeRecoverySpecification":
            if err := json.Unmarshal([]byte(v), &strct.PointInTimeRecoverySpecification); err != nil {
                return err
             }
        case "ReadProvisionedThroughputSettings":
            if err := json.Unmarshal([]byte(v), &strct.ReadProvisionedThroughputSettings); err != nil {
                return err
             }
        case "Region":
            if err := json.Unmarshal([]byte(v), &strct.Region); err != nil {
                return err
             }
            RegionReceived = true
        case "SSESpecification":
            if err := json.Unmarshal([]byte(v), &strct.SSESpecification); err != nil {
                return err
             }
        case "TableClass":
            if err := json.Unmarshal([]byte(v), &strct.TableClass); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Region (a required property) was received
    if !RegionReceived {
        return errors.New("\"Region\" is required but was not present")
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Arn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Arn\": ")
	if tmp, err := json.Marshal(strct.Arn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "AttributeDefinitions" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AttributeDefinitions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AttributeDefinitions\": ")
	if tmp, err := json.Marshal(strct.AttributeDefinitions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BillingMode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BillingMode\": ")
	if tmp, err := json.Marshal(strct.BillingMode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "GlobalSecondaryIndexes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"GlobalSecondaryIndexes\": ")
	if tmp, err := json.Marshal(strct.GlobalSecondaryIndexes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "KeySchema" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "KeySchema" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KeySchema\": ")
	if tmp, err := json.Marshal(strct.KeySchema); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LocalSecondaryIndexes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LocalSecondaryIndexes\": ")
	if tmp, err := json.Marshal(strct.LocalSecondaryIndexes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Replicas" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Replicas" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Replicas\": ")
	if tmp, err := json.Marshal(strct.Replicas); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SSESpecification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SSESpecification\": ")
	if tmp, err := json.Marshal(strct.SSESpecification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StreamArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StreamArn\": ")
	if tmp, err := json.Marshal(strct.StreamArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StreamSpecification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StreamSpecification\": ")
	if tmp, err := json.Marshal(strct.StreamSpecification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TableId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TableId\": ")
	if tmp, err := json.Marshal(strct.TableId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TableName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TableName\": ")
	if tmp, err := json.Marshal(strct.TableName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TimeToLiveSpecification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TimeToLiveSpecification\": ")
	if tmp, err := json.Marshal(strct.TimeToLiveSpecification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "WriteProvisionedThroughputSettings" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"WriteProvisionedThroughputSettings\": ")
	if tmp, err := json.Marshal(strct.WriteProvisionedThroughputSettings); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    AttributeDefinitionsReceived := false
    KeySchemaReceived := false
    ReplicasReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Arn":
            if err := json.Unmarshal([]byte(v), &strct.Arn); err != nil {
                return err
             }
        case "AttributeDefinitions":
            if err := json.Unmarshal([]byte(v), &strct.AttributeDefinitions); err != nil {
                return err
             }
            AttributeDefinitionsReceived = true
        case "BillingMode":
            if err := json.Unmarshal([]byte(v), &strct.BillingMode); err != nil {
                return err
             }
        case "GlobalSecondaryIndexes":
            if err := json.Unmarshal([]byte(v), &strct.GlobalSecondaryIndexes); err != nil {
                return err
             }
        case "KeySchema":
            if err := json.Unmarshal([]byte(v), &strct.KeySchema); err != nil {
                return err
             }
            KeySchemaReceived = true
        case "LocalSecondaryIndexes":
            if err := json.Unmarshal([]byte(v), &strct.LocalSecondaryIndexes); err != nil {
                return err
             }
        case "Replicas":
            if err := json.Unmarshal([]byte(v), &strct.Replicas); err != nil {
                return err
             }
            ReplicasReceived = true
        case "SSESpecification":
            if err := json.Unmarshal([]byte(v), &strct.SSESpecification); err != nil {
                return err
             }
        case "StreamArn":
            if err := json.Unmarshal([]byte(v), &strct.StreamArn); err != nil {
                return err
             }
        case "StreamSpecification":
            if err := json.Unmarshal([]byte(v), &strct.StreamSpecification); err != nil {
                return err
             }
        case "TableId":
            if err := json.Unmarshal([]byte(v), &strct.TableId); err != nil {
                return err
             }
        case "TableName":
            if err := json.Unmarshal([]byte(v), &strct.TableName); err != nil {
                return err
             }
        case "TimeToLiveSpecification":
            if err := json.Unmarshal([]byte(v), &strct.TimeToLiveSpecification); err != nil {
                return err
             }
        case "WriteProvisionedThroughputSettings":
            if err := json.Unmarshal([]byte(v), &strct.WriteProvisionedThroughputSettings); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if AttributeDefinitions (a required property) was received
    if !AttributeDefinitionsReceived {
        return errors.New("\"AttributeDefinitions\" is required but was not present")
    }
    // check if KeySchema (a required property) was received
    if !KeySchemaReceived {
        return errors.New("\"KeySchema\" is required but was not present")
    }
    // check if Replicas (a required property) was received
    if !ReplicasReceived {
        return errors.New("\"Replicas\" is required but was not present")
    }
    return nil
}

func (strct *SSESpecification) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "SSEEnabled" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "SSEEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SSEEnabled\": ")
	if tmp, err := json.Marshal(strct.SSEEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SSEType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SSEType\": ")
	if tmp, err := json.Marshal(strct.SSEType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SSESpecification) UnmarshalJSON(b []byte) error {
    SSEEnabledReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "SSEEnabled":
            if err := json.Unmarshal([]byte(v), &strct.SSEEnabled); err != nil {
                return err
             }
            SSEEnabledReceived = true
        case "SSEType":
            if err := json.Unmarshal([]byte(v), &strct.SSEType); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if SSEEnabled (a required property) was received
    if !SSEEnabledReceived {
        return errors.New("\"SSEEnabled\" is required but was not present")
    }
    return nil
}

func (strct *StreamSpecification) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "StreamViewType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "StreamViewType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StreamViewType\": ")
	if tmp, err := json.Marshal(strct.StreamViewType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *StreamSpecification) UnmarshalJSON(b []byte) error {
    StreamViewTypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "StreamViewType":
            if err := json.Unmarshal([]byte(v), &strct.StreamViewType); err != nil {
                return err
             }
            StreamViewTypeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if StreamViewType (a required property) was received
    if !StreamViewTypeReceived {
        return errors.New("\"StreamViewType\" is required but was not present")
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *TargetTrackingScalingPolicyConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DisableScaleIn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DisableScaleIn\": ")
	if tmp, err := json.Marshal(strct.DisableScaleIn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ScaleInCooldown" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ScaleInCooldown\": ")
	if tmp, err := json.Marshal(strct.ScaleInCooldown); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ScaleOutCooldown" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ScaleOutCooldown\": ")
	if tmp, err := json.Marshal(strct.ScaleOutCooldown); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TargetValue" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TargetValue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TargetValue\": ")
	if tmp, err := json.Marshal(strct.TargetValue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TargetTrackingScalingPolicyConfiguration) UnmarshalJSON(b []byte) error {
    TargetValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DisableScaleIn":
            if err := json.Unmarshal([]byte(v), &strct.DisableScaleIn); err != nil {
                return err
             }
        case "ScaleInCooldown":
            if err := json.Unmarshal([]byte(v), &strct.ScaleInCooldown); err != nil {
                return err
             }
        case "ScaleOutCooldown":
            if err := json.Unmarshal([]byte(v), &strct.ScaleOutCooldown); err != nil {
                return err
             }
        case "TargetValue":
            if err := json.Unmarshal([]byte(v), &strct.TargetValue); err != nil {
                return err
             }
            TargetValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if TargetValue (a required property) was received
    if !TargetValueReceived {
        return errors.New("\"TargetValue\" is required but was not present")
    }
    return nil
}

func (strct *TimeToLiveSpecification) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AttributeName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AttributeName\": ")
	if tmp, err := json.Marshal(strct.AttributeName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Enabled" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Enabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TimeToLiveSpecification) UnmarshalJSON(b []byte) error {
    EnabledReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AttributeName":
            if err := json.Unmarshal([]byte(v), &strct.AttributeName); err != nil {
                return err
             }
        case "Enabled":
            if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
                return err
             }
            EnabledReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Enabled (a required property) was received
    if !EnabledReceived {
        return errors.New("\"Enabled\" is required but was not present")
    }
    return nil
}

func (strct *WriteProvisionedThroughputSettings) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "WriteCapacityAutoScalingSettings" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"WriteCapacityAutoScalingSettings\": ")
	if tmp, err := json.Marshal(strct.WriteCapacityAutoScalingSettings); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *WriteProvisionedThroughputSettings) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "WriteCapacityAutoScalingSettings":
            if err := json.Unmarshal([]byte(v), &strct.WriteCapacityAutoScalingSettings); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}
