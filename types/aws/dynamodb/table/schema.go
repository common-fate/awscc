// Code generated by schema-generate. DO NOT EDIT.

package table

import (
    "errors"
    "bytes"
    "encoding/json"
    "fmt"
)

// AttributeDefinition 
type AttributeDefinition struct {
  AttributeName string `json:"AttributeName"`
  AttributeType string `json:"AttributeType"`
}

// ContributorInsightsSpecification 
type ContributorInsightsSpecification struct {
  Enabled bool `json:"Enabled"`
}

// Csv 
type Csv struct {
  Delimiter string `json:"Delimiter,omitempty"`
  HeaderList []string `json:"HeaderList,omitempty"`
}

// DeprecatedHashKeyElement 
type DeprecatedHashKeyElement struct {
  AttributeName string `json:"AttributeName"`
  AttributeType string `json:"AttributeType"`
}

// DeprecatedKeySchema 
type DeprecatedKeySchema struct {
  HashKeyElement *DeprecatedHashKeyElement `json:"HashKeyElement"`
}

// GlobalSecondaryIndex 
type GlobalSecondaryIndex struct {
  ContributorInsightsSpecification *ContributorInsightsSpecification `json:"ContributorInsightsSpecification,omitempty"`
  IndexName string `json:"IndexName"`
  KeySchema []*KeySchema `json:"KeySchema"`
  Projection *Projection `json:"Projection"`
  ProvisionedThroughput *ProvisionedThroughput `json:"ProvisionedThroughput,omitempty"`
}

// ImportSourceSpecification 
type ImportSourceSpecification struct {
  InputCompressionType string `json:"InputCompressionType,omitempty"`
  InputFormat string `json:"InputFormat"`
  InputFormatOptions *InputFormatOptions `json:"InputFormatOptions,omitempty"`
  S3BucketSource *S3BucketSource `json:"S3BucketSource"`
}

// InputFormatOptions 
type InputFormatOptions struct {
  Csv *Csv `json:"Csv,omitempty"`
}

// KeySchema 
type KeySchema struct {
  AttributeName string `json:"AttributeName"`
  KeyType string `json:"KeyType"`
}

// KinesisStreamSpecification 
type KinesisStreamSpecification struct {
  StreamArn string `json:"StreamArn"`
}

// LocalSecondaryIndex 
type LocalSecondaryIndex struct {
  IndexName string `json:"IndexName"`
  KeySchema []*KeySchema `json:"KeySchema"`
  Projection *Projection `json:"Projection"`
}

// PointInTimeRecoverySpecification 
type PointInTimeRecoverySpecification struct {
  PointInTimeRecoveryEnabled bool `json:"PointInTimeRecoveryEnabled,omitempty"`
}

// Projection 
type Projection struct {
  NonKeyAttributes []string `json:"NonKeyAttributes,omitempty"`
  ProjectionType string `json:"ProjectionType,omitempty"`
}

// ProvisionedThroughput 
type ProvisionedThroughput struct {
  ReadCapacityUnits int `json:"ReadCapacityUnits"`
  WriteCapacityUnits int `json:"WriteCapacityUnits"`
}

// Resource Version: None. Resource Type definition for AWS::DynamoDB::Table
type Resource struct {
  Arn string `json:"Arn,omitempty"`
  AttributeDefinitions []*AttributeDefinition `json:"AttributeDefinitions,omitempty"`
  BillingMode string `json:"BillingMode,omitempty"`
  ContributorInsightsSpecification *ContributorInsightsSpecification `json:"ContributorInsightsSpecification,omitempty"`
  GlobalSecondaryIndexes []*GlobalSecondaryIndex `json:"GlobalSecondaryIndexes,omitempty"`
  ImportSourceSpecification *ImportSourceSpecification `json:"ImportSourceSpecification,omitempty"`
  KeySchema interface{} `json:"KeySchema"`
  KinesisStreamSpecification *KinesisStreamSpecification `json:"KinesisStreamSpecification,omitempty"`
  LocalSecondaryIndexes []*LocalSecondaryIndex `json:"LocalSecondaryIndexes,omitempty"`
  PointInTimeRecoverySpecification *PointInTimeRecoverySpecification `json:"PointInTimeRecoverySpecification,omitempty"`
  ProvisionedThroughput *ProvisionedThroughput `json:"ProvisionedThroughput,omitempty"`
  SSESpecification *SSESpecification `json:"SSESpecification,omitempty"`
  StreamArn string `json:"StreamArn,omitempty"`
  StreamSpecification *StreamSpecification `json:"StreamSpecification,omitempty"`
  TableClass string `json:"TableClass,omitempty"`
  TableName string `json:"TableName,omitempty"`
  Tags []*Tag `json:"Tags,omitempty"`
  TimeToLiveSpecification *TimeToLiveSpecification `json:"TimeToLiveSpecification,omitempty"`
}

// S3BucketSource 
type S3BucketSource struct {
  S3Bucket string `json:"S3Bucket"`
  S3BucketOwner string `json:"S3BucketOwner,omitempty"`
  S3KeyPrefix string `json:"S3KeyPrefix,omitempty"`
}

// SSESpecification 
type SSESpecification struct {
  KMSMasterKeyId string `json:"KMSMasterKeyId,omitempty"`
  SSEEnabled bool `json:"SSEEnabled"`
  SSEType string `json:"SSEType,omitempty"`
}

// StreamSpecification 
type StreamSpecification struct {
  StreamViewType string `json:"StreamViewType"`
}

// Tag 
type Tag struct {
  Key string `json:"Key"`
  Value string `json:"Value"`
}

// TimeToLiveSpecification 
type TimeToLiveSpecification struct {
  AttributeName string `json:"AttributeName"`
  Enabled bool `json:"Enabled"`
}

func (strct *AttributeDefinition) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AttributeName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AttributeName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AttributeName\": ")
	if tmp, err := json.Marshal(strct.AttributeName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "AttributeType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AttributeType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AttributeType\": ")
	if tmp, err := json.Marshal(strct.AttributeType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AttributeDefinition) UnmarshalJSON(b []byte) error {
    AttributeNameReceived := false
    AttributeTypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AttributeName":
            if err := json.Unmarshal([]byte(v), &strct.AttributeName); err != nil {
                return err
             }
            AttributeNameReceived = true
        case "AttributeType":
            if err := json.Unmarshal([]byte(v), &strct.AttributeType); err != nil {
                return err
             }
            AttributeTypeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if AttributeName (a required property) was received
    if !AttributeNameReceived {
        return errors.New("\"AttributeName\" is required but was not present")
    }
    // check if AttributeType (a required property) was received
    if !AttributeTypeReceived {
        return errors.New("\"AttributeType\" is required but was not present")
    }
    return nil
}

func (strct *ContributorInsightsSpecification) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Enabled" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Enabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ContributorInsightsSpecification) UnmarshalJSON(b []byte) error {
    EnabledReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Enabled":
            if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
                return err
             }
            EnabledReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Enabled (a required property) was received
    if !EnabledReceived {
        return errors.New("\"Enabled\" is required but was not present")
    }
    return nil
}

func (strct *Csv) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Delimiter" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Delimiter\": ")
	if tmp, err := json.Marshal(strct.Delimiter); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "HeaderList" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HeaderList\": ")
	if tmp, err := json.Marshal(strct.HeaderList); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Csv) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Delimiter":
            if err := json.Unmarshal([]byte(v), &strct.Delimiter); err != nil {
                return err
             }
        case "HeaderList":
            if err := json.Unmarshal([]byte(v), &strct.HeaderList); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *DeprecatedHashKeyElement) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AttributeName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AttributeName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AttributeName\": ")
	if tmp, err := json.Marshal(strct.AttributeName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "AttributeType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AttributeType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AttributeType\": ")
	if tmp, err := json.Marshal(strct.AttributeType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DeprecatedHashKeyElement) UnmarshalJSON(b []byte) error {
    AttributeNameReceived := false
    AttributeTypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AttributeName":
            if err := json.Unmarshal([]byte(v), &strct.AttributeName); err != nil {
                return err
             }
            AttributeNameReceived = true
        case "AttributeType":
            if err := json.Unmarshal([]byte(v), &strct.AttributeType); err != nil {
                return err
             }
            AttributeTypeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if AttributeName (a required property) was received
    if !AttributeNameReceived {
        return errors.New("\"AttributeName\" is required but was not present")
    }
    // check if AttributeType (a required property) was received
    if !AttributeTypeReceived {
        return errors.New("\"AttributeType\" is required but was not present")
    }
    return nil
}

func (strct *DeprecatedKeySchema) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "HashKeyElement" field is required
    if strct.HashKeyElement == nil {
        return nil, errors.New("HashKeyElement is a required field")
    }
    // Marshal the "HashKeyElement" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HashKeyElement\": ")
	if tmp, err := json.Marshal(strct.HashKeyElement); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DeprecatedKeySchema) UnmarshalJSON(b []byte) error {
    HashKeyElementReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "HashKeyElement":
            if err := json.Unmarshal([]byte(v), &strct.HashKeyElement); err != nil {
                return err
             }
            HashKeyElementReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if HashKeyElement (a required property) was received
    if !HashKeyElementReceived {
        return errors.New("\"HashKeyElement\" is required but was not present")
    }
    return nil
}

func (strct *GlobalSecondaryIndex) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ContributorInsightsSpecification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ContributorInsightsSpecification\": ")
	if tmp, err := json.Marshal(strct.ContributorInsightsSpecification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "IndexName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "IndexName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IndexName\": ")
	if tmp, err := json.Marshal(strct.IndexName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "KeySchema" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "KeySchema" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KeySchema\": ")
	if tmp, err := json.Marshal(strct.KeySchema); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Projection" field is required
    if strct.Projection == nil {
        return nil, errors.New("Projection is a required field")
    }
    // Marshal the "Projection" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Projection\": ")
	if tmp, err := json.Marshal(strct.Projection); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ProvisionedThroughput" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ProvisionedThroughput\": ")
	if tmp, err := json.Marshal(strct.ProvisionedThroughput); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *GlobalSecondaryIndex) UnmarshalJSON(b []byte) error {
    IndexNameReceived := false
    KeySchemaReceived := false
    ProjectionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ContributorInsightsSpecification":
            if err := json.Unmarshal([]byte(v), &strct.ContributorInsightsSpecification); err != nil {
                return err
             }
        case "IndexName":
            if err := json.Unmarshal([]byte(v), &strct.IndexName); err != nil {
                return err
             }
            IndexNameReceived = true
        case "KeySchema":
            if err := json.Unmarshal([]byte(v), &strct.KeySchema); err != nil {
                return err
             }
            KeySchemaReceived = true
        case "Projection":
            if err := json.Unmarshal([]byte(v), &strct.Projection); err != nil {
                return err
             }
            ProjectionReceived = true
        case "ProvisionedThroughput":
            if err := json.Unmarshal([]byte(v), &strct.ProvisionedThroughput); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if IndexName (a required property) was received
    if !IndexNameReceived {
        return errors.New("\"IndexName\" is required but was not present")
    }
    // check if KeySchema (a required property) was received
    if !KeySchemaReceived {
        return errors.New("\"KeySchema\" is required but was not present")
    }
    // check if Projection (a required property) was received
    if !ProjectionReceived {
        return errors.New("\"Projection\" is required but was not present")
    }
    return nil
}

func (strct *ImportSourceSpecification) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "InputCompressionType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InputCompressionType\": ")
	if tmp, err := json.Marshal(strct.InputCompressionType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "InputFormat" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "InputFormat" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InputFormat\": ")
	if tmp, err := json.Marshal(strct.InputFormat); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "InputFormatOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InputFormatOptions\": ")
	if tmp, err := json.Marshal(strct.InputFormatOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "S3BucketSource" field is required
    if strct.S3BucketSource == nil {
        return nil, errors.New("S3BucketSource is a required field")
    }
    // Marshal the "S3BucketSource" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3BucketSource\": ")
	if tmp, err := json.Marshal(strct.S3BucketSource); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ImportSourceSpecification) UnmarshalJSON(b []byte) error {
    InputFormatReceived := false
    S3BucketSourceReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "InputCompressionType":
            if err := json.Unmarshal([]byte(v), &strct.InputCompressionType); err != nil {
                return err
             }
        case "InputFormat":
            if err := json.Unmarshal([]byte(v), &strct.InputFormat); err != nil {
                return err
             }
            InputFormatReceived = true
        case "InputFormatOptions":
            if err := json.Unmarshal([]byte(v), &strct.InputFormatOptions); err != nil {
                return err
             }
        case "S3BucketSource":
            if err := json.Unmarshal([]byte(v), &strct.S3BucketSource); err != nil {
                return err
             }
            S3BucketSourceReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if InputFormat (a required property) was received
    if !InputFormatReceived {
        return errors.New("\"InputFormat\" is required but was not present")
    }
    // check if S3BucketSource (a required property) was received
    if !S3BucketSourceReceived {
        return errors.New("\"S3BucketSource\" is required but was not present")
    }
    return nil
}

func (strct *InputFormatOptions) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Csv" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Csv\": ")
	if tmp, err := json.Marshal(strct.Csv); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *InputFormatOptions) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Csv":
            if err := json.Unmarshal([]byte(v), &strct.Csv); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *KeySchema) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AttributeName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AttributeName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AttributeName\": ")
	if tmp, err := json.Marshal(strct.AttributeName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "KeyType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "KeyType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KeyType\": ")
	if tmp, err := json.Marshal(strct.KeyType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *KeySchema) UnmarshalJSON(b []byte) error {
    AttributeNameReceived := false
    KeyTypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AttributeName":
            if err := json.Unmarshal([]byte(v), &strct.AttributeName); err != nil {
                return err
             }
            AttributeNameReceived = true
        case "KeyType":
            if err := json.Unmarshal([]byte(v), &strct.KeyType); err != nil {
                return err
             }
            KeyTypeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if AttributeName (a required property) was received
    if !AttributeNameReceived {
        return errors.New("\"AttributeName\" is required but was not present")
    }
    // check if KeyType (a required property) was received
    if !KeyTypeReceived {
        return errors.New("\"KeyType\" is required but was not present")
    }
    return nil
}

func (strct *KinesisStreamSpecification) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "StreamArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "StreamArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StreamArn\": ")
	if tmp, err := json.Marshal(strct.StreamArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *KinesisStreamSpecification) UnmarshalJSON(b []byte) error {
    StreamArnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "StreamArn":
            if err := json.Unmarshal([]byte(v), &strct.StreamArn); err != nil {
                return err
             }
            StreamArnReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if StreamArn (a required property) was received
    if !StreamArnReceived {
        return errors.New("\"StreamArn\" is required but was not present")
    }
    return nil
}

func (strct *LocalSecondaryIndex) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "IndexName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "IndexName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IndexName\": ")
	if tmp, err := json.Marshal(strct.IndexName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "KeySchema" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "KeySchema" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KeySchema\": ")
	if tmp, err := json.Marshal(strct.KeySchema); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Projection" field is required
    if strct.Projection == nil {
        return nil, errors.New("Projection is a required field")
    }
    // Marshal the "Projection" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Projection\": ")
	if tmp, err := json.Marshal(strct.Projection); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LocalSecondaryIndex) UnmarshalJSON(b []byte) error {
    IndexNameReceived := false
    KeySchemaReceived := false
    ProjectionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "IndexName":
            if err := json.Unmarshal([]byte(v), &strct.IndexName); err != nil {
                return err
             }
            IndexNameReceived = true
        case "KeySchema":
            if err := json.Unmarshal([]byte(v), &strct.KeySchema); err != nil {
                return err
             }
            KeySchemaReceived = true
        case "Projection":
            if err := json.Unmarshal([]byte(v), &strct.Projection); err != nil {
                return err
             }
            ProjectionReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if IndexName (a required property) was received
    if !IndexNameReceived {
        return errors.New("\"IndexName\" is required but was not present")
    }
    // check if KeySchema (a required property) was received
    if !KeySchemaReceived {
        return errors.New("\"KeySchema\" is required but was not present")
    }
    // check if Projection (a required property) was received
    if !ProjectionReceived {
        return errors.New("\"Projection\" is required but was not present")
    }
    return nil
}

func (strct *PointInTimeRecoverySpecification) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "PointInTimeRecoveryEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PointInTimeRecoveryEnabled\": ")
	if tmp, err := json.Marshal(strct.PointInTimeRecoveryEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PointInTimeRecoverySpecification) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "PointInTimeRecoveryEnabled":
            if err := json.Unmarshal([]byte(v), &strct.PointInTimeRecoveryEnabled); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Projection) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "NonKeyAttributes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NonKeyAttributes\": ")
	if tmp, err := json.Marshal(strct.NonKeyAttributes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ProjectionType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ProjectionType\": ")
	if tmp, err := json.Marshal(strct.ProjectionType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Projection) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "NonKeyAttributes":
            if err := json.Unmarshal([]byte(v), &strct.NonKeyAttributes); err != nil {
                return err
             }
        case "ProjectionType":
            if err := json.Unmarshal([]byte(v), &strct.ProjectionType); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ProvisionedThroughput) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ReadCapacityUnits" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ReadCapacityUnits" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ReadCapacityUnits\": ")
	if tmp, err := json.Marshal(strct.ReadCapacityUnits); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "WriteCapacityUnits" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "WriteCapacityUnits" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"WriteCapacityUnits\": ")
	if tmp, err := json.Marshal(strct.WriteCapacityUnits); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ProvisionedThroughput) UnmarshalJSON(b []byte) error {
    ReadCapacityUnitsReceived := false
    WriteCapacityUnitsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ReadCapacityUnits":
            if err := json.Unmarshal([]byte(v), &strct.ReadCapacityUnits); err != nil {
                return err
             }
            ReadCapacityUnitsReceived = true
        case "WriteCapacityUnits":
            if err := json.Unmarshal([]byte(v), &strct.WriteCapacityUnits); err != nil {
                return err
             }
            WriteCapacityUnitsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ReadCapacityUnits (a required property) was received
    if !ReadCapacityUnitsReceived {
        return errors.New("\"ReadCapacityUnits\" is required but was not present")
    }
    // check if WriteCapacityUnits (a required property) was received
    if !WriteCapacityUnitsReceived {
        return errors.New("\"WriteCapacityUnits\" is required but was not present")
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Arn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Arn\": ")
	if tmp, err := json.Marshal(strct.Arn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AttributeDefinitions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AttributeDefinitions\": ")
	if tmp, err := json.Marshal(strct.AttributeDefinitions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BillingMode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BillingMode\": ")
	if tmp, err := json.Marshal(strct.BillingMode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ContributorInsightsSpecification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ContributorInsightsSpecification\": ")
	if tmp, err := json.Marshal(strct.ContributorInsightsSpecification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "GlobalSecondaryIndexes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"GlobalSecondaryIndexes\": ")
	if tmp, err := json.Marshal(strct.GlobalSecondaryIndexes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ImportSourceSpecification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ImportSourceSpecification\": ")
	if tmp, err := json.Marshal(strct.ImportSourceSpecification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "KeySchema" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "KeySchema" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KeySchema\": ")
	if tmp, err := json.Marshal(strct.KeySchema); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "KinesisStreamSpecification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KinesisStreamSpecification\": ")
	if tmp, err := json.Marshal(strct.KinesisStreamSpecification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LocalSecondaryIndexes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LocalSecondaryIndexes\": ")
	if tmp, err := json.Marshal(strct.LocalSecondaryIndexes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PointInTimeRecoverySpecification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PointInTimeRecoverySpecification\": ")
	if tmp, err := json.Marshal(strct.PointInTimeRecoverySpecification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ProvisionedThroughput" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ProvisionedThroughput\": ")
	if tmp, err := json.Marshal(strct.ProvisionedThroughput); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SSESpecification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SSESpecification\": ")
	if tmp, err := json.Marshal(strct.SSESpecification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StreamArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StreamArn\": ")
	if tmp, err := json.Marshal(strct.StreamArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StreamSpecification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StreamSpecification\": ")
	if tmp, err := json.Marshal(strct.StreamSpecification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TableClass" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TableClass\": ")
	if tmp, err := json.Marshal(strct.TableClass); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TableName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TableName\": ")
	if tmp, err := json.Marshal(strct.TableName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TimeToLiveSpecification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TimeToLiveSpecification\": ")
	if tmp, err := json.Marshal(strct.TimeToLiveSpecification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    KeySchemaReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Arn":
            if err := json.Unmarshal([]byte(v), &strct.Arn); err != nil {
                return err
             }
        case "AttributeDefinitions":
            if err := json.Unmarshal([]byte(v), &strct.AttributeDefinitions); err != nil {
                return err
             }
        case "BillingMode":
            if err := json.Unmarshal([]byte(v), &strct.BillingMode); err != nil {
                return err
             }
        case "ContributorInsightsSpecification":
            if err := json.Unmarshal([]byte(v), &strct.ContributorInsightsSpecification); err != nil {
                return err
             }
        case "GlobalSecondaryIndexes":
            if err := json.Unmarshal([]byte(v), &strct.GlobalSecondaryIndexes); err != nil {
                return err
             }
        case "ImportSourceSpecification":
            if err := json.Unmarshal([]byte(v), &strct.ImportSourceSpecification); err != nil {
                return err
             }
        case "KeySchema":
            if err := json.Unmarshal([]byte(v), &strct.KeySchema); err != nil {
                return err
             }
            KeySchemaReceived = true
        case "KinesisStreamSpecification":
            if err := json.Unmarshal([]byte(v), &strct.KinesisStreamSpecification); err != nil {
                return err
             }
        case "LocalSecondaryIndexes":
            if err := json.Unmarshal([]byte(v), &strct.LocalSecondaryIndexes); err != nil {
                return err
             }
        case "PointInTimeRecoverySpecification":
            if err := json.Unmarshal([]byte(v), &strct.PointInTimeRecoverySpecification); err != nil {
                return err
             }
        case "ProvisionedThroughput":
            if err := json.Unmarshal([]byte(v), &strct.ProvisionedThroughput); err != nil {
                return err
             }
        case "SSESpecification":
            if err := json.Unmarshal([]byte(v), &strct.SSESpecification); err != nil {
                return err
             }
        case "StreamArn":
            if err := json.Unmarshal([]byte(v), &strct.StreamArn); err != nil {
                return err
             }
        case "StreamSpecification":
            if err := json.Unmarshal([]byte(v), &strct.StreamSpecification); err != nil {
                return err
             }
        case "TableClass":
            if err := json.Unmarshal([]byte(v), &strct.TableClass); err != nil {
                return err
             }
        case "TableName":
            if err := json.Unmarshal([]byte(v), &strct.TableName); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        case "TimeToLiveSpecification":
            if err := json.Unmarshal([]byte(v), &strct.TimeToLiveSpecification); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if KeySchema (a required property) was received
    if !KeySchemaReceived {
        return errors.New("\"KeySchema\" is required but was not present")
    }
    return nil
}

func (strct *S3BucketSource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "S3Bucket" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "S3Bucket" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3Bucket\": ")
	if tmp, err := json.Marshal(strct.S3Bucket); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "S3BucketOwner" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3BucketOwner\": ")
	if tmp, err := json.Marshal(strct.S3BucketOwner); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "S3KeyPrefix" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3KeyPrefix\": ")
	if tmp, err := json.Marshal(strct.S3KeyPrefix); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *S3BucketSource) UnmarshalJSON(b []byte) error {
    S3BucketReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "S3Bucket":
            if err := json.Unmarshal([]byte(v), &strct.S3Bucket); err != nil {
                return err
             }
            S3BucketReceived = true
        case "S3BucketOwner":
            if err := json.Unmarshal([]byte(v), &strct.S3BucketOwner); err != nil {
                return err
             }
        case "S3KeyPrefix":
            if err := json.Unmarshal([]byte(v), &strct.S3KeyPrefix); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if S3Bucket (a required property) was received
    if !S3BucketReceived {
        return errors.New("\"S3Bucket\" is required but was not present")
    }
    return nil
}

func (strct *SSESpecification) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "KMSMasterKeyId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KMSMasterKeyId\": ")
	if tmp, err := json.Marshal(strct.KMSMasterKeyId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "SSEEnabled" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "SSEEnabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SSEEnabled\": ")
	if tmp, err := json.Marshal(strct.SSEEnabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SSEType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SSEType\": ")
	if tmp, err := json.Marshal(strct.SSEType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SSESpecification) UnmarshalJSON(b []byte) error {
    SSEEnabledReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "KMSMasterKeyId":
            if err := json.Unmarshal([]byte(v), &strct.KMSMasterKeyId); err != nil {
                return err
             }
        case "SSEEnabled":
            if err := json.Unmarshal([]byte(v), &strct.SSEEnabled); err != nil {
                return err
             }
            SSEEnabledReceived = true
        case "SSEType":
            if err := json.Unmarshal([]byte(v), &strct.SSEType); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if SSEEnabled (a required property) was received
    if !SSEEnabledReceived {
        return errors.New("\"SSEEnabled\" is required but was not present")
    }
    return nil
}

func (strct *StreamSpecification) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "StreamViewType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "StreamViewType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StreamViewType\": ")
	if tmp, err := json.Marshal(strct.StreamViewType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *StreamSpecification) UnmarshalJSON(b []byte) error {
    StreamViewTypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "StreamViewType":
            if err := json.Unmarshal([]byte(v), &strct.StreamViewType); err != nil {
                return err
             }
            StreamViewTypeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if StreamViewType (a required property) was received
    if !StreamViewTypeReceived {
        return errors.New("\"StreamViewType\" is required but was not present")
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *TimeToLiveSpecification) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AttributeName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AttributeName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AttributeName\": ")
	if tmp, err := json.Marshal(strct.AttributeName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Enabled" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Enabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TimeToLiveSpecification) UnmarshalJSON(b []byte) error {
    AttributeNameReceived := false
    EnabledReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AttributeName":
            if err := json.Unmarshal([]byte(v), &strct.AttributeName); err != nil {
                return err
             }
            AttributeNameReceived = true
        case "Enabled":
            if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
                return err
             }
            EnabledReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if AttributeName (a required property) was received
    if !AttributeNameReceived {
        return errors.New("\"AttributeName\" is required but was not present")
    }
    // check if Enabled (a required property) was received
    if !EnabledReceived {
        return errors.New("\"Enabled\" is required but was not present")
    }
    return nil
}
