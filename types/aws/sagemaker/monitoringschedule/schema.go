// Code generated by schema-generate. DO NOT EDIT.

package monitoringschedule

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// BaselineConfig Baseline configuration used to validate that the data conforms to the specified constraints and statistics.
type BaselineConfig struct {
  ConstraintsResource *ConstraintsResource `json:"ConstraintsResource,omitempty"`
  StatisticsResource *StatisticsResource `json:"StatisticsResource,omitempty"`
}

// BatchTransformInput The batch transform input for a monitoring job.
type BatchTransformInput struct {

  // A URI that identifies the Amazon S3 storage location where Batch Transform Job captures data.
  DataCapturedDestinationS3Uri string `json:"DataCapturedDestinationS3Uri"`
  DatasetFormat *DatasetFormat `json:"DatasetFormat"`

  // Path to the filesystem where the endpoint data is available to the container.
  LocalPath string `json:"LocalPath"`

  // Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
  S3DataDistributionType string `json:"S3DataDistributionType,omitempty"`

  // Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
  S3InputMode string `json:"S3InputMode,omitempty"`
}

// ClusterConfig Configuration for the cluster used to run model monitoring jobs.
type ClusterConfig struct {

  // The number of ML compute instances to use in the model monitoring job. For distributed processing jobs, specify a value greater than 1. The default value is 1.
  InstanceCount int `json:"InstanceCount"`

  // The ML compute instance type for the processing job.
  InstanceType string `json:"InstanceType"`

  // The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the model monitoring job.
  VolumeKmsKeyId string `json:"VolumeKmsKeyId,omitempty"`

  // The size of the ML storage volume, in gigabytes, that you want to provision. You must specify sufficient ML storage for your scenario.
  VolumeSizeInGB int `json:"VolumeSizeInGB"`
}

// ConstraintsResource The baseline constraints resource for a monitoring job.
type ConstraintsResource struct {

  // The Amazon S3 URI for baseline constraint file in Amazon S3 that the current monitoring job should validated against.
  S3Uri string `json:"S3Uri,omitempty"`
}

// Csv The CSV format
type Csv struct {

  // A boolean flag indicating if given CSV has header
  Header bool `json:"Header,omitempty"`
}

// DatasetFormat The dataset format of the data to monitor
type DatasetFormat struct {
  Csv *Csv `json:"Csv,omitempty"`
  Json *Json `json:"Json,omitempty"`
  Parquet bool `json:"Parquet,omitempty"`
}

// EndpointInput The endpoint for a monitoring job.
type EndpointInput struct {
  EndpointName string `json:"EndpointName"`

  // Path to the filesystem where the endpoint data is available to the container.
  LocalPath string `json:"LocalPath"`

  // Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
  S3DataDistributionType string `json:"S3DataDistributionType,omitempty"`

  // Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
  S3InputMode string `json:"S3InputMode,omitempty"`
}

// Environment Sets the environment variables in the Docker container
type Environment struct {
}

// Json The Json format
type Json struct {

  // A boolean flag indicating if it is JSON line format
  Line bool `json:"Line,omitempty"`
}

// MonitoringAppSpecification Container image configuration object for the monitoring job.
type MonitoringAppSpecification struct {

  // An array of arguments for the container used to run the monitoring job.
  ContainerArguments []string `json:"ContainerArguments,omitempty"`

  // Specifies the entrypoint for a container used to run the monitoring job.
  ContainerEntrypoint []string `json:"ContainerEntrypoint,omitempty"`

  // The container image to be run by the monitoring job.
  ImageUri string `json:"ImageUri"`

  // An Amazon S3 URI to a script that is called after analysis has been performed. Applicable only for the built-in (first party) containers.
  PostAnalyticsProcessorSourceUri string `json:"PostAnalyticsProcessorSourceUri,omitempty"`

  // An Amazon S3 URI to a script that is called per row prior to running analysis. It can base64 decode the payload and convert it into a flatted json so that the built-in container can use the converted data. Applicable only for the built-in (first party) containers
  RecordPreprocessorSourceUri string `json:"RecordPreprocessorSourceUri,omitempty"`
}

// MonitoringExecutionSummary Summary of information about monitoring job
type MonitoringExecutionSummary struct {

  // The time at which the monitoring job was created.
  CreationTime string `json:"CreationTime"`
  EndpointName string `json:"EndpointName,omitempty"`

  // Contains the reason a monitoring job failed, if it failed.
  FailureReason string `json:"FailureReason,omitempty"`

  // A timestamp that indicates the last time the monitoring job was modified.
  LastModifiedTime string `json:"LastModifiedTime"`

  // The status of the monitoring job.
  MonitoringExecutionStatus string `json:"MonitoringExecutionStatus"`
  MonitoringScheduleName string `json:"MonitoringScheduleName"`

  // The Amazon Resource Name (ARN) of the monitoring job.
  ProcessingJobArn string `json:"ProcessingJobArn,omitempty"`

  // The time the monitoring job was scheduled.
  ScheduledTime string `json:"ScheduledTime"`
}

// MonitoringInput The inputs for a monitoring job.
type MonitoringInput struct {
  BatchTransformInput *BatchTransformInput `json:"BatchTransformInput,omitempty"`
  EndpointInput *EndpointInput `json:"EndpointInput,omitempty"`
}

// MonitoringJobDefinition Defines the monitoring job.
type MonitoringJobDefinition struct {
  BaselineConfig *BaselineConfig `json:"BaselineConfig,omitempty"`

  // Sets the environment variables in the Docker container
  Environment *Environment `json:"Environment,omitempty"`
  MonitoringAppSpecification *MonitoringAppSpecification `json:"MonitoringAppSpecification"`
  MonitoringInputs []*MonitoringInput `json:"MonitoringInputs"`
  MonitoringOutputConfig *MonitoringOutputConfig `json:"MonitoringOutputConfig"`
  MonitoringResources *MonitoringResources `json:"MonitoringResources"`
  NetworkConfig *NetworkConfig `json:"NetworkConfig,omitempty"`

  // The Amazon Resource Name (ARN) of an IAM role that Amazon SageMaker can assume to perform tasks on your behalf.
  RoleArn string `json:"RoleArn"`
  StoppingCondition *StoppingCondition `json:"StoppingCondition,omitempty"`
}

// MonitoringOutput The output object for a monitoring job.
type MonitoringOutput struct {
  S3Output *S3Output `json:"S3Output"`
}

// MonitoringOutputConfig The output configuration for monitoring jobs.
type MonitoringOutputConfig struct {

  // The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption.
  KmsKeyId string `json:"KmsKeyId,omitempty"`

  // Monitoring outputs for monitoring jobs. This is where the output of the periodic monitoring jobs is uploaded.
  MonitoringOutputs []*MonitoringOutput `json:"MonitoringOutputs"`
}

// MonitoringResources Identifies the resources to deploy for a monitoring job.
type MonitoringResources struct {
  ClusterConfig *ClusterConfig `json:"ClusterConfig"`
}

// MonitoringScheduleConfig The configuration object that specifies the monitoring schedule and defines the monitoring job.
type MonitoringScheduleConfig struct {
  MonitoringJobDefinition *MonitoringJobDefinition `json:"MonitoringJobDefinition,omitempty"`

  // Name of the job definition
  MonitoringJobDefinitionName string `json:"MonitoringJobDefinitionName,omitempty"`
  MonitoringType string `json:"MonitoringType,omitempty"`
  ScheduleConfig *ScheduleConfig `json:"ScheduleConfig,omitempty"`
}

// NetworkConfig Networking options for a job, such as network traffic encryption between containers, whether to allow inbound and outbound network calls to and from containers, and the VPC subnets and security groups to use for VPC-enabled jobs.
type NetworkConfig struct {

  // Whether to encrypt all communications between distributed processing jobs. Choose True to encrypt communications. Encryption provides greater security for distributed processing jobs, but the processing might take longer.
  EnableInterContainerTrafficEncryption bool `json:"EnableInterContainerTrafficEncryption,omitempty"`

  // Whether to allow inbound and outbound network calls to and from the containers used for the processing job.
  EnableNetworkIsolation bool `json:"EnableNetworkIsolation,omitempty"`
  VpcConfig *VpcConfig `json:"VpcConfig,omitempty"`
}

// Resource Resource Type definition for AWS::SageMaker::MonitoringSchedule
type Resource struct {

  // The time at which the schedule was created.
  CreationTime string `json:"CreationTime,omitempty"`
  EndpointName string `json:"EndpointName,omitempty"`

  // Contains the reason a monitoring job failed, if it failed.
  FailureReason string `json:"FailureReason,omitempty"`

  // A timestamp that indicates the last time the monitoring job was modified.
  LastModifiedTime string `json:"LastModifiedTime,omitempty"`

  // Describes metadata on the last execution to run, if there was one.
  LastMonitoringExecutionSummary *MonitoringExecutionSummary `json:"LastMonitoringExecutionSummary,omitempty"`

  // The Amazon Resource Name (ARN) of the monitoring schedule.
  MonitoringScheduleArn string `json:"MonitoringScheduleArn,omitempty"`
  MonitoringScheduleConfig *MonitoringScheduleConfig `json:"MonitoringScheduleConfig"`
  MonitoringScheduleName string `json:"MonitoringScheduleName"`

  // The status of a schedule job.
  MonitoringScheduleStatus string `json:"MonitoringScheduleStatus,omitempty"`

  // An array of key-value pairs to apply to this resource.
  Tags []*Tag `json:"Tags,omitempty"`
}

// S3Output Information about where and how to store the results of a monitoring job.
type S3Output struct {

  // The local path to the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job. LocalPath is an absolute path for the output data.
  LocalPath string `json:"LocalPath"`

  // Whether to upload the results of the monitoring job continuously or after the job completes.
  S3UploadMode string `json:"S3UploadMode,omitempty"`

  // A URI that identifies the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job.
  S3Uri string `json:"S3Uri"`
}

// ScheduleConfig Configuration details about the monitoring schedule.
type ScheduleConfig struct {

  // A cron expression that describes details about the monitoring schedule.
  ScheduleExpression string `json:"ScheduleExpression"`
}

// StatisticsResource The baseline statistics resource for a monitoring job.
type StatisticsResource struct {

  // The Amazon S3 URI for the baseline statistics file in Amazon S3 that the current monitoring job should be validated against.
  S3Uri string `json:"S3Uri,omitempty"`
}

// StoppingCondition Specifies a time limit for how long the monitoring job is allowed to run.
type StoppingCondition struct {

  // The maximum runtime allowed in seconds.
  MaxRuntimeInSeconds int `json:"MaxRuntimeInSeconds"`
}

// Tag A key-value pair to associate with a resource.
type Tag struct {

  // The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
  Key string `json:"Key"`

  // The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
  Value string `json:"Value"`
}

// VpcConfig Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC.
type VpcConfig struct {

  // The VPC security group IDs, in the form sg-xxxxxxxx. Specify the security groups for the VPC that is specified in the Subnets field.
  SecurityGroupIds []string `json:"SecurityGroupIds"`

  // The ID of the subnets in the VPC to which you want to connect to your monitoring jobs.
  Subnets []string `json:"Subnets"`
}

func (strct *BaselineConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ConstraintsResource" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConstraintsResource\": ")
	if tmp, err := json.Marshal(strct.ConstraintsResource); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StatisticsResource" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StatisticsResource\": ")
	if tmp, err := json.Marshal(strct.StatisticsResource); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BaselineConfig) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ConstraintsResource":
            if err := json.Unmarshal([]byte(v), &strct.ConstraintsResource); err != nil {
                return err
             }
        case "StatisticsResource":
            if err := json.Unmarshal([]byte(v), &strct.StatisticsResource); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *BatchTransformInput) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "DataCapturedDestinationS3Uri" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "DataCapturedDestinationS3Uri" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DataCapturedDestinationS3Uri\": ")
	if tmp, err := json.Marshal(strct.DataCapturedDestinationS3Uri); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "DatasetFormat" field is required
    if strct.DatasetFormat == nil {
        return nil, errors.New("DatasetFormat is a required field")
    }
    // Marshal the "DatasetFormat" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DatasetFormat\": ")
	if tmp, err := json.Marshal(strct.DatasetFormat); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "LocalPath" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "LocalPath" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LocalPath\": ")
	if tmp, err := json.Marshal(strct.LocalPath); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "S3DataDistributionType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3DataDistributionType\": ")
	if tmp, err := json.Marshal(strct.S3DataDistributionType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "S3InputMode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3InputMode\": ")
	if tmp, err := json.Marshal(strct.S3InputMode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BatchTransformInput) UnmarshalJSON(b []byte) error {
    DataCapturedDestinationS3UriReceived := false
    DatasetFormatReceived := false
    LocalPathReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DataCapturedDestinationS3Uri":
            if err := json.Unmarshal([]byte(v), &strct.DataCapturedDestinationS3Uri); err != nil {
                return err
             }
            DataCapturedDestinationS3UriReceived = true
        case "DatasetFormat":
            if err := json.Unmarshal([]byte(v), &strct.DatasetFormat); err != nil {
                return err
             }
            DatasetFormatReceived = true
        case "LocalPath":
            if err := json.Unmarshal([]byte(v), &strct.LocalPath); err != nil {
                return err
             }
            LocalPathReceived = true
        case "S3DataDistributionType":
            if err := json.Unmarshal([]byte(v), &strct.S3DataDistributionType); err != nil {
                return err
             }
        case "S3InputMode":
            if err := json.Unmarshal([]byte(v), &strct.S3InputMode); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if DataCapturedDestinationS3Uri (a required property) was received
    if !DataCapturedDestinationS3UriReceived {
        return errors.New("\"DataCapturedDestinationS3Uri\" is required but was not present")
    }
    // check if DatasetFormat (a required property) was received
    if !DatasetFormatReceived {
        return errors.New("\"DatasetFormat\" is required but was not present")
    }
    // check if LocalPath (a required property) was received
    if !LocalPathReceived {
        return errors.New("\"LocalPath\" is required but was not present")
    }
    return nil
}

func (strct *ClusterConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "InstanceCount" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "InstanceCount" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InstanceCount\": ")
	if tmp, err := json.Marshal(strct.InstanceCount); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "InstanceType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "InstanceType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InstanceType\": ")
	if tmp, err := json.Marshal(strct.InstanceType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VolumeKmsKeyId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VolumeKmsKeyId\": ")
	if tmp, err := json.Marshal(strct.VolumeKmsKeyId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "VolumeSizeInGB" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "VolumeSizeInGB" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VolumeSizeInGB\": ")
	if tmp, err := json.Marshal(strct.VolumeSizeInGB); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ClusterConfig) UnmarshalJSON(b []byte) error {
    InstanceCountReceived := false
    InstanceTypeReceived := false
    VolumeSizeInGBReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "InstanceCount":
            if err := json.Unmarshal([]byte(v), &strct.InstanceCount); err != nil {
                return err
             }
            InstanceCountReceived = true
        case "InstanceType":
            if err := json.Unmarshal([]byte(v), &strct.InstanceType); err != nil {
                return err
             }
            InstanceTypeReceived = true
        case "VolumeKmsKeyId":
            if err := json.Unmarshal([]byte(v), &strct.VolumeKmsKeyId); err != nil {
                return err
             }
        case "VolumeSizeInGB":
            if err := json.Unmarshal([]byte(v), &strct.VolumeSizeInGB); err != nil {
                return err
             }
            VolumeSizeInGBReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if InstanceCount (a required property) was received
    if !InstanceCountReceived {
        return errors.New("\"InstanceCount\" is required but was not present")
    }
    // check if InstanceType (a required property) was received
    if !InstanceTypeReceived {
        return errors.New("\"InstanceType\" is required but was not present")
    }
    // check if VolumeSizeInGB (a required property) was received
    if !VolumeSizeInGBReceived {
        return errors.New("\"VolumeSizeInGB\" is required but was not present")
    }
    return nil
}

func (strct *ConstraintsResource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "S3Uri" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3Uri\": ")
	if tmp, err := json.Marshal(strct.S3Uri); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ConstraintsResource) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "S3Uri":
            if err := json.Unmarshal([]byte(v), &strct.S3Uri); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *EndpointInput) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "EndpointName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "EndpointName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EndpointName\": ")
	if tmp, err := json.Marshal(strct.EndpointName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "LocalPath" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "LocalPath" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LocalPath\": ")
	if tmp, err := json.Marshal(strct.LocalPath); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "S3DataDistributionType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3DataDistributionType\": ")
	if tmp, err := json.Marshal(strct.S3DataDistributionType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "S3InputMode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3InputMode\": ")
	if tmp, err := json.Marshal(strct.S3InputMode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *EndpointInput) UnmarshalJSON(b []byte) error {
    EndpointNameReceived := false
    LocalPathReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "EndpointName":
            if err := json.Unmarshal([]byte(v), &strct.EndpointName); err != nil {
                return err
             }
            EndpointNameReceived = true
        case "LocalPath":
            if err := json.Unmarshal([]byte(v), &strct.LocalPath); err != nil {
                return err
             }
            LocalPathReceived = true
        case "S3DataDistributionType":
            if err := json.Unmarshal([]byte(v), &strct.S3DataDistributionType); err != nil {
                return err
             }
        case "S3InputMode":
            if err := json.Unmarshal([]byte(v), &strct.S3InputMode); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if EndpointName (a required property) was received
    if !EndpointNameReceived {
        return errors.New("\"EndpointName\" is required but was not present")
    }
    // check if LocalPath (a required property) was received
    if !LocalPathReceived {
        return errors.New("\"LocalPath\" is required but was not present")
    }
    return nil
}

func (strct *MonitoringAppSpecification) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ContainerArguments" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ContainerArguments\": ")
	if tmp, err := json.Marshal(strct.ContainerArguments); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ContainerEntrypoint" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ContainerEntrypoint\": ")
	if tmp, err := json.Marshal(strct.ContainerEntrypoint); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ImageUri" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ImageUri" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ImageUri\": ")
	if tmp, err := json.Marshal(strct.ImageUri); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PostAnalyticsProcessorSourceUri" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PostAnalyticsProcessorSourceUri\": ")
	if tmp, err := json.Marshal(strct.PostAnalyticsProcessorSourceUri); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RecordPreprocessorSourceUri" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RecordPreprocessorSourceUri\": ")
	if tmp, err := json.Marshal(strct.RecordPreprocessorSourceUri); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MonitoringAppSpecification) UnmarshalJSON(b []byte) error {
    ImageUriReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ContainerArguments":
            if err := json.Unmarshal([]byte(v), &strct.ContainerArguments); err != nil {
                return err
             }
        case "ContainerEntrypoint":
            if err := json.Unmarshal([]byte(v), &strct.ContainerEntrypoint); err != nil {
                return err
             }
        case "ImageUri":
            if err := json.Unmarshal([]byte(v), &strct.ImageUri); err != nil {
                return err
             }
            ImageUriReceived = true
        case "PostAnalyticsProcessorSourceUri":
            if err := json.Unmarshal([]byte(v), &strct.PostAnalyticsProcessorSourceUri); err != nil {
                return err
             }
        case "RecordPreprocessorSourceUri":
            if err := json.Unmarshal([]byte(v), &strct.RecordPreprocessorSourceUri); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ImageUri (a required property) was received
    if !ImageUriReceived {
        return errors.New("\"ImageUri\" is required but was not present")
    }
    return nil
}

func (strct *MonitoringExecutionSummary) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "CreationTime" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "CreationTime" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CreationTime\": ")
	if tmp, err := json.Marshal(strct.CreationTime); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EndpointName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EndpointName\": ")
	if tmp, err := json.Marshal(strct.EndpointName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FailureReason" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FailureReason\": ")
	if tmp, err := json.Marshal(strct.FailureReason); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "LastModifiedTime" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "LastModifiedTime" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LastModifiedTime\": ")
	if tmp, err := json.Marshal(strct.LastModifiedTime); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "MonitoringExecutionStatus" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "MonitoringExecutionStatus" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MonitoringExecutionStatus\": ")
	if tmp, err := json.Marshal(strct.MonitoringExecutionStatus); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "MonitoringScheduleName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "MonitoringScheduleName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MonitoringScheduleName\": ")
	if tmp, err := json.Marshal(strct.MonitoringScheduleName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ProcessingJobArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ProcessingJobArn\": ")
	if tmp, err := json.Marshal(strct.ProcessingJobArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ScheduledTime" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ScheduledTime" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ScheduledTime\": ")
	if tmp, err := json.Marshal(strct.ScheduledTime); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MonitoringExecutionSummary) UnmarshalJSON(b []byte) error {
    CreationTimeReceived := false
    LastModifiedTimeReceived := false
    MonitoringExecutionStatusReceived := false
    MonitoringScheduleNameReceived := false
    ScheduledTimeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CreationTime":
            if err := json.Unmarshal([]byte(v), &strct.CreationTime); err != nil {
                return err
             }
            CreationTimeReceived = true
        case "EndpointName":
            if err := json.Unmarshal([]byte(v), &strct.EndpointName); err != nil {
                return err
             }
        case "FailureReason":
            if err := json.Unmarshal([]byte(v), &strct.FailureReason); err != nil {
                return err
             }
        case "LastModifiedTime":
            if err := json.Unmarshal([]byte(v), &strct.LastModifiedTime); err != nil {
                return err
             }
            LastModifiedTimeReceived = true
        case "MonitoringExecutionStatus":
            if err := json.Unmarshal([]byte(v), &strct.MonitoringExecutionStatus); err != nil {
                return err
             }
            MonitoringExecutionStatusReceived = true
        case "MonitoringScheduleName":
            if err := json.Unmarshal([]byte(v), &strct.MonitoringScheduleName); err != nil {
                return err
             }
            MonitoringScheduleNameReceived = true
        case "ProcessingJobArn":
            if err := json.Unmarshal([]byte(v), &strct.ProcessingJobArn); err != nil {
                return err
             }
        case "ScheduledTime":
            if err := json.Unmarshal([]byte(v), &strct.ScheduledTime); err != nil {
                return err
             }
            ScheduledTimeReceived = true
        }
    }
    // check if CreationTime (a required property) was received
    if !CreationTimeReceived {
        return errors.New("\"CreationTime\" is required but was not present")
    }
    // check if LastModifiedTime (a required property) was received
    if !LastModifiedTimeReceived {
        return errors.New("\"LastModifiedTime\" is required but was not present")
    }
    // check if MonitoringExecutionStatus (a required property) was received
    if !MonitoringExecutionStatusReceived {
        return errors.New("\"MonitoringExecutionStatus\" is required but was not present")
    }
    // check if MonitoringScheduleName (a required property) was received
    if !MonitoringScheduleNameReceived {
        return errors.New("\"MonitoringScheduleName\" is required but was not present")
    }
    // check if ScheduledTime (a required property) was received
    if !ScheduledTimeReceived {
        return errors.New("\"ScheduledTime\" is required but was not present")
    }
    return nil
}

func (strct *MonitoringInput) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "BatchTransformInput" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BatchTransformInput\": ")
	if tmp, err := json.Marshal(strct.BatchTransformInput); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EndpointInput" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EndpointInput\": ")
	if tmp, err := json.Marshal(strct.EndpointInput); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MonitoringInput) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BatchTransformInput":
            if err := json.Unmarshal([]byte(v), &strct.BatchTransformInput); err != nil {
                return err
             }
        case "EndpointInput":
            if err := json.Unmarshal([]byte(v), &strct.EndpointInput); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *MonitoringJobDefinition) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "BaselineConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BaselineConfig\": ")
	if tmp, err := json.Marshal(strct.BaselineConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Environment" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Environment\": ")
	if tmp, err := json.Marshal(strct.Environment); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "MonitoringAppSpecification" field is required
    if strct.MonitoringAppSpecification == nil {
        return nil, errors.New("MonitoringAppSpecification is a required field")
    }
    // Marshal the "MonitoringAppSpecification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MonitoringAppSpecification\": ")
	if tmp, err := json.Marshal(strct.MonitoringAppSpecification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "MonitoringInputs" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "MonitoringInputs" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MonitoringInputs\": ")
	if tmp, err := json.Marshal(strct.MonitoringInputs); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "MonitoringOutputConfig" field is required
    if strct.MonitoringOutputConfig == nil {
        return nil, errors.New("MonitoringOutputConfig is a required field")
    }
    // Marshal the "MonitoringOutputConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MonitoringOutputConfig\": ")
	if tmp, err := json.Marshal(strct.MonitoringOutputConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "MonitoringResources" field is required
    if strct.MonitoringResources == nil {
        return nil, errors.New("MonitoringResources is a required field")
    }
    // Marshal the "MonitoringResources" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MonitoringResources\": ")
	if tmp, err := json.Marshal(strct.MonitoringResources); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "NetworkConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NetworkConfig\": ")
	if tmp, err := json.Marshal(strct.NetworkConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RoleArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoleArn\": ")
	if tmp, err := json.Marshal(strct.RoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StoppingCondition" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StoppingCondition\": ")
	if tmp, err := json.Marshal(strct.StoppingCondition); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MonitoringJobDefinition) UnmarshalJSON(b []byte) error {
    MonitoringAppSpecificationReceived := false
    MonitoringInputsReceived := false
    MonitoringOutputConfigReceived := false
    MonitoringResourcesReceived := false
    RoleArnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BaselineConfig":
            if err := json.Unmarshal([]byte(v), &strct.BaselineConfig); err != nil {
                return err
             }
        case "Environment":
            if err := json.Unmarshal([]byte(v), &strct.Environment); err != nil {
                return err
             }
        case "MonitoringAppSpecification":
            if err := json.Unmarshal([]byte(v), &strct.MonitoringAppSpecification); err != nil {
                return err
             }
            MonitoringAppSpecificationReceived = true
        case "MonitoringInputs":
            if err := json.Unmarshal([]byte(v), &strct.MonitoringInputs); err != nil {
                return err
             }
            MonitoringInputsReceived = true
        case "MonitoringOutputConfig":
            if err := json.Unmarshal([]byte(v), &strct.MonitoringOutputConfig); err != nil {
                return err
             }
            MonitoringOutputConfigReceived = true
        case "MonitoringResources":
            if err := json.Unmarshal([]byte(v), &strct.MonitoringResources); err != nil {
                return err
             }
            MonitoringResourcesReceived = true
        case "NetworkConfig":
            if err := json.Unmarshal([]byte(v), &strct.NetworkConfig); err != nil {
                return err
             }
        case "RoleArn":
            if err := json.Unmarshal([]byte(v), &strct.RoleArn); err != nil {
                return err
             }
            RoleArnReceived = true
        case "StoppingCondition":
            if err := json.Unmarshal([]byte(v), &strct.StoppingCondition); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if MonitoringAppSpecification (a required property) was received
    if !MonitoringAppSpecificationReceived {
        return errors.New("\"MonitoringAppSpecification\" is required but was not present")
    }
    // check if MonitoringInputs (a required property) was received
    if !MonitoringInputsReceived {
        return errors.New("\"MonitoringInputs\" is required but was not present")
    }
    // check if MonitoringOutputConfig (a required property) was received
    if !MonitoringOutputConfigReceived {
        return errors.New("\"MonitoringOutputConfig\" is required but was not present")
    }
    // check if MonitoringResources (a required property) was received
    if !MonitoringResourcesReceived {
        return errors.New("\"MonitoringResources\" is required but was not present")
    }
    // check if RoleArn (a required property) was received
    if !RoleArnReceived {
        return errors.New("\"RoleArn\" is required but was not present")
    }
    return nil
}

func (strct *MonitoringOutput) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "S3Output" field is required
    if strct.S3Output == nil {
        return nil, errors.New("S3Output is a required field")
    }
    // Marshal the "S3Output" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3Output\": ")
	if tmp, err := json.Marshal(strct.S3Output); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MonitoringOutput) UnmarshalJSON(b []byte) error {
    S3OutputReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "S3Output":
            if err := json.Unmarshal([]byte(v), &strct.S3Output); err != nil {
                return err
             }
            S3OutputReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if S3Output (a required property) was received
    if !S3OutputReceived {
        return errors.New("\"S3Output\" is required but was not present")
    }
    return nil
}

func (strct *MonitoringOutputConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "KmsKeyId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KmsKeyId\": ")
	if tmp, err := json.Marshal(strct.KmsKeyId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "MonitoringOutputs" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "MonitoringOutputs" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MonitoringOutputs\": ")
	if tmp, err := json.Marshal(strct.MonitoringOutputs); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MonitoringOutputConfig) UnmarshalJSON(b []byte) error {
    MonitoringOutputsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "KmsKeyId":
            if err := json.Unmarshal([]byte(v), &strct.KmsKeyId); err != nil {
                return err
             }
        case "MonitoringOutputs":
            if err := json.Unmarshal([]byte(v), &strct.MonitoringOutputs); err != nil {
                return err
             }
            MonitoringOutputsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if MonitoringOutputs (a required property) was received
    if !MonitoringOutputsReceived {
        return errors.New("\"MonitoringOutputs\" is required but was not present")
    }
    return nil
}

func (strct *MonitoringResources) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ClusterConfig" field is required
    if strct.ClusterConfig == nil {
        return nil, errors.New("ClusterConfig is a required field")
    }
    // Marshal the "ClusterConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ClusterConfig\": ")
	if tmp, err := json.Marshal(strct.ClusterConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MonitoringResources) UnmarshalJSON(b []byte) error {
    ClusterConfigReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ClusterConfig":
            if err := json.Unmarshal([]byte(v), &strct.ClusterConfig); err != nil {
                return err
             }
            ClusterConfigReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ClusterConfig (a required property) was received
    if !ClusterConfigReceived {
        return errors.New("\"ClusterConfig\" is required but was not present")
    }
    return nil
}

func (strct *MonitoringScheduleConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "MonitoringJobDefinition" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MonitoringJobDefinition\": ")
	if tmp, err := json.Marshal(strct.MonitoringJobDefinition); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MonitoringJobDefinitionName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MonitoringJobDefinitionName\": ")
	if tmp, err := json.Marshal(strct.MonitoringJobDefinitionName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MonitoringType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MonitoringType\": ")
	if tmp, err := json.Marshal(strct.MonitoringType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ScheduleConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ScheduleConfig\": ")
	if tmp, err := json.Marshal(strct.ScheduleConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MonitoringScheduleConfig) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "MonitoringJobDefinition":
            if err := json.Unmarshal([]byte(v), &strct.MonitoringJobDefinition); err != nil {
                return err
             }
        case "MonitoringJobDefinitionName":
            if err := json.Unmarshal([]byte(v), &strct.MonitoringJobDefinitionName); err != nil {
                return err
             }
        case "MonitoringType":
            if err := json.Unmarshal([]byte(v), &strct.MonitoringType); err != nil {
                return err
             }
        case "ScheduleConfig":
            if err := json.Unmarshal([]byte(v), &strct.ScheduleConfig); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *NetworkConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "EnableInterContainerTrafficEncryption" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EnableInterContainerTrafficEncryption\": ")
	if tmp, err := json.Marshal(strct.EnableInterContainerTrafficEncryption); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EnableNetworkIsolation" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EnableNetworkIsolation\": ")
	if tmp, err := json.Marshal(strct.EnableNetworkIsolation); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VpcConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VpcConfig\": ")
	if tmp, err := json.Marshal(strct.VpcConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *NetworkConfig) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "EnableInterContainerTrafficEncryption":
            if err := json.Unmarshal([]byte(v), &strct.EnableInterContainerTrafficEncryption); err != nil {
                return err
             }
        case "EnableNetworkIsolation":
            if err := json.Unmarshal([]byte(v), &strct.EnableNetworkIsolation); err != nil {
                return err
             }
        case "VpcConfig":
            if err := json.Unmarshal([]byte(v), &strct.VpcConfig); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CreationTime" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CreationTime\": ")
	if tmp, err := json.Marshal(strct.CreationTime); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EndpointName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EndpointName\": ")
	if tmp, err := json.Marshal(strct.EndpointName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FailureReason" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FailureReason\": ")
	if tmp, err := json.Marshal(strct.FailureReason); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LastModifiedTime" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LastModifiedTime\": ")
	if tmp, err := json.Marshal(strct.LastModifiedTime); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LastMonitoringExecutionSummary" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LastMonitoringExecutionSummary\": ")
	if tmp, err := json.Marshal(strct.LastMonitoringExecutionSummary); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MonitoringScheduleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MonitoringScheduleArn\": ")
	if tmp, err := json.Marshal(strct.MonitoringScheduleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "MonitoringScheduleConfig" field is required
    if strct.MonitoringScheduleConfig == nil {
        return nil, errors.New("MonitoringScheduleConfig is a required field")
    }
    // Marshal the "MonitoringScheduleConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MonitoringScheduleConfig\": ")
	if tmp, err := json.Marshal(strct.MonitoringScheduleConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "MonitoringScheduleName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "MonitoringScheduleName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MonitoringScheduleName\": ")
	if tmp, err := json.Marshal(strct.MonitoringScheduleName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MonitoringScheduleStatus" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MonitoringScheduleStatus\": ")
	if tmp, err := json.Marshal(strct.MonitoringScheduleStatus); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    MonitoringScheduleConfigReceived := false
    MonitoringScheduleNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CreationTime":
            if err := json.Unmarshal([]byte(v), &strct.CreationTime); err != nil {
                return err
             }
        case "EndpointName":
            if err := json.Unmarshal([]byte(v), &strct.EndpointName); err != nil {
                return err
             }
        case "FailureReason":
            if err := json.Unmarshal([]byte(v), &strct.FailureReason); err != nil {
                return err
             }
        case "LastModifiedTime":
            if err := json.Unmarshal([]byte(v), &strct.LastModifiedTime); err != nil {
                return err
             }
        case "LastMonitoringExecutionSummary":
            if err := json.Unmarshal([]byte(v), &strct.LastMonitoringExecutionSummary); err != nil {
                return err
             }
        case "MonitoringScheduleArn":
            if err := json.Unmarshal([]byte(v), &strct.MonitoringScheduleArn); err != nil {
                return err
             }
        case "MonitoringScheduleConfig":
            if err := json.Unmarshal([]byte(v), &strct.MonitoringScheduleConfig); err != nil {
                return err
             }
            MonitoringScheduleConfigReceived = true
        case "MonitoringScheduleName":
            if err := json.Unmarshal([]byte(v), &strct.MonitoringScheduleName); err != nil {
                return err
             }
            MonitoringScheduleNameReceived = true
        case "MonitoringScheduleStatus":
            if err := json.Unmarshal([]byte(v), &strct.MonitoringScheduleStatus); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if MonitoringScheduleConfig (a required property) was received
    if !MonitoringScheduleConfigReceived {
        return errors.New("\"MonitoringScheduleConfig\" is required but was not present")
    }
    // check if MonitoringScheduleName (a required property) was received
    if !MonitoringScheduleNameReceived {
        return errors.New("\"MonitoringScheduleName\" is required but was not present")
    }
    return nil
}

func (strct *S3Output) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "LocalPath" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "LocalPath" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LocalPath\": ")
	if tmp, err := json.Marshal(strct.LocalPath); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "S3UploadMode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3UploadMode\": ")
	if tmp, err := json.Marshal(strct.S3UploadMode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "S3Uri" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "S3Uri" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3Uri\": ")
	if tmp, err := json.Marshal(strct.S3Uri); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *S3Output) UnmarshalJSON(b []byte) error {
    LocalPathReceived := false
    S3UriReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "LocalPath":
            if err := json.Unmarshal([]byte(v), &strct.LocalPath); err != nil {
                return err
             }
            LocalPathReceived = true
        case "S3UploadMode":
            if err := json.Unmarshal([]byte(v), &strct.S3UploadMode); err != nil {
                return err
             }
        case "S3Uri":
            if err := json.Unmarshal([]byte(v), &strct.S3Uri); err != nil {
                return err
             }
            S3UriReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if LocalPath (a required property) was received
    if !LocalPathReceived {
        return errors.New("\"LocalPath\" is required but was not present")
    }
    // check if S3Uri (a required property) was received
    if !S3UriReceived {
        return errors.New("\"S3Uri\" is required but was not present")
    }
    return nil
}

func (strct *ScheduleConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ScheduleExpression" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ScheduleExpression" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ScheduleExpression\": ")
	if tmp, err := json.Marshal(strct.ScheduleExpression); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ScheduleConfig) UnmarshalJSON(b []byte) error {
    ScheduleExpressionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ScheduleExpression":
            if err := json.Unmarshal([]byte(v), &strct.ScheduleExpression); err != nil {
                return err
             }
            ScheduleExpressionReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ScheduleExpression (a required property) was received
    if !ScheduleExpressionReceived {
        return errors.New("\"ScheduleExpression\" is required but was not present")
    }
    return nil
}

func (strct *StatisticsResource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "S3Uri" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3Uri\": ")
	if tmp, err := json.Marshal(strct.S3Uri); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *StatisticsResource) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "S3Uri":
            if err := json.Unmarshal([]byte(v), &strct.S3Uri); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *StoppingCondition) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "MaxRuntimeInSeconds" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "MaxRuntimeInSeconds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaxRuntimeInSeconds\": ")
	if tmp, err := json.Marshal(strct.MaxRuntimeInSeconds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *StoppingCondition) UnmarshalJSON(b []byte) error {
    MaxRuntimeInSecondsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "MaxRuntimeInSeconds":
            if err := json.Unmarshal([]byte(v), &strct.MaxRuntimeInSeconds); err != nil {
                return err
             }
            MaxRuntimeInSecondsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if MaxRuntimeInSeconds (a required property) was received
    if !MaxRuntimeInSecondsReceived {
        return errors.New("\"MaxRuntimeInSeconds\" is required but was not present")
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *VpcConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "SecurityGroupIds" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "SecurityGroupIds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SecurityGroupIds\": ")
	if tmp, err := json.Marshal(strct.SecurityGroupIds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Subnets" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Subnets" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Subnets\": ")
	if tmp, err := json.Marshal(strct.Subnets); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *VpcConfig) UnmarshalJSON(b []byte) error {
    SecurityGroupIdsReceived := false
    SubnetsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "SecurityGroupIds":
            if err := json.Unmarshal([]byte(v), &strct.SecurityGroupIds); err != nil {
                return err
             }
            SecurityGroupIdsReceived = true
        case "Subnets":
            if err := json.Unmarshal([]byte(v), &strct.Subnets); err != nil {
                return err
             }
            SubnetsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if SecurityGroupIds (a required property) was received
    if !SecurityGroupIdsReceived {
        return errors.New("\"SecurityGroupIds\" is required but was not present")
    }
    // check if Subnets (a required property) was received
    if !SubnetsReceived {
        return errors.New("\"Subnets\" is required but was not present")
    }
    return nil
}
