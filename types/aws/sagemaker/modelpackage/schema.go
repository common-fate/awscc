// Code generated by schema-generate. DO NOT EDIT.

package modelpackage

import (
    "encoding/json"
    "fmt"
    "errors"
    "bytes"
)

// AdditionalInferenceSpecificationDefinition Additional Inference Specification specifies details about inference jobs that can be run with models based on this model package.AdditionalInferenceSpecifications can be added to existing model packages using AdditionalInferenceSpecificationsToAdd.
type AdditionalInferenceSpecificationDefinition struct {

  // The Amazon ECR registry path of the Docker image that contains the inference code.
  Containers []*ModelPackageContainerDefinition `json:"Containers"`

  // A description of the additional Inference specification.
  Description string `json:"Description,omitempty"`

  // A unique name to identify the additional inference specification. The name must be unique within the list of your additional inference specifications for a particular model package.
  Name string `json:"Name"`

  // The supported MIME types for the input data.
  SupportedContentTypes []string `json:"SupportedContentTypes,omitempty"`

  // A list of the instance types that are used to generate inferences in real-time
  SupportedRealtimeInferenceInstanceTypes []string `json:"SupportedRealtimeInferenceInstanceTypes,omitempty"`

  // The supported MIME types for the output data.
  SupportedResponseMIMETypes []string `json:"SupportedResponseMIMETypes,omitempty"`

  // A list of the instance types on which a transformation job can be run or on which an endpoint can be deployed.
  SupportedTransformInstanceTypes []string `json:"SupportedTransformInstanceTypes,omitempty"`
}

// Bias Contains bias metrics for a model.
type Bias struct {
  PostTrainingReport *MetricsSource `json:"PostTrainingReport,omitempty"`
  PreTrainingReport *MetricsSource `json:"PreTrainingReport,omitempty"`
  Report *MetricsSource `json:"Report,omitempty"`
}

// CustomerMetadataProperties The metadata properties associated with the model package versions.
type CustomerMetadataProperties struct {
}

// DataSource Describes the input source of a transform job and the way the transform job consumes it.
type DataSource struct {
  S3DataSource *S3DataSource `json:"S3DataSource"`
}

// DriftCheckBaselines Represents the drift check baselines that can be used when the model monitor is set using the model package.
type DriftCheckBaselines struct {
  Bias *DriftCheckBias `json:"Bias,omitempty"`
  Explainability *DriftCheckExplainability `json:"Explainability,omitempty"`
  ModelDataQuality *DriftCheckModelDataQuality `json:"ModelDataQuality,omitempty"`
  ModelQuality *DriftCheckModelQuality `json:"ModelQuality,omitempty"`
}

// DriftCheckBias Represents the drift check bias baselines that can be used when the model monitor is set using the model package.
type DriftCheckBias struct {
  ConfigFile *FileSource `json:"ConfigFile,omitempty"`
  PostTrainingConstraints *MetricsSource `json:"PostTrainingConstraints,omitempty"`
  PreTrainingConstraints *MetricsSource `json:"PreTrainingConstraints,omitempty"`
}

// DriftCheckExplainability Contains explainability metrics for a model.
type DriftCheckExplainability struct {
  ConfigFile *FileSource `json:"ConfigFile,omitempty"`
  Constraints *MetricsSource `json:"Constraints,omitempty"`
}

// DriftCheckModelDataQuality Represents the drift check data quality baselines that can be used when the model monitor is set using the model package.
type DriftCheckModelDataQuality struct {
  Constraints *MetricsSource `json:"Constraints,omitempty"`
  Statistics *MetricsSource `json:"Statistics,omitempty"`
}

// DriftCheckModelQuality Represents the drift check model quality baselines that can be used when the model monitor is set using the model package.
type DriftCheckModelQuality struct {
  Constraints *MetricsSource `json:"Constraints,omitempty"`
  Statistics *MetricsSource `json:"Statistics,omitempty"`
}

// Environment Sets the environment variables in the Docker container
type Environment struct {
}

// Explainability Contains explainability metrics for a model.
type Explainability struct {
  Report *MetricsSource `json:"Report,omitempty"`
}

// FileSource Represents a File Source Object.
type FileSource struct {

  // The digest of the file source.
  ContentDigest string `json:"ContentDigest,omitempty"`

  // The type of content stored in the file source.
  ContentType string `json:"ContentType,omitempty"`

  // The Amazon S3 URI for the file source.
  S3Uri string `json:"S3Uri"`
}

// InferenceSpecification Details about inference jobs that can be run with models based on this model package.
type InferenceSpecification struct {

  // The Amazon ECR registry path of the Docker image that contains the inference code.
  Containers []*ModelPackageContainerDefinition `json:"Containers"`

  // The supported MIME types for the input data.
  SupportedContentTypes []string `json:"SupportedContentTypes"`

  // A list of the instance types that are used to generate inferences in real-time
  SupportedRealtimeInferenceInstanceTypes []string `json:"SupportedRealtimeInferenceInstanceTypes,omitempty"`

  // The supported MIME types for the output data.
  SupportedResponseMIMETypes []string `json:"SupportedResponseMIMETypes"`

  // A list of the instance types on which a transformation job can be run or on which an endpoint can be deployed.
  SupportedTransformInstanceTypes []string `json:"SupportedTransformInstanceTypes,omitempty"`
}

// MetadataProperties Metadata properties of the tracking entity, trial, or trial component.
type MetadataProperties struct {

  // The commit ID.
  CommitId string `json:"CommitId,omitempty"`

  // The entity this entity was generated by.
  GeneratedBy string `json:"GeneratedBy,omitempty"`

  // The project ID metadata.
  ProjectId string `json:"ProjectId,omitempty"`

  // The repository metadata.
  Repository string `json:"Repository,omitempty"`
}

// MetricsSource Represents a Metric Source Object.
type MetricsSource struct {

  // The digest of the metric source.
  ContentDigest string `json:"ContentDigest,omitempty"`

  // The type of content stored in the metric source.
  ContentType string `json:"ContentType"`

  // The Amazon S3 URI for the metric source.
  S3Uri string `json:"S3Uri"`
}

// ModelDataQuality Metrics that measure the quality of the input data for a model.
type ModelDataQuality struct {
  Constraints *MetricsSource `json:"Constraints,omitempty"`
  Statistics *MetricsSource `json:"Statistics,omitempty"`
}

// ModelInput 
type ModelInput struct {

  // The input configuration object for the model.
  DataInputConfig string `json:"DataInputConfig"`
}

// ModelMetrics A structure that contains model metrics reports.
type ModelMetrics struct {
  Bias *Bias `json:"Bias,omitempty"`
  Explainability *Explainability `json:"Explainability,omitempty"`
  ModelDataQuality *ModelDataQuality `json:"ModelDataQuality,omitempty"`
  ModelQuality *ModelQuality `json:"ModelQuality,omitempty"`
}

// ModelPackageContainerDefinition Describes the Docker container for the model package.
type ModelPackageContainerDefinition struct {

  // The DNS host name for the Docker container.
  ContainerHostname string `json:"ContainerHostname,omitempty"`
  Environment *Environment `json:"Environment,omitempty"`

  // The machine learning framework of the model package container image.
  Framework string `json:"Framework,omitempty"`

  // The framework version of the Model Package Container Image.
  FrameworkVersion string `json:"FrameworkVersion,omitempty"`

  // The Amazon EC2 Container Registry (Amazon ECR) path where inference code is stored.
  Image string `json:"Image"`

  // An MD5 hash of the training algorithm that identifies the Docker image used for training.
  ImageDigest string `json:"ImageDigest,omitempty"`

  // A structure with Model Input details.
  ModelDataUrl string `json:"ModelDataUrl,omitempty"`
  ModelInput *ModelInput `json:"ModelInput,omitempty"`

  // The name of a pre-trained machine learning benchmarked by Amazon SageMaker Inference Recommender model that matches your model.
  NearestModelName string `json:"NearestModelName,omitempty"`

  // The AWS Marketplace product ID of the model package.
  ProductId string `json:"ProductId,omitempty"`
}

// ModelPackageStatusDetails Details about the current status of the model package.
type ModelPackageStatusDetails struct {
  ImageScanStatuses []*ModelPackageStatusItem `json:"ImageScanStatuses,omitempty"`
  ValidationStatuses []*ModelPackageStatusItem `json:"ValidationStatuses"`
}

// ModelPackageStatusItem Represents the overall status of a model package.
type ModelPackageStatusItem struct {

  // If the overall status is Failed, the reason for the failure.
  FailureReason string `json:"FailureReason,omitempty"`

  // The name of the model package for which the overall status is being reported.
  Name string `json:"Name"`

  // The current status.
  Status string `json:"Status"`
}

// ModelQuality Metrics that measure the quality of a model.
type ModelQuality struct {
  Constraints *MetricsSource `json:"Constraints,omitempty"`
  Statistics *MetricsSource `json:"Statistics,omitempty"`
}

// Resource Resource Type definition for AWS::SageMaker::ModelPackage
type Resource struct {
  AdditionalInferenceSpecificationDefinition *AdditionalInferenceSpecificationDefinition `json:"AdditionalInferenceSpecificationDefinition,omitempty"`
  AdditionalInferenceSpecifications []*AdditionalInferenceSpecificationDefinition `json:"AdditionalInferenceSpecifications,omitempty"`
  AdditionalInferenceSpecificationsToAdd []*AdditionalInferenceSpecificationDefinition `json:"AdditionalInferenceSpecificationsToAdd,omitempty"`
  ApprovalDescription string `json:"ApprovalDescription,omitempty"`
  CertifyForMarketplace bool `json:"CertifyForMarketplace,omitempty"`
  ClientToken string `json:"ClientToken,omitempty"`
  CreatedBy *UserContext `json:"CreatedBy,omitempty"`
  CreationTime string `json:"CreationTime,omitempty"`
  CustomerMetadataProperties *CustomerMetadataProperties `json:"CustomerMetadataProperties,omitempty"`
  Domain string `json:"Domain,omitempty"`
  DriftCheckBaselines *DriftCheckBaselines `json:"DriftCheckBaselines,omitempty"`
  Environment *Environment `json:"Environment,omitempty"`
  InferenceSpecification *InferenceSpecification `json:"InferenceSpecification,omitempty"`
  LastModifiedBy *UserContext `json:"LastModifiedBy,omitempty"`
  LastModifiedTime string `json:"LastModifiedTime,omitempty"`
  MetadataProperties *MetadataProperties `json:"MetadataProperties,omitempty"`
  ModelApprovalStatus string `json:"ModelApprovalStatus,omitempty"`
  ModelMetrics *ModelMetrics `json:"ModelMetrics,omitempty"`
  ModelPackageArn string `json:"ModelPackageArn,omitempty"`
  ModelPackageDescription string `json:"ModelPackageDescription,omitempty"`
  ModelPackageGroupName string `json:"ModelPackageGroupName,omitempty"`
  ModelPackageName string `json:"ModelPackageName,omitempty"`
  ModelPackageStatus string `json:"ModelPackageStatus,omitempty"`
  ModelPackageStatusDetails *ModelPackageStatusDetails `json:"ModelPackageStatusDetails,omitempty"`
  ModelPackageStatusItem *ModelPackageStatusItem `json:"ModelPackageStatusItem,omitempty"`
  ModelPackageVersion int `json:"ModelPackageVersion,omitempty"`
  SamplePayloadUrl string `json:"SamplePayloadUrl,omitempty"`
  SourceAlgorithmSpecification *SourceAlgorithmSpecification `json:"SourceAlgorithmSpecification,omitempty"`

  // An array of key-value pairs to apply to this resource.
  Tags []*Tag `json:"Tags,omitempty"`
  Task string `json:"Task,omitempty"`
  ValidationSpecification *ValidationSpecification `json:"ValidationSpecification,omitempty"`
}

// S3DataSource Describes the S3 data source.
type S3DataSource struct {

  // The S3 Data Source Type
  S3DataType string `json:"S3DataType"`

  // Depending on the value specified for the S3DataType, identifies either a key name prefix or a manifest.
  S3Uri string `json:"S3Uri"`
}

// SourceAlgorithm Specifies an algorithm that was used to create the model package. The algorithm must be either an algorithm resource in your Amazon SageMaker account or an algorithm in AWS Marketplace that you are subscribed to.
type SourceAlgorithm struct {

  // The name of an algorithm that was used to create the model package. The algorithm must be either an algorithm resource in your Amazon SageMaker account or an algorithm in AWS Marketplace that you are subscribed to.
  AlgorithmName string `json:"AlgorithmName"`

  // The Amazon S3 path where the model artifacts, which result from model training, are stored. This path must point to a single gzip compressed tar archive (.tar.gz suffix).
  ModelDataUrl string `json:"ModelDataUrl,omitempty"`
}

// SourceAlgorithmSpecification Details about the algorithm that was used to create the model package.
type SourceAlgorithmSpecification struct {

  // A list of algorithms that were used to create a model package.
  SourceAlgorithms []*SourceAlgorithm `json:"SourceAlgorithms"`
}

// Tag A key-value pair to associate with a resource.
type Tag struct {

  // The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
  Key string `json:"Key"`

  // The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
  Value string `json:"Value"`
}

// TransformInput Describes the input source of a transform job and the way the transform job consumes it.
type TransformInput struct {

  // If your transform data is compressed, specify the compression type. Amazon SageMaker automatically decompresses the data for the transform job accordingly. The default value is None.
  CompressionType string `json:"CompressionType,omitempty"`

  // The multipurpose internet mail extension (MIME) type of the data. Amazon SageMaker uses the MIME type with each http call to transfer data to the transform job.
  ContentType string `json:"ContentType,omitempty"`
  DataSource *DataSource `json:"DataSource"`

  // The method to use to split the transform job's data files into smaller batches. 
  SplitType string `json:"SplitType,omitempty"`
}

// TransformJobDefinition Defines the input needed to run a transform job using the inference specification specified in the algorithm.
type TransformJobDefinition struct {

  // A string that determines the number of records included in a single mini-batch.
  BatchStrategy string `json:"BatchStrategy,omitempty"`
  Environment *Environment `json:"Environment,omitempty"`

  // The maximum number of parallel requests that can be sent to each instance in a transform job. The default value is 1.
  MaxConcurrentTransforms int `json:"MaxConcurrentTransforms,omitempty"`

  // The maximum payload size allowed, in MB. A payload is the data portion of a record (without metadata).
  MaxPayloadInMB int `json:"MaxPayloadInMB,omitempty"`
  TransformInput *TransformInput `json:"TransformInput"`
  TransformOutput *TransformOutput `json:"TransformOutput"`
  TransformResources *TransformResources `json:"TransformResources"`
}

// TransformOutput Describes the results of a transform job.
type TransformOutput struct {

  // The MIME type used to specify the output data. Amazon SageMaker uses the MIME type with each http call to transfer data from the transform job.
  Accept string `json:"Accept,omitempty"`

  // Defines how to assemble the results of the transform job as a single S3 object.
  AssembleWith string `json:"AssembleWith,omitempty"`

  // The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption.
  KmsKeyId string `json:"KmsKeyId,omitempty"`

  // The Amazon S3 path where you want Amazon SageMaker to store the results of the transform job.
  S3OutputPath string `json:"S3OutputPath"`
}

// TransformResources Describes the resources, including ML instance types and ML instance count, to use for transform job.
type TransformResources struct {

  // The number of ML compute instances to use in the transform job. For distributed transform jobs, specify a value greater than 1. The default value is 1.
  InstanceCount int `json:"InstanceCount"`

  // The ML compute instance type for the transform job.
  InstanceType string `json:"InstanceType"`

  // The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt model data on the storage volume attached to the ML compute instance(s) that run the batch transform job.
  VolumeKmsKeyId string `json:"VolumeKmsKeyId,omitempty"`
}

// UserContext Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.
type UserContext struct {

  // The domain associated with the user.
  DomainId string `json:"DomainId,omitempty"`

  // The Amazon Resource Name (ARN) of the user's profile.
  UserProfileArn string `json:"UserProfileArn,omitempty"`

  // The name of the user's profile.
  UserProfileName string `json:"UserProfileName,omitempty"`
}

// ValidationProfile Contains data, such as the inputs and targeted instance types that are used in the process of validating the model package.
type ValidationProfile struct {

  // The name of the profile for the model package.
  ProfileName string `json:"ProfileName"`
  TransformJobDefinition *TransformJobDefinition `json:"TransformJobDefinition"`
}

// ValidationSpecification Specifies configurations for one or more transform jobs that Amazon SageMaker runs to test the model package.
type ValidationSpecification struct {
  ValidationProfiles []*ValidationProfile `json:"ValidationProfiles"`

  // The IAM roles to be used for the validation of the model package.
  ValidationRole string `json:"ValidationRole"`
}

func (strct *AdditionalInferenceSpecificationDefinition) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Containers" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Containers" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Containers\": ")
	if tmp, err := json.Marshal(strct.Containers); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SupportedContentTypes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SupportedContentTypes\": ")
	if tmp, err := json.Marshal(strct.SupportedContentTypes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SupportedRealtimeInferenceInstanceTypes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SupportedRealtimeInferenceInstanceTypes\": ")
	if tmp, err := json.Marshal(strct.SupportedRealtimeInferenceInstanceTypes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SupportedResponseMIMETypes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SupportedResponseMIMETypes\": ")
	if tmp, err := json.Marshal(strct.SupportedResponseMIMETypes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SupportedTransformInstanceTypes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SupportedTransformInstanceTypes\": ")
	if tmp, err := json.Marshal(strct.SupportedTransformInstanceTypes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AdditionalInferenceSpecificationDefinition) UnmarshalJSON(b []byte) error {
    ContainersReceived := false
    NameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Containers":
            if err := json.Unmarshal([]byte(v), &strct.Containers); err != nil {
                return err
             }
            ContainersReceived = true
        case "Description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        case "SupportedContentTypes":
            if err := json.Unmarshal([]byte(v), &strct.SupportedContentTypes); err != nil {
                return err
             }
        case "SupportedRealtimeInferenceInstanceTypes":
            if err := json.Unmarshal([]byte(v), &strct.SupportedRealtimeInferenceInstanceTypes); err != nil {
                return err
             }
        case "SupportedResponseMIMETypes":
            if err := json.Unmarshal([]byte(v), &strct.SupportedResponseMIMETypes); err != nil {
                return err
             }
        case "SupportedTransformInstanceTypes":
            if err := json.Unmarshal([]byte(v), &strct.SupportedTransformInstanceTypes); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Containers (a required property) was received
    if !ContainersReceived {
        return errors.New("\"Containers\" is required but was not present")
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    return nil
}

func (strct *Bias) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "PostTrainingReport" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PostTrainingReport\": ")
	if tmp, err := json.Marshal(strct.PostTrainingReport); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PreTrainingReport" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PreTrainingReport\": ")
	if tmp, err := json.Marshal(strct.PreTrainingReport); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Report" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Report\": ")
	if tmp, err := json.Marshal(strct.Report); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Bias) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "PostTrainingReport":
            if err := json.Unmarshal([]byte(v), &strct.PostTrainingReport); err != nil {
                return err
             }
        case "PreTrainingReport":
            if err := json.Unmarshal([]byte(v), &strct.PreTrainingReport); err != nil {
                return err
             }
        case "Report":
            if err := json.Unmarshal([]byte(v), &strct.Report); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *CustomerMetadataProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CustomerMetadataProperties) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *DataSource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "S3DataSource" field is required
    if strct.S3DataSource == nil {
        return nil, errors.New("S3DataSource is a required field")
    }
    // Marshal the "S3DataSource" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3DataSource\": ")
	if tmp, err := json.Marshal(strct.S3DataSource); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DataSource) UnmarshalJSON(b []byte) error {
    S3DataSourceReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "S3DataSource":
            if err := json.Unmarshal([]byte(v), &strct.S3DataSource); err != nil {
                return err
             }
            S3DataSourceReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if S3DataSource (a required property) was received
    if !S3DataSourceReceived {
        return errors.New("\"S3DataSource\" is required but was not present")
    }
    return nil
}

func (strct *DriftCheckBaselines) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Bias" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Bias\": ")
	if tmp, err := json.Marshal(strct.Bias); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Explainability" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Explainability\": ")
	if tmp, err := json.Marshal(strct.Explainability); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ModelDataQuality" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ModelDataQuality\": ")
	if tmp, err := json.Marshal(strct.ModelDataQuality); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ModelQuality" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ModelQuality\": ")
	if tmp, err := json.Marshal(strct.ModelQuality); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DriftCheckBaselines) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Bias":
            if err := json.Unmarshal([]byte(v), &strct.Bias); err != nil {
                return err
             }
        case "Explainability":
            if err := json.Unmarshal([]byte(v), &strct.Explainability); err != nil {
                return err
             }
        case "ModelDataQuality":
            if err := json.Unmarshal([]byte(v), &strct.ModelDataQuality); err != nil {
                return err
             }
        case "ModelQuality":
            if err := json.Unmarshal([]byte(v), &strct.ModelQuality); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *DriftCheckBias) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ConfigFile" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConfigFile\": ")
	if tmp, err := json.Marshal(strct.ConfigFile); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PostTrainingConstraints" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PostTrainingConstraints\": ")
	if tmp, err := json.Marshal(strct.PostTrainingConstraints); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PreTrainingConstraints" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PreTrainingConstraints\": ")
	if tmp, err := json.Marshal(strct.PreTrainingConstraints); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DriftCheckBias) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ConfigFile":
            if err := json.Unmarshal([]byte(v), &strct.ConfigFile); err != nil {
                return err
             }
        case "PostTrainingConstraints":
            if err := json.Unmarshal([]byte(v), &strct.PostTrainingConstraints); err != nil {
                return err
             }
        case "PreTrainingConstraints":
            if err := json.Unmarshal([]byte(v), &strct.PreTrainingConstraints); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *DriftCheckExplainability) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ConfigFile" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConfigFile\": ")
	if tmp, err := json.Marshal(strct.ConfigFile); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Constraints" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Constraints\": ")
	if tmp, err := json.Marshal(strct.Constraints); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DriftCheckExplainability) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ConfigFile":
            if err := json.Unmarshal([]byte(v), &strct.ConfigFile); err != nil {
                return err
             }
        case "Constraints":
            if err := json.Unmarshal([]byte(v), &strct.Constraints); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *DriftCheckModelDataQuality) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Constraints" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Constraints\": ")
	if tmp, err := json.Marshal(strct.Constraints); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Statistics" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Statistics\": ")
	if tmp, err := json.Marshal(strct.Statistics); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DriftCheckModelDataQuality) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Constraints":
            if err := json.Unmarshal([]byte(v), &strct.Constraints); err != nil {
                return err
             }
        case "Statistics":
            if err := json.Unmarshal([]byte(v), &strct.Statistics); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *DriftCheckModelQuality) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Constraints" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Constraints\": ")
	if tmp, err := json.Marshal(strct.Constraints); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Statistics" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Statistics\": ")
	if tmp, err := json.Marshal(strct.Statistics); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DriftCheckModelQuality) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Constraints":
            if err := json.Unmarshal([]byte(v), &strct.Constraints); err != nil {
                return err
             }
        case "Statistics":
            if err := json.Unmarshal([]byte(v), &strct.Statistics); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Environment) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Environment) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Explainability) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Report" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Report\": ")
	if tmp, err := json.Marshal(strct.Report); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Explainability) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Report":
            if err := json.Unmarshal([]byte(v), &strct.Report); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *FileSource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ContentDigest" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ContentDigest\": ")
	if tmp, err := json.Marshal(strct.ContentDigest); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ContentType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ContentType\": ")
	if tmp, err := json.Marshal(strct.ContentType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "S3Uri" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "S3Uri" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3Uri\": ")
	if tmp, err := json.Marshal(strct.S3Uri); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FileSource) UnmarshalJSON(b []byte) error {
    S3UriReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ContentDigest":
            if err := json.Unmarshal([]byte(v), &strct.ContentDigest); err != nil {
                return err
             }
        case "ContentType":
            if err := json.Unmarshal([]byte(v), &strct.ContentType); err != nil {
                return err
             }
        case "S3Uri":
            if err := json.Unmarshal([]byte(v), &strct.S3Uri); err != nil {
                return err
             }
            S3UriReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if S3Uri (a required property) was received
    if !S3UriReceived {
        return errors.New("\"S3Uri\" is required but was not present")
    }
    return nil
}

func (strct *InferenceSpecification) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Containers" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Containers" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Containers\": ")
	if tmp, err := json.Marshal(strct.Containers); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "SupportedContentTypes" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "SupportedContentTypes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SupportedContentTypes\": ")
	if tmp, err := json.Marshal(strct.SupportedContentTypes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SupportedRealtimeInferenceInstanceTypes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SupportedRealtimeInferenceInstanceTypes\": ")
	if tmp, err := json.Marshal(strct.SupportedRealtimeInferenceInstanceTypes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "SupportedResponseMIMETypes" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "SupportedResponseMIMETypes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SupportedResponseMIMETypes\": ")
	if tmp, err := json.Marshal(strct.SupportedResponseMIMETypes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SupportedTransformInstanceTypes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SupportedTransformInstanceTypes\": ")
	if tmp, err := json.Marshal(strct.SupportedTransformInstanceTypes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *InferenceSpecification) UnmarshalJSON(b []byte) error {
    ContainersReceived := false
    SupportedContentTypesReceived := false
    SupportedResponseMIMETypesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Containers":
            if err := json.Unmarshal([]byte(v), &strct.Containers); err != nil {
                return err
             }
            ContainersReceived = true
        case "SupportedContentTypes":
            if err := json.Unmarshal([]byte(v), &strct.SupportedContentTypes); err != nil {
                return err
             }
            SupportedContentTypesReceived = true
        case "SupportedRealtimeInferenceInstanceTypes":
            if err := json.Unmarshal([]byte(v), &strct.SupportedRealtimeInferenceInstanceTypes); err != nil {
                return err
             }
        case "SupportedResponseMIMETypes":
            if err := json.Unmarshal([]byte(v), &strct.SupportedResponseMIMETypes); err != nil {
                return err
             }
            SupportedResponseMIMETypesReceived = true
        case "SupportedTransformInstanceTypes":
            if err := json.Unmarshal([]byte(v), &strct.SupportedTransformInstanceTypes); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Containers (a required property) was received
    if !ContainersReceived {
        return errors.New("\"Containers\" is required but was not present")
    }
    // check if SupportedContentTypes (a required property) was received
    if !SupportedContentTypesReceived {
        return errors.New("\"SupportedContentTypes\" is required but was not present")
    }
    // check if SupportedResponseMIMETypes (a required property) was received
    if !SupportedResponseMIMETypesReceived {
        return errors.New("\"SupportedResponseMIMETypes\" is required but was not present")
    }
    return nil
}

func (strct *MetadataProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CommitId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CommitId\": ")
	if tmp, err := json.Marshal(strct.CommitId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "GeneratedBy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"GeneratedBy\": ")
	if tmp, err := json.Marshal(strct.GeneratedBy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ProjectId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ProjectId\": ")
	if tmp, err := json.Marshal(strct.ProjectId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Repository" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Repository\": ")
	if tmp, err := json.Marshal(strct.Repository); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MetadataProperties) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CommitId":
            if err := json.Unmarshal([]byte(v), &strct.CommitId); err != nil {
                return err
             }
        case "GeneratedBy":
            if err := json.Unmarshal([]byte(v), &strct.GeneratedBy); err != nil {
                return err
             }
        case "ProjectId":
            if err := json.Unmarshal([]byte(v), &strct.ProjectId); err != nil {
                return err
             }
        case "Repository":
            if err := json.Unmarshal([]byte(v), &strct.Repository); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *MetricsSource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ContentDigest" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ContentDigest\": ")
	if tmp, err := json.Marshal(strct.ContentDigest); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ContentType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ContentType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ContentType\": ")
	if tmp, err := json.Marshal(strct.ContentType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "S3Uri" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "S3Uri" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3Uri\": ")
	if tmp, err := json.Marshal(strct.S3Uri); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MetricsSource) UnmarshalJSON(b []byte) error {
    ContentTypeReceived := false
    S3UriReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ContentDigest":
            if err := json.Unmarshal([]byte(v), &strct.ContentDigest); err != nil {
                return err
             }
        case "ContentType":
            if err := json.Unmarshal([]byte(v), &strct.ContentType); err != nil {
                return err
             }
            ContentTypeReceived = true
        case "S3Uri":
            if err := json.Unmarshal([]byte(v), &strct.S3Uri); err != nil {
                return err
             }
            S3UriReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ContentType (a required property) was received
    if !ContentTypeReceived {
        return errors.New("\"ContentType\" is required but was not present")
    }
    // check if S3Uri (a required property) was received
    if !S3UriReceived {
        return errors.New("\"S3Uri\" is required but was not present")
    }
    return nil
}

func (strct *ModelDataQuality) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Constraints" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Constraints\": ")
	if tmp, err := json.Marshal(strct.Constraints); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Statistics" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Statistics\": ")
	if tmp, err := json.Marshal(strct.Statistics); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ModelDataQuality) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Constraints":
            if err := json.Unmarshal([]byte(v), &strct.Constraints); err != nil {
                return err
             }
        case "Statistics":
            if err := json.Unmarshal([]byte(v), &strct.Statistics); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ModelInput) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "DataInputConfig" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "DataInputConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DataInputConfig\": ")
	if tmp, err := json.Marshal(strct.DataInputConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ModelInput) UnmarshalJSON(b []byte) error {
    DataInputConfigReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DataInputConfig":
            if err := json.Unmarshal([]byte(v), &strct.DataInputConfig); err != nil {
                return err
             }
            DataInputConfigReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if DataInputConfig (a required property) was received
    if !DataInputConfigReceived {
        return errors.New("\"DataInputConfig\" is required but was not present")
    }
    return nil
}

func (strct *ModelMetrics) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Bias" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Bias\": ")
	if tmp, err := json.Marshal(strct.Bias); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Explainability" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Explainability\": ")
	if tmp, err := json.Marshal(strct.Explainability); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ModelDataQuality" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ModelDataQuality\": ")
	if tmp, err := json.Marshal(strct.ModelDataQuality); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ModelQuality" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ModelQuality\": ")
	if tmp, err := json.Marshal(strct.ModelQuality); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ModelMetrics) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Bias":
            if err := json.Unmarshal([]byte(v), &strct.Bias); err != nil {
                return err
             }
        case "Explainability":
            if err := json.Unmarshal([]byte(v), &strct.Explainability); err != nil {
                return err
             }
        case "ModelDataQuality":
            if err := json.Unmarshal([]byte(v), &strct.ModelDataQuality); err != nil {
                return err
             }
        case "ModelQuality":
            if err := json.Unmarshal([]byte(v), &strct.ModelQuality); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ModelPackageContainerDefinition) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ContainerHostname" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ContainerHostname\": ")
	if tmp, err := json.Marshal(strct.ContainerHostname); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Environment" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Environment\": ")
	if tmp, err := json.Marshal(strct.Environment); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Framework" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Framework\": ")
	if tmp, err := json.Marshal(strct.Framework); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FrameworkVersion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FrameworkVersion\": ")
	if tmp, err := json.Marshal(strct.FrameworkVersion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Image" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Image" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Image\": ")
	if tmp, err := json.Marshal(strct.Image); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ImageDigest" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ImageDigest\": ")
	if tmp, err := json.Marshal(strct.ImageDigest); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ModelDataUrl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ModelDataUrl\": ")
	if tmp, err := json.Marshal(strct.ModelDataUrl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ModelInput" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ModelInput\": ")
	if tmp, err := json.Marshal(strct.ModelInput); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "NearestModelName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NearestModelName\": ")
	if tmp, err := json.Marshal(strct.NearestModelName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ProductId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ProductId\": ")
	if tmp, err := json.Marshal(strct.ProductId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ModelPackageContainerDefinition) UnmarshalJSON(b []byte) error {
    ImageReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ContainerHostname":
            if err := json.Unmarshal([]byte(v), &strct.ContainerHostname); err != nil {
                return err
             }
        case "Environment":
            if err := json.Unmarshal([]byte(v), &strct.Environment); err != nil {
                return err
             }
        case "Framework":
            if err := json.Unmarshal([]byte(v), &strct.Framework); err != nil {
                return err
             }
        case "FrameworkVersion":
            if err := json.Unmarshal([]byte(v), &strct.FrameworkVersion); err != nil {
                return err
             }
        case "Image":
            if err := json.Unmarshal([]byte(v), &strct.Image); err != nil {
                return err
             }
            ImageReceived = true
        case "ImageDigest":
            if err := json.Unmarshal([]byte(v), &strct.ImageDigest); err != nil {
                return err
             }
        case "ModelDataUrl":
            if err := json.Unmarshal([]byte(v), &strct.ModelDataUrl); err != nil {
                return err
             }
        case "ModelInput":
            if err := json.Unmarshal([]byte(v), &strct.ModelInput); err != nil {
                return err
             }
        case "NearestModelName":
            if err := json.Unmarshal([]byte(v), &strct.NearestModelName); err != nil {
                return err
             }
        case "ProductId":
            if err := json.Unmarshal([]byte(v), &strct.ProductId); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Image (a required property) was received
    if !ImageReceived {
        return errors.New("\"Image\" is required but was not present")
    }
    return nil
}

func (strct *ModelPackageStatusDetails) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ImageScanStatuses" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ImageScanStatuses\": ")
	if tmp, err := json.Marshal(strct.ImageScanStatuses); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ValidationStatuses" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ValidationStatuses" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ValidationStatuses\": ")
	if tmp, err := json.Marshal(strct.ValidationStatuses); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ModelPackageStatusDetails) UnmarshalJSON(b []byte) error {
    ValidationStatusesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ImageScanStatuses":
            if err := json.Unmarshal([]byte(v), &strct.ImageScanStatuses); err != nil {
                return err
             }
        case "ValidationStatuses":
            if err := json.Unmarshal([]byte(v), &strct.ValidationStatuses); err != nil {
                return err
             }
            ValidationStatusesReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ValidationStatuses (a required property) was received
    if !ValidationStatusesReceived {
        return errors.New("\"ValidationStatuses\" is required but was not present")
    }
    return nil
}

func (strct *ModelPackageStatusItem) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "FailureReason" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FailureReason\": ")
	if tmp, err := json.Marshal(strct.FailureReason); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Status" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Status" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Status\": ")
	if tmp, err := json.Marshal(strct.Status); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ModelPackageStatusItem) UnmarshalJSON(b []byte) error {
    NameReceived := false
    StatusReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "FailureReason":
            if err := json.Unmarshal([]byte(v), &strct.FailureReason); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        case "Status":
            if err := json.Unmarshal([]byte(v), &strct.Status); err != nil {
                return err
             }
            StatusReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    // check if Status (a required property) was received
    if !StatusReceived {
        return errors.New("\"Status\" is required but was not present")
    }
    return nil
}

func (strct *ModelQuality) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Constraints" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Constraints\": ")
	if tmp, err := json.Marshal(strct.Constraints); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Statistics" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Statistics\": ")
	if tmp, err := json.Marshal(strct.Statistics); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ModelQuality) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Constraints":
            if err := json.Unmarshal([]byte(v), &strct.Constraints); err != nil {
                return err
             }
        case "Statistics":
            if err := json.Unmarshal([]byte(v), &strct.Statistics); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AdditionalInferenceSpecificationDefinition" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AdditionalInferenceSpecificationDefinition\": ")
	if tmp, err := json.Marshal(strct.AdditionalInferenceSpecificationDefinition); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AdditionalInferenceSpecifications" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AdditionalInferenceSpecifications\": ")
	if tmp, err := json.Marshal(strct.AdditionalInferenceSpecifications); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AdditionalInferenceSpecificationsToAdd" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AdditionalInferenceSpecificationsToAdd\": ")
	if tmp, err := json.Marshal(strct.AdditionalInferenceSpecificationsToAdd); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ApprovalDescription" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ApprovalDescription\": ")
	if tmp, err := json.Marshal(strct.ApprovalDescription); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CertifyForMarketplace" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CertifyForMarketplace\": ")
	if tmp, err := json.Marshal(strct.CertifyForMarketplace); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ClientToken" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ClientToken\": ")
	if tmp, err := json.Marshal(strct.ClientToken); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CreatedBy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CreatedBy\": ")
	if tmp, err := json.Marshal(strct.CreatedBy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CreationTime" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CreationTime\": ")
	if tmp, err := json.Marshal(strct.CreationTime); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CustomerMetadataProperties" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CustomerMetadataProperties\": ")
	if tmp, err := json.Marshal(strct.CustomerMetadataProperties); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Domain" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Domain\": ")
	if tmp, err := json.Marshal(strct.Domain); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DriftCheckBaselines" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DriftCheckBaselines\": ")
	if tmp, err := json.Marshal(strct.DriftCheckBaselines); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Environment" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Environment\": ")
	if tmp, err := json.Marshal(strct.Environment); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "InferenceSpecification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InferenceSpecification\": ")
	if tmp, err := json.Marshal(strct.InferenceSpecification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LastModifiedBy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LastModifiedBy\": ")
	if tmp, err := json.Marshal(strct.LastModifiedBy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LastModifiedTime" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LastModifiedTime\": ")
	if tmp, err := json.Marshal(strct.LastModifiedTime); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MetadataProperties" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MetadataProperties\": ")
	if tmp, err := json.Marshal(strct.MetadataProperties); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ModelApprovalStatus" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ModelApprovalStatus\": ")
	if tmp, err := json.Marshal(strct.ModelApprovalStatus); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ModelMetrics" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ModelMetrics\": ")
	if tmp, err := json.Marshal(strct.ModelMetrics); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ModelPackageArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ModelPackageArn\": ")
	if tmp, err := json.Marshal(strct.ModelPackageArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ModelPackageDescription" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ModelPackageDescription\": ")
	if tmp, err := json.Marshal(strct.ModelPackageDescription); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ModelPackageGroupName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ModelPackageGroupName\": ")
	if tmp, err := json.Marshal(strct.ModelPackageGroupName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ModelPackageName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ModelPackageName\": ")
	if tmp, err := json.Marshal(strct.ModelPackageName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ModelPackageStatus" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ModelPackageStatus\": ")
	if tmp, err := json.Marshal(strct.ModelPackageStatus); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ModelPackageStatusDetails" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ModelPackageStatusDetails\": ")
	if tmp, err := json.Marshal(strct.ModelPackageStatusDetails); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ModelPackageStatusItem" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ModelPackageStatusItem\": ")
	if tmp, err := json.Marshal(strct.ModelPackageStatusItem); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ModelPackageVersion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ModelPackageVersion\": ")
	if tmp, err := json.Marshal(strct.ModelPackageVersion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SamplePayloadUrl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SamplePayloadUrl\": ")
	if tmp, err := json.Marshal(strct.SamplePayloadUrl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SourceAlgorithmSpecification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SourceAlgorithmSpecification\": ")
	if tmp, err := json.Marshal(strct.SourceAlgorithmSpecification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Task" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Task\": ")
	if tmp, err := json.Marshal(strct.Task); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ValidationSpecification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ValidationSpecification\": ")
	if tmp, err := json.Marshal(strct.ValidationSpecification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AdditionalInferenceSpecificationDefinition":
            if err := json.Unmarshal([]byte(v), &strct.AdditionalInferenceSpecificationDefinition); err != nil {
                return err
             }
        case "AdditionalInferenceSpecifications":
            if err := json.Unmarshal([]byte(v), &strct.AdditionalInferenceSpecifications); err != nil {
                return err
             }
        case "AdditionalInferenceSpecificationsToAdd":
            if err := json.Unmarshal([]byte(v), &strct.AdditionalInferenceSpecificationsToAdd); err != nil {
                return err
             }
        case "ApprovalDescription":
            if err := json.Unmarshal([]byte(v), &strct.ApprovalDescription); err != nil {
                return err
             }
        case "CertifyForMarketplace":
            if err := json.Unmarshal([]byte(v), &strct.CertifyForMarketplace); err != nil {
                return err
             }
        case "ClientToken":
            if err := json.Unmarshal([]byte(v), &strct.ClientToken); err != nil {
                return err
             }
        case "CreatedBy":
            if err := json.Unmarshal([]byte(v), &strct.CreatedBy); err != nil {
                return err
             }
        case "CreationTime":
            if err := json.Unmarshal([]byte(v), &strct.CreationTime); err != nil {
                return err
             }
        case "CustomerMetadataProperties":
            if err := json.Unmarshal([]byte(v), &strct.CustomerMetadataProperties); err != nil {
                return err
             }
        case "Domain":
            if err := json.Unmarshal([]byte(v), &strct.Domain); err != nil {
                return err
             }
        case "DriftCheckBaselines":
            if err := json.Unmarshal([]byte(v), &strct.DriftCheckBaselines); err != nil {
                return err
             }
        case "Environment":
            if err := json.Unmarshal([]byte(v), &strct.Environment); err != nil {
                return err
             }
        case "InferenceSpecification":
            if err := json.Unmarshal([]byte(v), &strct.InferenceSpecification); err != nil {
                return err
             }
        case "LastModifiedBy":
            if err := json.Unmarshal([]byte(v), &strct.LastModifiedBy); err != nil {
                return err
             }
        case "LastModifiedTime":
            if err := json.Unmarshal([]byte(v), &strct.LastModifiedTime); err != nil {
                return err
             }
        case "MetadataProperties":
            if err := json.Unmarshal([]byte(v), &strct.MetadataProperties); err != nil {
                return err
             }
        case "ModelApprovalStatus":
            if err := json.Unmarshal([]byte(v), &strct.ModelApprovalStatus); err != nil {
                return err
             }
        case "ModelMetrics":
            if err := json.Unmarshal([]byte(v), &strct.ModelMetrics); err != nil {
                return err
             }
        case "ModelPackageArn":
            if err := json.Unmarshal([]byte(v), &strct.ModelPackageArn); err != nil {
                return err
             }
        case "ModelPackageDescription":
            if err := json.Unmarshal([]byte(v), &strct.ModelPackageDescription); err != nil {
                return err
             }
        case "ModelPackageGroupName":
            if err := json.Unmarshal([]byte(v), &strct.ModelPackageGroupName); err != nil {
                return err
             }
        case "ModelPackageName":
            if err := json.Unmarshal([]byte(v), &strct.ModelPackageName); err != nil {
                return err
             }
        case "ModelPackageStatus":
            if err := json.Unmarshal([]byte(v), &strct.ModelPackageStatus); err != nil {
                return err
             }
        case "ModelPackageStatusDetails":
            if err := json.Unmarshal([]byte(v), &strct.ModelPackageStatusDetails); err != nil {
                return err
             }
        case "ModelPackageStatusItem":
            if err := json.Unmarshal([]byte(v), &strct.ModelPackageStatusItem); err != nil {
                return err
             }
        case "ModelPackageVersion":
            if err := json.Unmarshal([]byte(v), &strct.ModelPackageVersion); err != nil {
                return err
             }
        case "SamplePayloadUrl":
            if err := json.Unmarshal([]byte(v), &strct.SamplePayloadUrl); err != nil {
                return err
             }
        case "SourceAlgorithmSpecification":
            if err := json.Unmarshal([]byte(v), &strct.SourceAlgorithmSpecification); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        case "Task":
            if err := json.Unmarshal([]byte(v), &strct.Task); err != nil {
                return err
             }
        case "ValidationSpecification":
            if err := json.Unmarshal([]byte(v), &strct.ValidationSpecification); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *S3DataSource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "S3DataType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "S3DataType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3DataType\": ")
	if tmp, err := json.Marshal(strct.S3DataType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "S3Uri" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "S3Uri" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3Uri\": ")
	if tmp, err := json.Marshal(strct.S3Uri); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *S3DataSource) UnmarshalJSON(b []byte) error {
    S3DataTypeReceived := false
    S3UriReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "S3DataType":
            if err := json.Unmarshal([]byte(v), &strct.S3DataType); err != nil {
                return err
             }
            S3DataTypeReceived = true
        case "S3Uri":
            if err := json.Unmarshal([]byte(v), &strct.S3Uri); err != nil {
                return err
             }
            S3UriReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if S3DataType (a required property) was received
    if !S3DataTypeReceived {
        return errors.New("\"S3DataType\" is required but was not present")
    }
    // check if S3Uri (a required property) was received
    if !S3UriReceived {
        return errors.New("\"S3Uri\" is required but was not present")
    }
    return nil
}

func (strct *SourceAlgorithm) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AlgorithmName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AlgorithmName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AlgorithmName\": ")
	if tmp, err := json.Marshal(strct.AlgorithmName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ModelDataUrl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ModelDataUrl\": ")
	if tmp, err := json.Marshal(strct.ModelDataUrl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SourceAlgorithm) UnmarshalJSON(b []byte) error {
    AlgorithmNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AlgorithmName":
            if err := json.Unmarshal([]byte(v), &strct.AlgorithmName); err != nil {
                return err
             }
            AlgorithmNameReceived = true
        case "ModelDataUrl":
            if err := json.Unmarshal([]byte(v), &strct.ModelDataUrl); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if AlgorithmName (a required property) was received
    if !AlgorithmNameReceived {
        return errors.New("\"AlgorithmName\" is required but was not present")
    }
    return nil
}

func (strct *SourceAlgorithmSpecification) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "SourceAlgorithms" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "SourceAlgorithms" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SourceAlgorithms\": ")
	if tmp, err := json.Marshal(strct.SourceAlgorithms); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SourceAlgorithmSpecification) UnmarshalJSON(b []byte) error {
    SourceAlgorithmsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "SourceAlgorithms":
            if err := json.Unmarshal([]byte(v), &strct.SourceAlgorithms); err != nil {
                return err
             }
            SourceAlgorithmsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if SourceAlgorithms (a required property) was received
    if !SourceAlgorithmsReceived {
        return errors.New("\"SourceAlgorithms\" is required but was not present")
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *TransformInput) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CompressionType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CompressionType\": ")
	if tmp, err := json.Marshal(strct.CompressionType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ContentType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ContentType\": ")
	if tmp, err := json.Marshal(strct.ContentType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "DataSource" field is required
    if strct.DataSource == nil {
        return nil, errors.New("DataSource is a required field")
    }
    // Marshal the "DataSource" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DataSource\": ")
	if tmp, err := json.Marshal(strct.DataSource); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SplitType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SplitType\": ")
	if tmp, err := json.Marshal(strct.SplitType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TransformInput) UnmarshalJSON(b []byte) error {
    DataSourceReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CompressionType":
            if err := json.Unmarshal([]byte(v), &strct.CompressionType); err != nil {
                return err
             }
        case "ContentType":
            if err := json.Unmarshal([]byte(v), &strct.ContentType); err != nil {
                return err
             }
        case "DataSource":
            if err := json.Unmarshal([]byte(v), &strct.DataSource); err != nil {
                return err
             }
            DataSourceReceived = true
        case "SplitType":
            if err := json.Unmarshal([]byte(v), &strct.SplitType); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if DataSource (a required property) was received
    if !DataSourceReceived {
        return errors.New("\"DataSource\" is required but was not present")
    }
    return nil
}

func (strct *TransformJobDefinition) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "BatchStrategy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BatchStrategy\": ")
	if tmp, err := json.Marshal(strct.BatchStrategy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Environment" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Environment\": ")
	if tmp, err := json.Marshal(strct.Environment); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MaxConcurrentTransforms" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaxConcurrentTransforms\": ")
	if tmp, err := json.Marshal(strct.MaxConcurrentTransforms); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MaxPayloadInMB" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaxPayloadInMB\": ")
	if tmp, err := json.Marshal(strct.MaxPayloadInMB); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TransformInput" field is required
    if strct.TransformInput == nil {
        return nil, errors.New("TransformInput is a required field")
    }
    // Marshal the "TransformInput" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TransformInput\": ")
	if tmp, err := json.Marshal(strct.TransformInput); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TransformOutput" field is required
    if strct.TransformOutput == nil {
        return nil, errors.New("TransformOutput is a required field")
    }
    // Marshal the "TransformOutput" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TransformOutput\": ")
	if tmp, err := json.Marshal(strct.TransformOutput); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TransformResources" field is required
    if strct.TransformResources == nil {
        return nil, errors.New("TransformResources is a required field")
    }
    // Marshal the "TransformResources" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TransformResources\": ")
	if tmp, err := json.Marshal(strct.TransformResources); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TransformJobDefinition) UnmarshalJSON(b []byte) error {
    TransformInputReceived := false
    TransformOutputReceived := false
    TransformResourcesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BatchStrategy":
            if err := json.Unmarshal([]byte(v), &strct.BatchStrategy); err != nil {
                return err
             }
        case "Environment":
            if err := json.Unmarshal([]byte(v), &strct.Environment); err != nil {
                return err
             }
        case "MaxConcurrentTransforms":
            if err := json.Unmarshal([]byte(v), &strct.MaxConcurrentTransforms); err != nil {
                return err
             }
        case "MaxPayloadInMB":
            if err := json.Unmarshal([]byte(v), &strct.MaxPayloadInMB); err != nil {
                return err
             }
        case "TransformInput":
            if err := json.Unmarshal([]byte(v), &strct.TransformInput); err != nil {
                return err
             }
            TransformInputReceived = true
        case "TransformOutput":
            if err := json.Unmarshal([]byte(v), &strct.TransformOutput); err != nil {
                return err
             }
            TransformOutputReceived = true
        case "TransformResources":
            if err := json.Unmarshal([]byte(v), &strct.TransformResources); err != nil {
                return err
             }
            TransformResourcesReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if TransformInput (a required property) was received
    if !TransformInputReceived {
        return errors.New("\"TransformInput\" is required but was not present")
    }
    // check if TransformOutput (a required property) was received
    if !TransformOutputReceived {
        return errors.New("\"TransformOutput\" is required but was not present")
    }
    // check if TransformResources (a required property) was received
    if !TransformResourcesReceived {
        return errors.New("\"TransformResources\" is required but was not present")
    }
    return nil
}

func (strct *TransformOutput) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Accept" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Accept\": ")
	if tmp, err := json.Marshal(strct.Accept); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AssembleWith" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AssembleWith\": ")
	if tmp, err := json.Marshal(strct.AssembleWith); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "KmsKeyId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KmsKeyId\": ")
	if tmp, err := json.Marshal(strct.KmsKeyId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "S3OutputPath" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "S3OutputPath" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3OutputPath\": ")
	if tmp, err := json.Marshal(strct.S3OutputPath); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TransformOutput) UnmarshalJSON(b []byte) error {
    S3OutputPathReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Accept":
            if err := json.Unmarshal([]byte(v), &strct.Accept); err != nil {
                return err
             }
        case "AssembleWith":
            if err := json.Unmarshal([]byte(v), &strct.AssembleWith); err != nil {
                return err
             }
        case "KmsKeyId":
            if err := json.Unmarshal([]byte(v), &strct.KmsKeyId); err != nil {
                return err
             }
        case "S3OutputPath":
            if err := json.Unmarshal([]byte(v), &strct.S3OutputPath); err != nil {
                return err
             }
            S3OutputPathReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if S3OutputPath (a required property) was received
    if !S3OutputPathReceived {
        return errors.New("\"S3OutputPath\" is required but was not present")
    }
    return nil
}

func (strct *TransformResources) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "InstanceCount" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "InstanceCount" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InstanceCount\": ")
	if tmp, err := json.Marshal(strct.InstanceCount); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "InstanceType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "InstanceType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InstanceType\": ")
	if tmp, err := json.Marshal(strct.InstanceType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VolumeKmsKeyId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VolumeKmsKeyId\": ")
	if tmp, err := json.Marshal(strct.VolumeKmsKeyId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TransformResources) UnmarshalJSON(b []byte) error {
    InstanceCountReceived := false
    InstanceTypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "InstanceCount":
            if err := json.Unmarshal([]byte(v), &strct.InstanceCount); err != nil {
                return err
             }
            InstanceCountReceived = true
        case "InstanceType":
            if err := json.Unmarshal([]byte(v), &strct.InstanceType); err != nil {
                return err
             }
            InstanceTypeReceived = true
        case "VolumeKmsKeyId":
            if err := json.Unmarshal([]byte(v), &strct.VolumeKmsKeyId); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if InstanceCount (a required property) was received
    if !InstanceCountReceived {
        return errors.New("\"InstanceCount\" is required but was not present")
    }
    // check if InstanceType (a required property) was received
    if !InstanceTypeReceived {
        return errors.New("\"InstanceType\" is required but was not present")
    }
    return nil
}

func (strct *UserContext) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DomainId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DomainId\": ")
	if tmp, err := json.Marshal(strct.DomainId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "UserProfileArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UserProfileArn\": ")
	if tmp, err := json.Marshal(strct.UserProfileArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "UserProfileName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UserProfileName\": ")
	if tmp, err := json.Marshal(strct.UserProfileName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *UserContext) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DomainId":
            if err := json.Unmarshal([]byte(v), &strct.DomainId); err != nil {
                return err
             }
        case "UserProfileArn":
            if err := json.Unmarshal([]byte(v), &strct.UserProfileArn); err != nil {
                return err
             }
        case "UserProfileName":
            if err := json.Unmarshal([]byte(v), &strct.UserProfileName); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ValidationProfile) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ProfileName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ProfileName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ProfileName\": ")
	if tmp, err := json.Marshal(strct.ProfileName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TransformJobDefinition" field is required
    if strct.TransformJobDefinition == nil {
        return nil, errors.New("TransformJobDefinition is a required field")
    }
    // Marshal the "TransformJobDefinition" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TransformJobDefinition\": ")
	if tmp, err := json.Marshal(strct.TransformJobDefinition); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ValidationProfile) UnmarshalJSON(b []byte) error {
    ProfileNameReceived := false
    TransformJobDefinitionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ProfileName":
            if err := json.Unmarshal([]byte(v), &strct.ProfileName); err != nil {
                return err
             }
            ProfileNameReceived = true
        case "TransformJobDefinition":
            if err := json.Unmarshal([]byte(v), &strct.TransformJobDefinition); err != nil {
                return err
             }
            TransformJobDefinitionReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ProfileName (a required property) was received
    if !ProfileNameReceived {
        return errors.New("\"ProfileName\" is required but was not present")
    }
    // check if TransformJobDefinition (a required property) was received
    if !TransformJobDefinitionReceived {
        return errors.New("\"TransformJobDefinition\" is required but was not present")
    }
    return nil
}

func (strct *ValidationSpecification) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ValidationProfiles" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ValidationProfiles" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ValidationProfiles\": ")
	if tmp, err := json.Marshal(strct.ValidationProfiles); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ValidationRole" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ValidationRole" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ValidationRole\": ")
	if tmp, err := json.Marshal(strct.ValidationRole); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ValidationSpecification) UnmarshalJSON(b []byte) error {
    ValidationProfilesReceived := false
    ValidationRoleReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ValidationProfiles":
            if err := json.Unmarshal([]byte(v), &strct.ValidationProfiles); err != nil {
                return err
             }
            ValidationProfilesReceived = true
        case "ValidationRole":
            if err := json.Unmarshal([]byte(v), &strct.ValidationRole); err != nil {
                return err
             }
            ValidationRoleReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ValidationProfiles (a required property) was received
    if !ValidationProfilesReceived {
        return errors.New("\"ValidationProfiles\" is required but was not present")
    }
    // check if ValidationRole (a required property) was received
    if !ValidationRoleReceived {
        return errors.New("\"ValidationRole\" is required but was not present")
    }
    return nil
}
