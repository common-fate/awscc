// Code generated by schema-generate. DO NOT EDIT.

package modelcard

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// AdditionalInformation 
type AdditionalInformation struct {

  // Caveats and recommendations for people who might use this model in their applications.
  CaveatsAndRecommendations string `json:"CaveatsAndRecommendations,omitempty"`

  // customer details.
  CustomDetails *CustomDetails `json:"CustomDetails,omitempty"`

  // Any ethical considerations that the author wants to provide.
  EthicalConsiderations string `json:"EthicalConsiderations,omitempty"`
}

// BarChartMetric 
type BarChartMetric struct {
  Name string `json:"Name"`
  Notes string `json:"Notes,omitempty"`
  Type string `json:"Type"`
  Value interface{} `json:"Value"`
  XAxisName []string `json:"XAxisName,omitempty"`
  YAxisName string `json:"YAxisName,omitempty"`
}

// BusinessDetails Business details.
type BusinessDetails struct {

  // What business problem does the model solve?
  BusinessProblem string `json:"BusinessProblem,omitempty"`

  // Business stakeholders.
  BusinessStakeholders string `json:"BusinessStakeholders,omitempty"`

  // Line of business.
  LineOfBusiness string `json:"LineOfBusiness,omitempty"`
}

// Content The content of the model card.
type Content struct {
  AdditionalInformation *AdditionalInformation `json:"AdditionalInformation,omitempty"`
  BusinessDetails *BusinessDetails `json:"BusinessDetails,omitempty"`
  EvaluationDetails []*EvaluationDetail `json:"EvaluationDetails,omitempty"`
  IntendedUses *IntendedUses `json:"IntendedUses,omitempty"`
  ModelOverview *ModelOverview `json:"ModelOverview,omitempty"`
  TrainingDetails *TrainingDetails `json:"TrainingDetails,omitempty"`
}

// CustomDetails customer details.
type CustomDetails struct {
}

// EvaluationDetail item of evaluation details
type EvaluationDetail struct {
  Datasets []string `json:"Datasets,omitempty"`
  EvaluationJobArn string `json:"EvaluationJobArn,omitempty"`
  EvaluationObservation string `json:"EvaluationObservation,omitempty"`

  // additional attributes associated with the evaluation results.
  Metadata *Metadata `json:"Metadata,omitempty"`
  MetricGroups []*MetricGroup `json:"MetricGroups,omitempty"`
  Name string `json:"Name"`
}

// Function objective function that training job is optimized for.
type Function struct {
  Condition string `json:"Condition,omitempty"`
  Facet string `json:"Facet,omitempty"`
  Function string `json:"Function,omitempty"`
}

// InferenceEnvironment Overview about the inference.
type InferenceEnvironment struct {

  // SageMaker inference image uri.
  ContainerImage []string `json:"ContainerImage,omitempty"`
}

// IntendedUses Intended usage of model.
type IntendedUses struct {
  ExplanationsForRiskRating string `json:"ExplanationsForRiskRating,omitempty"`
  FactorsAffectingModelEfficiency string `json:"FactorsAffectingModelEfficiency,omitempty"`

  // intended use cases.
  IntendedUses string `json:"IntendedUses,omitempty"`

  // Why the model was developed?
  PurposeOfModel string `json:"PurposeOfModel,omitempty"`
  RiskRating string `json:"RiskRating,omitempty"`
}

// LinearGraphMetric Linear graph metric.
type LinearGraphMetric struct {
  Name string `json:"Name"`
  Notes string `json:"Notes,omitempty"`
  Type string `json:"Type"`
  Value interface{} `json:"Value"`
  XAxisName string `json:"XAxisName,omitempty"`
  YAxisName string `json:"YAxisName,omitempty"`
}

// MatrixMetric 
type MatrixMetric struct {
  Name string `json:"Name"`
  Notes string `json:"Notes,omitempty"`
  Type string `json:"Type"`
  Value interface{} `json:"Value"`
  XAxisName []string `json:"XAxisName,omitempty"`
  YAxisName []string `json:"YAxisName,omitempty"`
}

// Metadata additional attributes associated with the evaluation results.
type Metadata struct {
}

// MetricGroup item in metric groups
type MetricGroup struct {
  MetricData []interface{} `json:"MetricData"`
  Name string `json:"Name"`
}

// ModelOverview Overview about the model.
type ModelOverview struct {

  // Algorithm used to solve the problem.
  AlgorithmType string `json:"AlgorithmType,omitempty"`

  // Overview about the inference.
  InferenceEnvironment *InferenceEnvironment `json:"InferenceEnvironment,omitempty"`

  // Location of the model artifact.
  ModelArtifact []string `json:"ModelArtifact,omitempty"`

  // Creator of model.
  ModelCreator string `json:"ModelCreator,omitempty"`

  // description of model.
  ModelDescription string `json:"ModelDescription,omitempty"`

  // SageMaker Model Arn or Non SageMaker Model id.
  ModelId string `json:"ModelId,omitempty"`

  // Name of the model.
  ModelName string `json:"ModelName,omitempty"`

  // Owner of model.
  ModelOwner string `json:"ModelOwner,omitempty"`

  // Version of the model.
  ModelVersion float64 `json:"ModelVersion,omitempty"`

  // Problem being solved with the model.
  ProblemType string `json:"ProblemType,omitempty"`
}

// ObjectiveFunction the objective function the model will optimize for.
type ObjectiveFunction struct {

  // objective function that training job is optimized for.
  Function *Function `json:"Function,omitempty"`
  Notes string `json:"Notes,omitempty"`
}

// Resource Resource Type definition for AWS::SageMaker::ModelCard.
type Resource struct {
  Content *Content `json:"Content"`

  // Information about the user who created or modified an experiment, trial, trial component, lineage group, project, or model card.
  CreatedBy *UserContext `json:"CreatedBy,omitempty"`

  // The date and time the model card was created.
  CreationTime string `json:"CreationTime,omitempty"`

  // Information about the user who created or modified an experiment, trial, trial component, lineage group, project, or model card.
  LastModifiedBy *UserContext `json:"LastModifiedBy,omitempty"`

  // The date and time the model card was last modified.
  LastModifiedTime string `json:"LastModifiedTime,omitempty"`

  // The Amazon Resource Name (ARN) of the successfully created model card.
  ModelCardArn string `json:"ModelCardArn,omitempty"`

  // The unique name of the model card.
  ModelCardName string `json:"ModelCardName"`

  // The processing status of model card deletion. The ModelCardProcessingStatus updates throughout the different deletion steps.
  ModelCardProcessingStatus string `json:"ModelCardProcessingStatus,omitempty"`

  // The approval status of the model card within your organization. Different organizations might have different criteria for model card review and approval.
  ModelCardStatus string `json:"ModelCardStatus"`

  // A version of the model card.
  ModelCardVersion int `json:"ModelCardVersion,omitempty"`
  SecurityConfig *SecurityConfig `json:"SecurityConfig,omitempty"`

  // Key-value pairs used to manage metadata for model cards.
  Tags []*Tag `json:"Tags,omitempty"`
}

// SecurityConfig An optional Key Management Service key to encrypt, decrypt, and re-encrypt model card content for regulated workloads with highly sensitive data.
// 
// 
type SecurityConfig struct {

  // A Key Management Service key ID to use for encrypting a model card.
  KmsKeyId string `json:"KmsKeyId,omitempty"`
}

// SimpleMetric metric data
type SimpleMetric struct {
  Name string `json:"Name"`
  Notes string `json:"Notes,omitempty"`
  Type string `json:"Type"`
  Value interface{} `json:"Value"`
  XAxisName string `json:"XAxisName,omitempty"`
  YAxisName string `json:"YAxisName,omitempty"`
}

// Tag A key-value pair to associate with a resource.
type Tag struct {

  // The tag key. Tag keys must be unique per resource.
  Key string `json:"Key"`

  // The tag value.
  Value string `json:"Value"`
}

// TrainingDetails Overview about the training.
type TrainingDetails struct {
  ObjectiveFunction *ObjectiveFunction `json:"ObjectiveFunction,omitempty"`
  TrainingJobDetails *TrainingJobDetails `json:"TrainingJobDetails,omitempty"`
  TrainingObservations string `json:"TrainingObservations,omitempty"`
}

// TrainingEnvironment 
type TrainingEnvironment struct {

  // SageMaker training image uri.
  ContainerImage []string `json:"ContainerImage,omitempty"`
}

// TrainingHyperParameter training hyper parameter
type TrainingHyperParameter struct {
  Name string `json:"Name"`
  Value string `json:"Value"`
}

// TrainingJobDetails 
type TrainingJobDetails struct {
  HyperParameters []*TrainingHyperParameter `json:"HyperParameters,omitempty"`

  // SageMaker Training job arn.
  TrainingArn string `json:"TrainingArn,omitempty"`

  // Location of the model datasets.
  TrainingDatasets []string `json:"TrainingDatasets,omitempty"`
  TrainingEnvironment *TrainingEnvironment `json:"TrainingEnvironment,omitempty"`
  TrainingMetrics []*TrainingMetric `json:"TrainingMetrics,omitempty"`
  UserProvidedHyperParameters []*TrainingHyperParameter `json:"UserProvidedHyperParameters,omitempty"`
  UserProvidedTrainingMetrics []*TrainingMetric `json:"UserProvidedTrainingMetrics,omitempty"`
}

// TrainingMetric training metric data.
type TrainingMetric struct {
  Name string `json:"Name"`
  Notes string `json:"Notes,omitempty"`
  Value float64 `json:"Value"`
}

// UserContext Information about the user who created or modified an experiment, trial, trial component, lineage group, project, or model card.
type UserContext struct {

  // The domain associated with the user.
  DomainId string `json:"DomainId,omitempty"`

  // The Amazon Resource Name (ARN) of the user's profile.
  UserProfileArn string `json:"UserProfileArn,omitempty"`

  // The name of the user's profile.
  UserProfileName string `json:"UserProfileName,omitempty"`
}

func (strct *AdditionalInformation) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CaveatsAndRecommendations" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CaveatsAndRecommendations\": ")
	if tmp, err := json.Marshal(strct.CaveatsAndRecommendations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CustomDetails" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CustomDetails\": ")
	if tmp, err := json.Marshal(strct.CustomDetails); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EthicalConsiderations" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EthicalConsiderations\": ")
	if tmp, err := json.Marshal(strct.EthicalConsiderations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AdditionalInformation) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CaveatsAndRecommendations":
            if err := json.Unmarshal([]byte(v), &strct.CaveatsAndRecommendations); err != nil {
                return err
             }
        case "CustomDetails":
            if err := json.Unmarshal([]byte(v), &strct.CustomDetails); err != nil {
                return err
             }
        case "EthicalConsiderations":
            if err := json.Unmarshal([]byte(v), &strct.EthicalConsiderations); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *BarChartMetric) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Notes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Notes\": ")
	if tmp, err := json.Marshal(strct.Notes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "XAxisName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"XAxisName\": ")
	if tmp, err := json.Marshal(strct.XAxisName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "YAxisName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"YAxisName\": ")
	if tmp, err := json.Marshal(strct.YAxisName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BarChartMetric) UnmarshalJSON(b []byte) error {
    NameReceived := false
    TypeReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        case "Notes":
            if err := json.Unmarshal([]byte(v), &strct.Notes); err != nil {
                return err
             }
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            TypeReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        case "XAxisName":
            if err := json.Unmarshal([]byte(v), &strct.XAxisName); err != nil {
                return err
             }
        case "YAxisName":
            if err := json.Unmarshal([]byte(v), &strct.YAxisName); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    // check if Type (a required property) was received
    if !TypeReceived {
        return errors.New("\"Type\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *BusinessDetails) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "BusinessProblem" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BusinessProblem\": ")
	if tmp, err := json.Marshal(strct.BusinessProblem); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BusinessStakeholders" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BusinessStakeholders\": ")
	if tmp, err := json.Marshal(strct.BusinessStakeholders); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LineOfBusiness" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LineOfBusiness\": ")
	if tmp, err := json.Marshal(strct.LineOfBusiness); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BusinessDetails) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BusinessProblem":
            if err := json.Unmarshal([]byte(v), &strct.BusinessProblem); err != nil {
                return err
             }
        case "BusinessStakeholders":
            if err := json.Unmarshal([]byte(v), &strct.BusinessStakeholders); err != nil {
                return err
             }
        case "LineOfBusiness":
            if err := json.Unmarshal([]byte(v), &strct.LineOfBusiness); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Content) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AdditionalInformation" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AdditionalInformation\": ")
	if tmp, err := json.Marshal(strct.AdditionalInformation); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BusinessDetails" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BusinessDetails\": ")
	if tmp, err := json.Marshal(strct.BusinessDetails); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EvaluationDetails" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EvaluationDetails\": ")
	if tmp, err := json.Marshal(strct.EvaluationDetails); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IntendedUses" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IntendedUses\": ")
	if tmp, err := json.Marshal(strct.IntendedUses); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ModelOverview" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ModelOverview\": ")
	if tmp, err := json.Marshal(strct.ModelOverview); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TrainingDetails" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TrainingDetails\": ")
	if tmp, err := json.Marshal(strct.TrainingDetails); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Content) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AdditionalInformation":
            if err := json.Unmarshal([]byte(v), &strct.AdditionalInformation); err != nil {
                return err
             }
        case "BusinessDetails":
            if err := json.Unmarshal([]byte(v), &strct.BusinessDetails); err != nil {
                return err
             }
        case "EvaluationDetails":
            if err := json.Unmarshal([]byte(v), &strct.EvaluationDetails); err != nil {
                return err
             }
        case "IntendedUses":
            if err := json.Unmarshal([]byte(v), &strct.IntendedUses); err != nil {
                return err
             }
        case "ModelOverview":
            if err := json.Unmarshal([]byte(v), &strct.ModelOverview); err != nil {
                return err
             }
        case "TrainingDetails":
            if err := json.Unmarshal([]byte(v), &strct.TrainingDetails); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *CustomDetails) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CustomDetails) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *EvaluationDetail) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Datasets" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Datasets\": ")
	if tmp, err := json.Marshal(strct.Datasets); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EvaluationJobArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EvaluationJobArn\": ")
	if tmp, err := json.Marshal(strct.EvaluationJobArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EvaluationObservation" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EvaluationObservation\": ")
	if tmp, err := json.Marshal(strct.EvaluationObservation); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Metadata" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Metadata\": ")
	if tmp, err := json.Marshal(strct.Metadata); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MetricGroups" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MetricGroups\": ")
	if tmp, err := json.Marshal(strct.MetricGroups); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *EvaluationDetail) UnmarshalJSON(b []byte) error {
    NameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Datasets":
            if err := json.Unmarshal([]byte(v), &strct.Datasets); err != nil {
                return err
             }
        case "EvaluationJobArn":
            if err := json.Unmarshal([]byte(v), &strct.EvaluationJobArn); err != nil {
                return err
             }
        case "EvaluationObservation":
            if err := json.Unmarshal([]byte(v), &strct.EvaluationObservation); err != nil {
                return err
             }
        case "Metadata":
            if err := json.Unmarshal([]byte(v), &strct.Metadata); err != nil {
                return err
             }
        case "MetricGroups":
            if err := json.Unmarshal([]byte(v), &strct.MetricGroups); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    return nil
}

func (strct *Function) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Condition" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Condition\": ")
	if tmp, err := json.Marshal(strct.Condition); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Facet" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Facet\": ")
	if tmp, err := json.Marshal(strct.Facet); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Function" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Function\": ")
	if tmp, err := json.Marshal(strct.Function); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Function) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Condition":
            if err := json.Unmarshal([]byte(v), &strct.Condition); err != nil {
                return err
             }
        case "Facet":
            if err := json.Unmarshal([]byte(v), &strct.Facet); err != nil {
                return err
             }
        case "Function":
            if err := json.Unmarshal([]byte(v), &strct.Function); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *InferenceEnvironment) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ContainerImage" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ContainerImage\": ")
	if tmp, err := json.Marshal(strct.ContainerImage); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *InferenceEnvironment) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ContainerImage":
            if err := json.Unmarshal([]byte(v), &strct.ContainerImage); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *IntendedUses) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ExplanationsForRiskRating" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ExplanationsForRiskRating\": ")
	if tmp, err := json.Marshal(strct.ExplanationsForRiskRating); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FactorsAffectingModelEfficiency" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FactorsAffectingModelEfficiency\": ")
	if tmp, err := json.Marshal(strct.FactorsAffectingModelEfficiency); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "IntendedUses" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"IntendedUses\": ")
	if tmp, err := json.Marshal(strct.IntendedUses); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PurposeOfModel" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PurposeOfModel\": ")
	if tmp, err := json.Marshal(strct.PurposeOfModel); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RiskRating" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RiskRating\": ")
	if tmp, err := json.Marshal(strct.RiskRating); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *IntendedUses) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ExplanationsForRiskRating":
            if err := json.Unmarshal([]byte(v), &strct.ExplanationsForRiskRating); err != nil {
                return err
             }
        case "FactorsAffectingModelEfficiency":
            if err := json.Unmarshal([]byte(v), &strct.FactorsAffectingModelEfficiency); err != nil {
                return err
             }
        case "IntendedUses":
            if err := json.Unmarshal([]byte(v), &strct.IntendedUses); err != nil {
                return err
             }
        case "PurposeOfModel":
            if err := json.Unmarshal([]byte(v), &strct.PurposeOfModel); err != nil {
                return err
             }
        case "RiskRating":
            if err := json.Unmarshal([]byte(v), &strct.RiskRating); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *LinearGraphMetric) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Notes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Notes\": ")
	if tmp, err := json.Marshal(strct.Notes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "XAxisName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"XAxisName\": ")
	if tmp, err := json.Marshal(strct.XAxisName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "YAxisName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"YAxisName\": ")
	if tmp, err := json.Marshal(strct.YAxisName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LinearGraphMetric) UnmarshalJSON(b []byte) error {
    NameReceived := false
    TypeReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        case "Notes":
            if err := json.Unmarshal([]byte(v), &strct.Notes); err != nil {
                return err
             }
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            TypeReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        case "XAxisName":
            if err := json.Unmarshal([]byte(v), &strct.XAxisName); err != nil {
                return err
             }
        case "YAxisName":
            if err := json.Unmarshal([]byte(v), &strct.YAxisName); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    // check if Type (a required property) was received
    if !TypeReceived {
        return errors.New("\"Type\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *MatrixMetric) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Notes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Notes\": ")
	if tmp, err := json.Marshal(strct.Notes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "XAxisName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"XAxisName\": ")
	if tmp, err := json.Marshal(strct.XAxisName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "YAxisName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"YAxisName\": ")
	if tmp, err := json.Marshal(strct.YAxisName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MatrixMetric) UnmarshalJSON(b []byte) error {
    NameReceived := false
    TypeReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        case "Notes":
            if err := json.Unmarshal([]byte(v), &strct.Notes); err != nil {
                return err
             }
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            TypeReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        case "XAxisName":
            if err := json.Unmarshal([]byte(v), &strct.XAxisName); err != nil {
                return err
             }
        case "YAxisName":
            if err := json.Unmarshal([]byte(v), &strct.YAxisName); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    // check if Type (a required property) was received
    if !TypeReceived {
        return errors.New("\"Type\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *Metadata) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Metadata) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *MetricGroup) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "MetricData" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "MetricData" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MetricData\": ")
	if tmp, err := json.Marshal(strct.MetricData); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MetricGroup) UnmarshalJSON(b []byte) error {
    MetricDataReceived := false
    NameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "MetricData":
            if err := json.Unmarshal([]byte(v), &strct.MetricData); err != nil {
                return err
             }
            MetricDataReceived = true
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if MetricData (a required property) was received
    if !MetricDataReceived {
        return errors.New("\"MetricData\" is required but was not present")
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    return nil
}

func (strct *ModelOverview) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AlgorithmType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AlgorithmType\": ")
	if tmp, err := json.Marshal(strct.AlgorithmType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "InferenceEnvironment" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InferenceEnvironment\": ")
	if tmp, err := json.Marshal(strct.InferenceEnvironment); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ModelArtifact" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ModelArtifact\": ")
	if tmp, err := json.Marshal(strct.ModelArtifact); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ModelCreator" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ModelCreator\": ")
	if tmp, err := json.Marshal(strct.ModelCreator); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ModelDescription" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ModelDescription\": ")
	if tmp, err := json.Marshal(strct.ModelDescription); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ModelId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ModelId\": ")
	if tmp, err := json.Marshal(strct.ModelId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ModelName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ModelName\": ")
	if tmp, err := json.Marshal(strct.ModelName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ModelOwner" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ModelOwner\": ")
	if tmp, err := json.Marshal(strct.ModelOwner); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ModelVersion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ModelVersion\": ")
	if tmp, err := json.Marshal(strct.ModelVersion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ProblemType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ProblemType\": ")
	if tmp, err := json.Marshal(strct.ProblemType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ModelOverview) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AlgorithmType":
            if err := json.Unmarshal([]byte(v), &strct.AlgorithmType); err != nil {
                return err
             }
        case "InferenceEnvironment":
            if err := json.Unmarshal([]byte(v), &strct.InferenceEnvironment); err != nil {
                return err
             }
        case "ModelArtifact":
            if err := json.Unmarshal([]byte(v), &strct.ModelArtifact); err != nil {
                return err
             }
        case "ModelCreator":
            if err := json.Unmarshal([]byte(v), &strct.ModelCreator); err != nil {
                return err
             }
        case "ModelDescription":
            if err := json.Unmarshal([]byte(v), &strct.ModelDescription); err != nil {
                return err
             }
        case "ModelId":
            if err := json.Unmarshal([]byte(v), &strct.ModelId); err != nil {
                return err
             }
        case "ModelName":
            if err := json.Unmarshal([]byte(v), &strct.ModelName); err != nil {
                return err
             }
        case "ModelOwner":
            if err := json.Unmarshal([]byte(v), &strct.ModelOwner); err != nil {
                return err
             }
        case "ModelVersion":
            if err := json.Unmarshal([]byte(v), &strct.ModelVersion); err != nil {
                return err
             }
        case "ProblemType":
            if err := json.Unmarshal([]byte(v), &strct.ProblemType); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ObjectiveFunction) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Function" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Function\": ")
	if tmp, err := json.Marshal(strct.Function); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Notes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Notes\": ")
	if tmp, err := json.Marshal(strct.Notes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ObjectiveFunction) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Function":
            if err := json.Unmarshal([]byte(v), &strct.Function); err != nil {
                return err
             }
        case "Notes":
            if err := json.Unmarshal([]byte(v), &strct.Notes); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Content" field is required
    if strct.Content == nil {
        return nil, errors.New("Content is a required field")
    }
    // Marshal the "Content" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Content\": ")
	if tmp, err := json.Marshal(strct.Content); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CreatedBy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CreatedBy\": ")
	if tmp, err := json.Marshal(strct.CreatedBy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CreationTime" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CreationTime\": ")
	if tmp, err := json.Marshal(strct.CreationTime); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LastModifiedBy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LastModifiedBy\": ")
	if tmp, err := json.Marshal(strct.LastModifiedBy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LastModifiedTime" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LastModifiedTime\": ")
	if tmp, err := json.Marshal(strct.LastModifiedTime); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ModelCardArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ModelCardArn\": ")
	if tmp, err := json.Marshal(strct.ModelCardArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ModelCardName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ModelCardName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ModelCardName\": ")
	if tmp, err := json.Marshal(strct.ModelCardName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ModelCardProcessingStatus" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ModelCardProcessingStatus\": ")
	if tmp, err := json.Marshal(strct.ModelCardProcessingStatus); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ModelCardStatus" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ModelCardStatus" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ModelCardStatus\": ")
	if tmp, err := json.Marshal(strct.ModelCardStatus); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ModelCardVersion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ModelCardVersion\": ")
	if tmp, err := json.Marshal(strct.ModelCardVersion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SecurityConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SecurityConfig\": ")
	if tmp, err := json.Marshal(strct.SecurityConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    ContentReceived := false
    ModelCardNameReceived := false
    ModelCardStatusReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Content":
            if err := json.Unmarshal([]byte(v), &strct.Content); err != nil {
                return err
             }
            ContentReceived = true
        case "CreatedBy":
            if err := json.Unmarshal([]byte(v), &strct.CreatedBy); err != nil {
                return err
             }
        case "CreationTime":
            if err := json.Unmarshal([]byte(v), &strct.CreationTime); err != nil {
                return err
             }
        case "LastModifiedBy":
            if err := json.Unmarshal([]byte(v), &strct.LastModifiedBy); err != nil {
                return err
             }
        case "LastModifiedTime":
            if err := json.Unmarshal([]byte(v), &strct.LastModifiedTime); err != nil {
                return err
             }
        case "ModelCardArn":
            if err := json.Unmarshal([]byte(v), &strct.ModelCardArn); err != nil {
                return err
             }
        case "ModelCardName":
            if err := json.Unmarshal([]byte(v), &strct.ModelCardName); err != nil {
                return err
             }
            ModelCardNameReceived = true
        case "ModelCardProcessingStatus":
            if err := json.Unmarshal([]byte(v), &strct.ModelCardProcessingStatus); err != nil {
                return err
             }
        case "ModelCardStatus":
            if err := json.Unmarshal([]byte(v), &strct.ModelCardStatus); err != nil {
                return err
             }
            ModelCardStatusReceived = true
        case "ModelCardVersion":
            if err := json.Unmarshal([]byte(v), &strct.ModelCardVersion); err != nil {
                return err
             }
        case "SecurityConfig":
            if err := json.Unmarshal([]byte(v), &strct.SecurityConfig); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Content (a required property) was received
    if !ContentReceived {
        return errors.New("\"Content\" is required but was not present")
    }
    // check if ModelCardName (a required property) was received
    if !ModelCardNameReceived {
        return errors.New("\"ModelCardName\" is required but was not present")
    }
    // check if ModelCardStatus (a required property) was received
    if !ModelCardStatusReceived {
        return errors.New("\"ModelCardStatus\" is required but was not present")
    }
    return nil
}

func (strct *SecurityConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "KmsKeyId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KmsKeyId\": ")
	if tmp, err := json.Marshal(strct.KmsKeyId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SecurityConfig) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "KmsKeyId":
            if err := json.Unmarshal([]byte(v), &strct.KmsKeyId); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *SimpleMetric) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Notes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Notes\": ")
	if tmp, err := json.Marshal(strct.Notes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "XAxisName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"XAxisName\": ")
	if tmp, err := json.Marshal(strct.XAxisName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "YAxisName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"YAxisName\": ")
	if tmp, err := json.Marshal(strct.YAxisName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SimpleMetric) UnmarshalJSON(b []byte) error {
    NameReceived := false
    TypeReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        case "Notes":
            if err := json.Unmarshal([]byte(v), &strct.Notes); err != nil {
                return err
             }
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            TypeReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        case "XAxisName":
            if err := json.Unmarshal([]byte(v), &strct.XAxisName); err != nil {
                return err
             }
        case "YAxisName":
            if err := json.Unmarshal([]byte(v), &strct.YAxisName); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    // check if Type (a required property) was received
    if !TypeReceived {
        return errors.New("\"Type\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *TrainingDetails) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ObjectiveFunction" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ObjectiveFunction\": ")
	if tmp, err := json.Marshal(strct.ObjectiveFunction); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TrainingJobDetails" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TrainingJobDetails\": ")
	if tmp, err := json.Marshal(strct.TrainingJobDetails); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TrainingObservations" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TrainingObservations\": ")
	if tmp, err := json.Marshal(strct.TrainingObservations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TrainingDetails) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ObjectiveFunction":
            if err := json.Unmarshal([]byte(v), &strct.ObjectiveFunction); err != nil {
                return err
             }
        case "TrainingJobDetails":
            if err := json.Unmarshal([]byte(v), &strct.TrainingJobDetails); err != nil {
                return err
             }
        case "TrainingObservations":
            if err := json.Unmarshal([]byte(v), &strct.TrainingObservations); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *TrainingEnvironment) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ContainerImage" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ContainerImage\": ")
	if tmp, err := json.Marshal(strct.ContainerImage); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TrainingEnvironment) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ContainerImage":
            if err := json.Unmarshal([]byte(v), &strct.ContainerImage); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *TrainingHyperParameter) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TrainingHyperParameter) UnmarshalJSON(b []byte) error {
    NameReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *TrainingJobDetails) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "HyperParameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HyperParameters\": ")
	if tmp, err := json.Marshal(strct.HyperParameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TrainingArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TrainingArn\": ")
	if tmp, err := json.Marshal(strct.TrainingArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TrainingDatasets" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TrainingDatasets\": ")
	if tmp, err := json.Marshal(strct.TrainingDatasets); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TrainingEnvironment" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TrainingEnvironment\": ")
	if tmp, err := json.Marshal(strct.TrainingEnvironment); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TrainingMetrics" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TrainingMetrics\": ")
	if tmp, err := json.Marshal(strct.TrainingMetrics); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "UserProvidedHyperParameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UserProvidedHyperParameters\": ")
	if tmp, err := json.Marshal(strct.UserProvidedHyperParameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "UserProvidedTrainingMetrics" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UserProvidedTrainingMetrics\": ")
	if tmp, err := json.Marshal(strct.UserProvidedTrainingMetrics); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TrainingJobDetails) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "HyperParameters":
            if err := json.Unmarshal([]byte(v), &strct.HyperParameters); err != nil {
                return err
             }
        case "TrainingArn":
            if err := json.Unmarshal([]byte(v), &strct.TrainingArn); err != nil {
                return err
             }
        case "TrainingDatasets":
            if err := json.Unmarshal([]byte(v), &strct.TrainingDatasets); err != nil {
                return err
             }
        case "TrainingEnvironment":
            if err := json.Unmarshal([]byte(v), &strct.TrainingEnvironment); err != nil {
                return err
             }
        case "TrainingMetrics":
            if err := json.Unmarshal([]byte(v), &strct.TrainingMetrics); err != nil {
                return err
             }
        case "UserProvidedHyperParameters":
            if err := json.Unmarshal([]byte(v), &strct.UserProvidedHyperParameters); err != nil {
                return err
             }
        case "UserProvidedTrainingMetrics":
            if err := json.Unmarshal([]byte(v), &strct.UserProvidedTrainingMetrics); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *TrainingMetric) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Notes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Notes\": ")
	if tmp, err := json.Marshal(strct.Notes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TrainingMetric) UnmarshalJSON(b []byte) error {
    NameReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        case "Notes":
            if err := json.Unmarshal([]byte(v), &strct.Notes); err != nil {
                return err
             }
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *UserContext) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DomainId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DomainId\": ")
	if tmp, err := json.Marshal(strct.DomainId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "UserProfileArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UserProfileArn\": ")
	if tmp, err := json.Marshal(strct.UserProfileArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "UserProfileName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UserProfileName\": ")
	if tmp, err := json.Marshal(strct.UserProfileName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *UserContext) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DomainId":
            if err := json.Unmarshal([]byte(v), &strct.DomainId); err != nil {
                return err
             }
        case "UserProfileArn":
            if err := json.Unmarshal([]byte(v), &strct.UserProfileArn); err != nil {
                return err
             }
        case "UserProfileName":
            if err := json.Unmarshal([]byte(v), &strct.UserProfileName); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}
