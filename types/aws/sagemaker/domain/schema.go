// Code generated by schema-generate. DO NOT EDIT.

package domain

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// CustomImage A custom SageMaker image.
type CustomImage struct {

  // The Name of the AppImageConfig.
  AppImageConfigName string `json:"AppImageConfigName"`

  // The name of the CustomImage. Must be unique to your account.
  ImageName string `json:"ImageName"`

  // The version number of the CustomImage.
  ImageVersionNumber int `json:"ImageVersionNumber,omitempty"`
}

// DefaultSpaceSettings A collection of settings that apply to spaces of Amazon SageMaker Studio. These settings are specified when the Create/Update Domain API is called.
type DefaultSpaceSettings struct {

  // The execution role for the space.
  ExecutionRole string `json:"ExecutionRole,omitempty"`

  // The Jupyter server's app settings.
  JupyterServerAppSettings *JupyterServerAppSettings `json:"JupyterServerAppSettings,omitempty"`

  // The kernel gateway app settings.
  KernelGatewayAppSettings *KernelGatewayAppSettings `json:"KernelGatewayAppSettings,omitempty"`

  // The security groups for the Amazon Virtual Private Cloud (VPC) that Studio uses for communication.
  SecurityGroups []string `json:"SecurityGroups,omitempty"`
}

// DomainSettings A collection of Domain settings.
type DomainSettings struct {
  RStudioServerProDomainSettings *RStudioServerProDomainSettings `json:"RStudioServerProDomainSettings,omitempty"`

  // The security groups for the Amazon Virtual Private Cloud that the Domain uses for communication between Domain-level apps and user apps.
  SecurityGroupIds []string `json:"SecurityGroupIds,omitempty"`
}

// JupyterServerAppSettings The JupyterServer app settings.
type JupyterServerAppSettings struct {
  DefaultResourceSpec *ResourceSpec `json:"DefaultResourceSpec,omitempty"`
}

// KernelGatewayAppSettings The kernel gateway app settings.
type KernelGatewayAppSettings struct {

  // A list of custom SageMaker images that are configured to run as a KernelGateway app.
  CustomImages []*CustomImage `json:"CustomImages,omitempty"`

  // The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the KernelGateway app.
  DefaultResourceSpec *ResourceSpec `json:"DefaultResourceSpec,omitempty"`
}

// RSessionAppSettings A collection of settings that apply to an RSessionGateway app.
type RSessionAppSettings struct {

  // A list of custom SageMaker images that are configured to run as a KernelGateway app.
  CustomImages []*CustomImage `json:"CustomImages,omitempty"`
  DefaultResourceSpec *ResourceSpec `json:"DefaultResourceSpec,omitempty"`
}

// RStudioServerProAppSettings A collection of settings that configure user interaction with the RStudioServerPro app.
type RStudioServerProAppSettings struct {

  // Indicates whether the current user has access to the RStudioServerPro app.
  AccessStatus string `json:"AccessStatus,omitempty"`

  // The level of permissions that the user has within the RStudioServerPro app. This value defaults to User. The Admin value allows the user access to the RStudio Administrative Dashboard.
  UserGroup string `json:"UserGroup,omitempty"`
}

// RStudioServerProDomainSettings A collection of settings that update the current configuration for the RStudioServerPro Domain-level app.
type RStudioServerProDomainSettings struct {
  DefaultResourceSpec *ResourceSpec `json:"DefaultResourceSpec,omitempty"`

  // The ARN of the execution role for the RStudioServerPro Domain-level app.
  DomainExecutionRoleArn string `json:"DomainExecutionRoleArn"`

  // A URL pointing to an RStudio Connect server.
  RStudioConnectUrl string `json:"RStudioConnectUrl,omitempty"`

  // A URL pointing to an RStudio Package Manager server.
  RStudioPackageManagerUrl string `json:"RStudioPackageManagerUrl,omitempty"`
}

// Resource Resource Type definition for AWS::SageMaker::Domain
type Resource struct {

  // Specifies the VPC used for non-EFS traffic. The default value is PublicInternetOnly.
  AppNetworkAccessType string `json:"AppNetworkAccessType,omitempty"`

  // The entity that creates and manages the required security groups for inter-app communication in VPCOnly mode. Required when CreateDomain.AppNetworkAccessType is VPCOnly and DomainSettings.RStudioServerProDomainSettings.DomainExecutionRoleArn is provided.
  AppSecurityGroupManagement string `json:"AppSecurityGroupManagement,omitempty"`

  // The mode of authentication that members use to access the domain.
  AuthMode string `json:"AuthMode"`

  // The default space settings.
  DefaultSpaceSettings *DefaultSpaceSettings `json:"DefaultSpaceSettings,omitempty"`

  // The default user settings.
  DefaultUserSettings *UserSettings `json:"DefaultUserSettings"`

  // The Amazon Resource Name (ARN) of the created domain.
  DomainArn string `json:"DomainArn,omitempty"`

  // The domain name.
  DomainId string `json:"DomainId,omitempty"`

  // A name for the domain.
  DomainName string `json:"DomainName"`
  DomainSettings *DomainSettings `json:"DomainSettings,omitempty"`

  // The ID of the Amazon Elastic File System (EFS) managed by this Domain.
  HomeEfsFileSystemId string `json:"HomeEfsFileSystemId,omitempty"`

  // SageMaker uses AWS KMS to encrypt the EFS volume attached to the domain with an AWS managed customer master key (CMK) by default.
  KmsKeyId string `json:"KmsKeyId,omitempty"`

  // The ID of the security group that authorizes traffic between the RSessionGateway apps and the RStudioServerPro app.
  SecurityGroupIdForDomainBoundary string `json:"SecurityGroupIdForDomainBoundary,omitempty"`

  // The SSO managed application instance ID.
  SingleSignOnManagedApplicationInstanceId string `json:"SingleSignOnManagedApplicationInstanceId,omitempty"`

  // The VPC subnets that Studio uses for communication.
  SubnetIds []string `json:"SubnetIds"`

  // A list of tags to apply to the user profile.
  Tags []*Tag `json:"Tags,omitempty"`

  // The URL to the created domain.
  Url string `json:"Url,omitempty"`

  // The ID of the Amazon Virtual Private Cloud (VPC) that Studio uses for communication.
  VpcId string `json:"VpcId"`
}

// ResourceSpec 
type ResourceSpec struct {

  // The instance type that the image version runs on.
  InstanceType string `json:"InstanceType,omitempty"`

  // The Amazon Resource Name (ARN) of the Lifecycle Configuration to attach to the Resource.
  LifecycleConfigArn string `json:"LifecycleConfigArn,omitempty"`

  // The Amazon Resource Name (ARN) of the SageMaker image that the image version belongs to.
  SageMakerImageArn string `json:"SageMakerImageArn,omitempty"`

  // The Amazon Resource Name (ARN) of the image version created on the instance.
  SageMakerImageVersionArn string `json:"SageMakerImageVersionArn,omitempty"`
}

// SharingSettings Specifies options when sharing an Amazon SageMaker Studio notebook. These settings are specified as part of DefaultUserSettings when the CreateDomain API is called, and as part of UserSettings when the CreateUserProfile API is called.
type SharingSettings struct {

  // Whether to include the notebook cell output when sharing the notebook. The default is Disabled.
  NotebookOutputOption string `json:"NotebookOutputOption,omitempty"`

  // When NotebookOutputOption is Allowed, the AWS Key Management Service (KMS) encryption key ID used to encrypt the notebook cell output in the Amazon S3 bucket.
  S3KmsKeyId string `json:"S3KmsKeyId,omitempty"`

  // When NotebookOutputOption is Allowed, the Amazon S3 bucket used to store the shared notebook snapshots.
  S3OutputPath string `json:"S3OutputPath,omitempty"`
}

// Tag 
type Tag struct {
  Key string `json:"Key"`
  Value string `json:"Value"`
}

// UserSettings A collection of settings that apply to users of Amazon SageMaker Studio. These settings are specified when the CreateUserProfile API is called, and as DefaultUserSettings when the CreateDomain API is called.
type UserSettings struct {

  // The execution role for the user.
  ExecutionRole string `json:"ExecutionRole,omitempty"`

  // The Jupyter server's app settings.
  JupyterServerAppSettings *JupyterServerAppSettings `json:"JupyterServerAppSettings,omitempty"`

  // The kernel gateway app settings.
  KernelGatewayAppSettings *KernelGatewayAppSettings `json:"KernelGatewayAppSettings,omitempty"`
  RSessionAppSettings *RSessionAppSettings `json:"RSessionAppSettings,omitempty"`
  RStudioServerProAppSettings *RStudioServerProAppSettings `json:"RStudioServerProAppSettings,omitempty"`

  // The security groups for the Amazon Virtual Private Cloud (VPC) that Studio uses for communication.
  SecurityGroups []string `json:"SecurityGroups,omitempty"`

  // The sharing settings.
  SharingSettings *SharingSettings `json:"SharingSettings,omitempty"`
}

func (strct *CustomImage) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AppImageConfigName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AppImageConfigName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AppImageConfigName\": ")
	if tmp, err := json.Marshal(strct.AppImageConfigName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ImageName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ImageName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ImageName\": ")
	if tmp, err := json.Marshal(strct.ImageName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ImageVersionNumber" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ImageVersionNumber\": ")
	if tmp, err := json.Marshal(strct.ImageVersionNumber); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CustomImage) UnmarshalJSON(b []byte) error {
    AppImageConfigNameReceived := false
    ImageNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AppImageConfigName":
            if err := json.Unmarshal([]byte(v), &strct.AppImageConfigName); err != nil {
                return err
             }
            AppImageConfigNameReceived = true
        case "ImageName":
            if err := json.Unmarshal([]byte(v), &strct.ImageName); err != nil {
                return err
             }
            ImageNameReceived = true
        case "ImageVersionNumber":
            if err := json.Unmarshal([]byte(v), &strct.ImageVersionNumber); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if AppImageConfigName (a required property) was received
    if !AppImageConfigNameReceived {
        return errors.New("\"AppImageConfigName\" is required but was not present")
    }
    // check if ImageName (a required property) was received
    if !ImageNameReceived {
        return errors.New("\"ImageName\" is required but was not present")
    }
    return nil
}

func (strct *DefaultSpaceSettings) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ExecutionRole" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ExecutionRole\": ")
	if tmp, err := json.Marshal(strct.ExecutionRole); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "JupyterServerAppSettings" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"JupyterServerAppSettings\": ")
	if tmp, err := json.Marshal(strct.JupyterServerAppSettings); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "KernelGatewayAppSettings" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KernelGatewayAppSettings\": ")
	if tmp, err := json.Marshal(strct.KernelGatewayAppSettings); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SecurityGroups" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SecurityGroups\": ")
	if tmp, err := json.Marshal(strct.SecurityGroups); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DefaultSpaceSettings) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ExecutionRole":
            if err := json.Unmarshal([]byte(v), &strct.ExecutionRole); err != nil {
                return err
             }
        case "JupyterServerAppSettings":
            if err := json.Unmarshal([]byte(v), &strct.JupyterServerAppSettings); err != nil {
                return err
             }
        case "KernelGatewayAppSettings":
            if err := json.Unmarshal([]byte(v), &strct.KernelGatewayAppSettings); err != nil {
                return err
             }
        case "SecurityGroups":
            if err := json.Unmarshal([]byte(v), &strct.SecurityGroups); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *DomainSettings) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "RStudioServerProDomainSettings" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RStudioServerProDomainSettings\": ")
	if tmp, err := json.Marshal(strct.RStudioServerProDomainSettings); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SecurityGroupIds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SecurityGroupIds\": ")
	if tmp, err := json.Marshal(strct.SecurityGroupIds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DomainSettings) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "RStudioServerProDomainSettings":
            if err := json.Unmarshal([]byte(v), &strct.RStudioServerProDomainSettings); err != nil {
                return err
             }
        case "SecurityGroupIds":
            if err := json.Unmarshal([]byte(v), &strct.SecurityGroupIds); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *JupyterServerAppSettings) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DefaultResourceSpec" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DefaultResourceSpec\": ")
	if tmp, err := json.Marshal(strct.DefaultResourceSpec); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *JupyterServerAppSettings) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DefaultResourceSpec":
            if err := json.Unmarshal([]byte(v), &strct.DefaultResourceSpec); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *KernelGatewayAppSettings) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CustomImages" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CustomImages\": ")
	if tmp, err := json.Marshal(strct.CustomImages); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DefaultResourceSpec" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DefaultResourceSpec\": ")
	if tmp, err := json.Marshal(strct.DefaultResourceSpec); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *KernelGatewayAppSettings) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CustomImages":
            if err := json.Unmarshal([]byte(v), &strct.CustomImages); err != nil {
                return err
             }
        case "DefaultResourceSpec":
            if err := json.Unmarshal([]byte(v), &strct.DefaultResourceSpec); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *RSessionAppSettings) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CustomImages" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CustomImages\": ")
	if tmp, err := json.Marshal(strct.CustomImages); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DefaultResourceSpec" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DefaultResourceSpec\": ")
	if tmp, err := json.Marshal(strct.DefaultResourceSpec); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RSessionAppSettings) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CustomImages":
            if err := json.Unmarshal([]byte(v), &strct.CustomImages); err != nil {
                return err
             }
        case "DefaultResourceSpec":
            if err := json.Unmarshal([]byte(v), &strct.DefaultResourceSpec); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *RStudioServerProAppSettings) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AccessStatus" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AccessStatus\": ")
	if tmp, err := json.Marshal(strct.AccessStatus); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "UserGroup" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UserGroup\": ")
	if tmp, err := json.Marshal(strct.UserGroup); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RStudioServerProAppSettings) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AccessStatus":
            if err := json.Unmarshal([]byte(v), &strct.AccessStatus); err != nil {
                return err
             }
        case "UserGroup":
            if err := json.Unmarshal([]byte(v), &strct.UserGroup); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *RStudioServerProDomainSettings) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DefaultResourceSpec" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DefaultResourceSpec\": ")
	if tmp, err := json.Marshal(strct.DefaultResourceSpec); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "DomainExecutionRoleArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "DomainExecutionRoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DomainExecutionRoleArn\": ")
	if tmp, err := json.Marshal(strct.DomainExecutionRoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RStudioConnectUrl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RStudioConnectUrl\": ")
	if tmp, err := json.Marshal(strct.RStudioConnectUrl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RStudioPackageManagerUrl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RStudioPackageManagerUrl\": ")
	if tmp, err := json.Marshal(strct.RStudioPackageManagerUrl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RStudioServerProDomainSettings) UnmarshalJSON(b []byte) error {
    DomainExecutionRoleArnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DefaultResourceSpec":
            if err := json.Unmarshal([]byte(v), &strct.DefaultResourceSpec); err != nil {
                return err
             }
        case "DomainExecutionRoleArn":
            if err := json.Unmarshal([]byte(v), &strct.DomainExecutionRoleArn); err != nil {
                return err
             }
            DomainExecutionRoleArnReceived = true
        case "RStudioConnectUrl":
            if err := json.Unmarshal([]byte(v), &strct.RStudioConnectUrl); err != nil {
                return err
             }
        case "RStudioPackageManagerUrl":
            if err := json.Unmarshal([]byte(v), &strct.RStudioPackageManagerUrl); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if DomainExecutionRoleArn (a required property) was received
    if !DomainExecutionRoleArnReceived {
        return errors.New("\"DomainExecutionRoleArn\" is required but was not present")
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AppNetworkAccessType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AppNetworkAccessType\": ")
	if tmp, err := json.Marshal(strct.AppNetworkAccessType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AppSecurityGroupManagement" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AppSecurityGroupManagement\": ")
	if tmp, err := json.Marshal(strct.AppSecurityGroupManagement); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "AuthMode" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AuthMode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AuthMode\": ")
	if tmp, err := json.Marshal(strct.AuthMode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DefaultSpaceSettings" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DefaultSpaceSettings\": ")
	if tmp, err := json.Marshal(strct.DefaultSpaceSettings); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "DefaultUserSettings" field is required
    if strct.DefaultUserSettings == nil {
        return nil, errors.New("DefaultUserSettings is a required field")
    }
    // Marshal the "DefaultUserSettings" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DefaultUserSettings\": ")
	if tmp, err := json.Marshal(strct.DefaultUserSettings); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DomainArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DomainArn\": ")
	if tmp, err := json.Marshal(strct.DomainArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DomainId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DomainId\": ")
	if tmp, err := json.Marshal(strct.DomainId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "DomainName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "DomainName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DomainName\": ")
	if tmp, err := json.Marshal(strct.DomainName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DomainSettings" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DomainSettings\": ")
	if tmp, err := json.Marshal(strct.DomainSettings); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "HomeEfsFileSystemId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HomeEfsFileSystemId\": ")
	if tmp, err := json.Marshal(strct.HomeEfsFileSystemId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "KmsKeyId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KmsKeyId\": ")
	if tmp, err := json.Marshal(strct.KmsKeyId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SecurityGroupIdForDomainBoundary" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SecurityGroupIdForDomainBoundary\": ")
	if tmp, err := json.Marshal(strct.SecurityGroupIdForDomainBoundary); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SingleSignOnManagedApplicationInstanceId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SingleSignOnManagedApplicationInstanceId\": ")
	if tmp, err := json.Marshal(strct.SingleSignOnManagedApplicationInstanceId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "SubnetIds" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "SubnetIds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SubnetIds\": ")
	if tmp, err := json.Marshal(strct.SubnetIds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Url" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Url\": ")
	if tmp, err := json.Marshal(strct.Url); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "VpcId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "VpcId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VpcId\": ")
	if tmp, err := json.Marshal(strct.VpcId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    AuthModeReceived := false
    DefaultUserSettingsReceived := false
    DomainNameReceived := false
    SubnetIdsReceived := false
    VpcIdReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AppNetworkAccessType":
            if err := json.Unmarshal([]byte(v), &strct.AppNetworkAccessType); err != nil {
                return err
             }
        case "AppSecurityGroupManagement":
            if err := json.Unmarshal([]byte(v), &strct.AppSecurityGroupManagement); err != nil {
                return err
             }
        case "AuthMode":
            if err := json.Unmarshal([]byte(v), &strct.AuthMode); err != nil {
                return err
             }
            AuthModeReceived = true
        case "DefaultSpaceSettings":
            if err := json.Unmarshal([]byte(v), &strct.DefaultSpaceSettings); err != nil {
                return err
             }
        case "DefaultUserSettings":
            if err := json.Unmarshal([]byte(v), &strct.DefaultUserSettings); err != nil {
                return err
             }
            DefaultUserSettingsReceived = true
        case "DomainArn":
            if err := json.Unmarshal([]byte(v), &strct.DomainArn); err != nil {
                return err
             }
        case "DomainId":
            if err := json.Unmarshal([]byte(v), &strct.DomainId); err != nil {
                return err
             }
        case "DomainName":
            if err := json.Unmarshal([]byte(v), &strct.DomainName); err != nil {
                return err
             }
            DomainNameReceived = true
        case "DomainSettings":
            if err := json.Unmarshal([]byte(v), &strct.DomainSettings); err != nil {
                return err
             }
        case "HomeEfsFileSystemId":
            if err := json.Unmarshal([]byte(v), &strct.HomeEfsFileSystemId); err != nil {
                return err
             }
        case "KmsKeyId":
            if err := json.Unmarshal([]byte(v), &strct.KmsKeyId); err != nil {
                return err
             }
        case "SecurityGroupIdForDomainBoundary":
            if err := json.Unmarshal([]byte(v), &strct.SecurityGroupIdForDomainBoundary); err != nil {
                return err
             }
        case "SingleSignOnManagedApplicationInstanceId":
            if err := json.Unmarshal([]byte(v), &strct.SingleSignOnManagedApplicationInstanceId); err != nil {
                return err
             }
        case "SubnetIds":
            if err := json.Unmarshal([]byte(v), &strct.SubnetIds); err != nil {
                return err
             }
            SubnetIdsReceived = true
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        case "Url":
            if err := json.Unmarshal([]byte(v), &strct.Url); err != nil {
                return err
             }
        case "VpcId":
            if err := json.Unmarshal([]byte(v), &strct.VpcId); err != nil {
                return err
             }
            VpcIdReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if AuthMode (a required property) was received
    if !AuthModeReceived {
        return errors.New("\"AuthMode\" is required but was not present")
    }
    // check if DefaultUserSettings (a required property) was received
    if !DefaultUserSettingsReceived {
        return errors.New("\"DefaultUserSettings\" is required but was not present")
    }
    // check if DomainName (a required property) was received
    if !DomainNameReceived {
        return errors.New("\"DomainName\" is required but was not present")
    }
    // check if SubnetIds (a required property) was received
    if !SubnetIdsReceived {
        return errors.New("\"SubnetIds\" is required but was not present")
    }
    // check if VpcId (a required property) was received
    if !VpcIdReceived {
        return errors.New("\"VpcId\" is required but was not present")
    }
    return nil
}

func (strct *ResourceSpec) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "InstanceType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InstanceType\": ")
	if tmp, err := json.Marshal(strct.InstanceType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LifecycleConfigArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LifecycleConfigArn\": ")
	if tmp, err := json.Marshal(strct.LifecycleConfigArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SageMakerImageArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SageMakerImageArn\": ")
	if tmp, err := json.Marshal(strct.SageMakerImageArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SageMakerImageVersionArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SageMakerImageVersionArn\": ")
	if tmp, err := json.Marshal(strct.SageMakerImageVersionArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ResourceSpec) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "InstanceType":
            if err := json.Unmarshal([]byte(v), &strct.InstanceType); err != nil {
                return err
             }
        case "LifecycleConfigArn":
            if err := json.Unmarshal([]byte(v), &strct.LifecycleConfigArn); err != nil {
                return err
             }
        case "SageMakerImageArn":
            if err := json.Unmarshal([]byte(v), &strct.SageMakerImageArn); err != nil {
                return err
             }
        case "SageMakerImageVersionArn":
            if err := json.Unmarshal([]byte(v), &strct.SageMakerImageVersionArn); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *SharingSettings) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "NotebookOutputOption" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NotebookOutputOption\": ")
	if tmp, err := json.Marshal(strct.NotebookOutputOption); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "S3KmsKeyId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3KmsKeyId\": ")
	if tmp, err := json.Marshal(strct.S3KmsKeyId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "S3OutputPath" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3OutputPath\": ")
	if tmp, err := json.Marshal(strct.S3OutputPath); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SharingSettings) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "NotebookOutputOption":
            if err := json.Unmarshal([]byte(v), &strct.NotebookOutputOption); err != nil {
                return err
             }
        case "S3KmsKeyId":
            if err := json.Unmarshal([]byte(v), &strct.S3KmsKeyId); err != nil {
                return err
             }
        case "S3OutputPath":
            if err := json.Unmarshal([]byte(v), &strct.S3OutputPath); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *UserSettings) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ExecutionRole" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ExecutionRole\": ")
	if tmp, err := json.Marshal(strct.ExecutionRole); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "JupyterServerAppSettings" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"JupyterServerAppSettings\": ")
	if tmp, err := json.Marshal(strct.JupyterServerAppSettings); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "KernelGatewayAppSettings" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KernelGatewayAppSettings\": ")
	if tmp, err := json.Marshal(strct.KernelGatewayAppSettings); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RSessionAppSettings" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RSessionAppSettings\": ")
	if tmp, err := json.Marshal(strct.RSessionAppSettings); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RStudioServerProAppSettings" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RStudioServerProAppSettings\": ")
	if tmp, err := json.Marshal(strct.RStudioServerProAppSettings); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SecurityGroups" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SecurityGroups\": ")
	if tmp, err := json.Marshal(strct.SecurityGroups); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SharingSettings" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SharingSettings\": ")
	if tmp, err := json.Marshal(strct.SharingSettings); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *UserSettings) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ExecutionRole":
            if err := json.Unmarshal([]byte(v), &strct.ExecutionRole); err != nil {
                return err
             }
        case "JupyterServerAppSettings":
            if err := json.Unmarshal([]byte(v), &strct.JupyterServerAppSettings); err != nil {
                return err
             }
        case "KernelGatewayAppSettings":
            if err := json.Unmarshal([]byte(v), &strct.KernelGatewayAppSettings); err != nil {
                return err
             }
        case "RSessionAppSettings":
            if err := json.Unmarshal([]byte(v), &strct.RSessionAppSettings); err != nil {
                return err
             }
        case "RStudioServerProAppSettings":
            if err := json.Unmarshal([]byte(v), &strct.RStudioServerProAppSettings); err != nil {
                return err
             }
        case "SecurityGroups":
            if err := json.Unmarshal([]byte(v), &strct.SecurityGroups); err != nil {
                return err
             }
        case "SharingSettings":
            if err := json.Unmarshal([]byte(v), &strct.SharingSettings); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}
