// Code generated by schema-generate. DO NOT EDIT.

package featuregroup

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// DataCatalogConfig 
type DataCatalogConfig struct {
  Catalog string `json:"Catalog"`
  Database string `json:"Database"`
  TableName string `json:"TableName"`
}

// FeatureDefinition 
type FeatureDefinition struct {
  FeatureName string `json:"FeatureName"`
  FeatureType string `json:"FeatureType"`
}

// OfflineStoreConfig 
type OfflineStoreConfig struct {
  DataCatalogConfig *DataCatalogConfig `json:"DataCatalogConfig,omitempty"`
  DisableGlueTableCreation bool `json:"DisableGlueTableCreation,omitempty"`
  S3StorageConfig *S3StorageConfig `json:"S3StorageConfig"`
  TableFormat string `json:"TableFormat,omitempty"`
}

// OnlineStoreConfig 
type OnlineStoreConfig struct {
  EnableOnlineStore bool `json:"EnableOnlineStore,omitempty"`
  SecurityConfig *OnlineStoreSecurityConfig `json:"SecurityConfig,omitempty"`
}

// OnlineStoreSecurityConfig 
type OnlineStoreSecurityConfig struct {
  KmsKeyId string `json:"KmsKeyId,omitempty"`
}

// Resource Resource Type definition for AWS::SageMaker::FeatureGroup
type Resource struct {

  // Description about the FeatureGroup.
  Description string `json:"Description,omitempty"`

  // The Event Time Feature Name.
  EventTimeFeatureName string `json:"EventTimeFeatureName"`

  // An Array of Feature Definition
  FeatureDefinitions []*FeatureDefinition `json:"FeatureDefinitions"`

  // The Name of the FeatureGroup.
  FeatureGroupName string `json:"FeatureGroupName"`
  OfflineStoreConfig *OfflineStoreConfig `json:"OfflineStoreConfig,omitempty"`
  OnlineStoreConfig *OnlineStoreConfig `json:"OnlineStoreConfig,omitempty"`

  // The Record Identifier Feature Name.
  RecordIdentifierFeatureName string `json:"RecordIdentifierFeatureName"`

  // Role Arn
  RoleArn string `json:"RoleArn,omitempty"`

  // An array of key-value pair to apply to this resource.
  Tags []*Tag `json:"Tags,omitempty"`
}

// S3StorageConfig 
type S3StorageConfig struct {
  KmsKeyId string `json:"KmsKeyId,omitempty"`
  S3Uri string `json:"S3Uri"`
}

// Tag A key-value pair to associate with a resource.
type Tag struct {
  Key string `json:"Key"`
  Value string `json:"Value"`
}

func (strct *DataCatalogConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Catalog" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Catalog" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Catalog\": ")
	if tmp, err := json.Marshal(strct.Catalog); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Database" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Database" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Database\": ")
	if tmp, err := json.Marshal(strct.Database); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TableName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TableName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TableName\": ")
	if tmp, err := json.Marshal(strct.TableName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DataCatalogConfig) UnmarshalJSON(b []byte) error {
    CatalogReceived := false
    DatabaseReceived := false
    TableNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Catalog":
            if err := json.Unmarshal([]byte(v), &strct.Catalog); err != nil {
                return err
             }
            CatalogReceived = true
        case "Database":
            if err := json.Unmarshal([]byte(v), &strct.Database); err != nil {
                return err
             }
            DatabaseReceived = true
        case "TableName":
            if err := json.Unmarshal([]byte(v), &strct.TableName); err != nil {
                return err
             }
            TableNameReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Catalog (a required property) was received
    if !CatalogReceived {
        return errors.New("\"Catalog\" is required but was not present")
    }
    // check if Database (a required property) was received
    if !DatabaseReceived {
        return errors.New("\"Database\" is required but was not present")
    }
    // check if TableName (a required property) was received
    if !TableNameReceived {
        return errors.New("\"TableName\" is required but was not present")
    }
    return nil
}

func (strct *FeatureDefinition) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "FeatureName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "FeatureName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FeatureName\": ")
	if tmp, err := json.Marshal(strct.FeatureName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "FeatureType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "FeatureType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FeatureType\": ")
	if tmp, err := json.Marshal(strct.FeatureType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FeatureDefinition) UnmarshalJSON(b []byte) error {
    FeatureNameReceived := false
    FeatureTypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "FeatureName":
            if err := json.Unmarshal([]byte(v), &strct.FeatureName); err != nil {
                return err
             }
            FeatureNameReceived = true
        case "FeatureType":
            if err := json.Unmarshal([]byte(v), &strct.FeatureType); err != nil {
                return err
             }
            FeatureTypeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if FeatureName (a required property) was received
    if !FeatureNameReceived {
        return errors.New("\"FeatureName\" is required but was not present")
    }
    // check if FeatureType (a required property) was received
    if !FeatureTypeReceived {
        return errors.New("\"FeatureType\" is required but was not present")
    }
    return nil
}

func (strct *OfflineStoreConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DataCatalogConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DataCatalogConfig\": ")
	if tmp, err := json.Marshal(strct.DataCatalogConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DisableGlueTableCreation" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DisableGlueTableCreation\": ")
	if tmp, err := json.Marshal(strct.DisableGlueTableCreation); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "S3StorageConfig" field is required
    if strct.S3StorageConfig == nil {
        return nil, errors.New("S3StorageConfig is a required field")
    }
    // Marshal the "S3StorageConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3StorageConfig\": ")
	if tmp, err := json.Marshal(strct.S3StorageConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TableFormat" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TableFormat\": ")
	if tmp, err := json.Marshal(strct.TableFormat); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *OfflineStoreConfig) UnmarshalJSON(b []byte) error {
    S3StorageConfigReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DataCatalogConfig":
            if err := json.Unmarshal([]byte(v), &strct.DataCatalogConfig); err != nil {
                return err
             }
        case "DisableGlueTableCreation":
            if err := json.Unmarshal([]byte(v), &strct.DisableGlueTableCreation); err != nil {
                return err
             }
        case "S3StorageConfig":
            if err := json.Unmarshal([]byte(v), &strct.S3StorageConfig); err != nil {
                return err
             }
            S3StorageConfigReceived = true
        case "TableFormat":
            if err := json.Unmarshal([]byte(v), &strct.TableFormat); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if S3StorageConfig (a required property) was received
    if !S3StorageConfigReceived {
        return errors.New("\"S3StorageConfig\" is required but was not present")
    }
    return nil
}

func (strct *OnlineStoreConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "EnableOnlineStore" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EnableOnlineStore\": ")
	if tmp, err := json.Marshal(strct.EnableOnlineStore); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SecurityConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SecurityConfig\": ")
	if tmp, err := json.Marshal(strct.SecurityConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *OnlineStoreConfig) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "EnableOnlineStore":
            if err := json.Unmarshal([]byte(v), &strct.EnableOnlineStore); err != nil {
                return err
             }
        case "SecurityConfig":
            if err := json.Unmarshal([]byte(v), &strct.SecurityConfig); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *OnlineStoreSecurityConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "KmsKeyId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KmsKeyId\": ")
	if tmp, err := json.Marshal(strct.KmsKeyId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *OnlineStoreSecurityConfig) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "KmsKeyId":
            if err := json.Unmarshal([]byte(v), &strct.KmsKeyId); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "EventTimeFeatureName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "EventTimeFeatureName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EventTimeFeatureName\": ")
	if tmp, err := json.Marshal(strct.EventTimeFeatureName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "FeatureDefinitions" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "FeatureDefinitions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FeatureDefinitions\": ")
	if tmp, err := json.Marshal(strct.FeatureDefinitions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "FeatureGroupName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "FeatureGroupName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FeatureGroupName\": ")
	if tmp, err := json.Marshal(strct.FeatureGroupName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OfflineStoreConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OfflineStoreConfig\": ")
	if tmp, err := json.Marshal(strct.OfflineStoreConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OnlineStoreConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OnlineStoreConfig\": ")
	if tmp, err := json.Marshal(strct.OnlineStoreConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RecordIdentifierFeatureName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RecordIdentifierFeatureName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RecordIdentifierFeatureName\": ")
	if tmp, err := json.Marshal(strct.RecordIdentifierFeatureName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoleArn\": ")
	if tmp, err := json.Marshal(strct.RoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    EventTimeFeatureNameReceived := false
    FeatureDefinitionsReceived := false
    FeatureGroupNameReceived := false
    RecordIdentifierFeatureNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "EventTimeFeatureName":
            if err := json.Unmarshal([]byte(v), &strct.EventTimeFeatureName); err != nil {
                return err
             }
            EventTimeFeatureNameReceived = true
        case "FeatureDefinitions":
            if err := json.Unmarshal([]byte(v), &strct.FeatureDefinitions); err != nil {
                return err
             }
            FeatureDefinitionsReceived = true
        case "FeatureGroupName":
            if err := json.Unmarshal([]byte(v), &strct.FeatureGroupName); err != nil {
                return err
             }
            FeatureGroupNameReceived = true
        case "OfflineStoreConfig":
            if err := json.Unmarshal([]byte(v), &strct.OfflineStoreConfig); err != nil {
                return err
             }
        case "OnlineStoreConfig":
            if err := json.Unmarshal([]byte(v), &strct.OnlineStoreConfig); err != nil {
                return err
             }
        case "RecordIdentifierFeatureName":
            if err := json.Unmarshal([]byte(v), &strct.RecordIdentifierFeatureName); err != nil {
                return err
             }
            RecordIdentifierFeatureNameReceived = true
        case "RoleArn":
            if err := json.Unmarshal([]byte(v), &strct.RoleArn); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if EventTimeFeatureName (a required property) was received
    if !EventTimeFeatureNameReceived {
        return errors.New("\"EventTimeFeatureName\" is required but was not present")
    }
    // check if FeatureDefinitions (a required property) was received
    if !FeatureDefinitionsReceived {
        return errors.New("\"FeatureDefinitions\" is required but was not present")
    }
    // check if FeatureGroupName (a required property) was received
    if !FeatureGroupNameReceived {
        return errors.New("\"FeatureGroupName\" is required but was not present")
    }
    // check if RecordIdentifierFeatureName (a required property) was received
    if !RecordIdentifierFeatureNameReceived {
        return errors.New("\"RecordIdentifierFeatureName\" is required but was not present")
    }
    return nil
}

func (strct *S3StorageConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "KmsKeyId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KmsKeyId\": ")
	if tmp, err := json.Marshal(strct.KmsKeyId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "S3Uri" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "S3Uri" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3Uri\": ")
	if tmp, err := json.Marshal(strct.S3Uri); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *S3StorageConfig) UnmarshalJSON(b []byte) error {
    S3UriReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "KmsKeyId":
            if err := json.Unmarshal([]byte(v), &strct.KmsKeyId); err != nil {
                return err
             }
        case "S3Uri":
            if err := json.Unmarshal([]byte(v), &strct.S3Uri); err != nil {
                return err
             }
            S3UriReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if S3Uri (a required property) was received
    if !S3UriReceived {
        return errors.New("\"S3Uri\" is required but was not present")
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}
