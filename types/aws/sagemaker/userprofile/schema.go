// Code generated by schema-generate. DO NOT EDIT.

package userprofile

import (
    "fmt"
    "errors"
    "bytes"
    "encoding/json"
)

// CustomImage A custom SageMaker image.
type CustomImage struct {

  // The Name of the AppImageConfig.
  AppImageConfigName string `json:"AppImageConfigName"`

  // The name of the CustomImage. Must be unique to your account.
  ImageName string `json:"ImageName"`

  // The version number of the CustomImage.
  ImageVersionNumber int `json:"ImageVersionNumber,omitempty"`
}

// JupyterServerAppSettings The JupyterServer app settings.
type JupyterServerAppSettings struct {
  DefaultResourceSpec *ResourceSpec `json:"DefaultResourceSpec,omitempty"`
}

// KernelGatewayAppSettings The kernel gateway app settings.
type KernelGatewayAppSettings struct {

  // A list of custom SageMaker images that are configured to run as a KernelGateway app.
  CustomImages []*CustomImage `json:"CustomImages,omitempty"`

  // The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the KernelGateway app.
  DefaultResourceSpec *ResourceSpec `json:"DefaultResourceSpec,omitempty"`
}

// RStudioServerProAppSettings A collection of settings that configure user interaction with the RStudioServerPro app.
type RStudioServerProAppSettings struct {

  // Indicates whether the current user has access to the RStudioServerPro app.
  AccessStatus string `json:"AccessStatus,omitempty"`

  // The level of permissions that the user has within the RStudioServerPro app. This value defaults to User. The Admin value allows the user access to the RStudio Administrative Dashboard.
  UserGroup string `json:"UserGroup,omitempty"`
}

// Resource Resource Type definition for AWS::SageMaker::UserProfile
type Resource struct {

  // The ID of the associated Domain.
  DomainId string `json:"DomainId"`

  // A specifier for the type of value specified in SingleSignOnUserValue. Currently, the only supported value is "UserName". If the Domain's AuthMode is SSO, this field is required. If the Domain's AuthMode is not SSO, this field cannot be specified.
  SingleSignOnUserIdentifier string `json:"SingleSignOnUserIdentifier,omitempty"`

  // The username of the associated AWS Single Sign-On User for this UserProfile. If the Domain's AuthMode is SSO, this field is required, and must match a valid username of a user in your directory. If the Domain's AuthMode is not SSO, this field cannot be specified.
  SingleSignOnUserValue string `json:"SingleSignOnUserValue,omitempty"`

  // A list of tags to apply to the user profile.
  Tags []*Tag `json:"Tags,omitempty"`

  // The user profile Amazon Resource Name (ARN).
  UserProfileArn string `json:"UserProfileArn,omitempty"`

  // A name for the UserProfile.
  UserProfileName string `json:"UserProfileName"`

  // A collection of settings.
  UserSettings *UserSettings `json:"UserSettings,omitempty"`
}

// ResourceSpec 
type ResourceSpec struct {

  // The instance type that the image version runs on.
  InstanceType string `json:"InstanceType,omitempty"`

  // The ARN of the SageMaker image that the image version belongs to.
  SageMakerImageArn string `json:"SageMakerImageArn,omitempty"`

  // The ARN of the image version created on the instance.
  SageMakerImageVersionArn string `json:"SageMakerImageVersionArn,omitempty"`
}

// SharingSettings Specifies options when sharing an Amazon SageMaker Studio notebook. These settings are specified as part of DefaultUserSettings when the CreateDomain API is called, and as part of UserSettings when the CreateUserProfile API is called.
type SharingSettings struct {

  // Whether to include the notebook cell output when sharing the notebook. The default is Disabled.
  NotebookOutputOption string `json:"NotebookOutputOption,omitempty"`

  // When NotebookOutputOption is Allowed, the AWS Key Management Service (KMS) encryption key ID used to encrypt the notebook cell output in the Amazon S3 bucket.
  S3KmsKeyId string `json:"S3KmsKeyId,omitempty"`

  // When NotebookOutputOption is Allowed, the Amazon S3 bucket used to store the shared notebook snapshots.
  S3OutputPath string `json:"S3OutputPath,omitempty"`
}

// Tag 
type Tag struct {
  Key string `json:"Key"`
  Value string `json:"Value"`
}

// UserSettings A collection of settings that apply to users of Amazon SageMaker Studio. These settings are specified when the CreateUserProfile API is called, and as DefaultUserSettings when the CreateDomain API is called.
type UserSettings struct {

  // The user profile Amazon Resource Name (ARN).
  ExecutionRole string `json:"ExecutionRole,omitempty"`

  // The Jupyter server's app settings.
  JupyterServerAppSettings *JupyterServerAppSettings `json:"JupyterServerAppSettings,omitempty"`

  // The kernel gateway app settings.
  KernelGatewayAppSettings *KernelGatewayAppSettings `json:"KernelGatewayAppSettings,omitempty"`
  RStudioServerProAppSettings *RStudioServerProAppSettings `json:"RStudioServerProAppSettings,omitempty"`

  // The security groups for the Amazon Virtual Private Cloud (VPC) that Studio uses for communication.
  SecurityGroups []string `json:"SecurityGroups,omitempty"`

  // The sharing settings.
  SharingSettings *SharingSettings `json:"SharingSettings,omitempty"`
}

func (strct *CustomImage) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AppImageConfigName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AppImageConfigName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AppImageConfigName\": ")
	if tmp, err := json.Marshal(strct.AppImageConfigName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ImageName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ImageName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ImageName\": ")
	if tmp, err := json.Marshal(strct.ImageName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ImageVersionNumber" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ImageVersionNumber\": ")
	if tmp, err := json.Marshal(strct.ImageVersionNumber); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CustomImage) UnmarshalJSON(b []byte) error {
    AppImageConfigNameReceived := false
    ImageNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AppImageConfigName":
            if err := json.Unmarshal([]byte(v), &strct.AppImageConfigName); err != nil {
                return err
             }
            AppImageConfigNameReceived = true
        case "ImageName":
            if err := json.Unmarshal([]byte(v), &strct.ImageName); err != nil {
                return err
             }
            ImageNameReceived = true
        case "ImageVersionNumber":
            if err := json.Unmarshal([]byte(v), &strct.ImageVersionNumber); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if AppImageConfigName (a required property) was received
    if !AppImageConfigNameReceived {
        return errors.New("\"AppImageConfigName\" is required but was not present")
    }
    // check if ImageName (a required property) was received
    if !ImageNameReceived {
        return errors.New("\"ImageName\" is required but was not present")
    }
    return nil
}

func (strct *JupyterServerAppSettings) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DefaultResourceSpec" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DefaultResourceSpec\": ")
	if tmp, err := json.Marshal(strct.DefaultResourceSpec); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *JupyterServerAppSettings) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DefaultResourceSpec":
            if err := json.Unmarshal([]byte(v), &strct.DefaultResourceSpec); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *KernelGatewayAppSettings) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CustomImages" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CustomImages\": ")
	if tmp, err := json.Marshal(strct.CustomImages); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DefaultResourceSpec" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DefaultResourceSpec\": ")
	if tmp, err := json.Marshal(strct.DefaultResourceSpec); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *KernelGatewayAppSettings) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CustomImages":
            if err := json.Unmarshal([]byte(v), &strct.CustomImages); err != nil {
                return err
             }
        case "DefaultResourceSpec":
            if err := json.Unmarshal([]byte(v), &strct.DefaultResourceSpec); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *RStudioServerProAppSettings) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AccessStatus" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AccessStatus\": ")
	if tmp, err := json.Marshal(strct.AccessStatus); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "UserGroup" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UserGroup\": ")
	if tmp, err := json.Marshal(strct.UserGroup); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RStudioServerProAppSettings) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AccessStatus":
            if err := json.Unmarshal([]byte(v), &strct.AccessStatus); err != nil {
                return err
             }
        case "UserGroup":
            if err := json.Unmarshal([]byte(v), &strct.UserGroup); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "DomainId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "DomainId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DomainId\": ")
	if tmp, err := json.Marshal(strct.DomainId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SingleSignOnUserIdentifier" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SingleSignOnUserIdentifier\": ")
	if tmp, err := json.Marshal(strct.SingleSignOnUserIdentifier); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SingleSignOnUserValue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SingleSignOnUserValue\": ")
	if tmp, err := json.Marshal(strct.SingleSignOnUserValue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "UserProfileArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UserProfileArn\": ")
	if tmp, err := json.Marshal(strct.UserProfileArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "UserProfileName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "UserProfileName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UserProfileName\": ")
	if tmp, err := json.Marshal(strct.UserProfileName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "UserSettings" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UserSettings\": ")
	if tmp, err := json.Marshal(strct.UserSettings); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    DomainIdReceived := false
    UserProfileNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DomainId":
            if err := json.Unmarshal([]byte(v), &strct.DomainId); err != nil {
                return err
             }
            DomainIdReceived = true
        case "SingleSignOnUserIdentifier":
            if err := json.Unmarshal([]byte(v), &strct.SingleSignOnUserIdentifier); err != nil {
                return err
             }
        case "SingleSignOnUserValue":
            if err := json.Unmarshal([]byte(v), &strct.SingleSignOnUserValue); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        case "UserProfileArn":
            if err := json.Unmarshal([]byte(v), &strct.UserProfileArn); err != nil {
                return err
             }
        case "UserProfileName":
            if err := json.Unmarshal([]byte(v), &strct.UserProfileName); err != nil {
                return err
             }
            UserProfileNameReceived = true
        case "UserSettings":
            if err := json.Unmarshal([]byte(v), &strct.UserSettings); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if DomainId (a required property) was received
    if !DomainIdReceived {
        return errors.New("\"DomainId\" is required but was not present")
    }
    // check if UserProfileName (a required property) was received
    if !UserProfileNameReceived {
        return errors.New("\"UserProfileName\" is required but was not present")
    }
    return nil
}

func (strct *ResourceSpec) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "InstanceType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InstanceType\": ")
	if tmp, err := json.Marshal(strct.InstanceType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SageMakerImageArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SageMakerImageArn\": ")
	if tmp, err := json.Marshal(strct.SageMakerImageArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SageMakerImageVersionArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SageMakerImageVersionArn\": ")
	if tmp, err := json.Marshal(strct.SageMakerImageVersionArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ResourceSpec) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "InstanceType":
            if err := json.Unmarshal([]byte(v), &strct.InstanceType); err != nil {
                return err
             }
        case "SageMakerImageArn":
            if err := json.Unmarshal([]byte(v), &strct.SageMakerImageArn); err != nil {
                return err
             }
        case "SageMakerImageVersionArn":
            if err := json.Unmarshal([]byte(v), &strct.SageMakerImageVersionArn); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *SharingSettings) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "NotebookOutputOption" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NotebookOutputOption\": ")
	if tmp, err := json.Marshal(strct.NotebookOutputOption); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "S3KmsKeyId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3KmsKeyId\": ")
	if tmp, err := json.Marshal(strct.S3KmsKeyId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "S3OutputPath" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3OutputPath\": ")
	if tmp, err := json.Marshal(strct.S3OutputPath); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SharingSettings) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "NotebookOutputOption":
            if err := json.Unmarshal([]byte(v), &strct.NotebookOutputOption); err != nil {
                return err
             }
        case "S3KmsKeyId":
            if err := json.Unmarshal([]byte(v), &strct.S3KmsKeyId); err != nil {
                return err
             }
        case "S3OutputPath":
            if err := json.Unmarshal([]byte(v), &strct.S3OutputPath); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *UserSettings) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ExecutionRole" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ExecutionRole\": ")
	if tmp, err := json.Marshal(strct.ExecutionRole); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "JupyterServerAppSettings" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"JupyterServerAppSettings\": ")
	if tmp, err := json.Marshal(strct.JupyterServerAppSettings); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "KernelGatewayAppSettings" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KernelGatewayAppSettings\": ")
	if tmp, err := json.Marshal(strct.KernelGatewayAppSettings); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RStudioServerProAppSettings" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RStudioServerProAppSettings\": ")
	if tmp, err := json.Marshal(strct.RStudioServerProAppSettings); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SecurityGroups" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SecurityGroups\": ")
	if tmp, err := json.Marshal(strct.SecurityGroups); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SharingSettings" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SharingSettings\": ")
	if tmp, err := json.Marshal(strct.SharingSettings); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *UserSettings) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ExecutionRole":
            if err := json.Unmarshal([]byte(v), &strct.ExecutionRole); err != nil {
                return err
             }
        case "JupyterServerAppSettings":
            if err := json.Unmarshal([]byte(v), &strct.JupyterServerAppSettings); err != nil {
                return err
             }
        case "KernelGatewayAppSettings":
            if err := json.Unmarshal([]byte(v), &strct.KernelGatewayAppSettings); err != nil {
                return err
             }
        case "RStudioServerProAppSettings":
            if err := json.Unmarshal([]byte(v), &strct.RStudioServerProAppSettings); err != nil {
                return err
             }
        case "SecurityGroups":
            if err := json.Unmarshal([]byte(v), &strct.SecurityGroups); err != nil {
                return err
             }
        case "SharingSettings":
            if err := json.Unmarshal([]byte(v), &strct.SharingSettings); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}
