// Code generated by schema-generate. DO NOT EDIT.

package scalingpolicy

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// CustomizedMetricSpecification 
type CustomizedMetricSpecification struct {
  Dimensions []*MetricDimension `json:"Dimensions,omitempty"`
  MetricName string `json:"MetricName"`
  Namespace string `json:"Namespace"`
  Statistic string `json:"Statistic"`
  Unit string `json:"Unit,omitempty"`
}

// Metric 
type Metric struct {
  Dimensions []*MetricDimension `json:"Dimensions,omitempty"`
  MetricName string `json:"MetricName"`
  Namespace string `json:"Namespace"`
}

// MetricDataQuery 
type MetricDataQuery struct {
  Expression string `json:"Expression,omitempty"`
  Id string `json:"Id"`
  Label string `json:"Label,omitempty"`
  MetricStat *MetricStat `json:"MetricStat,omitempty"`
  ReturnData bool `json:"ReturnData,omitempty"`
}

// MetricDimension 
type MetricDimension struct {
  Name string `json:"Name"`
  Value string `json:"Value"`
}

// MetricStat 
type MetricStat struct {
  Metric *Metric `json:"Metric"`
  Stat string `json:"Stat"`
  Unit string `json:"Unit,omitempty"`
}

// PredefinedMetricSpecification 
type PredefinedMetricSpecification struct {
  PredefinedMetricType string `json:"PredefinedMetricType"`
  ResourceLabel string `json:"ResourceLabel,omitempty"`
}

// PredictiveScalingConfiguration 
type PredictiveScalingConfiguration struct {
  MaxCapacityBreachBehavior string `json:"MaxCapacityBreachBehavior,omitempty"`
  MaxCapacityBuffer int `json:"MaxCapacityBuffer,omitempty"`
  MetricSpecifications []*PredictiveScalingMetricSpecification `json:"MetricSpecifications"`
  Mode string `json:"Mode,omitempty"`
  SchedulingBufferTime int `json:"SchedulingBufferTime,omitempty"`
}

// PredictiveScalingCustomizedCapacityMetric 
type PredictiveScalingCustomizedCapacityMetric struct {
  MetricDataQueries []*MetricDataQuery `json:"MetricDataQueries"`
}

// PredictiveScalingCustomizedLoadMetric 
type PredictiveScalingCustomizedLoadMetric struct {
  MetricDataQueries []*MetricDataQuery `json:"MetricDataQueries"`
}

// PredictiveScalingCustomizedScalingMetric 
type PredictiveScalingCustomizedScalingMetric struct {
  MetricDataQueries []*MetricDataQuery `json:"MetricDataQueries"`
}

// PredictiveScalingMetricSpecification 
type PredictiveScalingMetricSpecification struct {
  CustomizedCapacityMetricSpecification *PredictiveScalingCustomizedCapacityMetric `json:"CustomizedCapacityMetricSpecification,omitempty"`
  CustomizedLoadMetricSpecification *PredictiveScalingCustomizedLoadMetric `json:"CustomizedLoadMetricSpecification,omitempty"`
  CustomizedScalingMetricSpecification *PredictiveScalingCustomizedScalingMetric `json:"CustomizedScalingMetricSpecification,omitempty"`
  PredefinedLoadMetricSpecification *PredictiveScalingPredefinedLoadMetric `json:"PredefinedLoadMetricSpecification,omitempty"`
  PredefinedMetricPairSpecification *PredictiveScalingPredefinedMetricPair `json:"PredefinedMetricPairSpecification,omitempty"`
  PredefinedScalingMetricSpecification *PredictiveScalingPredefinedScalingMetric `json:"PredefinedScalingMetricSpecification,omitempty"`
  TargetValue float64 `json:"TargetValue"`
}

// PredictiveScalingPredefinedLoadMetric 
type PredictiveScalingPredefinedLoadMetric struct {
  PredefinedMetricType string `json:"PredefinedMetricType"`
  ResourceLabel string `json:"ResourceLabel,omitempty"`
}

// PredictiveScalingPredefinedMetricPair 
type PredictiveScalingPredefinedMetricPair struct {
  PredefinedMetricType string `json:"PredefinedMetricType"`
  ResourceLabel string `json:"ResourceLabel,omitempty"`
}

// PredictiveScalingPredefinedScalingMetric 
type PredictiveScalingPredefinedScalingMetric struct {
  PredefinedMetricType string `json:"PredefinedMetricType"`
  ResourceLabel string `json:"ResourceLabel,omitempty"`
}

// Resource The AWS::AutoScaling::ScalingPolicy resource specifies an Amazon EC2 Auto Scaling scaling policy so that the Auto Scaling group can scale the number of instances available for your application.
type Resource struct {

  // Specifies how the scaling adjustment is interpreted. The valid values are ChangeInCapacity, ExactCapacity, and PercentChangeInCapacity.
  AdjustmentType string `json:"AdjustmentType,omitempty"`

  // The ARN of the AutoScaling scaling policy
  Arn string `json:"Arn,omitempty"`

  // The name of the Auto Scaling group.
  AutoScalingGroupName string `json:"AutoScalingGroupName"`

  // The duration of the policy's cooldown period, in seconds. When a cooldown period is specified here, it overrides the default cooldown period defined for the Auto Scaling group.
  Cooldown string `json:"Cooldown,omitempty"`

  // The estimated time, in seconds, until a newly launched instance can contribute to the CloudWatch metrics. If not provided, the default is to use the value from the default cooldown period for the Auto Scaling group. Valid only if the policy type is TargetTrackingScaling or StepScaling.
  EstimatedInstanceWarmup int `json:"EstimatedInstanceWarmup,omitempty"`

  // The aggregation type for the CloudWatch metrics. The valid values are Minimum, Maximum, and Average. If the aggregation type is null, the value is treated as Average. Valid only if the policy type is StepScaling.
  MetricAggregationType string `json:"MetricAggregationType,omitempty"`

  // The minimum value to scale by when the adjustment type is PercentChangeInCapacity. For example, suppose that you create a step scaling policy to scale out an Auto Scaling group by 25 percent and you specify a MinAdjustmentMagnitude of 2. If the group has 4 instances and the scaling policy is performed, 25 percent of 4 is 1. However, because you specified a MinAdjustmentMagnitude of 2, Amazon EC2 Auto Scaling scales out the group by 2 instances.
  MinAdjustmentMagnitude int `json:"MinAdjustmentMagnitude,omitempty"`
  PolicyName string `json:"PolicyName,omitempty"`

  // One of the following policy types: TargetTrackingScaling, StepScaling, SimpleScaling (default), PredictiveScaling
  PolicyType string `json:"PolicyType,omitempty"`

  // A predictive scaling policy. Includes support for predefined metrics only.
  PredictiveScalingConfiguration *PredictiveScalingConfiguration `json:"PredictiveScalingConfiguration,omitempty"`

  // The amount by which to scale, based on the specified adjustment type. A positive value adds to the current capacity while a negative number removes from the current capacity. For exact capacity, you must specify a positive value. Required if the policy type is SimpleScaling. (Not used with any other policy type.)
  ScalingAdjustment int `json:"ScalingAdjustment,omitempty"`

  // A set of adjustments that enable you to scale based on the size of the alarm breach. Required if the policy type is StepScaling. (Not used with any other policy type.)
  StepAdjustments []*StepAdjustment `json:"StepAdjustments,omitempty"`

  // A target tracking scaling policy. Includes support for predefined or customized metrics.
  TargetTrackingConfiguration *TargetTrackingConfiguration `json:"TargetTrackingConfiguration,omitempty"`
}

// StepAdjustment 
type StepAdjustment struct {
  MetricIntervalLowerBound float64 `json:"MetricIntervalLowerBound,omitempty"`
  MetricIntervalUpperBound float64 `json:"MetricIntervalUpperBound,omitempty"`
  ScalingAdjustment int `json:"ScalingAdjustment"`
}

// TargetTrackingConfiguration 
type TargetTrackingConfiguration struct {
  CustomizedMetricSpecification *CustomizedMetricSpecification `json:"CustomizedMetricSpecification,omitempty"`
  DisableScaleIn bool `json:"DisableScaleIn,omitempty"`
  PredefinedMetricSpecification *PredefinedMetricSpecification `json:"PredefinedMetricSpecification,omitempty"`
  TargetValue float64 `json:"TargetValue"`
}

func (strct *CustomizedMetricSpecification) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Dimensions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Dimensions\": ")
	if tmp, err := json.Marshal(strct.Dimensions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "MetricName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "MetricName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MetricName\": ")
	if tmp, err := json.Marshal(strct.MetricName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Namespace" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Namespace" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Namespace\": ")
	if tmp, err := json.Marshal(strct.Namespace); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Statistic" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Statistic" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Statistic\": ")
	if tmp, err := json.Marshal(strct.Statistic); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Unit" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Unit\": ")
	if tmp, err := json.Marshal(strct.Unit); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CustomizedMetricSpecification) UnmarshalJSON(b []byte) error {
    MetricNameReceived := false
    NamespaceReceived := false
    StatisticReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Dimensions":
            if err := json.Unmarshal([]byte(v), &strct.Dimensions); err != nil {
                return err
             }
        case "MetricName":
            if err := json.Unmarshal([]byte(v), &strct.MetricName); err != nil {
                return err
             }
            MetricNameReceived = true
        case "Namespace":
            if err := json.Unmarshal([]byte(v), &strct.Namespace); err != nil {
                return err
             }
            NamespaceReceived = true
        case "Statistic":
            if err := json.Unmarshal([]byte(v), &strct.Statistic); err != nil {
                return err
             }
            StatisticReceived = true
        case "Unit":
            if err := json.Unmarshal([]byte(v), &strct.Unit); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if MetricName (a required property) was received
    if !MetricNameReceived {
        return errors.New("\"MetricName\" is required but was not present")
    }
    // check if Namespace (a required property) was received
    if !NamespaceReceived {
        return errors.New("\"Namespace\" is required but was not present")
    }
    // check if Statistic (a required property) was received
    if !StatisticReceived {
        return errors.New("\"Statistic\" is required but was not present")
    }
    return nil
}

func (strct *Metric) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Dimensions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Dimensions\": ")
	if tmp, err := json.Marshal(strct.Dimensions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "MetricName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "MetricName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MetricName\": ")
	if tmp, err := json.Marshal(strct.MetricName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Namespace" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Namespace" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Namespace\": ")
	if tmp, err := json.Marshal(strct.Namespace); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Metric) UnmarshalJSON(b []byte) error {
    MetricNameReceived := false
    NamespaceReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Dimensions":
            if err := json.Unmarshal([]byte(v), &strct.Dimensions); err != nil {
                return err
             }
        case "MetricName":
            if err := json.Unmarshal([]byte(v), &strct.MetricName); err != nil {
                return err
             }
            MetricNameReceived = true
        case "Namespace":
            if err := json.Unmarshal([]byte(v), &strct.Namespace); err != nil {
                return err
             }
            NamespaceReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if MetricName (a required property) was received
    if !MetricNameReceived {
        return errors.New("\"MetricName\" is required but was not present")
    }
    // check if Namespace (a required property) was received
    if !NamespaceReceived {
        return errors.New("\"Namespace\" is required but was not present")
    }
    return nil
}

func (strct *MetricDataQuery) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Expression" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Expression\": ")
	if tmp, err := json.Marshal(strct.Expression); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Id" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Id" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Label" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Label\": ")
	if tmp, err := json.Marshal(strct.Label); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MetricStat" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MetricStat\": ")
	if tmp, err := json.Marshal(strct.MetricStat); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ReturnData" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ReturnData\": ")
	if tmp, err := json.Marshal(strct.ReturnData); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MetricDataQuery) UnmarshalJSON(b []byte) error {
    IdReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Expression":
            if err := json.Unmarshal([]byte(v), &strct.Expression); err != nil {
                return err
             }
        case "Id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
            IdReceived = true
        case "Label":
            if err := json.Unmarshal([]byte(v), &strct.Label); err != nil {
                return err
             }
        case "MetricStat":
            if err := json.Unmarshal([]byte(v), &strct.MetricStat); err != nil {
                return err
             }
        case "ReturnData":
            if err := json.Unmarshal([]byte(v), &strct.ReturnData); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Id (a required property) was received
    if !IdReceived {
        return errors.New("\"Id\" is required but was not present")
    }
    return nil
}

func (strct *MetricDimension) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MetricDimension) UnmarshalJSON(b []byte) error {
    NameReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *MetricStat) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Metric" field is required
    if strct.Metric == nil {
        return nil, errors.New("Metric is a required field")
    }
    // Marshal the "Metric" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Metric\": ")
	if tmp, err := json.Marshal(strct.Metric); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Stat" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Stat" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Stat\": ")
	if tmp, err := json.Marshal(strct.Stat); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Unit" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Unit\": ")
	if tmp, err := json.Marshal(strct.Unit); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MetricStat) UnmarshalJSON(b []byte) error {
    MetricReceived := false
    StatReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Metric":
            if err := json.Unmarshal([]byte(v), &strct.Metric); err != nil {
                return err
             }
            MetricReceived = true
        case "Stat":
            if err := json.Unmarshal([]byte(v), &strct.Stat); err != nil {
                return err
             }
            StatReceived = true
        case "Unit":
            if err := json.Unmarshal([]byte(v), &strct.Unit); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Metric (a required property) was received
    if !MetricReceived {
        return errors.New("\"Metric\" is required but was not present")
    }
    // check if Stat (a required property) was received
    if !StatReceived {
        return errors.New("\"Stat\" is required but was not present")
    }
    return nil
}

func (strct *PredefinedMetricSpecification) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "PredefinedMetricType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "PredefinedMetricType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PredefinedMetricType\": ")
	if tmp, err := json.Marshal(strct.PredefinedMetricType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ResourceLabel" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ResourceLabel\": ")
	if tmp, err := json.Marshal(strct.ResourceLabel); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PredefinedMetricSpecification) UnmarshalJSON(b []byte) error {
    PredefinedMetricTypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "PredefinedMetricType":
            if err := json.Unmarshal([]byte(v), &strct.PredefinedMetricType); err != nil {
                return err
             }
            PredefinedMetricTypeReceived = true
        case "ResourceLabel":
            if err := json.Unmarshal([]byte(v), &strct.ResourceLabel); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if PredefinedMetricType (a required property) was received
    if !PredefinedMetricTypeReceived {
        return errors.New("\"PredefinedMetricType\" is required but was not present")
    }
    return nil
}

func (strct *PredictiveScalingConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "MaxCapacityBreachBehavior" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaxCapacityBreachBehavior\": ")
	if tmp, err := json.Marshal(strct.MaxCapacityBreachBehavior); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MaxCapacityBuffer" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaxCapacityBuffer\": ")
	if tmp, err := json.Marshal(strct.MaxCapacityBuffer); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "MetricSpecifications" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "MetricSpecifications" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MetricSpecifications\": ")
	if tmp, err := json.Marshal(strct.MetricSpecifications); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Mode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Mode\": ")
	if tmp, err := json.Marshal(strct.Mode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SchedulingBufferTime" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SchedulingBufferTime\": ")
	if tmp, err := json.Marshal(strct.SchedulingBufferTime); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PredictiveScalingConfiguration) UnmarshalJSON(b []byte) error {
    MetricSpecificationsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "MaxCapacityBreachBehavior":
            if err := json.Unmarshal([]byte(v), &strct.MaxCapacityBreachBehavior); err != nil {
                return err
             }
        case "MaxCapacityBuffer":
            if err := json.Unmarshal([]byte(v), &strct.MaxCapacityBuffer); err != nil {
                return err
             }
        case "MetricSpecifications":
            if err := json.Unmarshal([]byte(v), &strct.MetricSpecifications); err != nil {
                return err
             }
            MetricSpecificationsReceived = true
        case "Mode":
            if err := json.Unmarshal([]byte(v), &strct.Mode); err != nil {
                return err
             }
        case "SchedulingBufferTime":
            if err := json.Unmarshal([]byte(v), &strct.SchedulingBufferTime); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if MetricSpecifications (a required property) was received
    if !MetricSpecificationsReceived {
        return errors.New("\"MetricSpecifications\" is required but was not present")
    }
    return nil
}

func (strct *PredictiveScalingCustomizedCapacityMetric) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "MetricDataQueries" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "MetricDataQueries" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MetricDataQueries\": ")
	if tmp, err := json.Marshal(strct.MetricDataQueries); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PredictiveScalingCustomizedCapacityMetric) UnmarshalJSON(b []byte) error {
    MetricDataQueriesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "MetricDataQueries":
            if err := json.Unmarshal([]byte(v), &strct.MetricDataQueries); err != nil {
                return err
             }
            MetricDataQueriesReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if MetricDataQueries (a required property) was received
    if !MetricDataQueriesReceived {
        return errors.New("\"MetricDataQueries\" is required but was not present")
    }
    return nil
}

func (strct *PredictiveScalingCustomizedLoadMetric) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "MetricDataQueries" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "MetricDataQueries" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MetricDataQueries\": ")
	if tmp, err := json.Marshal(strct.MetricDataQueries); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PredictiveScalingCustomizedLoadMetric) UnmarshalJSON(b []byte) error {
    MetricDataQueriesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "MetricDataQueries":
            if err := json.Unmarshal([]byte(v), &strct.MetricDataQueries); err != nil {
                return err
             }
            MetricDataQueriesReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if MetricDataQueries (a required property) was received
    if !MetricDataQueriesReceived {
        return errors.New("\"MetricDataQueries\" is required but was not present")
    }
    return nil
}

func (strct *PredictiveScalingCustomizedScalingMetric) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "MetricDataQueries" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "MetricDataQueries" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MetricDataQueries\": ")
	if tmp, err := json.Marshal(strct.MetricDataQueries); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PredictiveScalingCustomizedScalingMetric) UnmarshalJSON(b []byte) error {
    MetricDataQueriesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "MetricDataQueries":
            if err := json.Unmarshal([]byte(v), &strct.MetricDataQueries); err != nil {
                return err
             }
            MetricDataQueriesReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if MetricDataQueries (a required property) was received
    if !MetricDataQueriesReceived {
        return errors.New("\"MetricDataQueries\" is required but was not present")
    }
    return nil
}

func (strct *PredictiveScalingMetricSpecification) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CustomizedCapacityMetricSpecification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CustomizedCapacityMetricSpecification\": ")
	if tmp, err := json.Marshal(strct.CustomizedCapacityMetricSpecification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CustomizedLoadMetricSpecification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CustomizedLoadMetricSpecification\": ")
	if tmp, err := json.Marshal(strct.CustomizedLoadMetricSpecification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CustomizedScalingMetricSpecification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CustomizedScalingMetricSpecification\": ")
	if tmp, err := json.Marshal(strct.CustomizedScalingMetricSpecification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PredefinedLoadMetricSpecification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PredefinedLoadMetricSpecification\": ")
	if tmp, err := json.Marshal(strct.PredefinedLoadMetricSpecification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PredefinedMetricPairSpecification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PredefinedMetricPairSpecification\": ")
	if tmp, err := json.Marshal(strct.PredefinedMetricPairSpecification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PredefinedScalingMetricSpecification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PredefinedScalingMetricSpecification\": ")
	if tmp, err := json.Marshal(strct.PredefinedScalingMetricSpecification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TargetValue" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TargetValue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TargetValue\": ")
	if tmp, err := json.Marshal(strct.TargetValue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PredictiveScalingMetricSpecification) UnmarshalJSON(b []byte) error {
    TargetValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CustomizedCapacityMetricSpecification":
            if err := json.Unmarshal([]byte(v), &strct.CustomizedCapacityMetricSpecification); err != nil {
                return err
             }
        case "CustomizedLoadMetricSpecification":
            if err := json.Unmarshal([]byte(v), &strct.CustomizedLoadMetricSpecification); err != nil {
                return err
             }
        case "CustomizedScalingMetricSpecification":
            if err := json.Unmarshal([]byte(v), &strct.CustomizedScalingMetricSpecification); err != nil {
                return err
             }
        case "PredefinedLoadMetricSpecification":
            if err := json.Unmarshal([]byte(v), &strct.PredefinedLoadMetricSpecification); err != nil {
                return err
             }
        case "PredefinedMetricPairSpecification":
            if err := json.Unmarshal([]byte(v), &strct.PredefinedMetricPairSpecification); err != nil {
                return err
             }
        case "PredefinedScalingMetricSpecification":
            if err := json.Unmarshal([]byte(v), &strct.PredefinedScalingMetricSpecification); err != nil {
                return err
             }
        case "TargetValue":
            if err := json.Unmarshal([]byte(v), &strct.TargetValue); err != nil {
                return err
             }
            TargetValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if TargetValue (a required property) was received
    if !TargetValueReceived {
        return errors.New("\"TargetValue\" is required but was not present")
    }
    return nil
}

func (strct *PredictiveScalingPredefinedLoadMetric) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "PredefinedMetricType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "PredefinedMetricType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PredefinedMetricType\": ")
	if tmp, err := json.Marshal(strct.PredefinedMetricType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ResourceLabel" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ResourceLabel\": ")
	if tmp, err := json.Marshal(strct.ResourceLabel); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PredictiveScalingPredefinedLoadMetric) UnmarshalJSON(b []byte) error {
    PredefinedMetricTypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "PredefinedMetricType":
            if err := json.Unmarshal([]byte(v), &strct.PredefinedMetricType); err != nil {
                return err
             }
            PredefinedMetricTypeReceived = true
        case "ResourceLabel":
            if err := json.Unmarshal([]byte(v), &strct.ResourceLabel); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if PredefinedMetricType (a required property) was received
    if !PredefinedMetricTypeReceived {
        return errors.New("\"PredefinedMetricType\" is required but was not present")
    }
    return nil
}

func (strct *PredictiveScalingPredefinedMetricPair) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "PredefinedMetricType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "PredefinedMetricType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PredefinedMetricType\": ")
	if tmp, err := json.Marshal(strct.PredefinedMetricType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ResourceLabel" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ResourceLabel\": ")
	if tmp, err := json.Marshal(strct.ResourceLabel); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PredictiveScalingPredefinedMetricPair) UnmarshalJSON(b []byte) error {
    PredefinedMetricTypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "PredefinedMetricType":
            if err := json.Unmarshal([]byte(v), &strct.PredefinedMetricType); err != nil {
                return err
             }
            PredefinedMetricTypeReceived = true
        case "ResourceLabel":
            if err := json.Unmarshal([]byte(v), &strct.ResourceLabel); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if PredefinedMetricType (a required property) was received
    if !PredefinedMetricTypeReceived {
        return errors.New("\"PredefinedMetricType\" is required but was not present")
    }
    return nil
}

func (strct *PredictiveScalingPredefinedScalingMetric) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "PredefinedMetricType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "PredefinedMetricType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PredefinedMetricType\": ")
	if tmp, err := json.Marshal(strct.PredefinedMetricType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ResourceLabel" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ResourceLabel\": ")
	if tmp, err := json.Marshal(strct.ResourceLabel); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PredictiveScalingPredefinedScalingMetric) UnmarshalJSON(b []byte) error {
    PredefinedMetricTypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "PredefinedMetricType":
            if err := json.Unmarshal([]byte(v), &strct.PredefinedMetricType); err != nil {
                return err
             }
            PredefinedMetricTypeReceived = true
        case "ResourceLabel":
            if err := json.Unmarshal([]byte(v), &strct.ResourceLabel); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if PredefinedMetricType (a required property) was received
    if !PredefinedMetricTypeReceived {
        return errors.New("\"PredefinedMetricType\" is required but was not present")
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AdjustmentType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AdjustmentType\": ")
	if tmp, err := json.Marshal(strct.AdjustmentType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Arn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Arn\": ")
	if tmp, err := json.Marshal(strct.Arn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "AutoScalingGroupName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AutoScalingGroupName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AutoScalingGroupName\": ")
	if tmp, err := json.Marshal(strct.AutoScalingGroupName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Cooldown" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Cooldown\": ")
	if tmp, err := json.Marshal(strct.Cooldown); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EstimatedInstanceWarmup" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EstimatedInstanceWarmup\": ")
	if tmp, err := json.Marshal(strct.EstimatedInstanceWarmup); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MetricAggregationType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MetricAggregationType\": ")
	if tmp, err := json.Marshal(strct.MetricAggregationType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MinAdjustmentMagnitude" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MinAdjustmentMagnitude\": ")
	if tmp, err := json.Marshal(strct.MinAdjustmentMagnitude); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PolicyName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PolicyName\": ")
	if tmp, err := json.Marshal(strct.PolicyName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PolicyType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PolicyType\": ")
	if tmp, err := json.Marshal(strct.PolicyType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PredictiveScalingConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PredictiveScalingConfiguration\": ")
	if tmp, err := json.Marshal(strct.PredictiveScalingConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ScalingAdjustment" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ScalingAdjustment\": ")
	if tmp, err := json.Marshal(strct.ScalingAdjustment); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StepAdjustments" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StepAdjustments\": ")
	if tmp, err := json.Marshal(strct.StepAdjustments); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TargetTrackingConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TargetTrackingConfiguration\": ")
	if tmp, err := json.Marshal(strct.TargetTrackingConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    AutoScalingGroupNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AdjustmentType":
            if err := json.Unmarshal([]byte(v), &strct.AdjustmentType); err != nil {
                return err
             }
        case "Arn":
            if err := json.Unmarshal([]byte(v), &strct.Arn); err != nil {
                return err
             }
        case "AutoScalingGroupName":
            if err := json.Unmarshal([]byte(v), &strct.AutoScalingGroupName); err != nil {
                return err
             }
            AutoScalingGroupNameReceived = true
        case "Cooldown":
            if err := json.Unmarshal([]byte(v), &strct.Cooldown); err != nil {
                return err
             }
        case "EstimatedInstanceWarmup":
            if err := json.Unmarshal([]byte(v), &strct.EstimatedInstanceWarmup); err != nil {
                return err
             }
        case "MetricAggregationType":
            if err := json.Unmarshal([]byte(v), &strct.MetricAggregationType); err != nil {
                return err
             }
        case "MinAdjustmentMagnitude":
            if err := json.Unmarshal([]byte(v), &strct.MinAdjustmentMagnitude); err != nil {
                return err
             }
        case "PolicyName":
            if err := json.Unmarshal([]byte(v), &strct.PolicyName); err != nil {
                return err
             }
        case "PolicyType":
            if err := json.Unmarshal([]byte(v), &strct.PolicyType); err != nil {
                return err
             }
        case "PredictiveScalingConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.PredictiveScalingConfiguration); err != nil {
                return err
             }
        case "ScalingAdjustment":
            if err := json.Unmarshal([]byte(v), &strct.ScalingAdjustment); err != nil {
                return err
             }
        case "StepAdjustments":
            if err := json.Unmarshal([]byte(v), &strct.StepAdjustments); err != nil {
                return err
             }
        case "TargetTrackingConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.TargetTrackingConfiguration); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if AutoScalingGroupName (a required property) was received
    if !AutoScalingGroupNameReceived {
        return errors.New("\"AutoScalingGroupName\" is required but was not present")
    }
    return nil
}

func (strct *StepAdjustment) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "MetricIntervalLowerBound" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MetricIntervalLowerBound\": ")
	if tmp, err := json.Marshal(strct.MetricIntervalLowerBound); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MetricIntervalUpperBound" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MetricIntervalUpperBound\": ")
	if tmp, err := json.Marshal(strct.MetricIntervalUpperBound); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ScalingAdjustment" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ScalingAdjustment" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ScalingAdjustment\": ")
	if tmp, err := json.Marshal(strct.ScalingAdjustment); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *StepAdjustment) UnmarshalJSON(b []byte) error {
    ScalingAdjustmentReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "MetricIntervalLowerBound":
            if err := json.Unmarshal([]byte(v), &strct.MetricIntervalLowerBound); err != nil {
                return err
             }
        case "MetricIntervalUpperBound":
            if err := json.Unmarshal([]byte(v), &strct.MetricIntervalUpperBound); err != nil {
                return err
             }
        case "ScalingAdjustment":
            if err := json.Unmarshal([]byte(v), &strct.ScalingAdjustment); err != nil {
                return err
             }
            ScalingAdjustmentReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ScalingAdjustment (a required property) was received
    if !ScalingAdjustmentReceived {
        return errors.New("\"ScalingAdjustment\" is required but was not present")
    }
    return nil
}

func (strct *TargetTrackingConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CustomizedMetricSpecification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CustomizedMetricSpecification\": ")
	if tmp, err := json.Marshal(strct.CustomizedMetricSpecification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DisableScaleIn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DisableScaleIn\": ")
	if tmp, err := json.Marshal(strct.DisableScaleIn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PredefinedMetricSpecification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PredefinedMetricSpecification\": ")
	if tmp, err := json.Marshal(strct.PredefinedMetricSpecification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TargetValue" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TargetValue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TargetValue\": ")
	if tmp, err := json.Marshal(strct.TargetValue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TargetTrackingConfiguration) UnmarshalJSON(b []byte) error {
    TargetValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CustomizedMetricSpecification":
            if err := json.Unmarshal([]byte(v), &strct.CustomizedMetricSpecification); err != nil {
                return err
             }
        case "DisableScaleIn":
            if err := json.Unmarshal([]byte(v), &strct.DisableScaleIn); err != nil {
                return err
             }
        case "PredefinedMetricSpecification":
            if err := json.Unmarshal([]byte(v), &strct.PredefinedMetricSpecification); err != nil {
                return err
             }
        case "TargetValue":
            if err := json.Unmarshal([]byte(v), &strct.TargetValue); err != nil {
                return err
             }
            TargetValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if TargetValue (a required property) was received
    if !TargetValueReceived {
        return errors.New("\"TargetValue\" is required but was not present")
    }
    return nil
}
