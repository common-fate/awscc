// Code generated by schema-generate. DO NOT EDIT.

package cluster

import (
    "fmt"
    "errors"
    "bytes"
    "encoding/json"
)

// BrokerLogs 
type BrokerLogs struct {
  CloudWatchLogs *CloudWatchLogs `json:"CloudWatchLogs,omitempty"`
  Firehose *Firehose `json:"Firehose,omitempty"`
  S3 *S3 `json:"S3,omitempty"`
}

// BrokerNodeGroupInfo 
type BrokerNodeGroupInfo struct {
  BrokerAZDistribution string `json:"BrokerAZDistribution,omitempty"`
  ClientSubnets []string `json:"ClientSubnets"`
  ConnectivityInfo *ConnectivityInfo `json:"ConnectivityInfo,omitempty"`
  InstanceType string `json:"InstanceType"`
  SecurityGroups []string `json:"SecurityGroups,omitempty"`
  StorageInfo *StorageInfo `json:"StorageInfo,omitempty"`
}

// ClientAuthentication 
type ClientAuthentication struct {
  Sasl *Sasl `json:"Sasl,omitempty"`
  Tls *Tls `json:"Tls,omitempty"`
  Unauthenticated *Unauthenticated `json:"Unauthenticated,omitempty"`
}

// CloudWatchLogs 
type CloudWatchLogs struct {
  Enabled bool `json:"Enabled"`
  LogGroup string `json:"LogGroup,omitempty"`
}

// ConfigurationInfo 
type ConfigurationInfo struct {
  Arn string `json:"Arn"`
  Revision int `json:"Revision"`
}

// ConnectivityInfo 
type ConnectivityInfo struct {
  PublicAccess *PublicAccess `json:"PublicAccess,omitempty"`
  VpcConnectivity *VpcConnectivity `json:"VpcConnectivity,omitempty"`
}

// EBSStorageInfo 
type EBSStorageInfo struct {
  ProvisionedThroughput *ProvisionedThroughput `json:"ProvisionedThroughput,omitempty"`
  VolumeSize int `json:"VolumeSize,omitempty"`
}

// EncryptionAtRest 
type EncryptionAtRest struct {
  DataVolumeKMSKeyId string `json:"DataVolumeKMSKeyId"`
}

// EncryptionInTransit 
type EncryptionInTransit struct {
  ClientBroker string `json:"ClientBroker,omitempty"`
  InCluster bool `json:"InCluster,omitempty"`
}

// EncryptionInfo 
type EncryptionInfo struct {
  EncryptionAtRest *EncryptionAtRest `json:"EncryptionAtRest,omitempty"`
  EncryptionInTransit *EncryptionInTransit `json:"EncryptionInTransit,omitempty"`
}

// Firehose 
type Firehose struct {
  DeliveryStream string `json:"DeliveryStream,omitempty"`
  Enabled bool `json:"Enabled"`
}

// Iam 
type Iam struct {
  Enabled bool `json:"Enabled"`
}

// JmxExporter 
type JmxExporter struct {
  EnabledInBroker bool `json:"EnabledInBroker"`
}

// LoggingInfo 
type LoggingInfo struct {
  BrokerLogs *BrokerLogs `json:"BrokerLogs"`
}

// NodeExporter 
type NodeExporter struct {
  EnabledInBroker bool `json:"EnabledInBroker"`
}

// OpenMonitoring 
type OpenMonitoring struct {
  Prometheus *Prometheus `json:"Prometheus"`
}

// Prometheus 
type Prometheus struct {
  JmxExporter *JmxExporter `json:"JmxExporter,omitempty"`
  NodeExporter *NodeExporter `json:"NodeExporter,omitempty"`
}

// ProvisionedThroughput 
type ProvisionedThroughput struct {
  Enabled bool `json:"Enabled,omitempty"`
  VolumeThroughput int `json:"VolumeThroughput,omitempty"`
}

// PublicAccess 
type PublicAccess struct {
  Type string `json:"Type,omitempty"`
}

// Resource Resource Type definition for AWS::MSK::Cluster
type Resource struct {
  Arn string `json:"Arn,omitempty"`
  BrokerNodeGroupInfo *BrokerNodeGroupInfo `json:"BrokerNodeGroupInfo"`
  ClientAuthentication *ClientAuthentication `json:"ClientAuthentication,omitempty"`
  ClusterName string `json:"ClusterName"`
  ConfigurationInfo *ConfigurationInfo `json:"ConfigurationInfo,omitempty"`

  // The current version of the MSK cluster
  CurrentVersion string `json:"CurrentVersion,omitempty"`
  EncryptionInfo *EncryptionInfo `json:"EncryptionInfo,omitempty"`
  EnhancedMonitoring string `json:"EnhancedMonitoring,omitempty"`
  KafkaVersion string `json:"KafkaVersion"`
  LoggingInfo *LoggingInfo `json:"LoggingInfo,omitempty"`
  NumberOfBrokerNodes int `json:"NumberOfBrokerNodes"`
  OpenMonitoring *OpenMonitoring `json:"OpenMonitoring,omitempty"`
  StorageMode string `json:"StorageMode,omitempty"`

  // A key-value pair to associate with a resource.
  Tags *Tags `json:"Tags,omitempty"`
}

// S3 
type S3 struct {
  Bucket string `json:"Bucket,omitempty"`
  Enabled bool `json:"Enabled"`
  Prefix string `json:"Prefix,omitempty"`
}

// Sasl 
type Sasl struct {
  Iam *Iam `json:"Iam,omitempty"`
  Scram *Scram `json:"Scram,omitempty"`
}

// Scram 
type Scram struct {
  Enabled bool `json:"Enabled"`
}

// StorageInfo 
type StorageInfo struct {
  EBSStorageInfo *EBSStorageInfo `json:"EBSStorageInfo,omitempty"`
}

// Tags A key-value pair to associate with a resource.
type Tags struct {
}

// Tls 
type Tls struct {
  CertificateAuthorityArnList []string `json:"CertificateAuthorityArnList,omitempty"`
  Enabled bool `json:"Enabled,omitempty"`
}

// Unauthenticated 
type Unauthenticated struct {
  Enabled bool `json:"Enabled"`
}

// VpcConnectivity 
type VpcConnectivity struct {
  ClientAuthentication *VpcConnectivityClientAuthentication `json:"ClientAuthentication,omitempty"`
}

// VpcConnectivityClientAuthentication 
type VpcConnectivityClientAuthentication struct {
  Sasl *VpcConnectivitySasl `json:"Sasl,omitempty"`
  Tls *VpcConnectivityTls `json:"Tls,omitempty"`
}

// VpcConnectivityIam 
type VpcConnectivityIam struct {
  Enabled bool `json:"Enabled"`
}

// VpcConnectivitySasl 
type VpcConnectivitySasl struct {
  Iam *VpcConnectivityIam `json:"Iam,omitempty"`
  Scram *VpcConnectivityScram `json:"Scram,omitempty"`
}

// VpcConnectivityScram 
type VpcConnectivityScram struct {
  Enabled bool `json:"Enabled"`
}

// VpcConnectivityTls 
type VpcConnectivityTls struct {
  Enabled bool `json:"Enabled"`
}

func (strct *BrokerLogs) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CloudWatchLogs" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CloudWatchLogs\": ")
	if tmp, err := json.Marshal(strct.CloudWatchLogs); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Firehose" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Firehose\": ")
	if tmp, err := json.Marshal(strct.Firehose); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "S3" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"S3\": ")
	if tmp, err := json.Marshal(strct.S3); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BrokerLogs) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CloudWatchLogs":
            if err := json.Unmarshal([]byte(v), &strct.CloudWatchLogs); err != nil {
                return err
             }
        case "Firehose":
            if err := json.Unmarshal([]byte(v), &strct.Firehose); err != nil {
                return err
             }
        case "S3":
            if err := json.Unmarshal([]byte(v), &strct.S3); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *BrokerNodeGroupInfo) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "BrokerAZDistribution" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BrokerAZDistribution\": ")
	if tmp, err := json.Marshal(strct.BrokerAZDistribution); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ClientSubnets" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ClientSubnets" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ClientSubnets\": ")
	if tmp, err := json.Marshal(strct.ClientSubnets); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ConnectivityInfo" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConnectivityInfo\": ")
	if tmp, err := json.Marshal(strct.ConnectivityInfo); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "InstanceType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "InstanceType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InstanceType\": ")
	if tmp, err := json.Marshal(strct.InstanceType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SecurityGroups" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SecurityGroups\": ")
	if tmp, err := json.Marshal(strct.SecurityGroups); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StorageInfo" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StorageInfo\": ")
	if tmp, err := json.Marshal(strct.StorageInfo); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BrokerNodeGroupInfo) UnmarshalJSON(b []byte) error {
    ClientSubnetsReceived := false
    InstanceTypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BrokerAZDistribution":
            if err := json.Unmarshal([]byte(v), &strct.BrokerAZDistribution); err != nil {
                return err
             }
        case "ClientSubnets":
            if err := json.Unmarshal([]byte(v), &strct.ClientSubnets); err != nil {
                return err
             }
            ClientSubnetsReceived = true
        case "ConnectivityInfo":
            if err := json.Unmarshal([]byte(v), &strct.ConnectivityInfo); err != nil {
                return err
             }
        case "InstanceType":
            if err := json.Unmarshal([]byte(v), &strct.InstanceType); err != nil {
                return err
             }
            InstanceTypeReceived = true
        case "SecurityGroups":
            if err := json.Unmarshal([]byte(v), &strct.SecurityGroups); err != nil {
                return err
             }
        case "StorageInfo":
            if err := json.Unmarshal([]byte(v), &strct.StorageInfo); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if ClientSubnets (a required property) was received
    if !ClientSubnetsReceived {
        return errors.New("\"ClientSubnets\" is required but was not present")
    }
    // check if InstanceType (a required property) was received
    if !InstanceTypeReceived {
        return errors.New("\"InstanceType\" is required but was not present")
    }
    return nil
}

func (strct *ClientAuthentication) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Sasl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Sasl\": ")
	if tmp, err := json.Marshal(strct.Sasl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tls" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tls\": ")
	if tmp, err := json.Marshal(strct.Tls); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Unauthenticated" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Unauthenticated\": ")
	if tmp, err := json.Marshal(strct.Unauthenticated); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ClientAuthentication) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Sasl":
            if err := json.Unmarshal([]byte(v), &strct.Sasl); err != nil {
                return err
             }
        case "Tls":
            if err := json.Unmarshal([]byte(v), &strct.Tls); err != nil {
                return err
             }
        case "Unauthenticated":
            if err := json.Unmarshal([]byte(v), &strct.Unauthenticated); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *CloudWatchLogs) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Enabled" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Enabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LogGroup" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LogGroup\": ")
	if tmp, err := json.Marshal(strct.LogGroup); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CloudWatchLogs) UnmarshalJSON(b []byte) error {
    EnabledReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Enabled":
            if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
                return err
             }
            EnabledReceived = true
        case "LogGroup":
            if err := json.Unmarshal([]byte(v), &strct.LogGroup); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Enabled (a required property) was received
    if !EnabledReceived {
        return errors.New("\"Enabled\" is required but was not present")
    }
    return nil
}

func (strct *ConfigurationInfo) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Arn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Arn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Arn\": ")
	if tmp, err := json.Marshal(strct.Arn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Revision" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Revision" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Revision\": ")
	if tmp, err := json.Marshal(strct.Revision); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ConfigurationInfo) UnmarshalJSON(b []byte) error {
    ArnReceived := false
    RevisionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Arn":
            if err := json.Unmarshal([]byte(v), &strct.Arn); err != nil {
                return err
             }
            ArnReceived = true
        case "Revision":
            if err := json.Unmarshal([]byte(v), &strct.Revision); err != nil {
                return err
             }
            RevisionReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Arn (a required property) was received
    if !ArnReceived {
        return errors.New("\"Arn\" is required but was not present")
    }
    // check if Revision (a required property) was received
    if !RevisionReceived {
        return errors.New("\"Revision\" is required but was not present")
    }
    return nil
}

func (strct *ConnectivityInfo) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "PublicAccess" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PublicAccess\": ")
	if tmp, err := json.Marshal(strct.PublicAccess); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VpcConnectivity" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VpcConnectivity\": ")
	if tmp, err := json.Marshal(strct.VpcConnectivity); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ConnectivityInfo) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "PublicAccess":
            if err := json.Unmarshal([]byte(v), &strct.PublicAccess); err != nil {
                return err
             }
        case "VpcConnectivity":
            if err := json.Unmarshal([]byte(v), &strct.VpcConnectivity); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *EBSStorageInfo) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ProvisionedThroughput" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ProvisionedThroughput\": ")
	if tmp, err := json.Marshal(strct.ProvisionedThroughput); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VolumeSize" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VolumeSize\": ")
	if tmp, err := json.Marshal(strct.VolumeSize); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *EBSStorageInfo) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ProvisionedThroughput":
            if err := json.Unmarshal([]byte(v), &strct.ProvisionedThroughput); err != nil {
                return err
             }
        case "VolumeSize":
            if err := json.Unmarshal([]byte(v), &strct.VolumeSize); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *EncryptionAtRest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "DataVolumeKMSKeyId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "DataVolumeKMSKeyId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DataVolumeKMSKeyId\": ")
	if tmp, err := json.Marshal(strct.DataVolumeKMSKeyId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *EncryptionAtRest) UnmarshalJSON(b []byte) error {
    DataVolumeKMSKeyIdReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DataVolumeKMSKeyId":
            if err := json.Unmarshal([]byte(v), &strct.DataVolumeKMSKeyId); err != nil {
                return err
             }
            DataVolumeKMSKeyIdReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if DataVolumeKMSKeyId (a required property) was received
    if !DataVolumeKMSKeyIdReceived {
        return errors.New("\"DataVolumeKMSKeyId\" is required but was not present")
    }
    return nil
}

func (strct *EncryptionInTransit) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ClientBroker" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ClientBroker\": ")
	if tmp, err := json.Marshal(strct.ClientBroker); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "InCluster" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InCluster\": ")
	if tmp, err := json.Marshal(strct.InCluster); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *EncryptionInTransit) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ClientBroker":
            if err := json.Unmarshal([]byte(v), &strct.ClientBroker); err != nil {
                return err
             }
        case "InCluster":
            if err := json.Unmarshal([]byte(v), &strct.InCluster); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *EncryptionInfo) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "EncryptionAtRest" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EncryptionAtRest\": ")
	if tmp, err := json.Marshal(strct.EncryptionAtRest); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EncryptionInTransit" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EncryptionInTransit\": ")
	if tmp, err := json.Marshal(strct.EncryptionInTransit); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *EncryptionInfo) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "EncryptionAtRest":
            if err := json.Unmarshal([]byte(v), &strct.EncryptionAtRest); err != nil {
                return err
             }
        case "EncryptionInTransit":
            if err := json.Unmarshal([]byte(v), &strct.EncryptionInTransit); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Firehose) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DeliveryStream" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DeliveryStream\": ")
	if tmp, err := json.Marshal(strct.DeliveryStream); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Enabled" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Enabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Firehose) UnmarshalJSON(b []byte) error {
    EnabledReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DeliveryStream":
            if err := json.Unmarshal([]byte(v), &strct.DeliveryStream); err != nil {
                return err
             }
        case "Enabled":
            if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
                return err
             }
            EnabledReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Enabled (a required property) was received
    if !EnabledReceived {
        return errors.New("\"Enabled\" is required but was not present")
    }
    return nil
}

func (strct *Iam) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Enabled" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Enabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Iam) UnmarshalJSON(b []byte) error {
    EnabledReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Enabled":
            if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
                return err
             }
            EnabledReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Enabled (a required property) was received
    if !EnabledReceived {
        return errors.New("\"Enabled\" is required but was not present")
    }
    return nil
}

func (strct *JmxExporter) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "EnabledInBroker" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "EnabledInBroker" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EnabledInBroker\": ")
	if tmp, err := json.Marshal(strct.EnabledInBroker); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *JmxExporter) UnmarshalJSON(b []byte) error {
    EnabledInBrokerReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "EnabledInBroker":
            if err := json.Unmarshal([]byte(v), &strct.EnabledInBroker); err != nil {
                return err
             }
            EnabledInBrokerReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if EnabledInBroker (a required property) was received
    if !EnabledInBrokerReceived {
        return errors.New("\"EnabledInBroker\" is required but was not present")
    }
    return nil
}

func (strct *LoggingInfo) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "BrokerLogs" field is required
    if strct.BrokerLogs == nil {
        return nil, errors.New("BrokerLogs is a required field")
    }
    // Marshal the "BrokerLogs" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BrokerLogs\": ")
	if tmp, err := json.Marshal(strct.BrokerLogs); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LoggingInfo) UnmarshalJSON(b []byte) error {
    BrokerLogsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BrokerLogs":
            if err := json.Unmarshal([]byte(v), &strct.BrokerLogs); err != nil {
                return err
             }
            BrokerLogsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if BrokerLogs (a required property) was received
    if !BrokerLogsReceived {
        return errors.New("\"BrokerLogs\" is required but was not present")
    }
    return nil
}

func (strct *NodeExporter) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "EnabledInBroker" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "EnabledInBroker" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EnabledInBroker\": ")
	if tmp, err := json.Marshal(strct.EnabledInBroker); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *NodeExporter) UnmarshalJSON(b []byte) error {
    EnabledInBrokerReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "EnabledInBroker":
            if err := json.Unmarshal([]byte(v), &strct.EnabledInBroker); err != nil {
                return err
             }
            EnabledInBrokerReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if EnabledInBroker (a required property) was received
    if !EnabledInBrokerReceived {
        return errors.New("\"EnabledInBroker\" is required but was not present")
    }
    return nil
}

func (strct *OpenMonitoring) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Prometheus" field is required
    if strct.Prometheus == nil {
        return nil, errors.New("Prometheus is a required field")
    }
    // Marshal the "Prometheus" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Prometheus\": ")
	if tmp, err := json.Marshal(strct.Prometheus); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *OpenMonitoring) UnmarshalJSON(b []byte) error {
    PrometheusReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Prometheus":
            if err := json.Unmarshal([]byte(v), &strct.Prometheus); err != nil {
                return err
             }
            PrometheusReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Prometheus (a required property) was received
    if !PrometheusReceived {
        return errors.New("\"Prometheus\" is required but was not present")
    }
    return nil
}

func (strct *Prometheus) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "JmxExporter" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"JmxExporter\": ")
	if tmp, err := json.Marshal(strct.JmxExporter); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "NodeExporter" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NodeExporter\": ")
	if tmp, err := json.Marshal(strct.NodeExporter); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Prometheus) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "JmxExporter":
            if err := json.Unmarshal([]byte(v), &strct.JmxExporter); err != nil {
                return err
             }
        case "NodeExporter":
            if err := json.Unmarshal([]byte(v), &strct.NodeExporter); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ProvisionedThroughput) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Enabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VolumeThroughput" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VolumeThroughput\": ")
	if tmp, err := json.Marshal(strct.VolumeThroughput); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ProvisionedThroughput) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Enabled":
            if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
                return err
             }
        case "VolumeThroughput":
            if err := json.Unmarshal([]byte(v), &strct.VolumeThroughput); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *PublicAccess) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PublicAccess) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Arn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Arn\": ")
	if tmp, err := json.Marshal(strct.Arn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "BrokerNodeGroupInfo" field is required
    if strct.BrokerNodeGroupInfo == nil {
        return nil, errors.New("BrokerNodeGroupInfo is a required field")
    }
    // Marshal the "BrokerNodeGroupInfo" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BrokerNodeGroupInfo\": ")
	if tmp, err := json.Marshal(strct.BrokerNodeGroupInfo); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ClientAuthentication" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ClientAuthentication\": ")
	if tmp, err := json.Marshal(strct.ClientAuthentication); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ClusterName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ClusterName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ClusterName\": ")
	if tmp, err := json.Marshal(strct.ClusterName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ConfigurationInfo" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConfigurationInfo\": ")
	if tmp, err := json.Marshal(strct.ConfigurationInfo); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CurrentVersion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CurrentVersion\": ")
	if tmp, err := json.Marshal(strct.CurrentVersion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EncryptionInfo" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EncryptionInfo\": ")
	if tmp, err := json.Marshal(strct.EncryptionInfo); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EnhancedMonitoring" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EnhancedMonitoring\": ")
	if tmp, err := json.Marshal(strct.EnhancedMonitoring); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "KafkaVersion" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "KafkaVersion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KafkaVersion\": ")
	if tmp, err := json.Marshal(strct.KafkaVersion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LoggingInfo" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LoggingInfo\": ")
	if tmp, err := json.Marshal(strct.LoggingInfo); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "NumberOfBrokerNodes" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "NumberOfBrokerNodes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NumberOfBrokerNodes\": ")
	if tmp, err := json.Marshal(strct.NumberOfBrokerNodes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OpenMonitoring" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OpenMonitoring\": ")
	if tmp, err := json.Marshal(strct.OpenMonitoring); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StorageMode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StorageMode\": ")
	if tmp, err := json.Marshal(strct.StorageMode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    BrokerNodeGroupInfoReceived := false
    ClusterNameReceived := false
    KafkaVersionReceived := false
    NumberOfBrokerNodesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Arn":
            if err := json.Unmarshal([]byte(v), &strct.Arn); err != nil {
                return err
             }
        case "BrokerNodeGroupInfo":
            if err := json.Unmarshal([]byte(v), &strct.BrokerNodeGroupInfo); err != nil {
                return err
             }
            BrokerNodeGroupInfoReceived = true
        case "ClientAuthentication":
            if err := json.Unmarshal([]byte(v), &strct.ClientAuthentication); err != nil {
                return err
             }
        case "ClusterName":
            if err := json.Unmarshal([]byte(v), &strct.ClusterName); err != nil {
                return err
             }
            ClusterNameReceived = true
        case "ConfigurationInfo":
            if err := json.Unmarshal([]byte(v), &strct.ConfigurationInfo); err != nil {
                return err
             }
        case "CurrentVersion":
            if err := json.Unmarshal([]byte(v), &strct.CurrentVersion); err != nil {
                return err
             }
        case "EncryptionInfo":
            if err := json.Unmarshal([]byte(v), &strct.EncryptionInfo); err != nil {
                return err
             }
        case "EnhancedMonitoring":
            if err := json.Unmarshal([]byte(v), &strct.EnhancedMonitoring); err != nil {
                return err
             }
        case "KafkaVersion":
            if err := json.Unmarshal([]byte(v), &strct.KafkaVersion); err != nil {
                return err
             }
            KafkaVersionReceived = true
        case "LoggingInfo":
            if err := json.Unmarshal([]byte(v), &strct.LoggingInfo); err != nil {
                return err
             }
        case "NumberOfBrokerNodes":
            if err := json.Unmarshal([]byte(v), &strct.NumberOfBrokerNodes); err != nil {
                return err
             }
            NumberOfBrokerNodesReceived = true
        case "OpenMonitoring":
            if err := json.Unmarshal([]byte(v), &strct.OpenMonitoring); err != nil {
                return err
             }
        case "StorageMode":
            if err := json.Unmarshal([]byte(v), &strct.StorageMode); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if BrokerNodeGroupInfo (a required property) was received
    if !BrokerNodeGroupInfoReceived {
        return errors.New("\"BrokerNodeGroupInfo\" is required but was not present")
    }
    // check if ClusterName (a required property) was received
    if !ClusterNameReceived {
        return errors.New("\"ClusterName\" is required but was not present")
    }
    // check if KafkaVersion (a required property) was received
    if !KafkaVersionReceived {
        return errors.New("\"KafkaVersion\" is required but was not present")
    }
    // check if NumberOfBrokerNodes (a required property) was received
    if !NumberOfBrokerNodesReceived {
        return errors.New("\"NumberOfBrokerNodes\" is required but was not present")
    }
    return nil
}

func (strct *S3) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Bucket" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Bucket\": ")
	if tmp, err := json.Marshal(strct.Bucket); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Enabled" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Enabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Prefix" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Prefix\": ")
	if tmp, err := json.Marshal(strct.Prefix); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *S3) UnmarshalJSON(b []byte) error {
    EnabledReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Bucket":
            if err := json.Unmarshal([]byte(v), &strct.Bucket); err != nil {
                return err
             }
        case "Enabled":
            if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
                return err
             }
            EnabledReceived = true
        case "Prefix":
            if err := json.Unmarshal([]byte(v), &strct.Prefix); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Enabled (a required property) was received
    if !EnabledReceived {
        return errors.New("\"Enabled\" is required but was not present")
    }
    return nil
}

func (strct *Sasl) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Iam" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Iam\": ")
	if tmp, err := json.Marshal(strct.Iam); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Scram" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Scram\": ")
	if tmp, err := json.Marshal(strct.Scram); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Sasl) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Iam":
            if err := json.Unmarshal([]byte(v), &strct.Iam); err != nil {
                return err
             }
        case "Scram":
            if err := json.Unmarshal([]byte(v), &strct.Scram); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Scram) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Enabled" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Enabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Scram) UnmarshalJSON(b []byte) error {
    EnabledReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Enabled":
            if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
                return err
             }
            EnabledReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Enabled (a required property) was received
    if !EnabledReceived {
        return errors.New("\"Enabled\" is required but was not present")
    }
    return nil
}

func (strct *StorageInfo) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "EBSStorageInfo" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EBSStorageInfo\": ")
	if tmp, err := json.Marshal(strct.EBSStorageInfo); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *StorageInfo) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "EBSStorageInfo":
            if err := json.Unmarshal([]byte(v), &strct.EBSStorageInfo); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Tags) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tags) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Tls) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CertificateAuthorityArnList" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CertificateAuthorityArnList\": ")
	if tmp, err := json.Marshal(strct.CertificateAuthorityArnList); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Enabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tls) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CertificateAuthorityArnList":
            if err := json.Unmarshal([]byte(v), &strct.CertificateAuthorityArnList); err != nil {
                return err
             }
        case "Enabled":
            if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Unauthenticated) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Enabled" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Enabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Unauthenticated) UnmarshalJSON(b []byte) error {
    EnabledReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Enabled":
            if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
                return err
             }
            EnabledReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Enabled (a required property) was received
    if !EnabledReceived {
        return errors.New("\"Enabled\" is required but was not present")
    }
    return nil
}

func (strct *VpcConnectivity) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ClientAuthentication" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ClientAuthentication\": ")
	if tmp, err := json.Marshal(strct.ClientAuthentication); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *VpcConnectivity) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ClientAuthentication":
            if err := json.Unmarshal([]byte(v), &strct.ClientAuthentication); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *VpcConnectivityClientAuthentication) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Sasl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Sasl\": ")
	if tmp, err := json.Marshal(strct.Sasl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tls" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tls\": ")
	if tmp, err := json.Marshal(strct.Tls); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *VpcConnectivityClientAuthentication) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Sasl":
            if err := json.Unmarshal([]byte(v), &strct.Sasl); err != nil {
                return err
             }
        case "Tls":
            if err := json.Unmarshal([]byte(v), &strct.Tls); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *VpcConnectivityIam) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Enabled" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Enabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *VpcConnectivityIam) UnmarshalJSON(b []byte) error {
    EnabledReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Enabled":
            if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
                return err
             }
            EnabledReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Enabled (a required property) was received
    if !EnabledReceived {
        return errors.New("\"Enabled\" is required but was not present")
    }
    return nil
}

func (strct *VpcConnectivitySasl) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Iam" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Iam\": ")
	if tmp, err := json.Marshal(strct.Iam); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Scram" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Scram\": ")
	if tmp, err := json.Marshal(strct.Scram); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *VpcConnectivitySasl) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Iam":
            if err := json.Unmarshal([]byte(v), &strct.Iam); err != nil {
                return err
             }
        case "Scram":
            if err := json.Unmarshal([]byte(v), &strct.Scram); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *VpcConnectivityScram) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Enabled" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Enabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *VpcConnectivityScram) UnmarshalJSON(b []byte) error {
    EnabledReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Enabled":
            if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
                return err
             }
            EnabledReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Enabled (a required property) was received
    if !EnabledReceived {
        return errors.New("\"Enabled\" is required but was not present")
    }
    return nil
}

func (strct *VpcConnectivityTls) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Enabled" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Enabled" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *VpcConnectivityTls) UnmarshalJSON(b []byte) error {
    EnabledReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Enabled":
            if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
                return err
             }
            EnabledReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Enabled (a required property) was received
    if !EnabledReceived {
        return errors.New("\"Enabled\" is required but was not present")
    }
    return nil
}
