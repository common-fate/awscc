// Code generated by schema-generate. DO NOT EDIT.

package filter

import (
    "encoding/json"
    "fmt"
    "errors"
    "bytes"
)

// DateFilter 
type DateFilter struct {
  EndInclusive int `json:"EndInclusive,omitempty"`
  StartInclusive int `json:"StartInclusive,omitempty"`
}

// FilterCriteria 
type FilterCriteria struct {
  AwsAccountId []*StringFilter `json:"AwsAccountId,omitempty"`
  ComponentId []*StringFilter `json:"ComponentId,omitempty"`
  ComponentType []*StringFilter `json:"ComponentType,omitempty"`
  Ec2InstanceImageId []*StringFilter `json:"Ec2InstanceImageId,omitempty"`
  Ec2InstanceSubnetId []*StringFilter `json:"Ec2InstanceSubnetId,omitempty"`
  Ec2InstanceVpcId []*StringFilter `json:"Ec2InstanceVpcId,omitempty"`
  EcrImageArchitecture []*StringFilter `json:"EcrImageArchitecture,omitempty"`
  EcrImageHash []*StringFilter `json:"EcrImageHash,omitempty"`
  EcrImagePushedAt []*DateFilter `json:"EcrImagePushedAt,omitempty"`
  EcrImageRegistry []*StringFilter `json:"EcrImageRegistry,omitempty"`
  EcrImageRepositoryName []*StringFilter `json:"EcrImageRepositoryName,omitempty"`
  EcrImageTags []*StringFilter `json:"EcrImageTags,omitempty"`
  FindingArn []*StringFilter `json:"FindingArn,omitempty"`
  FindingStatus []*StringFilter `json:"FindingStatus,omitempty"`
  FindingType []*StringFilter `json:"FindingType,omitempty"`
  FirstObservedAt []*DateFilter `json:"FirstObservedAt,omitempty"`
  InspectorScore []*NumberFilter `json:"InspectorScore,omitempty"`
  LastObservedAt []*DateFilter `json:"LastObservedAt,omitempty"`
  NetworkProtocol []*StringFilter `json:"NetworkProtocol,omitempty"`
  PortRange []*PortRangeFilter `json:"PortRange,omitempty"`
  RelatedVulnerabilities []*StringFilter `json:"RelatedVulnerabilities,omitempty"`
  ResourceId []*StringFilter `json:"ResourceId,omitempty"`
  ResourceTags []*MapFilter `json:"ResourceTags,omitempty"`
  ResourceType []*StringFilter `json:"ResourceType,omitempty"`
  Severity []*StringFilter `json:"Severity,omitempty"`
  Title []*StringFilter `json:"Title,omitempty"`
  UpdatedAt []*DateFilter `json:"UpdatedAt,omitempty"`
  VendorSeverity []*StringFilter `json:"VendorSeverity,omitempty"`
  VulnerabilityId []*StringFilter `json:"VulnerabilityId,omitempty"`
  VulnerabilitySource []*StringFilter `json:"VulnerabilitySource,omitempty"`
  VulnerablePackages []*PackageFilter `json:"VulnerablePackages,omitempty"`
}

// MapFilter 
type MapFilter struct {
  Comparison string `json:"Comparison"`
  Key string `json:"Key,omitempty"`
  Value string `json:"Value,omitempty"`
}

// NumberFilter 
type NumberFilter struct {
  LowerInclusive float64 `json:"LowerInclusive,omitempty"`
  UpperInclusive float64 `json:"UpperInclusive,omitempty"`
}

// PackageFilter 
type PackageFilter struct {
  Architecture *StringFilter `json:"Architecture,omitempty"`
  Epoch *NumberFilter `json:"Epoch,omitempty"`
  Name *StringFilter `json:"Name,omitempty"`
  Release *StringFilter `json:"Release,omitempty"`
  SourceLayerHash *StringFilter `json:"SourceLayerHash,omitempty"`
  Version *StringFilter `json:"Version,omitempty"`
}

// PortRangeFilter 
type PortRangeFilter struct {
  BeginInclusive int `json:"BeginInclusive,omitempty"`
  EndInclusive int `json:"EndInclusive,omitempty"`
}

// Resource Inspector Filter resource schema
type Resource struct {

  // Findings filter ARN.
  Arn string `json:"Arn,omitempty"`

  // Findings filter description.
  Description string `json:"Description,omitempty"`

  // Findings filter action.
  FilterAction string `json:"FilterAction"`

  // Findings filter criteria.
  FilterCriteria *FilterCriteria `json:"FilterCriteria"`

  // Findings filter name.
  Name string `json:"Name"`
}

// StringFilter 
type StringFilter struct {
  Comparison string `json:"Comparison"`
  Value string `json:"Value"`
}

func (strct *DateFilter) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "EndInclusive" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EndInclusive\": ")
	if tmp, err := json.Marshal(strct.EndInclusive); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StartInclusive" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StartInclusive\": ")
	if tmp, err := json.Marshal(strct.StartInclusive); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DateFilter) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "EndInclusive":
            if err := json.Unmarshal([]byte(v), &strct.EndInclusive); err != nil {
                return err
             }
        case "StartInclusive":
            if err := json.Unmarshal([]byte(v), &strct.StartInclusive); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *FilterCriteria) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AwsAccountId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AwsAccountId\": ")
	if tmp, err := json.Marshal(strct.AwsAccountId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ComponentId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ComponentId\": ")
	if tmp, err := json.Marshal(strct.ComponentId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ComponentType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ComponentType\": ")
	if tmp, err := json.Marshal(strct.ComponentType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Ec2InstanceImageId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Ec2InstanceImageId\": ")
	if tmp, err := json.Marshal(strct.Ec2InstanceImageId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Ec2InstanceSubnetId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Ec2InstanceSubnetId\": ")
	if tmp, err := json.Marshal(strct.Ec2InstanceSubnetId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Ec2InstanceVpcId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Ec2InstanceVpcId\": ")
	if tmp, err := json.Marshal(strct.Ec2InstanceVpcId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EcrImageArchitecture" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EcrImageArchitecture\": ")
	if tmp, err := json.Marshal(strct.EcrImageArchitecture); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EcrImageHash" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EcrImageHash\": ")
	if tmp, err := json.Marshal(strct.EcrImageHash); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EcrImagePushedAt" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EcrImagePushedAt\": ")
	if tmp, err := json.Marshal(strct.EcrImagePushedAt); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EcrImageRegistry" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EcrImageRegistry\": ")
	if tmp, err := json.Marshal(strct.EcrImageRegistry); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EcrImageRepositoryName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EcrImageRepositoryName\": ")
	if tmp, err := json.Marshal(strct.EcrImageRepositoryName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EcrImageTags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EcrImageTags\": ")
	if tmp, err := json.Marshal(strct.EcrImageTags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FindingArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FindingArn\": ")
	if tmp, err := json.Marshal(strct.FindingArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FindingStatus" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FindingStatus\": ")
	if tmp, err := json.Marshal(strct.FindingStatus); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FindingType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FindingType\": ")
	if tmp, err := json.Marshal(strct.FindingType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FirstObservedAt" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FirstObservedAt\": ")
	if tmp, err := json.Marshal(strct.FirstObservedAt); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "InspectorScore" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InspectorScore\": ")
	if tmp, err := json.Marshal(strct.InspectorScore); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LastObservedAt" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LastObservedAt\": ")
	if tmp, err := json.Marshal(strct.LastObservedAt); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "NetworkProtocol" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NetworkProtocol\": ")
	if tmp, err := json.Marshal(strct.NetworkProtocol); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PortRange" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PortRange\": ")
	if tmp, err := json.Marshal(strct.PortRange); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RelatedVulnerabilities" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RelatedVulnerabilities\": ")
	if tmp, err := json.Marshal(strct.RelatedVulnerabilities); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ResourceId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ResourceId\": ")
	if tmp, err := json.Marshal(strct.ResourceId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ResourceTags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ResourceTags\": ")
	if tmp, err := json.Marshal(strct.ResourceTags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ResourceType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ResourceType\": ")
	if tmp, err := json.Marshal(strct.ResourceType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Severity" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Severity\": ")
	if tmp, err := json.Marshal(strct.Severity); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Title" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Title\": ")
	if tmp, err := json.Marshal(strct.Title); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "UpdatedAt" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UpdatedAt\": ")
	if tmp, err := json.Marshal(strct.UpdatedAt); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VendorSeverity" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VendorSeverity\": ")
	if tmp, err := json.Marshal(strct.VendorSeverity); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VulnerabilityId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VulnerabilityId\": ")
	if tmp, err := json.Marshal(strct.VulnerabilityId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VulnerabilitySource" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VulnerabilitySource\": ")
	if tmp, err := json.Marshal(strct.VulnerabilitySource); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VulnerablePackages" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VulnerablePackages\": ")
	if tmp, err := json.Marshal(strct.VulnerablePackages); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FilterCriteria) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AwsAccountId":
            if err := json.Unmarshal([]byte(v), &strct.AwsAccountId); err != nil {
                return err
             }
        case "ComponentId":
            if err := json.Unmarshal([]byte(v), &strct.ComponentId); err != nil {
                return err
             }
        case "ComponentType":
            if err := json.Unmarshal([]byte(v), &strct.ComponentType); err != nil {
                return err
             }
        case "Ec2InstanceImageId":
            if err := json.Unmarshal([]byte(v), &strct.Ec2InstanceImageId); err != nil {
                return err
             }
        case "Ec2InstanceSubnetId":
            if err := json.Unmarshal([]byte(v), &strct.Ec2InstanceSubnetId); err != nil {
                return err
             }
        case "Ec2InstanceVpcId":
            if err := json.Unmarshal([]byte(v), &strct.Ec2InstanceVpcId); err != nil {
                return err
             }
        case "EcrImageArchitecture":
            if err := json.Unmarshal([]byte(v), &strct.EcrImageArchitecture); err != nil {
                return err
             }
        case "EcrImageHash":
            if err := json.Unmarshal([]byte(v), &strct.EcrImageHash); err != nil {
                return err
             }
        case "EcrImagePushedAt":
            if err := json.Unmarshal([]byte(v), &strct.EcrImagePushedAt); err != nil {
                return err
             }
        case "EcrImageRegistry":
            if err := json.Unmarshal([]byte(v), &strct.EcrImageRegistry); err != nil {
                return err
             }
        case "EcrImageRepositoryName":
            if err := json.Unmarshal([]byte(v), &strct.EcrImageRepositoryName); err != nil {
                return err
             }
        case "EcrImageTags":
            if err := json.Unmarshal([]byte(v), &strct.EcrImageTags); err != nil {
                return err
             }
        case "FindingArn":
            if err := json.Unmarshal([]byte(v), &strct.FindingArn); err != nil {
                return err
             }
        case "FindingStatus":
            if err := json.Unmarshal([]byte(v), &strct.FindingStatus); err != nil {
                return err
             }
        case "FindingType":
            if err := json.Unmarshal([]byte(v), &strct.FindingType); err != nil {
                return err
             }
        case "FirstObservedAt":
            if err := json.Unmarshal([]byte(v), &strct.FirstObservedAt); err != nil {
                return err
             }
        case "InspectorScore":
            if err := json.Unmarshal([]byte(v), &strct.InspectorScore); err != nil {
                return err
             }
        case "LastObservedAt":
            if err := json.Unmarshal([]byte(v), &strct.LastObservedAt); err != nil {
                return err
             }
        case "NetworkProtocol":
            if err := json.Unmarshal([]byte(v), &strct.NetworkProtocol); err != nil {
                return err
             }
        case "PortRange":
            if err := json.Unmarshal([]byte(v), &strct.PortRange); err != nil {
                return err
             }
        case "RelatedVulnerabilities":
            if err := json.Unmarshal([]byte(v), &strct.RelatedVulnerabilities); err != nil {
                return err
             }
        case "ResourceId":
            if err := json.Unmarshal([]byte(v), &strct.ResourceId); err != nil {
                return err
             }
        case "ResourceTags":
            if err := json.Unmarshal([]byte(v), &strct.ResourceTags); err != nil {
                return err
             }
        case "ResourceType":
            if err := json.Unmarshal([]byte(v), &strct.ResourceType); err != nil {
                return err
             }
        case "Severity":
            if err := json.Unmarshal([]byte(v), &strct.Severity); err != nil {
                return err
             }
        case "Title":
            if err := json.Unmarshal([]byte(v), &strct.Title); err != nil {
                return err
             }
        case "UpdatedAt":
            if err := json.Unmarshal([]byte(v), &strct.UpdatedAt); err != nil {
                return err
             }
        case "VendorSeverity":
            if err := json.Unmarshal([]byte(v), &strct.VendorSeverity); err != nil {
                return err
             }
        case "VulnerabilityId":
            if err := json.Unmarshal([]byte(v), &strct.VulnerabilityId); err != nil {
                return err
             }
        case "VulnerabilitySource":
            if err := json.Unmarshal([]byte(v), &strct.VulnerabilitySource); err != nil {
                return err
             }
        case "VulnerablePackages":
            if err := json.Unmarshal([]byte(v), &strct.VulnerablePackages); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *MapFilter) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Comparison" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Comparison" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Comparison\": ")
	if tmp, err := json.Marshal(strct.Comparison); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MapFilter) UnmarshalJSON(b []byte) error {
    ComparisonReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Comparison":
            if err := json.Unmarshal([]byte(v), &strct.Comparison); err != nil {
                return err
             }
            ComparisonReceived = true
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Comparison (a required property) was received
    if !ComparisonReceived {
        return errors.New("\"Comparison\" is required but was not present")
    }
    return nil
}

func (strct *NumberFilter) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "LowerInclusive" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LowerInclusive\": ")
	if tmp, err := json.Marshal(strct.LowerInclusive); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "UpperInclusive" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"UpperInclusive\": ")
	if tmp, err := json.Marshal(strct.UpperInclusive); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *NumberFilter) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "LowerInclusive":
            if err := json.Unmarshal([]byte(v), &strct.LowerInclusive); err != nil {
                return err
             }
        case "UpperInclusive":
            if err := json.Unmarshal([]byte(v), &strct.UpperInclusive); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *PackageFilter) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Architecture" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Architecture\": ")
	if tmp, err := json.Marshal(strct.Architecture); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Epoch" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Epoch\": ")
	if tmp, err := json.Marshal(strct.Epoch); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Release" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Release\": ")
	if tmp, err := json.Marshal(strct.Release); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SourceLayerHash" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SourceLayerHash\": ")
	if tmp, err := json.Marshal(strct.SourceLayerHash); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Version" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Version\": ")
	if tmp, err := json.Marshal(strct.Version); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PackageFilter) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Architecture":
            if err := json.Unmarshal([]byte(v), &strct.Architecture); err != nil {
                return err
             }
        case "Epoch":
            if err := json.Unmarshal([]byte(v), &strct.Epoch); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "Release":
            if err := json.Unmarshal([]byte(v), &strct.Release); err != nil {
                return err
             }
        case "SourceLayerHash":
            if err := json.Unmarshal([]byte(v), &strct.SourceLayerHash); err != nil {
                return err
             }
        case "Version":
            if err := json.Unmarshal([]byte(v), &strct.Version); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *PortRangeFilter) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "BeginInclusive" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BeginInclusive\": ")
	if tmp, err := json.Marshal(strct.BeginInclusive); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EndInclusive" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EndInclusive\": ")
	if tmp, err := json.Marshal(strct.EndInclusive); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PortRangeFilter) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BeginInclusive":
            if err := json.Unmarshal([]byte(v), &strct.BeginInclusive); err != nil {
                return err
             }
        case "EndInclusive":
            if err := json.Unmarshal([]byte(v), &strct.EndInclusive); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Arn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Arn\": ")
	if tmp, err := json.Marshal(strct.Arn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "FilterAction" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "FilterAction" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FilterAction\": ")
	if tmp, err := json.Marshal(strct.FilterAction); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "FilterCriteria" field is required
    if strct.FilterCriteria == nil {
        return nil, errors.New("FilterCriteria is a required field")
    }
    // Marshal the "FilterCriteria" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FilterCriteria\": ")
	if tmp, err := json.Marshal(strct.FilterCriteria); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    FilterActionReceived := false
    FilterCriteriaReceived := false
    NameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Arn":
            if err := json.Unmarshal([]byte(v), &strct.Arn); err != nil {
                return err
             }
        case "Description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "FilterAction":
            if err := json.Unmarshal([]byte(v), &strct.FilterAction); err != nil {
                return err
             }
            FilterActionReceived = true
        case "FilterCriteria":
            if err := json.Unmarshal([]byte(v), &strct.FilterCriteria); err != nil {
                return err
             }
            FilterCriteriaReceived = true
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if FilterAction (a required property) was received
    if !FilterActionReceived {
        return errors.New("\"FilterAction\" is required but was not present")
    }
    // check if FilterCriteria (a required property) was received
    if !FilterCriteriaReceived {
        return errors.New("\"FilterCriteria\" is required but was not present")
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    return nil
}

func (strct *StringFilter) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Comparison" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Comparison" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Comparison\": ")
	if tmp, err := json.Marshal(strct.Comparison); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *StringFilter) UnmarshalJSON(b []byte) error {
    ComparisonReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Comparison":
            if err := json.Unmarshal([]byte(v), &strct.Comparison); err != nil {
                return err
             }
            ComparisonReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Comparison (a required property) was received
    if !ComparisonReceived {
        return errors.New("\"Comparison\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}
