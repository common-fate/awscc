// Code generated by schema-generate. DO NOT EDIT.

package pipe

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// AwsVpcConfiguration 
type AwsVpcConfiguration struct {
  AssignPublicIp string `json:"AssignPublicIp,omitempty"`
  SecurityGroups []string `json:"SecurityGroups,omitempty"`
  Subnets []string `json:"Subnets"`
}

// BatchArrayProperties 
type BatchArrayProperties struct {
  Size int `json:"Size,omitempty"`
}

// BatchContainerOverrides 
type BatchContainerOverrides struct {
  Command []string `json:"Command,omitempty"`
  Environment []*BatchEnvironmentVariable `json:"Environment,omitempty"`
  InstanceType string `json:"InstanceType,omitempty"`
  ResourceRequirements []*BatchResourceRequirement `json:"ResourceRequirements,omitempty"`
}

// BatchEnvironmentVariable 
type BatchEnvironmentVariable struct {
  Name string `json:"Name,omitempty"`
  Value string `json:"Value,omitempty"`
}

// BatchJobDependency 
type BatchJobDependency struct {
  JobId string `json:"JobId,omitempty"`
  Type string `json:"Type,omitempty"`
}

// BatchParametersMap 
type BatchParametersMap struct {
}

// BatchResourceRequirement 
type BatchResourceRequirement struct {
  Type string `json:"Type"`
  Value string `json:"Value"`
}

// BatchRetryStrategy 
type BatchRetryStrategy struct {
  Attempts int `json:"Attempts,omitempty"`
}

// CapacityProviderStrategyItem 
type CapacityProviderStrategyItem struct {
  Base int `json:"Base,omitempty"`
  CapacityProvider string `json:"CapacityProvider"`
  Weight int `json:"Weight,omitempty"`
}

// DeadLetterConfig 
type DeadLetterConfig struct {
  Arn string `json:"Arn,omitempty"`
}

// EcsContainerOverride 
type EcsContainerOverride struct {
  Command []string `json:"Command,omitempty"`
  Cpu int `json:"Cpu,omitempty"`
  Environment []*EcsEnvironmentVariable `json:"Environment,omitempty"`
  EnvironmentFiles []*EcsEnvironmentFile `json:"EnvironmentFiles,omitempty"`
  Memory int `json:"Memory,omitempty"`
  MemoryReservation int `json:"MemoryReservation,omitempty"`
  Name string `json:"Name,omitempty"`
  ResourceRequirements []*EcsResourceRequirement `json:"ResourceRequirements,omitempty"`
}

// EcsEnvironmentFile 
type EcsEnvironmentFile struct {
  Type string `json:"Type"`
  Value string `json:"Value"`
}

// EcsEnvironmentVariable 
type EcsEnvironmentVariable struct {
  Name string `json:"Name,omitempty"`
  Value string `json:"Value,omitempty"`
}

// EcsEphemeralStorage 
type EcsEphemeralStorage struct {
  SizeInGiB int `json:"SizeInGiB"`
}

// EcsInferenceAcceleratorOverride 
type EcsInferenceAcceleratorOverride struct {
  DeviceName string `json:"DeviceName,omitempty"`
  DeviceType string `json:"DeviceType,omitempty"`
}

// EcsResourceRequirement 
type EcsResourceRequirement struct {
  Type string `json:"Type"`
  Value string `json:"Value"`
}

// EcsTaskOverride 
type EcsTaskOverride struct {
  ContainerOverrides []*EcsContainerOverride `json:"ContainerOverrides,omitempty"`
  Cpu string `json:"Cpu,omitempty"`
  EphemeralStorage *EcsEphemeralStorage `json:"EphemeralStorage,omitempty"`
  ExecutionRoleArn string `json:"ExecutionRoleArn,omitempty"`
  InferenceAcceleratorOverrides []*EcsInferenceAcceleratorOverride `json:"InferenceAcceleratorOverrides,omitempty"`
  Memory string `json:"Memory,omitempty"`
  TaskRoleArn string `json:"TaskRoleArn,omitempty"`
}

// Filter 
type Filter struct {
  Pattern string `json:"Pattern,omitempty"`
}

// FilterCriteria 
type FilterCriteria struct {
  Filters []*Filter `json:"Filters,omitempty"`
}

// HeaderParametersMap 
type HeaderParametersMap struct {
}

// NetworkConfiguration 
type NetworkConfiguration struct {
  AwsvpcConfiguration *AwsVpcConfiguration `json:"AwsvpcConfiguration,omitempty"`
}

// PipeEnrichmentHttpParameters 
type PipeEnrichmentHttpParameters struct {
  HeaderParameters *HeaderParametersMap `json:"HeaderParameters,omitempty"`
  PathParameterValues []string `json:"PathParameterValues,omitempty"`
  QueryStringParameters *QueryStringParametersMap `json:"QueryStringParameters,omitempty"`
}

// PipeEnrichmentParameters 
type PipeEnrichmentParameters struct {
  HttpParameters *PipeEnrichmentHttpParameters `json:"HttpParameters,omitempty"`
  InputTemplate string `json:"InputTemplate,omitempty"`
}

// PipeSourceActiveMQBrokerParameters 
type PipeSourceActiveMQBrokerParameters struct {
  BatchSize int `json:"BatchSize,omitempty"`
  Credentials interface{} `json:"Credentials"`
  MaximumBatchingWindowInSeconds int `json:"MaximumBatchingWindowInSeconds,omitempty"`
  QueueName string `json:"QueueName"`
}

// PipeSourceDynamoDBStreamParameters 
type PipeSourceDynamoDBStreamParameters struct {
  BatchSize int `json:"BatchSize,omitempty"`
  DeadLetterConfig *DeadLetterConfig `json:"DeadLetterConfig,omitempty"`
  MaximumBatchingWindowInSeconds int `json:"MaximumBatchingWindowInSeconds,omitempty"`
  MaximumRecordAgeInSeconds int `json:"MaximumRecordAgeInSeconds,omitempty"`
  MaximumRetryAttempts int `json:"MaximumRetryAttempts,omitempty"`
  OnPartialBatchItemFailure string `json:"OnPartialBatchItemFailure,omitempty"`
  ParallelizationFactor int `json:"ParallelizationFactor,omitempty"`
  StartingPosition string `json:"StartingPosition"`
}

// PipeSourceKinesisStreamParameters 
type PipeSourceKinesisStreamParameters struct {
  BatchSize int `json:"BatchSize,omitempty"`
  DeadLetterConfig *DeadLetterConfig `json:"DeadLetterConfig,omitempty"`
  MaximumBatchingWindowInSeconds int `json:"MaximumBatchingWindowInSeconds,omitempty"`
  MaximumRecordAgeInSeconds int `json:"MaximumRecordAgeInSeconds,omitempty"`
  MaximumRetryAttempts int `json:"MaximumRetryAttempts,omitempty"`
  OnPartialBatchItemFailure string `json:"OnPartialBatchItemFailure,omitempty"`
  ParallelizationFactor int `json:"ParallelizationFactor,omitempty"`
  StartingPosition string `json:"StartingPosition"`
  StartingPositionTimestamp string `json:"StartingPositionTimestamp,omitempty"`
}

// PipeSourceManagedStreamingKafkaParameters 
type PipeSourceManagedStreamingKafkaParameters struct {
  BatchSize int `json:"BatchSize,omitempty"`
  ConsumerGroupID string `json:"ConsumerGroupID,omitempty"`
  Credentials interface{} `json:"Credentials,omitempty"`
  MaximumBatchingWindowInSeconds int `json:"MaximumBatchingWindowInSeconds,omitempty"`
  StartingPosition string `json:"StartingPosition,omitempty"`
  TopicName string `json:"TopicName"`
}

// PipeSourceParameters 
type PipeSourceParameters struct {
  ActiveMQBrokerParameters *PipeSourceActiveMQBrokerParameters `json:"ActiveMQBrokerParameters,omitempty"`
  DynamoDBStreamParameters *PipeSourceDynamoDBStreamParameters `json:"DynamoDBStreamParameters,omitempty"`
  FilterCriteria *FilterCriteria `json:"FilterCriteria,omitempty"`
  KinesisStreamParameters *PipeSourceKinesisStreamParameters `json:"KinesisStreamParameters,omitempty"`
  ManagedStreamingKafkaParameters *PipeSourceManagedStreamingKafkaParameters `json:"ManagedStreamingKafkaParameters,omitempty"`
  RabbitMQBrokerParameters *PipeSourceRabbitMQBrokerParameters `json:"RabbitMQBrokerParameters,omitempty"`
  SelfManagedKafkaParameters *PipeSourceSelfManagedKafkaParameters `json:"SelfManagedKafkaParameters,omitempty"`
  SqsQueueParameters *PipeSourceSqsQueueParameters `json:"SqsQueueParameters,omitempty"`
}

// PipeSourceRabbitMQBrokerParameters 
type PipeSourceRabbitMQBrokerParameters struct {
  BatchSize int `json:"BatchSize,omitempty"`
  Credentials interface{} `json:"Credentials"`
  MaximumBatchingWindowInSeconds int `json:"MaximumBatchingWindowInSeconds,omitempty"`
  QueueName string `json:"QueueName"`
  VirtualHost string `json:"VirtualHost,omitempty"`
}

// PipeSourceSelfManagedKafkaParameters 
type PipeSourceSelfManagedKafkaParameters struct {
  AdditionalBootstrapServers []string `json:"AdditionalBootstrapServers,omitempty"`
  BatchSize int `json:"BatchSize,omitempty"`
  ConsumerGroupID string `json:"ConsumerGroupID,omitempty"`
  Credentials interface{} `json:"Credentials,omitempty"`
  MaximumBatchingWindowInSeconds int `json:"MaximumBatchingWindowInSeconds,omitempty"`

  // Optional SecretManager ARN which stores the database credentials
  ServerRootCaCertificate string `json:"ServerRootCaCertificate,omitempty"`
  StartingPosition string `json:"StartingPosition,omitempty"`
  TopicName string `json:"TopicName"`
  Vpc *SelfManagedKafkaAccessConfigurationVpc `json:"Vpc,omitempty"`
}

// PipeSourceSqsQueueParameters 
type PipeSourceSqsQueueParameters struct {
  BatchSize int `json:"BatchSize,omitempty"`
  MaximumBatchingWindowInSeconds int `json:"MaximumBatchingWindowInSeconds,omitempty"`
}

// PipeTargetBatchJobParameters 
type PipeTargetBatchJobParameters struct {
  ArrayProperties *BatchArrayProperties `json:"ArrayProperties,omitempty"`
  ContainerOverrides *BatchContainerOverrides `json:"ContainerOverrides,omitempty"`
  DependsOn []*BatchJobDependency `json:"DependsOn,omitempty"`
  JobDefinition string `json:"JobDefinition"`
  JobName string `json:"JobName"`
  Parameters *BatchParametersMap `json:"Parameters,omitempty"`
  RetryStrategy *BatchRetryStrategy `json:"RetryStrategy,omitempty"`
}

// PipeTargetCloudWatchLogsParameters 
type PipeTargetCloudWatchLogsParameters struct {
  LogStreamName string `json:"LogStreamName,omitempty"`
  Timestamp string `json:"Timestamp,omitempty"`
}

// PipeTargetEcsTaskParameters 
type PipeTargetEcsTaskParameters struct {
  CapacityProviderStrategy []*CapacityProviderStrategyItem `json:"CapacityProviderStrategy,omitempty"`
  EnableECSManagedTags bool `json:"EnableECSManagedTags,omitempty"`
  EnableExecuteCommand bool `json:"EnableExecuteCommand,omitempty"`
  Group string `json:"Group,omitempty"`
  LaunchType string `json:"LaunchType,omitempty"`
  NetworkConfiguration *NetworkConfiguration `json:"NetworkConfiguration,omitempty"`
  Overrides *EcsTaskOverride `json:"Overrides,omitempty"`
  PlacementConstraints []*PlacementConstraint `json:"PlacementConstraints,omitempty"`
  PlacementStrategy []*PlacementStrategy `json:"PlacementStrategy,omitempty"`
  PlatformVersion string `json:"PlatformVersion,omitempty"`
  PropagateTags string `json:"PropagateTags,omitempty"`
  ReferenceId string `json:"ReferenceId,omitempty"`
  Tags []*Tag `json:"Tags,omitempty"`
  TaskCount int `json:"TaskCount,omitempty"`
  TaskDefinitionArn string `json:"TaskDefinitionArn"`
}

// PipeTargetEventBridgeEventBusParameters 
type PipeTargetEventBridgeEventBusParameters struct {
  DetailType string `json:"DetailType,omitempty"`
  EndpointId string `json:"EndpointId,omitempty"`
  Resources []string `json:"Resources,omitempty"`
  Source string `json:"Source,omitempty"`
  Time string `json:"Time,omitempty"`
}

// PipeTargetHttpParameters 
type PipeTargetHttpParameters struct {
  HeaderParameters *HeaderParametersMap `json:"HeaderParameters,omitempty"`
  PathParameterValues []string `json:"PathParameterValues,omitempty"`
  QueryStringParameters *QueryStringParametersMap `json:"QueryStringParameters,omitempty"`
}

// PipeTargetKinesisStreamParameters 
type PipeTargetKinesisStreamParameters struct {
  PartitionKey string `json:"PartitionKey"`
}

// PipeTargetLambdaFunctionParameters 
type PipeTargetLambdaFunctionParameters struct {
  InvocationType string `json:"InvocationType,omitempty"`
}

// PipeTargetParameters 
type PipeTargetParameters struct {
  BatchJobParameters *PipeTargetBatchJobParameters `json:"BatchJobParameters,omitempty"`
  CloudWatchLogsParameters *PipeTargetCloudWatchLogsParameters `json:"CloudWatchLogsParameters,omitempty"`
  EcsTaskParameters *PipeTargetEcsTaskParameters `json:"EcsTaskParameters,omitempty"`
  EventBridgeEventBusParameters *PipeTargetEventBridgeEventBusParameters `json:"EventBridgeEventBusParameters,omitempty"`
  HttpParameters *PipeTargetHttpParameters `json:"HttpParameters,omitempty"`
  InputTemplate string `json:"InputTemplate,omitempty"`
  KinesisStreamParameters *PipeTargetKinesisStreamParameters `json:"KinesisStreamParameters,omitempty"`
  LambdaFunctionParameters *PipeTargetLambdaFunctionParameters `json:"LambdaFunctionParameters,omitempty"`
  RedshiftDataParameters *PipeTargetRedshiftDataParameters `json:"RedshiftDataParameters,omitempty"`
  SageMakerPipelineParameters *PipeTargetSageMakerPipelineParameters `json:"SageMakerPipelineParameters,omitempty"`
  SqsQueueParameters *PipeTargetSqsQueueParameters `json:"SqsQueueParameters,omitempty"`
  StepFunctionStateMachineParameters *PipeTargetStateMachineParameters `json:"StepFunctionStateMachineParameters,omitempty"`
}

// PipeTargetRedshiftDataParameters 
type PipeTargetRedshiftDataParameters struct {

  // Redshift Database
  Database string `json:"Database"`

  // Database user name
  DbUser string `json:"DbUser,omitempty"`

  // Optional SecretManager ARN which stores the database credentials
  SecretManagerArn string `json:"SecretManagerArn,omitempty"`

  // A list of SQLs.
  Sqls []string `json:"Sqls"`

  // A name for Redshift DataAPI statement which can be used as filter of ListStatement.
  StatementName string `json:"StatementName,omitempty"`
  WithEvent bool `json:"WithEvent,omitempty"`
}

// PipeTargetSageMakerPipelineParameters 
type PipeTargetSageMakerPipelineParameters struct {
  PipelineParameterList []*SageMakerPipelineParameter `json:"PipelineParameterList,omitempty"`
}

// PipeTargetSqsQueueParameters 
type PipeTargetSqsQueueParameters struct {
  MessageDeduplicationId string `json:"MessageDeduplicationId,omitempty"`
  MessageGroupId string `json:"MessageGroupId,omitempty"`
}

// PipeTargetStateMachineParameters 
type PipeTargetStateMachineParameters struct {
  InvocationType string `json:"InvocationType,omitempty"`
}

// PlacementConstraint 
type PlacementConstraint struct {
  Expression string `json:"Expression,omitempty"`
  Type string `json:"Type,omitempty"`
}

// PlacementStrategy 
type PlacementStrategy struct {
  Field string `json:"Field,omitempty"`
  Type string `json:"Type,omitempty"`
}

// QueryStringParametersMap 
type QueryStringParametersMap struct {
}

// Resource Definition of AWS::Pipes::Pipe Resource Type
type Resource struct {
  Arn string `json:"Arn,omitempty"`
  CreationTime string `json:"CreationTime,omitempty"`
  CurrentState string `json:"CurrentState,omitempty"`
  Description string `json:"Description,omitempty"`
  DesiredState string `json:"DesiredState,omitempty"`
  Enrichment string `json:"Enrichment,omitempty"`
  EnrichmentParameters *PipeEnrichmentParameters `json:"EnrichmentParameters,omitempty"`
  LastModifiedTime string `json:"LastModifiedTime,omitempty"`
  Name string `json:"Name,omitempty"`
  RoleArn string `json:"RoleArn"`
  Source string `json:"Source"`
  SourceParameters *PipeSourceParameters `json:"SourceParameters,omitempty"`
  StateReason string `json:"StateReason,omitempty"`
  Tags *TagMap `json:"Tags,omitempty"`
  Target string `json:"Target"`
  TargetParameters *PipeTargetParameters `json:"TargetParameters,omitempty"`
}

// SageMakerPipelineParameter 
type SageMakerPipelineParameter struct {
  Name string `json:"Name"`
  Value string `json:"Value"`
}

// SelfManagedKafkaAccessConfigurationVpc 
type SelfManagedKafkaAccessConfigurationVpc struct {

  // List of SecurityGroupId.
  SecurityGroup []string `json:"SecurityGroup,omitempty"`

  // List of SubnetId.
  Subnets []string `json:"Subnets,omitempty"`
}

// Tag 
type Tag struct {
  Key string `json:"Key"`
  Value string `json:"Value"`
}

// TagMap 
type TagMap struct {
}

func (strct *AwsVpcConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AssignPublicIp" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AssignPublicIp\": ")
	if tmp, err := json.Marshal(strct.AssignPublicIp); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SecurityGroups" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SecurityGroups\": ")
	if tmp, err := json.Marshal(strct.SecurityGroups); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Subnets" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Subnets" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Subnets\": ")
	if tmp, err := json.Marshal(strct.Subnets); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AwsVpcConfiguration) UnmarshalJSON(b []byte) error {
    SubnetsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AssignPublicIp":
            if err := json.Unmarshal([]byte(v), &strct.AssignPublicIp); err != nil {
                return err
             }
        case "SecurityGroups":
            if err := json.Unmarshal([]byte(v), &strct.SecurityGroups); err != nil {
                return err
             }
        case "Subnets":
            if err := json.Unmarshal([]byte(v), &strct.Subnets); err != nil {
                return err
             }
            SubnetsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Subnets (a required property) was received
    if !SubnetsReceived {
        return errors.New("\"Subnets\" is required but was not present")
    }
    return nil
}

func (strct *BatchArrayProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Size" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Size\": ")
	if tmp, err := json.Marshal(strct.Size); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BatchArrayProperties) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Size":
            if err := json.Unmarshal([]byte(v), &strct.Size); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *BatchContainerOverrides) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Command" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Command\": ")
	if tmp, err := json.Marshal(strct.Command); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Environment" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Environment\": ")
	if tmp, err := json.Marshal(strct.Environment); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "InstanceType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InstanceType\": ")
	if tmp, err := json.Marshal(strct.InstanceType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ResourceRequirements" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ResourceRequirements\": ")
	if tmp, err := json.Marshal(strct.ResourceRequirements); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BatchContainerOverrides) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Command":
            if err := json.Unmarshal([]byte(v), &strct.Command); err != nil {
                return err
             }
        case "Environment":
            if err := json.Unmarshal([]byte(v), &strct.Environment); err != nil {
                return err
             }
        case "InstanceType":
            if err := json.Unmarshal([]byte(v), &strct.InstanceType); err != nil {
                return err
             }
        case "ResourceRequirements":
            if err := json.Unmarshal([]byte(v), &strct.ResourceRequirements); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *BatchEnvironmentVariable) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BatchEnvironmentVariable) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *BatchJobDependency) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "JobId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"JobId\": ")
	if tmp, err := json.Marshal(strct.JobId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BatchJobDependency) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "JobId":
            if err := json.Unmarshal([]byte(v), &strct.JobId); err != nil {
                return err
             }
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *BatchParametersMap) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BatchParametersMap) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *BatchResourceRequirement) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BatchResourceRequirement) UnmarshalJSON(b []byte) error {
    TypeReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            TypeReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Type (a required property) was received
    if !TypeReceived {
        return errors.New("\"Type\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *BatchRetryStrategy) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Attempts" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Attempts\": ")
	if tmp, err := json.Marshal(strct.Attempts); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BatchRetryStrategy) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Attempts":
            if err := json.Unmarshal([]byte(v), &strct.Attempts); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *CapacityProviderStrategyItem) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Base" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Base\": ")
	if tmp, err := json.Marshal(strct.Base); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "CapacityProvider" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "CapacityProvider" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CapacityProvider\": ")
	if tmp, err := json.Marshal(strct.CapacityProvider); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Weight" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Weight\": ")
	if tmp, err := json.Marshal(strct.Weight); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CapacityProviderStrategyItem) UnmarshalJSON(b []byte) error {
    CapacityProviderReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Base":
            if err := json.Unmarshal([]byte(v), &strct.Base); err != nil {
                return err
             }
        case "CapacityProvider":
            if err := json.Unmarshal([]byte(v), &strct.CapacityProvider); err != nil {
                return err
             }
            CapacityProviderReceived = true
        case "Weight":
            if err := json.Unmarshal([]byte(v), &strct.Weight); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if CapacityProvider (a required property) was received
    if !CapacityProviderReceived {
        return errors.New("\"CapacityProvider\" is required but was not present")
    }
    return nil
}

func (strct *DeadLetterConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Arn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Arn\": ")
	if tmp, err := json.Marshal(strct.Arn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DeadLetterConfig) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Arn":
            if err := json.Unmarshal([]byte(v), &strct.Arn); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *EcsContainerOverride) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Command" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Command\": ")
	if tmp, err := json.Marshal(strct.Command); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Cpu" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Cpu\": ")
	if tmp, err := json.Marshal(strct.Cpu); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Environment" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Environment\": ")
	if tmp, err := json.Marshal(strct.Environment); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EnvironmentFiles" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EnvironmentFiles\": ")
	if tmp, err := json.Marshal(strct.EnvironmentFiles); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Memory" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Memory\": ")
	if tmp, err := json.Marshal(strct.Memory); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MemoryReservation" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MemoryReservation\": ")
	if tmp, err := json.Marshal(strct.MemoryReservation); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ResourceRequirements" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ResourceRequirements\": ")
	if tmp, err := json.Marshal(strct.ResourceRequirements); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *EcsContainerOverride) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Command":
            if err := json.Unmarshal([]byte(v), &strct.Command); err != nil {
                return err
             }
        case "Cpu":
            if err := json.Unmarshal([]byte(v), &strct.Cpu); err != nil {
                return err
             }
        case "Environment":
            if err := json.Unmarshal([]byte(v), &strct.Environment); err != nil {
                return err
             }
        case "EnvironmentFiles":
            if err := json.Unmarshal([]byte(v), &strct.EnvironmentFiles); err != nil {
                return err
             }
        case "Memory":
            if err := json.Unmarshal([]byte(v), &strct.Memory); err != nil {
                return err
             }
        case "MemoryReservation":
            if err := json.Unmarshal([]byte(v), &strct.MemoryReservation); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "ResourceRequirements":
            if err := json.Unmarshal([]byte(v), &strct.ResourceRequirements); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *EcsEnvironmentFile) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *EcsEnvironmentFile) UnmarshalJSON(b []byte) error {
    TypeReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            TypeReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Type (a required property) was received
    if !TypeReceived {
        return errors.New("\"Type\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *EcsEnvironmentVariable) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *EcsEnvironmentVariable) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *EcsEphemeralStorage) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "SizeInGiB" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "SizeInGiB" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SizeInGiB\": ")
	if tmp, err := json.Marshal(strct.SizeInGiB); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *EcsEphemeralStorage) UnmarshalJSON(b []byte) error {
    SizeInGiBReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "SizeInGiB":
            if err := json.Unmarshal([]byte(v), &strct.SizeInGiB); err != nil {
                return err
             }
            SizeInGiBReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if SizeInGiB (a required property) was received
    if !SizeInGiBReceived {
        return errors.New("\"SizeInGiB\" is required but was not present")
    }
    return nil
}

func (strct *EcsInferenceAcceleratorOverride) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DeviceName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DeviceName\": ")
	if tmp, err := json.Marshal(strct.DeviceName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DeviceType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DeviceType\": ")
	if tmp, err := json.Marshal(strct.DeviceType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *EcsInferenceAcceleratorOverride) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DeviceName":
            if err := json.Unmarshal([]byte(v), &strct.DeviceName); err != nil {
                return err
             }
        case "DeviceType":
            if err := json.Unmarshal([]byte(v), &strct.DeviceType); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *EcsResourceRequirement) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *EcsResourceRequirement) UnmarshalJSON(b []byte) error {
    TypeReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            TypeReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Type (a required property) was received
    if !TypeReceived {
        return errors.New("\"Type\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *EcsTaskOverride) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ContainerOverrides" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ContainerOverrides\": ")
	if tmp, err := json.Marshal(strct.ContainerOverrides); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Cpu" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Cpu\": ")
	if tmp, err := json.Marshal(strct.Cpu); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EphemeralStorage" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EphemeralStorage\": ")
	if tmp, err := json.Marshal(strct.EphemeralStorage); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ExecutionRoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ExecutionRoleArn\": ")
	if tmp, err := json.Marshal(strct.ExecutionRoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "InferenceAcceleratorOverrides" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InferenceAcceleratorOverrides\": ")
	if tmp, err := json.Marshal(strct.InferenceAcceleratorOverrides); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Memory" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Memory\": ")
	if tmp, err := json.Marshal(strct.Memory); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TaskRoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TaskRoleArn\": ")
	if tmp, err := json.Marshal(strct.TaskRoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *EcsTaskOverride) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ContainerOverrides":
            if err := json.Unmarshal([]byte(v), &strct.ContainerOverrides); err != nil {
                return err
             }
        case "Cpu":
            if err := json.Unmarshal([]byte(v), &strct.Cpu); err != nil {
                return err
             }
        case "EphemeralStorage":
            if err := json.Unmarshal([]byte(v), &strct.EphemeralStorage); err != nil {
                return err
             }
        case "ExecutionRoleArn":
            if err := json.Unmarshal([]byte(v), &strct.ExecutionRoleArn); err != nil {
                return err
             }
        case "InferenceAcceleratorOverrides":
            if err := json.Unmarshal([]byte(v), &strct.InferenceAcceleratorOverrides); err != nil {
                return err
             }
        case "Memory":
            if err := json.Unmarshal([]byte(v), &strct.Memory); err != nil {
                return err
             }
        case "TaskRoleArn":
            if err := json.Unmarshal([]byte(v), &strct.TaskRoleArn); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Filter) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Pattern" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Pattern\": ")
	if tmp, err := json.Marshal(strct.Pattern); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Filter) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Pattern":
            if err := json.Unmarshal([]byte(v), &strct.Pattern); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *FilterCriteria) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Filters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Filters\": ")
	if tmp, err := json.Marshal(strct.Filters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FilterCriteria) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Filters":
            if err := json.Unmarshal([]byte(v), &strct.Filters); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *HeaderParametersMap) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *HeaderParametersMap) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *NetworkConfiguration) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AwsvpcConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AwsvpcConfiguration\": ")
	if tmp, err := json.Marshal(strct.AwsvpcConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *NetworkConfiguration) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AwsvpcConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.AwsvpcConfiguration); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *PipeEnrichmentHttpParameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "HeaderParameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HeaderParameters\": ")
	if tmp, err := json.Marshal(strct.HeaderParameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PathParameterValues" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PathParameterValues\": ")
	if tmp, err := json.Marshal(strct.PathParameterValues); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "QueryStringParameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"QueryStringParameters\": ")
	if tmp, err := json.Marshal(strct.QueryStringParameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PipeEnrichmentHttpParameters) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "HeaderParameters":
            if err := json.Unmarshal([]byte(v), &strct.HeaderParameters); err != nil {
                return err
             }
        case "PathParameterValues":
            if err := json.Unmarshal([]byte(v), &strct.PathParameterValues); err != nil {
                return err
             }
        case "QueryStringParameters":
            if err := json.Unmarshal([]byte(v), &strct.QueryStringParameters); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *PipeEnrichmentParameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "HttpParameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HttpParameters\": ")
	if tmp, err := json.Marshal(strct.HttpParameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "InputTemplate" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InputTemplate\": ")
	if tmp, err := json.Marshal(strct.InputTemplate); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PipeEnrichmentParameters) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "HttpParameters":
            if err := json.Unmarshal([]byte(v), &strct.HttpParameters); err != nil {
                return err
             }
        case "InputTemplate":
            if err := json.Unmarshal([]byte(v), &strct.InputTemplate); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *PipeSourceActiveMQBrokerParameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "BatchSize" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BatchSize\": ")
	if tmp, err := json.Marshal(strct.BatchSize); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Credentials" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Credentials" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Credentials\": ")
	if tmp, err := json.Marshal(strct.Credentials); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MaximumBatchingWindowInSeconds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaximumBatchingWindowInSeconds\": ")
	if tmp, err := json.Marshal(strct.MaximumBatchingWindowInSeconds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "QueueName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "QueueName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"QueueName\": ")
	if tmp, err := json.Marshal(strct.QueueName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PipeSourceActiveMQBrokerParameters) UnmarshalJSON(b []byte) error {
    CredentialsReceived := false
    QueueNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BatchSize":
            if err := json.Unmarshal([]byte(v), &strct.BatchSize); err != nil {
                return err
             }
        case "Credentials":
            if err := json.Unmarshal([]byte(v), &strct.Credentials); err != nil {
                return err
             }
            CredentialsReceived = true
        case "MaximumBatchingWindowInSeconds":
            if err := json.Unmarshal([]byte(v), &strct.MaximumBatchingWindowInSeconds); err != nil {
                return err
             }
        case "QueueName":
            if err := json.Unmarshal([]byte(v), &strct.QueueName); err != nil {
                return err
             }
            QueueNameReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Credentials (a required property) was received
    if !CredentialsReceived {
        return errors.New("\"Credentials\" is required but was not present")
    }
    // check if QueueName (a required property) was received
    if !QueueNameReceived {
        return errors.New("\"QueueName\" is required but was not present")
    }
    return nil
}

func (strct *PipeSourceDynamoDBStreamParameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "BatchSize" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BatchSize\": ")
	if tmp, err := json.Marshal(strct.BatchSize); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DeadLetterConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DeadLetterConfig\": ")
	if tmp, err := json.Marshal(strct.DeadLetterConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MaximumBatchingWindowInSeconds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaximumBatchingWindowInSeconds\": ")
	if tmp, err := json.Marshal(strct.MaximumBatchingWindowInSeconds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MaximumRecordAgeInSeconds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaximumRecordAgeInSeconds\": ")
	if tmp, err := json.Marshal(strct.MaximumRecordAgeInSeconds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MaximumRetryAttempts" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaximumRetryAttempts\": ")
	if tmp, err := json.Marshal(strct.MaximumRetryAttempts); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OnPartialBatchItemFailure" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OnPartialBatchItemFailure\": ")
	if tmp, err := json.Marshal(strct.OnPartialBatchItemFailure); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ParallelizationFactor" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ParallelizationFactor\": ")
	if tmp, err := json.Marshal(strct.ParallelizationFactor); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "StartingPosition" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "StartingPosition" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StartingPosition\": ")
	if tmp, err := json.Marshal(strct.StartingPosition); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PipeSourceDynamoDBStreamParameters) UnmarshalJSON(b []byte) error {
    StartingPositionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BatchSize":
            if err := json.Unmarshal([]byte(v), &strct.BatchSize); err != nil {
                return err
             }
        case "DeadLetterConfig":
            if err := json.Unmarshal([]byte(v), &strct.DeadLetterConfig); err != nil {
                return err
             }
        case "MaximumBatchingWindowInSeconds":
            if err := json.Unmarshal([]byte(v), &strct.MaximumBatchingWindowInSeconds); err != nil {
                return err
             }
        case "MaximumRecordAgeInSeconds":
            if err := json.Unmarshal([]byte(v), &strct.MaximumRecordAgeInSeconds); err != nil {
                return err
             }
        case "MaximumRetryAttempts":
            if err := json.Unmarshal([]byte(v), &strct.MaximumRetryAttempts); err != nil {
                return err
             }
        case "OnPartialBatchItemFailure":
            if err := json.Unmarshal([]byte(v), &strct.OnPartialBatchItemFailure); err != nil {
                return err
             }
        case "ParallelizationFactor":
            if err := json.Unmarshal([]byte(v), &strct.ParallelizationFactor); err != nil {
                return err
             }
        case "StartingPosition":
            if err := json.Unmarshal([]byte(v), &strct.StartingPosition); err != nil {
                return err
             }
            StartingPositionReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if StartingPosition (a required property) was received
    if !StartingPositionReceived {
        return errors.New("\"StartingPosition\" is required but was not present")
    }
    return nil
}

func (strct *PipeSourceKinesisStreamParameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "BatchSize" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BatchSize\": ")
	if tmp, err := json.Marshal(strct.BatchSize); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DeadLetterConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DeadLetterConfig\": ")
	if tmp, err := json.Marshal(strct.DeadLetterConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MaximumBatchingWindowInSeconds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaximumBatchingWindowInSeconds\": ")
	if tmp, err := json.Marshal(strct.MaximumBatchingWindowInSeconds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MaximumRecordAgeInSeconds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaximumRecordAgeInSeconds\": ")
	if tmp, err := json.Marshal(strct.MaximumRecordAgeInSeconds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MaximumRetryAttempts" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaximumRetryAttempts\": ")
	if tmp, err := json.Marshal(strct.MaximumRetryAttempts); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "OnPartialBatchItemFailure" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"OnPartialBatchItemFailure\": ")
	if tmp, err := json.Marshal(strct.OnPartialBatchItemFailure); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ParallelizationFactor" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ParallelizationFactor\": ")
	if tmp, err := json.Marshal(strct.ParallelizationFactor); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "StartingPosition" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "StartingPosition" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StartingPosition\": ")
	if tmp, err := json.Marshal(strct.StartingPosition); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StartingPositionTimestamp" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StartingPositionTimestamp\": ")
	if tmp, err := json.Marshal(strct.StartingPositionTimestamp); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PipeSourceKinesisStreamParameters) UnmarshalJSON(b []byte) error {
    StartingPositionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BatchSize":
            if err := json.Unmarshal([]byte(v), &strct.BatchSize); err != nil {
                return err
             }
        case "DeadLetterConfig":
            if err := json.Unmarshal([]byte(v), &strct.DeadLetterConfig); err != nil {
                return err
             }
        case "MaximumBatchingWindowInSeconds":
            if err := json.Unmarshal([]byte(v), &strct.MaximumBatchingWindowInSeconds); err != nil {
                return err
             }
        case "MaximumRecordAgeInSeconds":
            if err := json.Unmarshal([]byte(v), &strct.MaximumRecordAgeInSeconds); err != nil {
                return err
             }
        case "MaximumRetryAttempts":
            if err := json.Unmarshal([]byte(v), &strct.MaximumRetryAttempts); err != nil {
                return err
             }
        case "OnPartialBatchItemFailure":
            if err := json.Unmarshal([]byte(v), &strct.OnPartialBatchItemFailure); err != nil {
                return err
             }
        case "ParallelizationFactor":
            if err := json.Unmarshal([]byte(v), &strct.ParallelizationFactor); err != nil {
                return err
             }
        case "StartingPosition":
            if err := json.Unmarshal([]byte(v), &strct.StartingPosition); err != nil {
                return err
             }
            StartingPositionReceived = true
        case "StartingPositionTimestamp":
            if err := json.Unmarshal([]byte(v), &strct.StartingPositionTimestamp); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if StartingPosition (a required property) was received
    if !StartingPositionReceived {
        return errors.New("\"StartingPosition\" is required but was not present")
    }
    return nil
}

func (strct *PipeSourceManagedStreamingKafkaParameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "BatchSize" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BatchSize\": ")
	if tmp, err := json.Marshal(strct.BatchSize); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ConsumerGroupID" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConsumerGroupID\": ")
	if tmp, err := json.Marshal(strct.ConsumerGroupID); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Credentials" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Credentials\": ")
	if tmp, err := json.Marshal(strct.Credentials); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MaximumBatchingWindowInSeconds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaximumBatchingWindowInSeconds\": ")
	if tmp, err := json.Marshal(strct.MaximumBatchingWindowInSeconds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StartingPosition" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StartingPosition\": ")
	if tmp, err := json.Marshal(strct.StartingPosition); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TopicName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TopicName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TopicName\": ")
	if tmp, err := json.Marshal(strct.TopicName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PipeSourceManagedStreamingKafkaParameters) UnmarshalJSON(b []byte) error {
    TopicNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BatchSize":
            if err := json.Unmarshal([]byte(v), &strct.BatchSize); err != nil {
                return err
             }
        case "ConsumerGroupID":
            if err := json.Unmarshal([]byte(v), &strct.ConsumerGroupID); err != nil {
                return err
             }
        case "Credentials":
            if err := json.Unmarshal([]byte(v), &strct.Credentials); err != nil {
                return err
             }
        case "MaximumBatchingWindowInSeconds":
            if err := json.Unmarshal([]byte(v), &strct.MaximumBatchingWindowInSeconds); err != nil {
                return err
             }
        case "StartingPosition":
            if err := json.Unmarshal([]byte(v), &strct.StartingPosition); err != nil {
                return err
             }
        case "TopicName":
            if err := json.Unmarshal([]byte(v), &strct.TopicName); err != nil {
                return err
             }
            TopicNameReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if TopicName (a required property) was received
    if !TopicNameReceived {
        return errors.New("\"TopicName\" is required but was not present")
    }
    return nil
}

func (strct *PipeSourceParameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ActiveMQBrokerParameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ActiveMQBrokerParameters\": ")
	if tmp, err := json.Marshal(strct.ActiveMQBrokerParameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DynamoDBStreamParameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DynamoDBStreamParameters\": ")
	if tmp, err := json.Marshal(strct.DynamoDBStreamParameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FilterCriteria" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FilterCriteria\": ")
	if tmp, err := json.Marshal(strct.FilterCriteria); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "KinesisStreamParameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KinesisStreamParameters\": ")
	if tmp, err := json.Marshal(strct.KinesisStreamParameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ManagedStreamingKafkaParameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ManagedStreamingKafkaParameters\": ")
	if tmp, err := json.Marshal(strct.ManagedStreamingKafkaParameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RabbitMQBrokerParameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RabbitMQBrokerParameters\": ")
	if tmp, err := json.Marshal(strct.RabbitMQBrokerParameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SelfManagedKafkaParameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SelfManagedKafkaParameters\": ")
	if tmp, err := json.Marshal(strct.SelfManagedKafkaParameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SqsQueueParameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SqsQueueParameters\": ")
	if tmp, err := json.Marshal(strct.SqsQueueParameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PipeSourceParameters) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ActiveMQBrokerParameters":
            if err := json.Unmarshal([]byte(v), &strct.ActiveMQBrokerParameters); err != nil {
                return err
             }
        case "DynamoDBStreamParameters":
            if err := json.Unmarshal([]byte(v), &strct.DynamoDBStreamParameters); err != nil {
                return err
             }
        case "FilterCriteria":
            if err := json.Unmarshal([]byte(v), &strct.FilterCriteria); err != nil {
                return err
             }
        case "KinesisStreamParameters":
            if err := json.Unmarshal([]byte(v), &strct.KinesisStreamParameters); err != nil {
                return err
             }
        case "ManagedStreamingKafkaParameters":
            if err := json.Unmarshal([]byte(v), &strct.ManagedStreamingKafkaParameters); err != nil {
                return err
             }
        case "RabbitMQBrokerParameters":
            if err := json.Unmarshal([]byte(v), &strct.RabbitMQBrokerParameters); err != nil {
                return err
             }
        case "SelfManagedKafkaParameters":
            if err := json.Unmarshal([]byte(v), &strct.SelfManagedKafkaParameters); err != nil {
                return err
             }
        case "SqsQueueParameters":
            if err := json.Unmarshal([]byte(v), &strct.SqsQueueParameters); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *PipeSourceRabbitMQBrokerParameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "BatchSize" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BatchSize\": ")
	if tmp, err := json.Marshal(strct.BatchSize); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Credentials" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Credentials" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Credentials\": ")
	if tmp, err := json.Marshal(strct.Credentials); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MaximumBatchingWindowInSeconds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaximumBatchingWindowInSeconds\": ")
	if tmp, err := json.Marshal(strct.MaximumBatchingWindowInSeconds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "QueueName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "QueueName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"QueueName\": ")
	if tmp, err := json.Marshal(strct.QueueName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "VirtualHost" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"VirtualHost\": ")
	if tmp, err := json.Marshal(strct.VirtualHost); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PipeSourceRabbitMQBrokerParameters) UnmarshalJSON(b []byte) error {
    CredentialsReceived := false
    QueueNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BatchSize":
            if err := json.Unmarshal([]byte(v), &strct.BatchSize); err != nil {
                return err
             }
        case "Credentials":
            if err := json.Unmarshal([]byte(v), &strct.Credentials); err != nil {
                return err
             }
            CredentialsReceived = true
        case "MaximumBatchingWindowInSeconds":
            if err := json.Unmarshal([]byte(v), &strct.MaximumBatchingWindowInSeconds); err != nil {
                return err
             }
        case "QueueName":
            if err := json.Unmarshal([]byte(v), &strct.QueueName); err != nil {
                return err
             }
            QueueNameReceived = true
        case "VirtualHost":
            if err := json.Unmarshal([]byte(v), &strct.VirtualHost); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Credentials (a required property) was received
    if !CredentialsReceived {
        return errors.New("\"Credentials\" is required but was not present")
    }
    // check if QueueName (a required property) was received
    if !QueueNameReceived {
        return errors.New("\"QueueName\" is required but was not present")
    }
    return nil
}

func (strct *PipeSourceSelfManagedKafkaParameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "AdditionalBootstrapServers" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AdditionalBootstrapServers\": ")
	if tmp, err := json.Marshal(strct.AdditionalBootstrapServers); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BatchSize" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BatchSize\": ")
	if tmp, err := json.Marshal(strct.BatchSize); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ConsumerGroupID" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ConsumerGroupID\": ")
	if tmp, err := json.Marshal(strct.ConsumerGroupID); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Credentials" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Credentials\": ")
	if tmp, err := json.Marshal(strct.Credentials); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MaximumBatchingWindowInSeconds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaximumBatchingWindowInSeconds\": ")
	if tmp, err := json.Marshal(strct.MaximumBatchingWindowInSeconds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ServerRootCaCertificate" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ServerRootCaCertificate\": ")
	if tmp, err := json.Marshal(strct.ServerRootCaCertificate); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StartingPosition" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StartingPosition\": ")
	if tmp, err := json.Marshal(strct.StartingPosition); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TopicName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TopicName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TopicName\": ")
	if tmp, err := json.Marshal(strct.TopicName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Vpc" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Vpc\": ")
	if tmp, err := json.Marshal(strct.Vpc); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PipeSourceSelfManagedKafkaParameters) UnmarshalJSON(b []byte) error {
    TopicNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "AdditionalBootstrapServers":
            if err := json.Unmarshal([]byte(v), &strct.AdditionalBootstrapServers); err != nil {
                return err
             }
        case "BatchSize":
            if err := json.Unmarshal([]byte(v), &strct.BatchSize); err != nil {
                return err
             }
        case "ConsumerGroupID":
            if err := json.Unmarshal([]byte(v), &strct.ConsumerGroupID); err != nil {
                return err
             }
        case "Credentials":
            if err := json.Unmarshal([]byte(v), &strct.Credentials); err != nil {
                return err
             }
        case "MaximumBatchingWindowInSeconds":
            if err := json.Unmarshal([]byte(v), &strct.MaximumBatchingWindowInSeconds); err != nil {
                return err
             }
        case "ServerRootCaCertificate":
            if err := json.Unmarshal([]byte(v), &strct.ServerRootCaCertificate); err != nil {
                return err
             }
        case "StartingPosition":
            if err := json.Unmarshal([]byte(v), &strct.StartingPosition); err != nil {
                return err
             }
        case "TopicName":
            if err := json.Unmarshal([]byte(v), &strct.TopicName); err != nil {
                return err
             }
            TopicNameReceived = true
        case "Vpc":
            if err := json.Unmarshal([]byte(v), &strct.Vpc); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if TopicName (a required property) was received
    if !TopicNameReceived {
        return errors.New("\"TopicName\" is required but was not present")
    }
    return nil
}

func (strct *PipeSourceSqsQueueParameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "BatchSize" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BatchSize\": ")
	if tmp, err := json.Marshal(strct.BatchSize); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MaximumBatchingWindowInSeconds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MaximumBatchingWindowInSeconds\": ")
	if tmp, err := json.Marshal(strct.MaximumBatchingWindowInSeconds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PipeSourceSqsQueueParameters) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BatchSize":
            if err := json.Unmarshal([]byte(v), &strct.BatchSize); err != nil {
                return err
             }
        case "MaximumBatchingWindowInSeconds":
            if err := json.Unmarshal([]byte(v), &strct.MaximumBatchingWindowInSeconds); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *PipeTargetBatchJobParameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ArrayProperties" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ArrayProperties\": ")
	if tmp, err := json.Marshal(strct.ArrayProperties); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ContainerOverrides" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ContainerOverrides\": ")
	if tmp, err := json.Marshal(strct.ContainerOverrides); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DependsOn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DependsOn\": ")
	if tmp, err := json.Marshal(strct.DependsOn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "JobDefinition" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "JobDefinition" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"JobDefinition\": ")
	if tmp, err := json.Marshal(strct.JobDefinition); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "JobName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "JobName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"JobName\": ")
	if tmp, err := json.Marshal(strct.JobName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Parameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Parameters\": ")
	if tmp, err := json.Marshal(strct.Parameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RetryStrategy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RetryStrategy\": ")
	if tmp, err := json.Marshal(strct.RetryStrategy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PipeTargetBatchJobParameters) UnmarshalJSON(b []byte) error {
    JobDefinitionReceived := false
    JobNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ArrayProperties":
            if err := json.Unmarshal([]byte(v), &strct.ArrayProperties); err != nil {
                return err
             }
        case "ContainerOverrides":
            if err := json.Unmarshal([]byte(v), &strct.ContainerOverrides); err != nil {
                return err
             }
        case "DependsOn":
            if err := json.Unmarshal([]byte(v), &strct.DependsOn); err != nil {
                return err
             }
        case "JobDefinition":
            if err := json.Unmarshal([]byte(v), &strct.JobDefinition); err != nil {
                return err
             }
            JobDefinitionReceived = true
        case "JobName":
            if err := json.Unmarshal([]byte(v), &strct.JobName); err != nil {
                return err
             }
            JobNameReceived = true
        case "Parameters":
            if err := json.Unmarshal([]byte(v), &strct.Parameters); err != nil {
                return err
             }
        case "RetryStrategy":
            if err := json.Unmarshal([]byte(v), &strct.RetryStrategy); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if JobDefinition (a required property) was received
    if !JobDefinitionReceived {
        return errors.New("\"JobDefinition\" is required but was not present")
    }
    // check if JobName (a required property) was received
    if !JobNameReceived {
        return errors.New("\"JobName\" is required but was not present")
    }
    return nil
}

func (strct *PipeTargetCloudWatchLogsParameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "LogStreamName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LogStreamName\": ")
	if tmp, err := json.Marshal(strct.LogStreamName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Timestamp" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Timestamp\": ")
	if tmp, err := json.Marshal(strct.Timestamp); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PipeTargetCloudWatchLogsParameters) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "LogStreamName":
            if err := json.Unmarshal([]byte(v), &strct.LogStreamName); err != nil {
                return err
             }
        case "Timestamp":
            if err := json.Unmarshal([]byte(v), &strct.Timestamp); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *PipeTargetEcsTaskParameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "CapacityProviderStrategy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CapacityProviderStrategy\": ")
	if tmp, err := json.Marshal(strct.CapacityProviderStrategy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EnableECSManagedTags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EnableECSManagedTags\": ")
	if tmp, err := json.Marshal(strct.EnableECSManagedTags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EnableExecuteCommand" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EnableExecuteCommand\": ")
	if tmp, err := json.Marshal(strct.EnableExecuteCommand); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Group" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Group\": ")
	if tmp, err := json.Marshal(strct.Group); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LaunchType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LaunchType\": ")
	if tmp, err := json.Marshal(strct.LaunchType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "NetworkConfiguration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"NetworkConfiguration\": ")
	if tmp, err := json.Marshal(strct.NetworkConfiguration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Overrides" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Overrides\": ")
	if tmp, err := json.Marshal(strct.Overrides); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PlacementConstraints" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PlacementConstraints\": ")
	if tmp, err := json.Marshal(strct.PlacementConstraints); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PlacementStrategy" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PlacementStrategy\": ")
	if tmp, err := json.Marshal(strct.PlacementStrategy); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PlatformVersion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PlatformVersion\": ")
	if tmp, err := json.Marshal(strct.PlatformVersion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PropagateTags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PropagateTags\": ")
	if tmp, err := json.Marshal(strct.PropagateTags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ReferenceId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ReferenceId\": ")
	if tmp, err := json.Marshal(strct.ReferenceId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TaskCount" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TaskCount\": ")
	if tmp, err := json.Marshal(strct.TaskCount); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TaskDefinitionArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TaskDefinitionArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TaskDefinitionArn\": ")
	if tmp, err := json.Marshal(strct.TaskDefinitionArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PipeTargetEcsTaskParameters) UnmarshalJSON(b []byte) error {
    TaskDefinitionArnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CapacityProviderStrategy":
            if err := json.Unmarshal([]byte(v), &strct.CapacityProviderStrategy); err != nil {
                return err
             }
        case "EnableECSManagedTags":
            if err := json.Unmarshal([]byte(v), &strct.EnableECSManagedTags); err != nil {
                return err
             }
        case "EnableExecuteCommand":
            if err := json.Unmarshal([]byte(v), &strct.EnableExecuteCommand); err != nil {
                return err
             }
        case "Group":
            if err := json.Unmarshal([]byte(v), &strct.Group); err != nil {
                return err
             }
        case "LaunchType":
            if err := json.Unmarshal([]byte(v), &strct.LaunchType); err != nil {
                return err
             }
        case "NetworkConfiguration":
            if err := json.Unmarshal([]byte(v), &strct.NetworkConfiguration); err != nil {
                return err
             }
        case "Overrides":
            if err := json.Unmarshal([]byte(v), &strct.Overrides); err != nil {
                return err
             }
        case "PlacementConstraints":
            if err := json.Unmarshal([]byte(v), &strct.PlacementConstraints); err != nil {
                return err
             }
        case "PlacementStrategy":
            if err := json.Unmarshal([]byte(v), &strct.PlacementStrategy); err != nil {
                return err
             }
        case "PlatformVersion":
            if err := json.Unmarshal([]byte(v), &strct.PlatformVersion); err != nil {
                return err
             }
        case "PropagateTags":
            if err := json.Unmarshal([]byte(v), &strct.PropagateTags); err != nil {
                return err
             }
        case "ReferenceId":
            if err := json.Unmarshal([]byte(v), &strct.ReferenceId); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        case "TaskCount":
            if err := json.Unmarshal([]byte(v), &strct.TaskCount); err != nil {
                return err
             }
        case "TaskDefinitionArn":
            if err := json.Unmarshal([]byte(v), &strct.TaskDefinitionArn); err != nil {
                return err
             }
            TaskDefinitionArnReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if TaskDefinitionArn (a required property) was received
    if !TaskDefinitionArnReceived {
        return errors.New("\"TaskDefinitionArn\" is required but was not present")
    }
    return nil
}

func (strct *PipeTargetEventBridgeEventBusParameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "DetailType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DetailType\": ")
	if tmp, err := json.Marshal(strct.DetailType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EndpointId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EndpointId\": ")
	if tmp, err := json.Marshal(strct.EndpointId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Resources" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Resources\": ")
	if tmp, err := json.Marshal(strct.Resources); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Source" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Source\": ")
	if tmp, err := json.Marshal(strct.Source); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Time" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Time\": ")
	if tmp, err := json.Marshal(strct.Time); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PipeTargetEventBridgeEventBusParameters) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "DetailType":
            if err := json.Unmarshal([]byte(v), &strct.DetailType); err != nil {
                return err
             }
        case "EndpointId":
            if err := json.Unmarshal([]byte(v), &strct.EndpointId); err != nil {
                return err
             }
        case "Resources":
            if err := json.Unmarshal([]byte(v), &strct.Resources); err != nil {
                return err
             }
        case "Source":
            if err := json.Unmarshal([]byte(v), &strct.Source); err != nil {
                return err
             }
        case "Time":
            if err := json.Unmarshal([]byte(v), &strct.Time); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *PipeTargetHttpParameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "HeaderParameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HeaderParameters\": ")
	if tmp, err := json.Marshal(strct.HeaderParameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PathParameterValues" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PathParameterValues\": ")
	if tmp, err := json.Marshal(strct.PathParameterValues); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "QueryStringParameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"QueryStringParameters\": ")
	if tmp, err := json.Marshal(strct.QueryStringParameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PipeTargetHttpParameters) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "HeaderParameters":
            if err := json.Unmarshal([]byte(v), &strct.HeaderParameters); err != nil {
                return err
             }
        case "PathParameterValues":
            if err := json.Unmarshal([]byte(v), &strct.PathParameterValues); err != nil {
                return err
             }
        case "QueryStringParameters":
            if err := json.Unmarshal([]byte(v), &strct.QueryStringParameters); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *PipeTargetKinesisStreamParameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "PartitionKey" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "PartitionKey" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PartitionKey\": ")
	if tmp, err := json.Marshal(strct.PartitionKey); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PipeTargetKinesisStreamParameters) UnmarshalJSON(b []byte) error {
    PartitionKeyReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "PartitionKey":
            if err := json.Unmarshal([]byte(v), &strct.PartitionKey); err != nil {
                return err
             }
            PartitionKeyReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if PartitionKey (a required property) was received
    if !PartitionKeyReceived {
        return errors.New("\"PartitionKey\" is required but was not present")
    }
    return nil
}

func (strct *PipeTargetLambdaFunctionParameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "InvocationType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InvocationType\": ")
	if tmp, err := json.Marshal(strct.InvocationType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PipeTargetLambdaFunctionParameters) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "InvocationType":
            if err := json.Unmarshal([]byte(v), &strct.InvocationType); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *PipeTargetParameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "BatchJobParameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BatchJobParameters\": ")
	if tmp, err := json.Marshal(strct.BatchJobParameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CloudWatchLogsParameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CloudWatchLogsParameters\": ")
	if tmp, err := json.Marshal(strct.CloudWatchLogsParameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EcsTaskParameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EcsTaskParameters\": ")
	if tmp, err := json.Marshal(strct.EcsTaskParameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EventBridgeEventBusParameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EventBridgeEventBusParameters\": ")
	if tmp, err := json.Marshal(strct.EventBridgeEventBusParameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "HttpParameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HttpParameters\": ")
	if tmp, err := json.Marshal(strct.HttpParameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "InputTemplate" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InputTemplate\": ")
	if tmp, err := json.Marshal(strct.InputTemplate); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "KinesisStreamParameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"KinesisStreamParameters\": ")
	if tmp, err := json.Marshal(strct.KinesisStreamParameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LambdaFunctionParameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LambdaFunctionParameters\": ")
	if tmp, err := json.Marshal(strct.LambdaFunctionParameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RedshiftDataParameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RedshiftDataParameters\": ")
	if tmp, err := json.Marshal(strct.RedshiftDataParameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SageMakerPipelineParameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SageMakerPipelineParameters\": ")
	if tmp, err := json.Marshal(strct.SageMakerPipelineParameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SqsQueueParameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SqsQueueParameters\": ")
	if tmp, err := json.Marshal(strct.SqsQueueParameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StepFunctionStateMachineParameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StepFunctionStateMachineParameters\": ")
	if tmp, err := json.Marshal(strct.StepFunctionStateMachineParameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PipeTargetParameters) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "BatchJobParameters":
            if err := json.Unmarshal([]byte(v), &strct.BatchJobParameters); err != nil {
                return err
             }
        case "CloudWatchLogsParameters":
            if err := json.Unmarshal([]byte(v), &strct.CloudWatchLogsParameters); err != nil {
                return err
             }
        case "EcsTaskParameters":
            if err := json.Unmarshal([]byte(v), &strct.EcsTaskParameters); err != nil {
                return err
             }
        case "EventBridgeEventBusParameters":
            if err := json.Unmarshal([]byte(v), &strct.EventBridgeEventBusParameters); err != nil {
                return err
             }
        case "HttpParameters":
            if err := json.Unmarshal([]byte(v), &strct.HttpParameters); err != nil {
                return err
             }
        case "InputTemplate":
            if err := json.Unmarshal([]byte(v), &strct.InputTemplate); err != nil {
                return err
             }
        case "KinesisStreamParameters":
            if err := json.Unmarshal([]byte(v), &strct.KinesisStreamParameters); err != nil {
                return err
             }
        case "LambdaFunctionParameters":
            if err := json.Unmarshal([]byte(v), &strct.LambdaFunctionParameters); err != nil {
                return err
             }
        case "RedshiftDataParameters":
            if err := json.Unmarshal([]byte(v), &strct.RedshiftDataParameters); err != nil {
                return err
             }
        case "SageMakerPipelineParameters":
            if err := json.Unmarshal([]byte(v), &strct.SageMakerPipelineParameters); err != nil {
                return err
             }
        case "SqsQueueParameters":
            if err := json.Unmarshal([]byte(v), &strct.SqsQueueParameters); err != nil {
                return err
             }
        case "StepFunctionStateMachineParameters":
            if err := json.Unmarshal([]byte(v), &strct.StepFunctionStateMachineParameters); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *PipeTargetRedshiftDataParameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Database" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Database" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Database\": ")
	if tmp, err := json.Marshal(strct.Database); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DbUser" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DbUser\": ")
	if tmp, err := json.Marshal(strct.DbUser); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SecretManagerArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SecretManagerArn\": ")
	if tmp, err := json.Marshal(strct.SecretManagerArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Sqls" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Sqls" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Sqls\": ")
	if tmp, err := json.Marshal(strct.Sqls); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StatementName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StatementName\": ")
	if tmp, err := json.Marshal(strct.StatementName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "WithEvent" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"WithEvent\": ")
	if tmp, err := json.Marshal(strct.WithEvent); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PipeTargetRedshiftDataParameters) UnmarshalJSON(b []byte) error {
    DatabaseReceived := false
    SqlsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Database":
            if err := json.Unmarshal([]byte(v), &strct.Database); err != nil {
                return err
             }
            DatabaseReceived = true
        case "DbUser":
            if err := json.Unmarshal([]byte(v), &strct.DbUser); err != nil {
                return err
             }
        case "SecretManagerArn":
            if err := json.Unmarshal([]byte(v), &strct.SecretManagerArn); err != nil {
                return err
             }
        case "Sqls":
            if err := json.Unmarshal([]byte(v), &strct.Sqls); err != nil {
                return err
             }
            SqlsReceived = true
        case "StatementName":
            if err := json.Unmarshal([]byte(v), &strct.StatementName); err != nil {
                return err
             }
        case "WithEvent":
            if err := json.Unmarshal([]byte(v), &strct.WithEvent); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Database (a required property) was received
    if !DatabaseReceived {
        return errors.New("\"Database\" is required but was not present")
    }
    // check if Sqls (a required property) was received
    if !SqlsReceived {
        return errors.New("\"Sqls\" is required but was not present")
    }
    return nil
}

func (strct *PipeTargetSageMakerPipelineParameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "PipelineParameterList" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PipelineParameterList\": ")
	if tmp, err := json.Marshal(strct.PipelineParameterList); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PipeTargetSageMakerPipelineParameters) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "PipelineParameterList":
            if err := json.Unmarshal([]byte(v), &strct.PipelineParameterList); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *PipeTargetSqsQueueParameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "MessageDeduplicationId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MessageDeduplicationId\": ")
	if tmp, err := json.Marshal(strct.MessageDeduplicationId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MessageGroupId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MessageGroupId\": ")
	if tmp, err := json.Marshal(strct.MessageGroupId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PipeTargetSqsQueueParameters) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "MessageDeduplicationId":
            if err := json.Unmarshal([]byte(v), &strct.MessageDeduplicationId); err != nil {
                return err
             }
        case "MessageGroupId":
            if err := json.Unmarshal([]byte(v), &strct.MessageGroupId); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *PipeTargetStateMachineParameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "InvocationType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"InvocationType\": ")
	if tmp, err := json.Marshal(strct.InvocationType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PipeTargetStateMachineParameters) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "InvocationType":
            if err := json.Unmarshal([]byte(v), &strct.InvocationType); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *PlacementConstraint) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Expression" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Expression\": ")
	if tmp, err := json.Marshal(strct.Expression); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PlacementConstraint) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Expression":
            if err := json.Unmarshal([]byte(v), &strct.Expression); err != nil {
                return err
             }
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *PlacementStrategy) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Field" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Field\": ")
	if tmp, err := json.Marshal(strct.Field); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PlacementStrategy) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Field":
            if err := json.Unmarshal([]byte(v), &strct.Field); err != nil {
                return err
             }
        case "Type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *QueryStringParametersMap) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *QueryStringParametersMap) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Arn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Arn\": ")
	if tmp, err := json.Marshal(strct.Arn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CreationTime" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CreationTime\": ")
	if tmp, err := json.Marshal(strct.CreationTime); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CurrentState" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CurrentState\": ")
	if tmp, err := json.Marshal(strct.CurrentState); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DesiredState" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DesiredState\": ")
	if tmp, err := json.Marshal(strct.DesiredState); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Enrichment" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Enrichment\": ")
	if tmp, err := json.Marshal(strct.Enrichment); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EnrichmentParameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EnrichmentParameters\": ")
	if tmp, err := json.Marshal(strct.EnrichmentParameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LastModifiedTime" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LastModifiedTime\": ")
	if tmp, err := json.Marshal(strct.LastModifiedTime); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RoleArn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "RoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RoleArn\": ")
	if tmp, err := json.Marshal(strct.RoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Source" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Source" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Source\": ")
	if tmp, err := json.Marshal(strct.Source); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SourceParameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SourceParameters\": ")
	if tmp, err := json.Marshal(strct.SourceParameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "StateReason" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"StateReason\": ")
	if tmp, err := json.Marshal(strct.StateReason); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Target" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Target" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Target\": ")
	if tmp, err := json.Marshal(strct.Target); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TargetParameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TargetParameters\": ")
	if tmp, err := json.Marshal(strct.TargetParameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    RoleArnReceived := false
    SourceReceived := false
    TargetReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Arn":
            if err := json.Unmarshal([]byte(v), &strct.Arn); err != nil {
                return err
             }
        case "CreationTime":
            if err := json.Unmarshal([]byte(v), &strct.CreationTime); err != nil {
                return err
             }
        case "CurrentState":
            if err := json.Unmarshal([]byte(v), &strct.CurrentState); err != nil {
                return err
             }
        case "Description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "DesiredState":
            if err := json.Unmarshal([]byte(v), &strct.DesiredState); err != nil {
                return err
             }
        case "Enrichment":
            if err := json.Unmarshal([]byte(v), &strct.Enrichment); err != nil {
                return err
             }
        case "EnrichmentParameters":
            if err := json.Unmarshal([]byte(v), &strct.EnrichmentParameters); err != nil {
                return err
             }
        case "LastModifiedTime":
            if err := json.Unmarshal([]byte(v), &strct.LastModifiedTime); err != nil {
                return err
             }
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "RoleArn":
            if err := json.Unmarshal([]byte(v), &strct.RoleArn); err != nil {
                return err
             }
            RoleArnReceived = true
        case "Source":
            if err := json.Unmarshal([]byte(v), &strct.Source); err != nil {
                return err
             }
            SourceReceived = true
        case "SourceParameters":
            if err := json.Unmarshal([]byte(v), &strct.SourceParameters); err != nil {
                return err
             }
        case "StateReason":
            if err := json.Unmarshal([]byte(v), &strct.StateReason); err != nil {
                return err
             }
        case "Tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        case "Target":
            if err := json.Unmarshal([]byte(v), &strct.Target); err != nil {
                return err
             }
            TargetReceived = true
        case "TargetParameters":
            if err := json.Unmarshal([]byte(v), &strct.TargetParameters); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if RoleArn (a required property) was received
    if !RoleArnReceived {
        return errors.New("\"RoleArn\" is required but was not present")
    }
    // check if Source (a required property) was received
    if !SourceReceived {
        return errors.New("\"Source\" is required but was not present")
    }
    // check if Target (a required property) was received
    if !TargetReceived {
        return errors.New("\"Target\" is required but was not present")
    }
    return nil
}

func (strct *SageMakerPipelineParameter) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SageMakerPipelineParameter) UnmarshalJSON(b []byte) error {
    NameReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            NameReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Name (a required property) was received
    if !NameReceived {
        return errors.New("\"Name\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *SelfManagedKafkaAccessConfigurationVpc) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "SecurityGroup" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SecurityGroup\": ")
	if tmp, err := json.Marshal(strct.SecurityGroup); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "Subnets" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Subnets\": ")
	if tmp, err := json.Marshal(strct.Subnets); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SelfManagedKafkaAccessConfigurationVpc) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "SecurityGroup":
            if err := json.Unmarshal([]byte(v), &strct.SecurityGroup); err != nil {
                return err
             }
        case "Subnets":
            if err := json.Unmarshal([]byte(v), &strct.Subnets); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "Value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    KeyReceived := false
    ValueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            KeyReceived = true
        case "Value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            ValueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if Key (a required property) was received
    if !KeyReceived {
        return errors.New("\"Key\" is required but was not present")
    }
    // check if Value (a required property) was received
    if !ValueReceived {
        return errors.New("\"Value\" is required but was not present")
    }
    return nil
}

func (strct *TagMap) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TagMap) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}
